#! /bin/tcsh -f

#
# recon-all
#
# script to run all of the reconstruction routines
#
# Original Author: Doug Greve
# CVS Revision Info:
#    $Author: nicks $
#    $Date: 2007/05/31 19:22:38 $
#    $Revision: 1.107 $
#
# Copyright (C) 2002-2007,
# The General Hospital Corporation (Boston, MA).
# All rights reserved.
#
# Distribution, usage and copying of this software is covered under the
# terms found in the License Agreement file named 'COPYING' found in the
# FreeSurfer source code root directory, and duplicated here:
# https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferOpenSourceLicense
#
# General inquiries: freesurfer@nmr.mgh.harvard.edu
# Bug reports: analysis-bugs@nmr.mgh.harvard.edu
#

#
umask 002;

set VERSION = '$Id: recon-all,v 1.107 2007/05/31 19:22:38 nicks Exp $';
set ProgName = `basename $0`;

set inputargs = ($argv);
set subjid = ();
set hemilist = (lh rh);
set mailuser = ();
set WaitForFile = ();
set nWaitsMax  = 1000;
set WaitSleep =  1m;
set NotifyFile = ();
set PrintHelp = 0;
set LF = ();
set LF_DEFAULT_NAME = recon-all.log;
set SF = ();
set SF_DEFAULT_NAME = recon-all-status.log;
set CF = ();
set CF_DEFAULT_NAME = recon-all.cmd;
set AppendLog    = 1;
set AppendStatus = 1;
set DoLegacy = 0;
set LegacyWarnOnly = 0; # only warn if -legacy but not a legacy but was once

set Force = 0;
set DoCleanTal   = 0;
set DoCleanCP    = 0;
set DoCleanSeed  = 0;
set DoCleanPFH   = 0;
set DoCleanBM    = 0;
set DoCleanASeg  = 0;
set DoCleanWM    = 0;

set InputList = ();

# Expert preferences
set XOptsFile = ();
set XOptsClean = 0; # Delete a pre-existing xopts file
set XOptsUse   = 0; # Use a pre-existing xopts file
set XOptsOverwrite = 0; # Overwrite a pre-existing xopts file
set ControlPointsFile = ();
set PonsSeedCRS = (); # SeedCRS center of pons for mri_fill #
set CCSeedCRS = ();   # SeedCRS center of corpus callosum for mri_fill #
set RHSeedCRS = ();   # SeedCRS point in the right hemi wm for mri_fill #
set LHSeedCRS = ();   # SeedCRS point in the left  hemi wm for mri_fill #
set WaterShed = 1;      # 0=no WS, 1= WS normal, 2 = WS only, 3 = WS+1st
set WSLess    = 0;      # Shrinks skull surface
set WSMore    = 0;      # Expands skull surface
set WSPctPreFlood = (); # Pre-flooding height
set WSSeedPoint = ();   # C R S
set WSAtlas     = 0;    # 0=don't use atlas, 1=use atlas (for skull strip)
set WSGcaAtlas  = 1;    # 1=use GCA atlas and registration to do skull strip
set NuIterations = 2;   # Number of iterations for nu intensity correction
set HiRes = ();         # hires option (currently only conformed to min)
set Norm3dIters = ();   # passed as -n to mri_normalize
set NormMaxGrad = 1;    # passed as -g to mri_normalize (input: -normmaxgrad)
set WMSeg_wlo = ();
set WMSeg_ghi = ();
set FixWithGA = 1;   # for topology fixer
set FixDiagOnly = 0; # for topology fixer
set RmNeckRadius = 25;  # used by mri_remove_neck
set UseCAAlign = (-align); # flag added to mri_ca_label
set UseCAAlignAfter = (-align-after); # flag added to mri_ca_register
set UseAseg  = 1 # when set to 0 (using -noaseg), then aseg.mgz is not used
set NoAsegInorm2 = 0 # when set to 1 (using -noaseg-inorm2), then aseg.mgz
                     # is not used during the 2nd mri_normalize step
set UseNoNeg = 0 # if 1, add '-remove_negative 1' to mris_sphere,mris_register
set NoThicken = 0 # if 1, add '-thicken 0' to mri_segment
set NoCortexLabel = 0 # if 1, add '-cortex 0' to mris_make_surfaces
set UnCompress = 0    # if 1, add '-uncompress' to mri_ca_reg
set BigVentricles = 0 # if 1, add '-bigventricles' to mri_ca_label and reg.
                      # else, add '-nobigventricles'
set DoSecondPassRenorm = 0 # if 1, add -secondpassrenorm to mri_ca_register
set UseOldTopoFix = 1 # if 1, use mris_fix_topology instead of mris_topo_fixer
set UseNewTopoFix = 0 # if 1, use mris_topo_fixer instead of mris_fix_topology
set NoRandomness = 0 # if 1, seed critical binaries with identical seeds, to
                     # ensure consistency in surface creation. otherwise, the
                     # default is to seed with current time and date,
                     # resulting in slightly different surfaces each run.
                     # affects: mris_smooth, mris_sphere, mris_topology_fixer,
                     # mris_topo_fixer, mris_ca_label
set RngSeed = 1234   # seed for random number generator, used only when
                     # -norandomness flag is used, and can be overriden by
                     # the flag -rng-seed <seed>
set DoMultiStrip = 0 # if 1, then multiple instances of mri_watershed and
                     # mri_em_register are run in order to determine the best
                     # skull-strip
set IsMPRAGE = 0     # if 1, then -mprage added to mri_normalize/segment
set IsWashuMPRAGE = 0 # if 1, then -washu_mprage added to mri_normalize/segment
set DoCropsize256 = 0 # if 1, then crop to 256^3 during mri_convert -conform
set NoNormMGZ = 0; # set to 1 when -nosubcortseg or -noaseg flag is used,
                   # which causes norm.mgz not to used during inorm2 step
set NoWMSA = 0;      # if 1, then -nowmsa flag is added to mri_ca_label
set DoQdecCache = 0; # if 1, then create smoothed fsaverage surface files
set measurelist = ( thickness area area.pial volume curv sulc jacobian_white  )
                     # ^ these are the files smoothed by DoQdecCache (-qcache)
set fwhmlist = ( 0 5 10 15 20 25 ) # see DoQdecCache
set target = fsaverage # see DoQdecCache 

set UseMincMritotal = 0; # if 1, then use the BIC-MNI mritotal tal reg tools
set DoMakefile = 0; # if 1, run make -f recon-all.makefile $(MakefileTarget)
set MakefileTarget = () # argument to recon-all -make 
set DoAsegStatsDiff = 0; # if 1, then run asegstatsdiff
set DoAparcStatsDiff = 0; # if 1, then run aparcstatsdiff

# Longitudinal processing:
set longitudinal = 0;    # if 1, will run the longitudinal scheme
set tp1id = ();
set UseTP1CtrlVol = 0;   # if 1, use ctrl volume of tp1 in normalization step
set no_orig_pial = 0;    # if 1, mris_make_surfaces won't use orig pial
set regfile = ();        # registration file to align tp1 to current subj
                  # default settings for second registration method:
set REG_METHOD    = fsl_rigid
set REG_COST      = corratio
set REG_DOF       = 6
set REG_FILE_TYPE = norm

# For defacing, as found in:
# $FREESURFER_HOME/average/
set brain_template = talairach_mixed_with_skull.gca
set face_template  = face.gca

# For subcortical segmentation
set GCA      = RB_all_2006-02-15.gca
set GCASkull = RB_all_withskull_2006-02-15.gca

# For cortical registration, as found in $AvgCurvTifPath/$hemi.$AvgCurvTif
set AvgCurvTifPath = "${FREESURFER_HOME}/average"
set AvgCurvTif = average.curvature.filled.buckner40.tif

# For cortical parcellation atlas, as found in:
# $FREESURFER_HOME/average/$hemi.$GCS
set GCS = curvature.buckner40.filled.desikan_killiany.2005-6-6.gcs

# Set this to 0 to do everything but run the command.
# This is good for debugging.
set RunIt = 1;

# print versions and exit
set DoVersionsOnly = 0;

#----- Volume -----------#
set DoConvertInput   = 0;
set DoMotionCor      = 0;
set DoDeface         = 0;
set DoNuIntensityCor = 0;
set DoTalairach      = 0;
set DoTalCheck       = 0;
set DoNormalization  = 0;
set DoNormalization2 = 0;
set DoMaskBFS        = 0;
set UseControlPoints = 0;
set DoSkullStrip     = 0;
set DoSegmentation   = 0;
set DoGCAReg         = 0;
set DoCARegInv       = 0;
set DoCANormalize    = 0;
set DoCAReg          = 0;
set DoRemoveNeck     = 0;
set DoSkullLTA       = 0;
set DoCALabel        = 0;
set DoSegStats       = 0;
set DoFill           = 0;
#----- Surface -----------#
set DoTessellate     = 0;
set SvInitOrigSurf   = 0;
set DoSmooth1        = 0;
set DoInflate1       = 0;
set DoQSphere        = 0;
set DoFix            = 0;
set DoSmooth2        = 0;
set DoInflate2       = 0;
set DoSphere         = 0;
set DoSurfReg        = 0;
set DoJacobianWhite  = 0;
set DoJacobianDist0  = 0;
set DoContraSurfReg  = 0;
set DoContraSurfRegWithinSubject = 0;
set DoAvgCurv        = 0;
set DoMorphRGB       = 0;
set DoFinalSurfs     = 0;
set DoCortParc       = 0;
set DoCortParc2      = 0;
set DoParcStats      = 0;
set DoParcStats2     = 0;
set DoCortRibbonVolMask = 0;
set DoVnoMatchCheck  = 0;


setenv LANG C # Required by MNI tool
setenv FIX_VERTEX_AREA; # see -<no>fixvertexarea flag

# ----------- Surface and Volume ------------------#
set DoAParc2ASeg = 0;

set PWD = pwd;
if($#argv == 0) goto usage_exit;
set n = `echo $argv | egrep -e -help | wc -l`
if($n != 0) then
  set PrintHelp = 1;
  goto usage_exit;
endif
set n = `echo $argv | egrep -e -version | wc -l`
if($n != 0) then
  echo $VERSION
  exit 0;
endif

goto parse_args;
parse_args_return:
goto check_params;
check_params_return:

if ($DoMakefile) then
  setenv MAKE_SUBJECT $subjid
  set make_flags=( $MakefileTarget )
  if ( ! $RunIt) set make_flags=( -n $make_flags )
  echo "Subject '$subjid': make $make_flags"
  make -f $FREESURFER_HOME/bin/recon-all.makefile ${make_flags}
  exit ($status)
endif

echo "INFO: SUBJECTS_DIR is $SUBJECTS_DIR"

# Get "True" FS HOME
pushd $FREESURFER_HOME > /dev/null
set freesurfer_home_true = `pwd`;
popd > /dev/null
echo "Actual FREESURFER_HOME $freesurfer_home_true"

set DateString = "`date '+%y%m%d%H%M'`"

cd $subjdir # This variable is set in check_params
mkdir -p mri scripts surf tmp label touch stats touch src trash bem
mkdir -p mri/transforms mri/transforms/bak mri/orig
set touchdir = $subjdir/touch

# Create cmd and env files from scratch
if(! $DoVersionsOnly) then
  set CF = ($subjdir/scripts/$CF_DEFAULT_NAME)
  rm -f $CF
  # Create a separate file for the env
  set ENVF = $subjdir/scripts/recon-all.env
  if(-e $ENVF) mv $ENVF $ENVF.bak
  date                                     >> $ENVF
  echo "FREESURFER_HOME $FREESURFER_HOME"  >> $ENVF
  echo "Actual FREESURFER_HOME $freesurfer_home_true"  >> $ENVF
  pwd                                      >> $ENVF
  echo "setenv SUBJECTS_DIR $SUBJECTS_DIR" >> $ENVF
  echo $inputargs                          >> $ENVF
  uname -a                                 >> $ENVF
  echo ""                                  >> $ENVF
  limit                                    >> $ENVF
  echo ""                                  >> $ENVF
  printenv                                 >> $ENVF
endif

if($DoVersionsOnly) then
  if (-e /dev/stdout) then
    set LF = /dev/stdout
    set SF = /dev/stdout
  else
    set LF = /dev/null
    set SF = /dev/null
  endif
endif

# ------------ Create the log file --------------- #
if($#LF == 0) then
  set LF = ($subjdir/scripts/$LF_DEFAULT_NAME)
  if(-e $LF) then
    ls -l $LF
    if(! $AppendLog) then
      mv $LF $LF.old
    else
      echo "\n\n"  >> $LF
      echo "New invocation of recon-all "  >> $LF
      echo "\n\n"  >> $LF
    endif
  endif
else
  if(-e $LF) then
    echo "\n\n"  >> $LF
    echo "New invocation of recon-all "  >> $LF
    echo "\n\n"  >> $LF
  endif
endif

date >> $LF
$PWD >> $LF
echo $0 >> $LF
echo $inputargs >> $LF
echo "subjid $subjid" >> $LF
echo "setenv SUBJECTS_DIR $SUBJECTS_DIR" >> $LF
echo "FREESURFER_HOME $FREESURFER_HOME" >> $LF
echo "Actual FREESURFER_HOME $freesurfer_home_true" >> $LF
if (-e $FREESURFER_HOME/build-stamp.txt) then
  echo "build-stamp.txt: `cat $FREESURFER_HOME/build-stamp.txt`" >> $LF
endif
uname -a | tee -a $LF
limit >> $LF

## gather all versions here
echo "########################################" >> $LF
echo "program versions used" >> $LF
echo $VERSION                >> $LF
mri_motion_correct.fsl -version >> $LF
flirt -version >> $LF
talairach_avi --version >> $LF
tkregister2_cmdl --all-info >> $LF
nu_correct -version >> $LF
mri_normalize -all-info >> $LF
mri_watershed -all-info >> $LF
mri_segment -all-info >> $LF
mri_label2label -all-info >> $LF
mri_em_register -all-info >> $LF
mri_ca_normalize -all-info >> $LF
mri_ca_register -all-info >> $LF
mri_ca_label -all-info >> $LF
mri_pretess -all-info >> $LF
mri_fill -all-info >> $LF
mri_tessellate -all-info >> $LF
mri_concatenate_lta -all-info >> $LF
mri_normalize_tp2 -all-info >> $LF
mris_smooth -all-info >> $LF
mris_inflate -all-info >> $LF
mris_sphere -all-info >> $LF
mris_fix_topology -all-info >> $LF
mris_topo_fixer -all-info >> $LF
mris_ca_label -all-info >> $LF
mris_euler_number -all-info >> $LF
mris_make_surfaces -all-info >> $LF
mris_register -all-info >> $LF
mris_anatomical_stats -all-info >> $LF
mrisp_paint -all-info >> $LF
echo "#######################################" >> $LF
echo "GCA $GCA" >> $LF
echo "GCASkull $GCASkull" >> $LF
echo "AvgCurvTif $AvgCurvTif" >> $LF
echo "GCS $GCS" >> $LF
echo "#######################################" >> $LF

if($DoVersionsOnly) exit 0;

# ------- Check FREESURFER HOME consistency ---------------------#
set CSDF = $subjdir/scripts/csurfdir
if(-e $CSDF) then
  set tmp = `cat $CSDF`;
  if($tmp != $FREESURFER_HOME) then
   echo "INFO: current FREESURFER_HOME does not match that of previous processing." \
     | tee -a $LF
   echo "    Current: $FREESURFER_HOME" | tee -a $LF
   echo "    Previous: $tmp" | tee -a $LF
   sleep 1;
  endif
else
  echo $FREESURFER_HOME > $CSDF
endif

# --------------- Create the status file ---------------- #
if($#SF == 0) then
  set SF = ($subjdir/scripts/$SF_DEFAULT_NAME)
  if(-e $SF) then
    if(! $AppendStatus) then
       mv $SF $SF.old
    else
      echo "\n\n"  >> $SF
      echo "New invocation of recon-all "  >> $SF
      echo "\n\n"  >> $SF
    endif
  endif
else
  if(-e $SF) then
    echo "\n\n"  >> $SF
    echo "New invocation of recon-all "  >> $SF
    echo "\n\n"  >> $SF
  endif
endif
echo "status file for recon-all" >> $SF
date >> $SF

# Put a copy of myself (this script) in the scripts dir
cp $0 $subjdir/scripts/recon-all.local-copy

# Wait for a file to appear #
if($#WaitForFile != 0) then
  echo "Waiting for $WaitForFile" |& tee -a $SF |& tee -a $LF
  echo "  WaitSleep $WaitSleep" |& tee -a $SF |& tee -a $LF
  echo "  nWaitsMax $nWaitsMax" |& tee -a $SF |& tee -a $LF
  @ nWaits = 1;
  while(! -e $WaitForFile && $nWaits < $nWaitsMax)
    sleep $WaitSleep;
    @ nWaits = $nWaits + 1;
  end
  if(! -e $WaitForFile ) then
    echo "ERROR: timed out waiting for $WaitForFile"
    goto error_exit;
  endif
  echo "Finished Waiting `date`" |& tee -a $SF |& tee -a $LF
endif

#------------ Clean -----------------------------#
if($DoCleanSeed) then
   set cmd = ("mv -f $subjdir/scripts/seed-*.crs.man.dat $subjdir/trash");
   echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
   if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanTal) then
   set cmd = (mv -f $subjdir/mri/transforms/talairach.xfm $subjdir/trash)
   echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
   if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanPFH) then
   set cmd = (mv -f $subjdir/mri/optimal_preflood_height $subjdir/trash)
   echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
   if($RunIt) $cmd  |& tee -a $LF
   set cmd = (mv -f $subjdir/mri/optimal_skullstrip_invol $subjdir/trash)
   echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
   if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanBM) then
   set cmd = (mv -f $subjdir/mri/brainmask.mgz $subjdir/trash)
   echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
   if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanASeg) then
   set cmd = (mv -f $subjdir/mri/aseg.mgz $subjdir/trash)
   echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
   if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanWM) then
   set cmd = (mv -f $subjdir/mri/wm.mgz $subjdir/trash)
   echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
   if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanCP) then
   set cmd = (mv -f $subjdir/tmp/control.dat $subjdir/trash)
   echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
   if($RunIt) $cmd  |& tee -a $LF
endif

#------------ Handle Seed Points for Fill/Cut ------------------#
set seedfile = $subjdir/scripts/seed-pons.crs.man.dat
if($#PonsSeedCRS) then
  echo "# Manually specified seed CRS for Pons" > $seedfile
  echo $PonsSeedCRS >>  $seedfile
endif
if(-e $seedfile) set PonsSeedCRS = `cat $seedfile | grep -v \#`
set seedfile = $subjdir/scripts/seed-cc.crs.man.dat
if($#CCSeedCRS) then
  echo "# Manually specified seed CRS for CC" > $seedfile
  echo $CCSeedCRS >>  $seedfile
endif
if(-e $seedfile) set CCSeedCRS = `cat $seedfile | grep -v \#`
set seedfile = $subjdir/scripts/seed-lh.crs.man.dat
if($#LHSeedCRS) then
  echo "# Manually specified seed CRS for LH" > $seedfile
  echo $LHSeedCRS >>  $seedfile
endif
if(-e $seedfile) set LHSeedCRS = `cat $seedfile | grep -v \#`
set seedfile = $subjdir/scripts/seed-rh.crs.man.dat
if($#RHSeedCRS) then
  echo "# Manually specified seed CRS for RH" > $seedfile
  echo $RHSeedCRS >>  $seedfile
endif
if(-e $seedfile) set RHSeedCRS = `cat $seedfile | grep -v \#`

set ControlPointsFile = $subjdir/tmp/control.dat
if(-e $ControlPointsFile) then
  set UseControlPoints = 1;
  set CPOpt = (-f $ControlPointsFile);
else
  set CPOpt = ();
endif

#----------- Convert Input ------------------#
if($#InputList != 0) then
  @ nth = 1;
  foreach InputVol ($InputList)
    set nthid = `printf %03d.mgz $nth`
    set cmd = (mri_convert $InputVol $subjdir/mri/orig/$nthid)
    $PWD |& tee -a $LF
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    @ nth = $nth + 1;
  end
endif

#----------- Motion Correct and Average ------------------#
if($DoMotionCor) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# MotionCor `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  set cmd = ();

  # Get list of input run directories #
  set RunList = ();
  ls $subjdir/mri/orig/[0-9][0-9][0-9].mgz >& /dev/null
  if(! $status) then
    set RunList = `ls $subjdir/mri/orig/[0-9][0-9][0-9].mgz`;
  else
    # No runs found
    ls $subjdir/mri//[0-9][0-9][0-9].mgz >& /dev/null
    if(! $status) then
      set RunList = `ls $subjdir/mri//[0-9][0-9][0-9].mgz`;
    else
      ls $subjdir/src/[0-9][0-9][0-9].mgz >& /dev/null
      if(! $status) then
         set RunList = $subjdir/src/[0-9][0-9][0-9].mgz
      endif
    endif
  endif
  if($#RunList == 0) then
    echo "ERROR: no run data found in $subjdir/mri. Make sure to" \
      |& tee -a $LF
    echo "have a volume called 001.mgz in  $subjdir/mri/orig." |& tee -a $LF
    echo "If you have a second run of data call it 002.mgz, etc." \
      |& tee -a $LF
    echo "See also: https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/Conversion" \
      |& tee -a $LF
    goto error_exit;
  endif
  echo "Found $#RunList runs" |& tee -a $LF
  foreach run ($RunList)
    echo $run |& tee -a $LF
  end

  set origvol = $subjdir/mri/orig.mgz
  set rawavg  = $subjdir/mri/rawavg.mgz

  # Only one run, copy to rawavg
  if($#RunList == 1) then
    echo "WARNING: only one run found. This is OK, but motion"|& tee -a $LF
    echo "correction cannot be performed on one run, so I'll"|& tee -a $LF
    echo "copy the run to rawavg and continue."|& tee -a $LF
    sleep 2s;
    set cmd = (cp $RunList $rawavg)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      sleep 1; # Sleep here to assure that they have diff time stamps
      $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

  # Actually perform the motion correction -- creates rawavg
  if($#RunList > 1) then
    set cmd = (mri_motion_correct.fsl -o $rawavg -wild $RunList)
    echo "#-----------------------------------------------"
    $PWD |& tee -a $LF
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $cmd |& tee -a $LF
      if($status) goto error_exit;
      echo $cmd > $touchdir/motion_correct.touch
    endif
  endif

  # At this point, rawavg.mgz exists. Use it to create orig.mgz,
  # conform to COR FOV but keep mgz format.
  set cmd = (mri_convert $rawavg $origvol)
  if($#HiRes) then
    set cmd = ($cmd $HiRes)
  else
    set cmd = ($cmd --conform)
  endif
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) then
    $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/conform.touch
  endif

  # the cropsize256 option is used to process files having a FOV >256.
  # the image is cropped, and the center ras is properly set.
  if($DoCropsize256) then
    set cmd = (mri_convert $origvol $origvol)
    set cmd1 = ($cmd --cropsize 256 256 256)
    set CRAS = `mri_info --cras $origvol`
    set cmd2 = ($cmd --out_center ${CRAS})
    $PWD |& tee -a $LF
    echo "\n $cmd1 \n"|& tee -a $LF |& tee -a $CF
    echo "\n $cmd2 \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $cmd1 |& tee -a $LF
      if($status) goto error_exit;
      echo $cmd1 > $touchdir/crop.touch
      $cmd2 |& tee -a $LF
      if($status) goto error_exit;
      echo $cmd2 > $touchdir/cras.touch
    endif
  endif

  # Add xfm to orig, eventhough it does not exist yet. This is a
  # compromise to keep from having to change the time stamp of
  # the orig volume after talairaching.
  set cmd = (mri_add_xform_to_header -c \
             $subjdir/mri/transforms/talairach.xfm \
             $origvol $origvol)
  echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
  if($RunIt) then
    $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif

endif # Motion Correction

#--- Longitudinal: compute linear registration from tp1 to current subj ---#
if ($longitudinal) then
  echo "---------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Longitudinal: 1st Registration (linear) `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  set cmd = (fsl_rigid_register -cost corratio \
        -i $tp1dir/mri/orig.mgz \
        -r $subjdir/mri/orig.mgz \
        -o $subjdir/mri/orig_${tp1id}_to_${subjid}.mgz \
        -dof 6 \
        -ltamat $tp1dir/mri/transforms/$regfile)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) then
    if( -e $tp1dir/mri/transforms/$regfile) then
      rm -f $tp1dir/mri/transforms/$regfile
    endif
    $cmd |& tee -a $LF
    if($status) goto error_exit;
    if( ! -e $tp1dir/mri/transforms/$regfile) then
      echo "ERROR: FLIRT registration failed " |& tee -a $LF
      goto error_exit;
    endif
    rm -f $subjdir/mri/*.fslmat
  endif
endif

#----------- Nu Intensity Correction ------------------#
if($DoNuIntensityCor) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Nu Intensity Correction `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_nu_correct.mni $XOptsFile`;
  set cmd = (mri_nu_correct.mni  --i orig.mgz \
     --o nu.mgz --n $NuIterations $xopts)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  touch $touchdir/nu.touch
endif

#----------- Talairach ------------------#
if($DoTalairach) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Talairach `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xfm = transforms/talairach.xfm
  set xfma = transforms/talairach.auto.xfm
  if ( $longitudinal ) then
    # longitudinal processing stream:
    set tal_targ = ${FREESURFER_HOME}/average/mni305.cor.mgz
    if( ! -e $tal_targ ) then
      echo "ERROR: template file $tal_targ for talairach reg doesn't exist" \
        |& tee -a $LF
      goto error_exit;
    endif
    if( -e $tp1dir/mri/$xfm) then
      set tal_xfm = $xfm
    else
      set tal_xfm = $xfma
    endif
    set cmd = (mri_concatenate_lta -invert1 -tal \
      $tp1dir/mri/orig.mgz $tal_targ \
      $tp1dir/mri/transforms/$regfile \
      $tp1dir/mri/$tal_xfm \
      $subjdir/mri/$xfma)
  else
    # default processing:
    if ($UseMincMritotal) then
      # use the MINC mritotal utility
      set xopts = `fsr-getxopts talairach $XOptsFile`;
      set cmd = (talairach --i nu.mgz --xfm $xfma $xopts)
    else
      # Avi Snyder's registration tools
      set xopts = `fsr-getxopts talairach_avi $XOptsFile`;
      set cmd = (talairach_avi --i nu.mgz --xfm $xfma $xopts)
    endif
  endif
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  if($DoCleanTal || ! -e $xfm) then
    if(-e $xfm) cp $xfm transforms/bak/talairach.xfm.$DateString
    set cmd = (cp $xfma $xfm)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) then
      sleep 1; # Sleep here to assure that they have diff time stamps
      $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

  echo $cmd > $touchdir/talairach.touch
endif

# perform the failure detection scheme
if($DoTalCheck) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Talairach Failure Detection `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts talairach_afd $XOptsFile`;
  set xfm = transforms/talairach.xfm
  set cmd = (talairach_afd -T 0.005 -xfm $xfm $xopts)
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) then
    $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------- Defacing ------------------#
if($DoDeface) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Deface `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set cmd = (mri_deface orig.mgz \
     $FREESURFER_HOME/average/$brain_template \
     $FREESURFER_HOME/average/$face_template \
     orig_defaced.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  touch $touchdir/deface.touch
endif

#----------- Intensity Normalization1 ------------------#
if($DoNormalization) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Intensity Normalization `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF
  set xopts = `fsr-getxopts mri_normalize $XOptsFile`;
  if ( ! $longitudinal || ! $UseTP1CtrlVol) then
    # default processing stream:
    set cmd = (mri_normalize -g $NormMaxGrad);
    if($UseControlPoints) set cmd = ($cmd -f $ControlPointsFile)
    if($#Norm3dIters)     set cmd = ($cmd -n $Norm3dIters)
    if($IsMPRAGE)         set cmd = ($cmd -mprage)
    if($IsWashuMPRAGE)    set cmd = ($cmd -washu_mprage)
    set cmd = ($cmd $xopts nu.mgz T1.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
  else
    # longitudinal processing stream:
    if(! -e $tp1dir/mri/ctrl_vol.mgz) then
      echo "Recompute intensity normalization to create $tp1id ctrl_vol.mgz" \
        |& tee -a $LF
      set cmd = (mri_normalize)
      if($IsMPRAGE)      set cmd = ($cmd -mprage)
      if($IsWashuMPRAGE) set cmd = ($cmd -washu_mprage)
      set cmd = ($cmd \
        -mask $tp1dir/mri/brain.mgz
        -W $tp1dir/mri/ctrl_vol.mgz $tp1dir/mri/bias_vol.mgz \
        $tp1dir/mri/nu.mgz \
        $tp1dir/mri/T1_tmp.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
      if( ! -e $tp1dir/mri/ctrl_vol.mgz ) then
        echo "ERROR: unable to generate control-point volume for time-point1" \
          |& tee -a $LF
        goto error_exit;
      endif
      rm -f $tp1dir/mri/bias_vol.mgz
      rm -f $tp1dir/mri/T1_tmp.mgz
    endif
    set cmd = (mri_normalize_tp2 \
      -T1 $tp1dir/mri/nu.mgz \
      -ctrl $tp1dir/mri/ctrl_vol.mgz \
      -mask1 $tp1dir/mri/brain.mgz \
      -xform $tp1dir/mri/transforms/$regfile \
      $subjdir/mri/nu.mgz \
      $subjdir/mri/T1.mgz)
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
  endif
  echo $cmd > $touchdir/inorm1.touch
endif

#----------- Skull Stripping ------------------#
if($DoSkullStrip) then
skullstrip:
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Skull Stripping `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF

  if ($longitudinal) then
    # longitudinal processing stream:
    set BM  = brainmask.mgz
    set BMA = brainmask.auto.mgz
    set cmd = (mri_mask \
      -xform $tp1dir/mri/transforms/$regfile \
      T1.mgz \
      $tp1dir/mri/$BM $BMA)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    goto skipped_skullstrip;
  endif

  set xopts = `fsr-getxopts mri_watershed $XOptsFile`;
  set opts = ();
  if($WaterShed == 0) set opts = ($opts -n);
  if($WaterShed == 2) set opts = ($opts -wat);
  if($WaterShed == 3) set opts = ($opts -wat+temp);
  if($WaterShed == 4) set opts = ($opts -atlas);
  if($WSLess) set opts = ($opts -less);
  if($WSMore) set opts = ($opts -more);
  if($WSAtlas) set opts = ($opts -atlas);
  if($#WSSeedPoint != 0) set opts = ($opts -s $WSSeedPoint);
  if($#WSPctPreFlood != 0) then
    set opts = ($opts -h $WSPctPreFlood);
    set DoMultiStrip = 0
  else if( -e optimal_preflood_height) then
    set WSPctPreFlood = `cat optimal_preflood_height`
    set opts = ($opts -h $WSPctPreFlood);
    set DoMultiStrip = 0
    echo "Using optimal preflood height of $WSPctPreFlood" |& tee -a $LF
  endif

  set cmd = (mri_watershed)
  set BM  = brainmask.mgz

  if ($WSGcaAtlas || $DoMultiStrip) then
    # if using the GCA atlas to help with the skull-strip, then run the 
    # GCA registration (mri_em_register) to align to an atlas with a skull,
    # unless that file already exists
    if ( ! -e transforms/talairach_with_skull.lta || $DoCleanBM ) then
      set xopts2 = `fsr-getxopts mri_em_register $XOptsFile`;
      set cmd2 = (mri_em_register)
      set cmd2 = ($cmd2 -skull)
      set cmd2 = ($cmd2 $xopts2 nu.mgz $FREESURFER_HOME/average/$GCASkull)
      set cmd2 = ($cmd2 transforms/talairach_with_skull.lta)
      echo "\n $cmd2 \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd2 |& tee -a $LF
      if($status) goto error_exit;
      echo $cmd2 > $touchdir/em_register.touch
    endif

    if ($WSGcaAtlas) then
      # if just using -brain_atlas flag, then include necessary options
      set opts = (-brain_atlas $FREESURFER_HOME/average/$GCASkull \
                  transforms/talairach_with_skull.lta $opts)
    endif
  endif

  if($DoMultiStrip) then

    # when DoMultiStrip is enabled, multiple instances of mri_watershed are
    # run each using the following preflood height parameters
    if ( $?WATERSHED_PREFLOOD_HEIGHTS ) then
      # externally specified in the environment
      set PREFLOOD_HEIGHTS = ( $WATERSHED_PREFLOOD_HEIGHTS )
    else
      # defaults:
      set PREFLOOD_HEIGHTS = ( 5 10 20 30 )
    endif
    set SS_VOLUMES = ( orig T1 )
    if ( $?GOTO_LL_CALC ) goto ll_calc

    # create command files, one job for each volume type and preflood height...
    set CMDFS = ()
    foreach vol ( $SS_VOLUMES )
      foreach pfh ( $PREFLOOD_HEIGHTS )
        set cmd = (mri_watershed)
        set BMA_OLD = brainmask.auto.mgz
        if(-e $BMA_OLD && -e $BM && ! $DoCleanBM) then
          set cmd = ($cmd -keep $BMA_OLD $BM $BM)
        endif
        set BMA = brainmask_${vol}_PFH${pfh}.auto.mgz
        set cmd = ($cmd $opts -h ${pfh} $xopts ${vol}.mgz $BMA)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        set CMDF = mri_watershed_${vol}_PFH${pfh}.cmd
        echo "$cmd" > $CMDF
        set CMDFS = ( $CMDFS $CMDF )
      end
    end

    # and launch parallel jobs and wait for completion.
    # the batchjobs script will append each job output to $LF
    if($RunIt) then
      batchjobs $LF $CMDFS
      if($status) goto error_exit;
    endif

    # brainmask volumes actually need to be T1 volumes, because while
    # mri_watershed may run best in some cases using orig.mgz as input,
    # we really want the brainmask to be from T1.mgz (post normalization)
    set CMDFS = ()
    foreach pfh ( $PREFLOOD_HEIGHTS )
      set BMA_ORIG = brainmask_orig_PFH${pfh}.auto.mgz
      if ( -e $BMA_ORIG ) then
        set cmd = (mri_mask T1.mgz $BMA_ORIG $BMA_ORIG)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        set CMDF = mri_mask_PFH${pfh}.cmd
        echo "$cmd" > $CMDF
        set CMDFS = ( $CMDFS $CMDF )
      endif
    end

    # and launch parallel jobs and wait for completion.
    # the batchjobs script will append each job output to $LF
    if($RunIt) then
      if($#CMDFS != 0) then
        batchjobs $LF $CMDFS
        if($status) goto error_exit;
      endif
    endif
    echo $cmd > $touchdir/skull_strip.touch

    # calculate a measure of skull-strip performance (mri_log_likelihood):
    ll_calc:
    set max_ll = -9999999999;
    set best_pfh = 0;
    set best_vol = ();
    set xopts = `fsr-getxopts mri_log_likelihood $XOptsFile`;
    foreach vol ( $SS_VOLUMES )
      foreach pfh ( $PREFLOOD_HEIGHTS )
        set BMA = brainmask_${vol}_PFH${pfh}.auto.mgz
        set LTA = transforms/talairach_with_skull.lta
        set cmd = (mri_log_likelihood -orig T1.mgz $BMA)
        set cmd = ($cmd $xopts $FREESURFER_HOME/average/$GCA $LTA)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) then
          $cmd |& tee -a $LF |& tee -a ll_tmp
          # extract the last line of output, containing the result
          set ll = `tail --lines 1 ll_tmp`
          rm -f ll_tmp
        endif
        if($status) goto error_exit;
        # and make the best result the brainmask.auto.mgz
        if($RunIt) then
          echo "$BMA log_likelihood= $ll" |& tee -a $LF
          if ("$ll" == "nan") continue
          if ($ll > $max_ll) then
            set max_ll = $ll;
            set best_pfh = $pfh;
            set best_vol = $vol;
            rm -f brainmask.auto.mgz
            cp $BMA brainmask.auto.mgz
            if($status) goto error_exit;
          endif
        endif
      end
    end
    if($RunIt) then
      if ($best_pfh == 0) then
        echo "ERROR: failure in calculating best preflood height param." \
          |& tee -a $LF
        goto error_exit;
      endif
      echo ""
      echo "Optimal input vol: $best_vol, pre-flood height= $best_pfh, results in log_likelihood= $max_ll" \
        |& tee -a $LF
      #rm -f *_PFH*.auto.*
      #rm -f *_PFH*.*
      # save this result, so that it is used next time, negating the need
      # to run mulitstrip (parallel jobs) again
      echo "$best_vol" > optimal_skullstrip_invol
      echo "$best_pfh" > optimal_preflood_height
    endif
    echo $cmd > $touchdir/log_likelihood.touch
    # make sure this is set properly:
    set BMA = brainmask.auto.mgz

  else

    # single-job skull-strip (default)

    set BMA = brainmask.auto.mgz
    if(-e $BMA && -e $BM && ! $DoCleanBM) set cmd = ($cmd -keep $BMA $BM $BM)
    set INVOL = T1
    if( -e optimal_skullstrip_invol) set INVOL = `cat optimal_skullstrip_invol`
    set cmd = ($cmd $opts $xopts $INVOL.mgz $BMA)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    if("$INVOL" == "orig") then
      # while mri_watershed may run best in some cases using orig.mgz as input,
      # we really want the brainmask to be from T1.mgz (post normalization)
      set cmd = (mri_mask T1.mgz $BMA $BMA)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/skull_strip.touch

  endif

  skipped_skullstrip:

  goto handle_legacy_brain_mask;
  handle_legacy_brain_mask_return:

  if(! -e $BM || $DoCleanBM) then
    set cmd = (cp $BMA $BM)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) then
      sleep 1; # Sleep here to assure that they have diff time stamps
      $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

endif

#-------------- GCA Registration  -------------------------#
if($DoGCAReg) then
  echo "#-------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# EM Registration `date`" |& tee -a $SF |& tee -a $LF  |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF
  set xopts = `fsr-getxopts mri_em_register $XOptsFile`;
  if ( ! $longitudinal ) then
    # default processing:
    set cmd = (mri_em_register -mask brainmask.mgz \
                $xopts nu.mgz $FREESURFER_HOME/average/$GCA \
                transforms/talairach.lta)
  else
    # longitudinal processing:
    set cmd = (mri_concatenate_lta -invert1 $tp1dir/mri/transforms/$regfile \
                $tp1dir/mri/transforms/talairach.lta \
                transforms/talairach.lta)
  endif
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/em_register.touch
endif

#------------ Canonical Normalization --------------#
if($DoCANormalize) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# CA Normalize `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null

  $PWD |& tee -a $LF
  set xopts = `fsr-getxopts mri_ca_normalize $XOptsFile`;
  set cmd = (mri_ca_normalize)
  if($UseControlPoints)  set cmd = ($cmd -f $ControlPointsFile)
  set cmd = ($cmd -mask brainmask.mgz $xopts nu.mgz \
      $FREESURFER_HOME/average/$GCA transforms/talairach.lta norm.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/ca_normalize.touch
endif

#--- Longitudinal: Second registration from tp1 to current subj ---#
if ($longitudinal) then
  echo "---------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Longitudinal: 2nd  Registration  `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF

  echo "REG_METHOD    = $REG_METHOD" |& tee -a $LF
  echo "REG_COST      = $REG_COST" |& tee -a $LF
  echo "REG_DOF       = $REG_DOF" |& tee -a $LF
  echo "REG_FILE_TYPE = $REG_FILE_TYPE" |& tee -a $LF

  if ( $REG_METHOD == fsl_rigid ) then
    set cmd = (fsl_rigid_register -cost $REG_COST \
        -i $tp1dir/mri/${REG_FILE_TYPE}.mgz \
        -r $subjdir/mri/${REG_FILE_TYPE}.mgz \
        -o $subjdir/mri/${REG_FILE_TYPE}_${tp1id}_to_${subjid}.mgz \
        -dof $REG_DOF \
        -ltamat $tp1dir/mri/transforms/$regfile)
  endif

  if ( $REG_METHOD == linear_align ) then
    set cmd = (mri_linear_align -r -skip 8 \
        $tp1dir/mri/${REG_FILE_TYPE}.mgz \
        $subjdir/mri/${REG_FILE_TYPE}.mgz \
        $tp1dir/mri/transforms/$regfile)
  endif

  if ( $REG_METHOD == nonlinear_align ) then
    set cmd = (mri_nl_align \
        -apply 0 \
        -z 1 \
        -passes 2 \
        -tol 0.2 \
        -levels 2 \
        -intensity 0.01 \
        -T $tp1dir/mri/transforms/$regfile \
        $tp1dir/mri/${REG_FILE_TYPE}.mgz \
        $subjdir/mri/${REG_FILE_TYPE}.mgz \
        $subjdir/mri/transforms/${subjid}_nl.m3z)
  endif

  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) then
    if( -e $tp1dir/mri/transforms/$regfile) then
      rm -f $tp1dir/mri/transforms/$regfile
    endif
    $cmd |& tee -a $LF
    if($status) goto error_exit;
    if( ! -e $tp1dir/mri/transforms/$regfile ) then
      echo "ERROR: SECOND registration: $REG_METHOD failed " |& tee -a $LF
      goto error_exit;
    endif
    if ( $REG_METHOD == fsl_rigid ) then
      set cmd = (rm -f $subjdir/mri/*.fslmat)
      $cmd |& tee -a $LF
    endif
  endif

endif

#------------ Canonical Registration --------------#
if($DoCAReg) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# CA Reg `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF

  set xopts = `fsr-getxopts mri_ca_register $XOptsFile`;
  set cmd = (mri_ca_register)
  set cmd = ($cmd $UseCAAlignAfter)
  if($UnCompress) set cmd = ($cmd -uncompress)
  if($BigVentricles) set cmd = ($cmd -bigventricles)
  if( ! $BigVentricles) set cmd = ($cmd -nobigventricles)
  if($DoSecondPassRenorm) set cmd = ($cmd -secondpassrenorm)
  set cmd = ($cmd -mask brainmask.mgz -T transforms/talairach.lta)
  if ( $longitudinal ) then
    set cmd = ($cmd -levels 2 -A 1 \
                -l $tp1dir/mri/transforms/talairach.m3z \
                $tp1dir/mri/transforms/$regfile)
  endif
  set cmd = ($cmd $xopts norm.mgz \
             $FREESURFER_HOME/average/$GCA \
             transforms/talairach.m3z)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) then
    echo "ERROR: mri_ca_register with non-zero status" |& tee -a $LF
    goto error_exit;
  endif
  echo $cmd > $touchdir/ca_register.touch
endif

#------------ Inverse of Canonical Registration --------------#
if($DoCARegInv) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# CA Reg Inv `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF
  # set xopts = `fsr-getxopts mri_ca_register $XOptsFile`; # careful here
  set cmd = (mri_ca_register -invert-and-save transforms/talairach.m3z)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) then
    echo "ERROR: mri_ca_register with non-zero status" |& tee -a $LF
    goto error_exit;
  endif
  echo $cmd > $touchdir/ca_register_inv.touch
endif

#------------ Removes neck and part of the face  --------------#
if($DoRemoveNeck) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# Remove Neck `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_remove_neck $XOptsFile`;
  set cmd = (mri_remove_neck -radius $RmNeckRadius $xopts \
             nu.mgz transforms/talairach.m3z \
             $FREESURFER_HOME/average/$GCA nu_noneck.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/mri_remove_neck.touch
endif

#------------ Recompute lta with skull but no neck  --------------#
if($DoSkullLTA) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# SkullLTA `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_em_register $XOptsFile`;
  set cmd = (mri_em_register -skull -t transforms/talairach.lta \
     $xopts nu_noneck.mgz $FREESURFER_HOME/average/$GCASkull \
     transforms/talairach_with_skull.lta)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/skull.lta.touch
endif

#-------------- SubCort Segmentation --------------#
if($DoCALabel) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# SubCort Seg `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null

  # Check whether there is a difference bet aseg.auto.mgz
  # and aseg.mgz, which indicates an edit. Must do this
  # prior to doing labeling.
  if(-e aseg.auto.mgz && -e aseg.mgz) then
    set cmd = (mri_diff aseg.auto.mgz aseg.mgz);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    set ASegDiff = $status;
    if($ASegDiff == 1) goto error_exit;
    # ASegDiff will = 0 if no diff or !0 for diff
  else
    set ASegDiff = 0;
  endif
  echo $ASegDiff

  set xopts = `fsr-getxopts mri_ca_label $XOptsFile`;
  set cmd = (mri_ca_label)
  set cmd = ($cmd $UseCAAlign)
  if($BigVentricles) set cmd = ($cmd -bigventricles)
  if( ! $BigVentricles) set cmd = ($cmd -nobigventricles)
  if($NoWMSA) set cmd = ($cmd -nowmsa)
  if( ! $longitudinal ) then
    # default stream:
    set cmd = ($cmd $xopts norm.mgz \
        transforms/talairach.m3z $FREESURFER_HOME/average/$GCA \
        aseg.auto.mgz);
  else
    # longitudinal processing:
    set cmd = ($cmd $xopts -l $tp1dir/mri/aseg.mgz \
        $tp1dir/mri/transforms/$regfile norm.mgz \
        transforms/talairach.m3z $FREESURFER_HOME/average/$GCA \
        aseg.auto.mgz);
  endif
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;

  if($DoCleanASeg || ! $ASegDiff) then
    set cmd = (cp aseg.auto.mgz aseg.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) then
      sleep 1; # Sleep here to assure that they have diff time stamps
      $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif
  echo $cmd > $touchdir/ca_label.touch
endif

# ----------- Intensity Normalization2 ------------------------#
if($DoNormalization2) then
  echo "#--------------------------------------------" \
    |& tee -a $LF  |& tee -a $CF
  echo "#@# Intensity Normalization2 `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_normalize $XOptsFile`;
  set cmd = (mri_normalize);
  if($UseControlPoints)   set cmd = ($cmd -f $ControlPointsFile)
  if($IsMPRAGE)           set cmd = ($cmd -mprage)
  if($IsWashuMPRAGE)      set cmd = ($cmd -washu_mprage)
  if($UseAseg && ! $NoAsegInorm2) set cmd = ($cmd -aseg aseg.mgz)
  if($NoNormMGZ) then
    # norm.mgz doesnt exist with -noaseg or -nosubcortseg, so use brainmask.mgz
    set cmd = ($cmd $xopts brainmask.mgz brain.mgz)
  else
    set cmd = ($cmd -mask brainmask.mgz $xopts norm.mgz brain.mgz)
  endif
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/inorm2.touch
endif

# -------------- Mask BFS ----------------------#
if($DoMaskBFS) then
  echo "#--------------------------------------------" \
    |& tee -a $LF  |& tee -a $CF
  echo "#@# Mask BFS `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_mask $XOptsFile`;
  # Set threshold to WM_MIN_VAL=5
  set cmd = (mri_mask -T 5 $xopts brain.mgz brainmask.mgz brain.finalsurfs.mgz)
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
endif

#---------------- WM Segmentation --------------------------#
if($DoSegmentation) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# WM Segmentation `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null

  if(! $DoCleanWM && -e wm.mgz) then
    set cmd = (cp wm.mgz wm.seg.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif
  # ----------- Segment -------------------------
  set xopts = `fsr-getxopts mri_segment $XOptsFile`;
  set cmd = (mri_segment);
  if ($NoThicken) set cmd = ($cmd -thicken 0)
  if(! $DoCleanWM && -e wm.seg.mgz) set cmd = ($cmd -keep)
  if($IsMPRAGE)         set cmd = ($cmd -mprage)
  if($IsWashuMPRAGE)    set cmd = ($cmd -washu_mprage)
  set cmd = ($cmd $WMSeg_wlo $WMSeg_ghi $xopts brain.mgz wm.seg.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  # ----------- Edit with ASeg -------------------------
  if($UseAseg) then
    set xopts = `fsr-getxopts mri_edit_wm_with_aseg $XOptsFile`;
    set cmd = (mri_edit_wm_with_aseg)
    if(! $DoCleanWM) set cmd = ($cmd -keep-in)
    set cmd = ($cmd $xopts wm.seg.mgz brain.mgz aseg.mgz wm.asegedit.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif
  # ----------- PreTess -------------------------
  set xopts = `fsr-getxopts mri_pretess $XOptsFile`;
  set wmlabelstring = "wm"
  if($UseAseg) then
    set WM_vol = wm.asegedit.mgz
  else
    set WM_vol = wm.seg.mgz
  endif
  if($NoNormMGZ) then
    set norm_vol = brain.mgz
  else
    set norm_vol = norm.mgz
  endif
  set cmd = (mri_pretess )
  if(! $DoCleanWM && -e wm.mgz) set cmd = ($cmd -keep)
  set cmd = ($cmd $xopts $WM_vol $wmlabelstring $norm_vol wm.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;

  echo $cmd > $touchdir/wmsegment.touch
endif

#---------------- Fill --------------------------#
if($DoFill) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Fill `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_fill $XOptsFile`;
  set seedopts = ();
  if($#PonsSeedCRS) set seedopts = ($seedopts -Pv  $PonsSeedCRS);
  if($#CCSeedCRS)   set seedopts = ($seedopts -Cv  $CCSeedCRS);
  if($#LHSeedCRS)   set seedopts = ($seedopts -lhv $LHSeedCRS);
  if($#RHSeedCRS)   set seedopts = ($seedopts -rhv $RHSeedCRS);
  set cmd = (mri_fill -a ../scripts/ponscc.cut.log $seedopts)
  if(-e transforms/talairach.lta) then
    set cmd = ($cmd  -xform transforms/talairach.lta)
  endif
  if($UseAseg) set cmd = ($cmd -segmentation aseg.mgz);
  if(! $UseOldTopoFix && ! $NoNormMGZ) set cmd = ($cmd -topofix norm.mgz);
  set cmd = ($cmd $xopts wm.mgz filled.mgz)
  $PWD |& tee -a $LF
  echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;

  echo $cmd > $touchdir/fill.touch
endif

#########################################################
#                  Per-Hemisphere                       #
#########################################################

foreach hemi ($hemilist)

  #---------------- Tessellate --------------------------#
  if($DoTessellate && ( ! $longitudinal )) then
    if($hemi == "lh") then
      set hemivalue = 255;
    else
      set hemivalue = 127;
    endif
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Tessellate $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF

    # necessary second pretess, per f.segonne
    set xopts = `fsr-getxopts mri_pretess $XOptsFile`;
    if($NoNormMGZ) then
      set norm_vol = brain.mgz
    else
      set norm_vol = norm.mgz
    endif
    set cmd = (mri_pretess $xopts ../mri/filled.mgz $hemivalue \
                ../mri/$norm_vol ../mri/filled-pretess$hemivalue.mgz)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;

    set xopts = `fsr-getxopts mri_tessellate $XOptsFile`;
    set cmd = (mri_tessellate $xopts ../mri/filled-pretess$hemivalue.mgz \
                $hemivalue ../surf/$hemi.orig.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    set cmd = (rm -f ../mri/filled-pretess$hemivalue.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF

    # remove possible extra components, per f.segonne
    set xopts = `fsr-getxopts mris_extract_main_component $XOptsFile`;
    set cmd = (mris_extract_main_component $xopts ../surf/$hemi.orig.nofix \
               ../surf/$hemi.orig.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;

    echo $cmd > $touchdir/$hemi.tessellate.touch
  endif

  #---------------- Smooth1 --------------------------#
  if($DoSmooth1 && ( ! $longitudinal )) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Smooth1 $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_smooth $XOptsFile`;
    # -nw prevents it from writing curv and area
    set cmd = (mris_smooth -nw)
    if ($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts \
        ../surf/$hemi.orig.nofix ../surf/$hemi.smoothwm.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    $PWD |& tee -a $LF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.smoothwm1.touch
  endif

  #---------------- Inflate1 --------------------------#
  if($DoInflate1 && ( ! $longitudinal )) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Inflation1 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_inflate $XOptsFile`;
    set cmd = (mris_inflate  -no-save-sulc $xopts \
      ../surf/$hemi.smoothwm.nofix ../surf/$hemi.inflated.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    $PWD |& tee -a $LF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.inflate1.touch
  endif

  #---------------- QSphere --------------------------#
  if($DoQSphere && ( ! $longitudinal )) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# QSphere $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_sphere $XOptsFile`;
    set cmd = (mris_sphere -q)
    if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts)
    set cmd = ($cmd ../surf/$hemi.inflated.nofix ../surf/$hemi.qsphere.nofix)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.qsphere.touch
  endif

  #---------------- Fix Topology --------------------------#
  if($DoFix && ( ! $longitudinal )) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Fix Topology $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    # Must copy unfixed to fixed
    set cmd = (cp ../surf/$hemi.orig.nofix ../surf/$hemi.orig)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    set cmd = (cp ../surf/$hemi.inflated.nofix ../surf/$hemi.inflated)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    # Now can run fixer
    if($UseOldTopoFix) then
      set xopts = `fsr-getxopts mris_fix_topology $XOptsFile`;
      set cmd = (mris_fix_topology -mgz -sphere qsphere.nofix)
      if($FixWithGA) set cmd = ($cmd -ga)
      if($FixDiagOnly) set cmd = ($cmd -diagonly)
      if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
      set cmd = ($cmd $xopts $subjid $hemi)
      $PWD |& tee -a $LF
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
      # check if total defect index != 0, meaning, euler # != 2 (surface bad)
      set cmd = (mris_euler_number ../surf/$hemi.orig)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) then 
        $cmd >& mris_euler_number.log
        if($status) goto error_exit;
        set defect_idx=`grep "total defect index" mris_euler_number.log | awk '{print $5}'`
        if("$defect_idx" != "0") then
          echo "mris_fix_topology failed! (euler number != 2)" |& tee -a $LF
          echo "Trying mris_topo_fixer..." |& tee -a $LF
          set UseNewTopoFix = 1
          set UseOldTopoFix = 0
          # cannot use the failed ?h.orig surface, must revert to ?.orig.nofix 
          set cmd = (cp ../surf/$hemi.orig.nofix ../surf/$hemi.orig)
          echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
          if($RunIt) $cmd |& tee -a $LF
          if($status) goto error_exit;
        endif
        cat mris_euler_number.log |& tee -a $LF
        rm -f mris_euler_number.log
      endif
    endif
    if($UseNewTopoFix) then
      set cmd = (cp ../surf/$hemi.qsphere.nofix ../surf/$hemi.qsphere)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
      set cmd = (cp ../surf/$hemi.smoothwm.nofix ../surf/$hemi.smoothwm)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
      set xopts = `fsr-getxopts mris_topo_fixer $XOptsFile`;
      set cmd = (mris_topo_fixer -mgz -warnings)
      if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
      set cmd = ($cmd $xopts $subjid $hemi)
      $PWD |& tee -a $LF
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    # run surface intersection checker/fixer
    set xopts = `fsr-getxopts mris_remove_intersection $XOptsFile`;
    set cmd = (mris_remove_intersection)
    set cmd = ($cmd $xopts ../surf/$hemi.orig ../surf/$hemi.orig)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    # Remove hemi.inflated, real one created after make_final_surfs
    set cmd = (rm ../surf/$hemi.inflated)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd
    if($UseNewTopoFix) then
      # Copy *h.orig_corrected to *h.orig
      set cmd = (cp ../surf/$hemi.orig_corrected ../surf/$hemi.orig )
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.topofix.touch
  endif

  # Smooth2 and Inflate2 moved to after MFS

  #---------------- Make Final Surfaces --------------------------#
  if($DoFinalSurfs) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Make Final Surf $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null

    if( $longitudinal ) then
      set cmd = (mris_transform --dst $subjdir/mri/orig.mgz \
        $tp1dir/surf/${hemi}.white \
        $tp1dir/mri/transforms/$regfile \
        $subjdir/surf/${hemi}.orig)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd
      if($status) goto error_exit;

      set cmd = (mris_transform --dst $subjdir/mri/orig.mgz \
        $tp1dir/surf/${hemi}.white \
        $tp1dir/mri/transforms/$regfile \
        $subjdir/surf/${hemi}.orig_white)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd
      if($status) goto error_exit;

      set cmd = (mris_transform --dst $subjdir/mri/orig.mgz \
        $tp1dir/surf/${hemi}.pial \
        $tp1dir/mri/transforms/$regfile \
        $subjdir/surf/${hemi}.orig_pial)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd
      if($status) goto error_exit;
    endif

    set xopts = `fsr-getxopts mris_make_surfaces $XOptsFile`;
    if( ! $longitudinal) then
      # default stream:
      set cmd = (mris_make_surfaces)
      if ( ! $UseAseg) set cmd = ($cmd -noaseg)
      if ($NoCortexLabel) set cmd = ($cmd -cortex 0)
      set cmd = ($cmd -mgz -T1 brain.finalsurfs $xopts $subjid $hemi);
    else
      # longitudinal processing:
      if ($no_orig_pial) then
        set cmd = (mris_make_surfaces \
            -orig_white orig_white \
            -orig orig_white)
      else
        set cmd = (mris_make_surfaces \
            -orig_white orig_white \
            -orig_pial orig_pial \
            -orig orig_white)
      endif
      set cmd = ($cmd -long -max 3.5 \
        -mgz -T1 brain.finalsurfs $xopts $subjid $hemi)
    endif
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.final_surfaces.touch
  endif

  #---------------- Smooth2 --------------------------#
  if($DoSmooth2) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Smooth2 $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_smooth $XOptsFile`;
    # Use -nw to keep from writing out curv and area
    # Default number of iterations is 10, but use 3 here
    set cmd = (mris_smooth -n 3 -nw)
    if ($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts)
    set cmd = ($cmd ../surf/$hemi.white ../surf/$hemi.smoothwm)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    $PWD |& tee -a $LF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.smoothwm2.touch
  endif

  #---------------- Inflate2 --------------------------#
  if($DoInflate2) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Inflation2 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_inflate $XOptsFile`;
    set cmd = (mris_inflate $xopts ../surf/$hemi.smoothwm \
               ../surf/$hemi.inflated)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    # create curvature files ?h.inflated.H and ?h.inflated.K
    set xopts = `fsr-getxopts mris_curvature $XOptsFile`;
    set cmd = (mris_curvature -n -a 5 -w -distances 10 10)
    set cmd = ($cmd $xopts ../surf/$hemi.inflated)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.inflate2.touch
  endif

  #---------------- Cortical Ribbon -------------------------#
  if($DoCortRibbonVolMask) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Cortical ribbon mask $hemi `date`" \
      |& tee -a $SF|& tee -a $LF|& tee -a $CF
    cd $subjdir/mri > /dev/null
    set xopts = `fsr-getxopts mris_surf2vol $XOptsFile`;
    set cmd = (mri_surf2vol --mkmask --hemi $hemi --fillribbon \
      --template orig.mgz --volregidentity $subjid \
      --outvol $hemi.ribbon.mgz $xopts);
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.cortical_ribbon.touch
  endif

  #---------------Begin Morph --------------------------------#
  #---------------- Sphere --------------------------#
  if($DoSphere) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Sphere $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    if ( ! $longitudinal ) then
      # default stream:
      set xopts = `fsr-getxopts mris_sphere $XOptsFile`;
      set cmd = (mris_sphere)
      if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
      if($UseNoNeg) set cmd = ($cmd -remove_negative 1)
      set cmd = ($cmd $xopts)
      set cmd = ($cmd ../surf/$hemi.inflated ../surf/$hemi.sphere)
    else
      # longitudinal processing:
      set cmd = (cp $tp1dir/surf/$hemi.sphere $subjdir/surf/$hemi.sphere)
    endif
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.sphmorph.touch
  endif

  #---------------- Surface Registration --------------------------#
  if($DoSurfReg) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Surf Reg $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set AvgTif = ${AvgCurvTifPath}/$hemi.${AvgCurvTif}
    set xopts = `fsr-getxopts mris_register $XOptsFile`;
    set cmd = (mris_register -curv)
    if($UseNoNeg) set cmd = ($cmd -remove_negative 1)
    set cmd = ($cmd $xopts)
    if ( ! $longitudinal ) then
      # default stream:
      set cmd = ($cmd ../surf/$hemi.sphere $AvgTif ../surf/$hemi.sphere.reg)
    else
      # longitudinal processing:
      set cmd = ($cmd  -nosulc -norot \
                    $tp1dir/surf/$hemi.sphere.reg \
                    $AvgTif \
                    ../surf/$hemi.sphere.reg)
    endif
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.sphreg.touch
  endif

  #---------------- Jacobian white --------------------------#
  if($DoJacobianWhite) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Jacobian white $hemi `date`" \
        |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    # produce the jacobian, from the white surface to the sphere
    set cmd = (mris_jacobian \
                ../surf/$hemi.white \
                ../surf/$hemi.sphere.reg \
                ../surf/$hemi.jacobian_white)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.jacobian_white.touch
  endif

  #--- Surface Registration, allow maximal distortion, produce Jacobian ---#
  if($DoJacobianDist0) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Jacobian dist0 $hemi `date`" \
        |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set AvgTif = ${AvgCurvTifPath}/$hemi.${AvgCurvTif}
    set xopts = `fsr-getxopts mris_register $XOptsFile`;
    set cmd = (mris_register -curv -norot -jacobian \
        ../surf/$hemi.jacobian_dist0 -dist 0)
    set cmd = ($cmd $xopts)
    set cmd = ($cmd ../surf/$hemi.sphere.reg $AvgTif \
        ../surf/$hemi.sphere.dist0.jacobian.reg)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.jacobian_dist0.touch
  endif

  #---------------- Average Curv for Display----------------------#
  if($DoAvgCurv) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# AvgCurv $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    set AvgTif = ${AvgCurvTifPath}/$hemi.${AvgCurvTif}
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mrisp_paint $XOptsFile`;
    # -a 5 means to smooth 5 iterations
    set cmd = (mrisp_paint -a 5 $xopts "$AvgTif#6" \
      ../surf/$hemi.sphere.reg ../surf/$hemi.avg_curv)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.avgcurv.touch
  endif

  #---------------- Cortical Parcellation------------------------#
  if($DoCortParc) then
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Cortical Parc $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_ca_label $XOptsFile`;
    set CPAtlas = $FREESURFER_HOME/average/$hemi.$GCS
    set annot = ../label/$hemi.aparc.annot
    set cmd = (mris_ca_label)
    if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    if( ! $longitudinal) then
      # default stream:
      set cmd = ($cmd $xopts $subjid $hemi \
                    ../surf/$hemi.sphere.reg $CPAtlas $annot)
    else
      # longitudinal:
      set cmd = ($cmd $xopts \
                    -long -R $tp1dir/label/${hemi}.aparc.annot \
                    $subjid $hemi \
                    ../surf/$hemi.sphere.reg $CPAtlas $annot)
    endif
    $PWD |& tee -a $LF
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.aparc.touch
  endif

  # ---------- Surface Anatomical Stats ---------------------------
  if($DoParcStats) then
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Parcellation Stats $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set annot = ../label/$hemi.aparc.annot
    set stats = ../stats/$hemi.aparc.stats
    set ctab  = ../stats/aparc.annot.ctab
    set xopts = `fsr-getxopts mris_anatomical_stats $XOptsFile`;
    set cmd = (mris_anatomical_stats -mgz -f $stats \
            -b -a $annot -c $ctab $xopts $subjid $hemi);
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.aparcstats.touch
  endif

  #---------------- Cortical Parcellation 2------------------------#
  if($DoCortParc2) then
    echo "#-----------------------------------------"\
      |& tee -a $LF |& tee -a $CF
    echo "#@# Cortical Parc 2 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_ca_label $XOptsFile`;
    set CPAtlas = $FREESURFER_HOME/average/$hemi.atlas2005_simple.gcs
    set annot = ../label/$hemi.aparc.a2005s.annot
    set cmd = (mris_ca_label)
    if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    if( ! $longitudinal) then
      # default stream:
      set cmd = ($cmd $xopts $subjid $hemi \
                    ../surf/$hemi.sphere.reg $CPAtlas $annot)
    else
      # longitudinal:
      set cmd = ($cmd $xopts \
                    -long -R $tp1dir/label/${hemi}.aparc.a2005s.annot \
                    $subjid $hemi \
                    ../surf/$hemi.sphere.reg $CPAtlas $annot)
    endif
    $PWD |& tee -a $LF
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.aparc2.touch
  endif

  # ---------- Surface Anatomical Stats 2 ---------------------------
  if($DoParcStats2) then
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Parcellation Stats 2 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set annot = ../label/$hemi.aparc.a2005s.annot
    set stats = ../stats/$hemi.aparc.a2005s.stats
    set ctab  = ../stats/aparc.annot.a2005s.ctab
    set xopts = `fsr-getxopts mris_anatomical_stats $XOptsFile`;
    set cmd = (mris_anatomical_stats -mgz -f $stats \
            -b -a $annot -c $ctab $xopts $subjid $hemi);
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.aparcstats2.touch
  endif

  # ---------- Surface Vertices Number Match Check --------------
  if($DoVnoMatchCheck) then
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Vno Match Check $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set cmd = (vno_match_check $subjid $hemi);
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.vnomatchcheck.touch
  endif

  # ------ Compare aseg stats of two subjects ------
  if ($DoAparcStatsDiff) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# AParc Stats Diff `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $SUBJECTS_DIR > /dev/null
    $PWD |& tee -a $LF
    foreach parc (aparc)
      foreach meas (area volume thickness)
        set subj1=($tp1id)
        if ( "x$subj1" == "x$subjid" ) then
          # aparcstats2table doesnt accept identical subject names, so fake it
          ln -s $subj1 ${tp1id}_tmp
          set subj1=(${tp1id}_tmp)
        endif
        set cmd=(aparcstatsdiff $subj1 $subjid $hemi $parc $meas)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) $cmd |& tee -a $LF
        if (-e ${tp1id}_tmp) rm ${tp1id}_tmp
      end
    end
    echo $cmd > $touchdir/aparcstatsdiff.touch
  endif

end # Loop over hemilist

#-------------- ASeg Stats --------------#
if($DoSegStats) then
  # Stats on the automatic segmentation
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# ASeg Stats `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir > /dev/null
  set xopts = `fsr-getxopts mri_segstats $XOptsFile`;
  set cmd = (mri_segstats --seg mri/aseg.mgz --sum stats/aseg.stats)
  set cmd = ($cmd --pv mri/norm.mgz )
  set cmd = ($cmd --excludeid 0)
  set cmd = ($cmd --brain-vol-from-seg --brainmask mri/brainmask.mgz)
  set cmd = ($cmd --in mri/norm.mgz --in-intensity-name norm)
  set cmd = ($cmd --in-intensity-units MR)
  set cmd = ($cmd --etiv --subject $subjid $xopts);
  if ( ( -e surf/lh.white ) && ( -e surf/rh.white ) ) then
    set cmd = ($cmd --surf-wm-vol)
  else
    echo "\nINFO: ?h.white surfaces not available to mri_segstats.\n"\
     |& tee -a $SF |& tee -a $LF |& tee -a $CF
  endif
  #set cmd = ($cmd --ctab-gca $FREESURFER_HOME/average/$GCA)
  set cmd = ($cmd --ctab $FREESURFER_HOME/ASegStatsLUT.txt)
  set cmd = ($cmd $xopts);
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/segstats.touch
endif

if ($DoAsegStatsDiff) then
  # Compare aseg stats of two subjects
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# ASeg Stats Diff `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $SUBJECTS_DIR > /dev/null
  set subj1=($tp1id)
  if ( "x$subj1" == "x$subjid" ) then
    # asegstats2table doesnt accept identical subject names, so fake it
    ln -s $subj1 ${tp1id}_tmp
    set subj1=(${tp1id}_tmp)
  endif
  set cmd=(asegstatsdiff $subj1 $subjid)
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if (-e ${tp1id}_tmp) rm ${tp1id}_tmp
  echo $cmd > $touchdir/asegstatsdiff.touch
endif


# ----------------- AParc2ASeg ---------------------------------------- #
if($DoAParc2ASeg) then
  echo "#-----------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# AParc-to-ASeg `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir > /dev/null
  set xopts = `fsr-getxopts mri_aparc2aseg $XOptsFile`;
  # Rahul's
  set cmd = (mri_aparc2aseg --s $subjid --ribbon $xopts)
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/aparc2aseg.touch
  # Now do Christophe's
  set xopts = `fsr-getxopts mri_aparc2aseg $XOptsFile`;
  set cmd = (mri_aparc2aseg --s $subjid --ribbon --a2005s $xopts)
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/aparc.a2005s2aseg.touch
endif

# -----------------------------------------------------------
# Do Contra Surface Registration here so don't have 
# to wait for other results
foreach hemi ($hemilist)

  # Registers ipsi and contra
  if($DoContraSurfReg) then
    if($hemi == lh) then
      set nothemi = rh;
    else
      set nothemi = lh;
    endif
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Contra Surf Reg $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set AvgTif = ${AvgCurvTifPath}/$nothemi.${AvgCurvTif}
    set xopts = `fsr-getxopts mris_register $XOptsFile`;
    set cmd = (mris_register -curv -reverse ../surf/$hemi.sphere)
    if($UseNoNeg) set cmd = ($cmd -remove_negative 1)
    set cmd = ($cmd $xopts)
    set cmd = ($cmd $AvgTif ../surf/$hemi.$nothemi.sphere.reg)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.sphreg.contra.touch
  endif

  # Register ipsi to contra directly (instead of thru sphere)
  # Creates lh.rh.sphere (note that there is no .reg)
  if($DoContraSurfRegWithinSubject) then
    cd $subjdir/surf
    if($hemi == lh) then
      set nothemi = rh;
    else
      set nothemi = lh;
    endif
    if(! -e $nothemi.inflated.H) then
      echo "ERROR: cannot find $nothemi.inflated.H, try running -inflate2" \
          |& tee -a $LF
      goto error_exit;
    endif
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Contra Surf Reg Within Subject $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    set cmd = (mris_register -dist 0.3 -reverse -1 \
       ./$hemi.sphere ./$nothemi.sphere ./$hemi.$nothemi.sphere)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.sphere.contra.touch
  endif

end # hemi


# ---------------------------------------------------------------
# Create the smoothed surfaces to fsaverage target needed by Qdec.
if ($DoQdecCache) then
  cd $subjdir/surf
  $PWD |& tee -a $LF
  foreach hemi ($hemilist)
    foreach measure ($measurelist)
      echo "#--------------------------------------------" \
          |& tee -a $LF |& tee -a $CF
      echo "#@# Qdec Cache $hemi $measure $target `date`" \
          |& tee -a $SF |& tee -a $LF |& tee -a $CF
      # check that the file exists, print only warning if not
      if ( ! -e ${hemi}.${measure} ) then
        echo "WARNING: File ${hemi}.${measure} does not exist!" \
            |& tee -a $LF |& tee -a $CF
        echo "Skipping creation of smoothed data for ${hemi}.${measure}" \
            |& tee -a $LF |& tee -a $CF
      else
        set MeasFile=(${hemi}.${measure}.${target})
        set cmd=(mris_preproc \
            --s ${subjid} \
            --hemi ${hemi} \
            --meas ${measure} \
            --target ${target} \
            --out ${MeasFile}.mgh)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) $cmd |& tee -a $LF
        if($status) goto error_exit;
        if($RunIt) rm -Rf tmp.mris_preproc.*

        foreach fwhm ($fwhmlist)
          set OutFile=(${hemi}.${measure}.fwhm${fwhm}.${target})
          set cmd=(mri_surf2surf \
              --s ${target} \
              --hemi ${hemi} \
              --fwhm ${fwhm} \
              --sval ${MeasFile}.mgh \
              --tval ${OutFile}.mgh)
          echo "#--------------------------------------------" \
              |& tee -a $LF |& tee -a $CF
          echo "#@# Qdec Cache $hemi $measure fwhm$fwhm $target `date`" \
              |& tee -a $SF |& tee -a $LF |& tee -a $CF
          echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
          if($RunIt) $cmd |& tee -a $LF
          if($status) goto error_exit;
          if($RunIt) rm -Rf tmp.mris_preproc.*
          echo $cmd > $touchdir/$hemi.$measure.$fwhm.qcache.touch
        end # fwhm
      endif # if ( ! -e ${hemi}.${measure} )
    end # measure
  end # hemi
endif # DoQdecCache


echo "" |& tee -a $LF
echo "#------------------------------------------" |& tee -a $LF
echo "" |& tee -a $LF

if($#NotifyFile != 0) then
  echo "INFO: touching notification file $NotifyFile" |& tee -a $LF
  touch $NotifyFile
endif

echo "recon-all finished without error at `date`" |& tee -a $LF |& tee -a $SF


if($#mailuser != 0) then
  echo "recon-all $subjid finished without error at `date`" | \
    mail -s "$subjid DONE `date`" $mailuser
endif

echo "done"

exit 0
#############------------------------------------#######################
##################>>>>>>>>>>>>>.<<<<<<<<<<<<<<<<<#######################
#############------------------------------------#######################

############--------------##################
error_exit:
  uname -a | tee -a $LF | tee -a $SF
  echo "" |& tee -a $LF |& tee -a $SF
  echo "recon-all exited with ERRORS at `date`" |& tee -a $LF |& tee -a $SF
  echo "" |& tee -a $LF |& tee -a $SF
  if($#mailuser != 0) then
    echo "recon-all $subjid finished with errors at `date`" | \
      mail -s "$subjid ERROR `date`" $mailuser
  endif

  exit 1;
endif

############--------------##################
parse_args:
set cmdline = ($argv);
while( $#argv != 0 )

  set flag = $argv[1]; shift;

  switch($flag)

    # This is a temporary flag to test how changing the way the vertex
    # area is computed in mrisurf.c affects a recon. It is set by default!
    case "-fixvertexarea"
      setenv FIX_VERTEX_AREA;
      breaksw
    case "-nofixvertexarea"
      unsetenv FIX_VERTEX_AREA;
      breaksw

    case "-subject":
    case "-subjid":
    case "-sid":
    case "-s":
      if ( $#argv < 1) goto arg1err;
      set subjid = $argv[1]; shift;
      set subjid = `basename $subjid`; # removes trailing /
      breaksw

    case "-sd":
      if ( $#argv < 1) goto arg1err;
      setenv  SUBJECTS_DIR $argv[1]; shift;
      breaksw

    case "-i"
      if( $#argv < 1) goto arg1err;
      set InputVol = "$argv[1]"; shift;
      if(! -e "$InputVol") then
        echo "ERROR: cannot find $InputVol"
        goto error_exit;
      endif
      if(! -r "$InputVol") then
        echo "ERROR: $InputVol exists but is not readable"
        goto error_exit;
      endif
      set InVolDir  = `dirname  "$InputVol"`;
      set InVolBase = `basename "$InputVol"`;
      pushd $InVolDir > /dev/null
      set InVolDir = `pwd`;
      popd > /dev/null
      set InputVol = "$InVolDir/$InVolBase";
      set InputList = ($InputList "$InputVol");
      set DoConvertInput = 1;
      breaksw

    case "-hemi":
      if ( $#argv < 1) goto arg1err;
      set hemilist = $argv[1]; shift;
      if($hemilist != lh && $hemilist != rh) then
        echo "ERROR: hemi = $hemilist, must be either lh or rh"
        goto error_exit;
      endif
      breaksw

    case "-mail":
      if ( $#argv < 1) goto arg1err;
      set mailuser = $argv[1]; shift;
      breaksw

    case "-motioncor":
    case "-mc":
      set DoMotionCor = 1;
      breaksw
    case "-nomotioncor":
    case "-nomc":
      set DoMotionCor = 0;
      breaksw

    case "-talairach":
      set DoTalairach = 1;
      breaksw
    case "-notalairach":
      set DoTalairach = 0;
      breaksw
    case "-use-mritotal":
      set UseMincMritotal = 1;
      breaksw

    case "-deface":
      set DoDeface = 1;
      breaksw
    case "-nodeface":
      set DoDeface = 0;
      breaksw

    case "-nuintensitycor":
      set DoNuIntensityCor = 1;
      breaksw
    case "-nonuintensitycor":
      set DoNuIntensityCor = 0;
      breaksw
    case "-nuinterations":
    case "-nuiterations":
      if ( $#argv < 1) goto arg1err;
      set NuIterations = $argv[1]; shift;
      breaksw

    case "-norm3diters":
      if ( $#argv < 1) goto arg1err;
      set Norm3dIters = $argv[1]; shift;
      breaksw

    case "-normmaxgrad":
      if ( $#argv < 1) goto arg1err;
      set NormMaxGrad = $argv[1]; shift;
      breaksw

    case "-normalization":
      set DoNormalization = 1;
      breaksw
    case "-nonormalization":
      set DoNormalization = 0;
      breaksw
    case "-normalization2":
      set DoNormalization2 = 1;
      breaksw
    case "-nonormalization2":
      set DoNormalization2 = 0;
      breaksw
    case "-usecontrolpoints":
      set UseControlPoints = 1;
      breaksw

    case "-maskbfs":
      set DoMaskBFS = 1;
      breaksw
    case "-nomaskbfs":
      set DoMaskBFS = 0;
      breaksw

    case "-skullstrip":
      set DoSkullStrip = 1;
      breaksw
    case "-noskullstrip":
      set DoSkullStrip = 0;
      breaksw

    case "-multistrip":
      set DoMultiStrip = 1;
      set DoSkullStrip = 1;
      breaksw
    case "-nomultistrip":
      set DoMultiStrip = 0;
      breaksw

    case "-segmentation":
      set DoSegmentation = 1;
      breaksw
    case "-nosegmentation":
      set DoSegmentation = 0;
      breaksw

    case "-gcareg":
      set DoGCAReg = 1;
      breaksw
    case "-nogcareg":
      set DoGCAReg = 0;
      breaksw

    case "-careginv":
      set DoCARegInv = 1;
      breaksw
    case "-nocareginv":
      set DoCARegInv = 0;
      breaksw

    case "-canorm":
      set DoCANormalize = 1;
      breaksw
    case "-nocanorm":
      set DoCANormalize = 0;
      breaksw

    case "-careg":
      set DoCAReg = 1;
      breaksw
    case "-nocareg":
      set DoCAReg = 0;
      breaksw

    case "-rmneck":
      set DoRemoveNeck = 1;
      breaksw
    case "-normneck":
      set DoRemoveNeck = 0;
      breaksw

    case "-skull-lta":
      set DoSkullLTA  = 1;
      breaksw
    case "-noskull-lta":
      set DoSkullLTA  = 0;
      breaksw

    case "-calabel":
      set DoCALabel = 1;
      breaksw
    case "-nocalabel":
      set DoCALabel = 0;
      breaksw

    case "-subcortseg":
      set DoGCAReg         = 1;
      set DoCARegInv       = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 1;
      breaksw

    case "-nosubcortseg":
      set DoGCAReg         = 0;
      set DoCARegInv       = 0;
      set DoRemoveNeck     = 0;
      set DoSkullLTA       = 0;
      set DoCANormalize    = 0;
      set DoCAReg          = 0;
      set DoCALabel        = 0;
      set DoSegStats       = 0;
      set NoNormMGZ        = 1;
      breaksw

    case "-noaseg":
      set UseAseg          = 0;
      set DoGCAReg         = 0;
      set DoCARegInv       = 0;
      set DoRemoveNeck     = 0;
      set DoSkullLTA       = 0;
      set DoCANormalize    = 0;
      set DoCAReg          = 0;
      set DoCALabel        = 0;
      set DoSegStats       = 0;
      set NoNormMGZ        = 1;
      set DoAParc2ASeg     = 0;
      breaksw

    case "-noaseg-inorm2":
      set NoAsegInorm2     = 1;
      breaksw

    case "-gca":
      if ( $#argv < 1) goto arg1err;
      set GCA = $argv[1]; shift;
      breaksw

    case "-gca-skull":
      if ( $#argv < 1) goto arg1err;
      set GCASkull = $argv[1]; shift;
      breaksw

    case "-fill":
      set DoFill = 1;
      breaksw
    case "-nofill":
      set DoFill = 0;
      breaksw
    case "-pons-crs":
      if ( $#argv < 3) goto arg3err;
      set PonsSeedCRS = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-cc-crs":
      if ( $#argv < 3) goto arg3err;
      set CCSeedCRS = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-lh-crs":
      if ( $#argv < 3) goto arg3err;
      set LHSeedCRS = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-rh-crs":
      if ( $#argv < 3) goto arg3err;
      set RHSeedCRS = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-watershed":
      echo $argv[1];
      if ( $#argv < 1 ) goto arg1err;
      switch($argv[1])
        case "nowatershed":
          set WaterShed = 0; breaksw;
        case "normal":
          set WaterShed = 1; breaksw;
        case "watershedonly":
          set WaterShed = 2; breaksw;
        case "watershedtemplate":
          set WaterShed = 3; breaksw;
        case "atlas":
          set WaterShed = 4; breaksw;
        default:
          echo "ERROR: -watershed argument $argv[1] unrecognized."
          echo "Valid arguments are: atlas, nowatershed, normal, watershedonly,"
          echo "and watershedtemplate."
          goto error_exit;
        breaksw;
      endsw
      shift;
      breaksw
    case "-wsless":
      set WSLess = 1; breaksw
    case "-wsmore":
      set WSMore = 1; breaksw
    case "-wsatlas":
      set WSAtlas = 1; breaksw
    case "-no-wsatlas":
      set WSAtlas = 0; breaksw
    case "-wsthresh":
      if ( $#argv < 1) goto arg1err;
      set WSPctPreFlood = $argv[1]; shift;
      breaksw
    case "-wsseed":
      if ( $#argv < 3) goto arg3err;
      set WSSeedPoint = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-wsgcaatlas":
      set WSGcaAtlas = 1; breaksw
    case "-no-wsgcaatlas":
      set WSGcaAtlas = 0; breaksw

    case "-seg-wlo"
      if( $#argv < 1) goto arg1err;
      set WMSeg_wlo = (-wlo $argv[1]); shift;
      breaksw
    case "-seg-ghi"
      if( $#argv < 1) goto arg1err;
      set WMSeg_ghi = (-ghi $argv[1]); shift;
      breaksw

    case "-ca-align":
      set UseCAAlign = (-align);
      breaksw
    case "-no-ca-align":
      set UseCAAlign = ();
      breaksw

    case "-ca-align-after":
      set UseCAAlignAfter = (-align-after);
      breaksw
    case "-no-ca-align-after":
      set UseCAAlignAfter = ();
      breaksw

    case "-tessellate":
    case "-tess":
      set DoTessellate = 1;
      breaksw
    case "-notessellate":
    case "-notess":
      set DoTessellate = 0;
      breaksw

    case "-smooth1":
      set DoSmooth1 = 1;
      breaksw
    case "-nosmooth1":
      set DoSmooth1 = 0;
      breaksw

    case "-inflate1":
      set DoInflate1 = 1;
      breaksw
    case "-noinflate1":
      set DoInflate1 = 0;
      breaksw

    case "-svinitinflated":
      set SvInitInflated = 1;
      breaksw
    case "-nosvinitinflated":
      set SvInitInflated = 0;
      breaksw

    case "-qsphere":
      set DoQSphere = 1;
      breaksw
    case "-noqsphere":
      set DoQSphere = 0;
      breaksw

    case "-fix":
      set DoFix = 1;
      breaksw
    case "-nofix":
      set DoFix = 0;
      breaksw

    case "-fix-with-ga":
      set FixWithGA = 1;
      breaksw

    case "-fix-with-ga-errflag":
      set DoFix = 1;
      set FixWithGA = 1;
      set FixWithErrFlag = 1;
      breaksw

    case "-no-fix-with-ga":
      set FixWithGA = 0;
      breaksw

    case "-fix-diag-only":
      set DoFix = 1;
      set FixWithGA = 1;
      set FixDiagOnly = 1;
      breaksw

    case "-use-old-fixer":
      set UseOldTopoFix = 1;
      set UseNewTopoFix = 0;
      breaksw

    case "-use-new-fixer":
      set UseOldTopoFix = 0;
      set UseNewTopoFix = 1;
      breaksw

    case "-norandomness":
      set NoRandomness = 1;
      breaksw

    case "-rng-seed":
      set NoRandomness = 1;
      set RngSeed = $argv[1]; shift;
      breaksw

    case "-smooth2":
      set DoSmooth2 = 1;
      breaksw
    case "-nosmooth2":
      set DoSmooth2 = 0;
      breaksw

    case "-inflate2":
      set DoInflate2 = 1;
      breaksw
    case "-noinflate2":
      set DoInflate2 = 0;
      breaksw

    case "-cortribbon":
      set DoCortRibbonVolMask = 1;
      breaksw
    case "-nocortribbon":
      set DoCortRibbonVolMask = 0;
      breaksw

    case "-sphere":
      set DoSphere = 1;
      breaksw
    case "-nosphere":
      set DoSphere = 0;
      breaksw

    case "-surfreg":
      set DoSurfReg = 1;
      breaksw
    case "-nosurfreg":
      set DoSurfReg = 0;
      breaksw

    case "-jacobian_white":
      set DoJacobianWhite = 1;
      breaksw
    case "-nojacobian_white":
      set DoJacobianWhite = 0;
      breaksw

    case "-jacobian_dist0":
      set DoJacobianDist0 = 1;
      breaksw
    case "-nojacobian_dist0":
      set DoJacobianDist0 = 0;
      breaksw

    case "-contrasurfreg":
      set DoContraSurfReg = 1;
      breaksw
    case "-nocontrasurfreg":
      set DoContraSurfReg = 0;
      breaksw

    case "-contrasurfreg-subj":
      set DoContraSurfRegWithinSubject = 1;
      breaksw
    case "-nocontrasurfreg-subj":
      set DoContraSurfRegWithinSubject = 0;
      breaksw

    case "-avgcurv":
      set DoAvgCurv = 1;
      breaksw
    case "-noavgcurv":
      set DoAvgCurv = 0;
      breaksw

    case "-finalsurfs":
      set DoFinalSurfs = 1;
      breaksw
    case "-nofinalsurfs":
      set DoFinalSurfs = 0;
      breaksw

    case "-cortparc":
      set DoCortParc = 1;
      breaksw
    case "-nocortparc":
      set DoCortParc = 0;
      breaksw

    case "-cortparc2":
      set DoCortParc2 = 1;
      breaksw
    case "-nocortparc2":
      set DoCortParc2 = 0;
      breaksw

    case "-parcstats":
      set DoParcStats = 1;
      breaksw
    case "-noparcstats":
      set DoParcStats = 0;
      breaksw

    case "-parcstats2":
      set DoParcStats2 = 1;
      breaksw
    case "-noparcstats2":
      set DoParcStats2 = 0;
      breaksw

    case "-segstats":
      set DoSegStats = 1;
      breaksw
    case "-nosegstats":
      set DoSegStats = 0;
      breaksw

    case "-aparc2aseg":
      set DoAParc2ASeg = 1;
      breaksw
    case "-noaparc2aseg":
      set DoAParc2ASeg = 0;
      breaksw

    case "-expert":
      if( $#argv < 1) goto arg1err;
      set XOptsFile = $argv[1]; shift;
      fsr-checkxopts $XOptsFile
      if($status) goto error_exit;
      set XOptsFile = `getfullpath $XOptsFile`
      breaksw

    case "-xopts-use"
      set XOptsUse = 1; # Use pre-existing xopts
      breaksw
    case "-xopts-clean"
      set XOptsClean = 1; # Delete pre-existing xopts
      breaksw
    case "-xopts-overwrite"
      set XOptsOverwrite = 1; # Overwrite pre-existing xopts
      breaksw

    case "-legacy":
      set DoLegacy = 1;
      breaksw
    case "-legacy-warn":
      # dont exit if -legacy is specified, but the dir is not
      # a legacy but was at one point
      set LegacyWarnOnly = 1;
      breaksw

    case "-clean":
      set DoCleanTal   = 1;
      set DoCleanCP    = 1;
      set DoCleanSeed  = 1;
      set DoCleanPFH   = 1;
      set DoCleanBM    = 1;
      set DoCleanASeg  = 1;
      set DoCleanWM    = 1;
      breaksw

    case "-clean-cp":
      set DoCleanCP   = 1;
      breaksw

    case "-clean-wm":
      set DoCleanWM   = 1;
      breaksw

    case "-clean-cpwm":
    case "-clean-wmcp":
      set DoCleanWM   = 1;
      set DoCleanCP   = 1;
      breaksw

    case "-clean-seed":
      set DoCleanSeed   = 1;
      breaksw

    case "-clean-tal":
      set DoCleanTal   = 1;
      breaksw

    case "-clean-pfh":
      set DoCleanPFH   = 1;
      breaksw

    case "-clean-bm":
      set DoCleanBM   = 1;
      breaksw

    case "-clean-aseg":
      set DoCleanASeg   = 1;
      breaksw

    case "-all":
    case "-autorecon-all":
      set DoMotionCor      = 1;
      set DoTalairach      = 1;
      set DoTalCheck       = 1;
      set DoNuIntensityCor = 1;
      set DoNormalization  = 1;
      set DoSkullStrip     = 1;
      set DoGCAReg         = 1;
      set DoCARegInv       = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 1;
      set DoNormalization2 = 1;
      set DoMaskBFS        = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoFinalSurfs     = 1;
      set DoCortRibbonVolMask = 1;
      set DoSphere         = 1;
      set DoSurfReg        = 1;
      set DoContraSurfReg  = 0;
      set DoAvgCurv        = 1;
      set DoJacobianWhite  = 1;
      set DoCortParc       = 1;
      set DoParcStats      = 1;
      set DoCortParc2      = 1;
      set DoParcStats2     = 1;
      set DoAParc2ASeg     = 1;
      breaksw

    case "-autorecon1":
      set DoMotionCor      = 1;
      set DoTalairach      = 1;
      set DoTalCheck       = 1;
      set DoNuIntensityCor = 1;
      set DoNormalization  = 1;
      set DoSkullStrip     = 1;
      breaksw

    case "-autorecon2":
      set DoGCAReg         = 1;
      set DoCARegInv       = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 1;
      set DoNormalization2 = 1;
      set DoMaskBFS        = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoFinalSurfs     = 1;
      set DoCortRibbonVolMask = 1;
      breaksw

    case "-autorecon2-volonly":
      set DoGCAReg         = 1;
      set DoCARegInv       = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 1;
      set DoNormalization2 = 1;
      set DoMaskBFS        = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      breaksw

    case "-autorecon2-perhemi":
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoFinalSurfs     = 1;
      set DoCortRibbonVolMask = 1;
      breaksw

    case "-autorecon2-inflate1":
      set DoGCAReg         = 1;
      set DoCARegInv       = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 1;
      set DoNormalization2 = 1;
      set DoMaskBFS        = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      breaksw

    case "-autorecon2-cp":
      set DoNormalization2 = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoMaskBFS        = 1;
      set DoFinalSurfs     = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoCortRibbonVolMask = 1;
      breaksw

    case "-autorecon2-wm":
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoMaskBFS        = 1;
      set DoFinalSurfs     = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoCortRibbonVolMask = 1;
      breaksw

    case "-autorecon2-pial":
      set DoMaskBFS        = 1;
      set DoFinalSurfs     = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoCortRibbonVolMask = 1;
      breaksw

    case "-autorecon3":
      set DoSphere         = 1;
      set DoSurfReg        = 1;
      set DoContraSurfReg  = 0;
      set DoAvgCurv        = 1;
      set DoJacobianWhite  = 1;
      set DoCortParc       = 1;
      set DoParcStats      = 1;
      set DoCortParc2      = 1;
      set DoParcStats2     = 1;
      set DoAParc2ASeg     = 1;
      breaksw

    case "-autorecon-hemi":
      if ( $#argv < 1) goto arg1err;
      set hemilist = $argv[1]; shift;
      if($hemilist != lh && $hemilist != rh) then
        echo "ERROR: hemi = $hemilist, must be either lh or rh"
        goto error_exit;
      endif
      set LF_DEFAULT_NAME = "recon-all-${hemilist}.log"
      set SF_DEFAULT_NAME = "recon-all-status-${hemilist}.log"
      set CF_DEFAULT_NAME = "recon-all-${hemilist}.cmd"
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoFinalSurfs     = 1;
      set DoCortRibbonVolMask = 1;
      set DoSphere         = 1;
      set DoSurfReg        = 1;
      set DoContraSurfReg  = 0;
      set DoAvgCurv        = 1;
      set DoJacobianWhite  = 1;
      set DoCortParc       = 1;
      set DoParcStats      = 1;
      set DoCortParc2      = 1;
      set DoParcStats2     = 1;
      set DoAParc2ASeg     = 1;
      breaksw

    case "-waitfor":
      if ( $#argv < 1) goto arg1err;
      set WaitForFile = $argv[1]; shift;
      breaksw

    case "-notify":
      if ( $#argv < 1) goto arg1err;
      set NotifyFile = $argv[1]; shift;
      breaksw

    case "-status":
      if ( $#argv < 1) goto arg1err;
      set SF = $argv[1]; shift;
      breaksw

    case "-noappendlog":
      set AppendLog = 0;
      breaksw

    case "-noappendstatus":
      set AppendStatus = 0;
      breaksw

    case "-noappend":
      set AppendLog = 0;
      set AppendStatus = 0;
      breaksw

    case "-log":
      if ( $#argv < 1) goto arg1err;
      set LF = $argv[1]; shift;
      breaksw

    case "-nolog":
      set LF = /dev/null
      breaksw

    case "-csurfdir":
      if ( $#argv < 1) goto arg1err;
      setenv FREESURFER_HOME $argv[1]; shift;
      if(! -e $FREESURFER_HOME) then
        echo "ERROR: cannot find $FREESURFER_HOME"
        goto error_exit;
      endif
      pushd $FREESURFER_HOME > /dev/null
      setenv FREESURFER_HOME `pwd`;
      breaksw

    case "-dontrun":
      set RunIt = 0;
      breaksw

    case "-onlyversions":
      set DoVersionsOnly = 1;
      breaksw

    case "-allowcoredump":
      limit coredumpsize unlimited
      breaksw

    case "-force":
      set Force = 1;
      breaksw

    case "-verbose":
      set verbose = 1;
      breaksw

    case "-echo":
      set echo = 1;
      breaksw

    case "-debug":
      set verbose = 1;
      set echo = 1;
      breaksw

    case "-umask":
      if ( $#argv < 1) goto arg1err;
      umask $1; shift;
      breaksw

    case "-grp":
      if ( $#argv < 1) goto arg1err;
      set grp = $argv[1];
      set curgrp = `id -gn`;
      if($grp != $curgrp) then
        echo "ERROR: current group ($curgrp) does not equal specified group $grp"
        goto error_exit;
      endif
      breaksw

    case "-cm":
      set HiRes = ('-cm')
      echo "INFO: all COR volumes are conformed to the min voxel size"
      breaksw

    case "-noneg":
      set UseNoNeg = 1;
      breaksw

    case "-nothicken":
      set NoThicken = 1;
      breaksw

    case "-nocortexlabel":
      set NoCortexLabel = 1;
      breaksw

    case "-uncompress":
      set UnCompress = 1;
      breaksw

    case "-bigventricles":
      set BigVentricles = 1;
      breaksw

    case "-nobigventricles":
      set BigVentricles = 0;
      breaksw

    case "-secondpassrenorm":
      set DoSecondPassRenorm = 1;
      breaksw

    # flags -long, -tp1id, -reg, -reg-method, -reg-cost, -reg-dof,
    # -reg-file-type, -no-orig-pial and -usetp1ctrlvol are all associated
    # with longitudinal processing
    case "-long":
    case "-longitudinal":
      set longitudinal = 1;
      breaksw

    case "-tp1id":
    case "-tp1":
      if ( $#argv < 1) goto arg1err;
      set tp1id = $argv[1]; shift;
      set tp1id = `basename $tp1id`; # remove trailing /
      breaksw

    case "-reg":
    case "-regfile":
      if ( $#argv < 1) goto arg1err;
      set regfile = $argv[1]; shift;
      breaksw

    case "-reg-method":
      if ( $#argv < 1) goto arg1err;
      set REG_METHOD = $argv[1]; shift;
      breaksw

    case "-reg-cost":
      if ( $#argv < 1) goto arg1err;
      set REG_COST = $argv[1]; shift;
      breaksw

    case "-reg-dof":
      if ( $#argv < 1) goto arg1err;
      set REG_DOF = $argv[1]; shift;
      breaksw

    case "-reg-file-type":
      if ( $#argv < 1) goto arg1err;
      set REG_FILE_TYPE = $argv[1]; shift;
      breaksw

    case "-no-orig-pial":
      set no_orig_pial = 1;
      breaksw

    case "-usetp1ctrlvol":
      set UseTP1CtrlVol = 1;
      breaksw

    case "-mprage":
      set IsMPRAGE = 1;
      breaksw;

    case "-washu_mprage":
      set IsWashuMPRAGE = 1;
      breaksw;

    case "-cropsize256":
      set DoCropsize256 = 1;
      breaksw;

    case "-nowmsa":
      set NoWMSA = 1;
      breaksw;

    case "-tal-check":
      set DoTalCheck = 1;
      breaksw;

    case "-notal-check":
      set DoTalCheck = 0;
      breaksw;

    case "-avgcurvtifpath":
      if ( $#argv < 1) goto arg1err;
      set AvgCurvTifPath = $argv[1]; shift;
      breaksw

    case "-avgcurvtif":
      if ( $#argv < 1) goto arg1err;
      set AvgCurvTif = $argv[1]; shift;
      breaksw

    case "-qcache":
      set DoQdecCache = 1;
      breaksw;

    case "-measure":
      if ( $#argv < 1) goto arg1err;
      set measurelist = $argv[1]; shift;
      breaksw

    case "-fwhm":
      if ( $#argv < 1) goto arg1err;
      set fwhmlist = $argv[1]; shift;
      breaksw

    case "-target":
      if ( $#argv < 1) goto arg1err;
      set target = $argv[1]; shift;
      breaksw

    case "-vno_match_check":
      set DoVnoMatchCheck = 1;
      breaksw;

    case "-make"
      if ( $#argv < 1) goto arg1err;
      set DoMakefile = 1;
      set MakefileTarget = $argv[1]; shift;
      breaksw;

    case "-asegstatsdiff":
      set DoAsegStatsDiff = 1;
      breaksw;

    case "-aparcstatsdiff":
      set DoAparcStatsDiff = 1;
      breaksw;

    default:
      echo ERROR: Flag $flag unrecognized.
      echo $cmdline
      goto error_exit;
      breaksw
  endsw
end

goto parse_args_return;
############--------------##################
############--------------##################
arg1err:
  echo "ERROR: flag $flag requires one argument"
  exit 1
############--------------##################
############--------------##################
arg3err:
  echo "ERROR: flag $flag requires three arguments"
  exit 1
############--------------##################


############--------------##################
check_params:
  if(! $DoVersionsOnly) then
    if($#subjid != 1) then
      echo "ERROR: must specify a subject id"
      exit 1;
    endif

    if(! $?SUBJECTS_DIR ) then
      echo "ERROR: environment variable SUBJECTS_DIR not set"
      echo "  this can be done by setting it in the shell before"
      echo "  executing recon-all or by using the -sd flag"
      exit 1;
    endif

    if(! -e $SUBJECTS_DIR ) then
      echo "ERROR: SUBJECTS_DIR $SUBJECTS_DIR does not exist."
      exit 1;
    endif

    if($longitudinal) then
      if($#tp1id != 1) then
        echo "ERROR: must specify a subject id for time-point1 (-tp1id subjid)"
        exit 1;
      endif

      if($#regfile != 1) then
        set regfile = ${tp1id}_to_${subjid}.lta
      endif

      set tp1dir = $SUBJECTS_DIR/$tp1id
      if(! -e $tp1dir) then
        echo "ERROR: cannot find $tp1dir"
        exit 1;
      endif
    endif

    # Get the full path #
    pushd $SUBJECTS_DIR > /dev/null
    setenv SUBJECTS_DIR `$PWD`;
    popd > /dev/null

    set subjdir = $SUBJECTS_DIR/$subjid

    #------------ Legacy -----------------------------------#
    if( -e $subjdir) then
      if(-e $subjdir/scripts/recon-all.status) then
        echo "INFO: this is a legacy analysis "
        if(! $DoLegacy) then
          echo "ERROR: user must specify -legacy with legacy analysis. "
          echo "  This will cause brain.mgz to be copied to brainmask.mgz,"
          echo "  and recon-all.status will be renamed to recon-all.legacy.status."
          echo "  At this point, the analysis will no longer be considered"
          echo "  legacy.";
          exit 1;
        endif
      endif
    endif
    if($DoLegacy && ! -e $subjdir/scripts/recon-all.status) then
      echo "ERROR: you have specified -legacy, but this does not look like "
      echo "       a legacy analysis".
      if( -e $subjdir/scripts/recon-all.legacy.status) then
        echo "         It appears that this was once a legacy analysis, but"
        echo "         it has been updated."
        if($LegacyWarnOnly) then
          echo "           BUT! you have asked to continue with a warning"
          set DoLegacy = 0;
        else
          exit 1;
        endif
      else
        exit 1;
      endif
    endif
    if($DoLegacy) then
      set brain     = $subjdir/mri/brain
      set brainmask = $subjdir/mri/brainmask
      set brainlegacy = $subjdir/mri/brain.legacy
      if(-e $brain.mgz) then
        cp $brain.mgz $brainmask.mgz
        if($status) goto error_exit;
        cp $brainmask.mgz $brainlegacy.mgz
        if($status) goto error_exit;
      else
        if(-e $brain/COR-.info) then
          mri_convert $brain $brainmask.mgz
          if($status) goto error_exit;
          cp $brainmask.mgz $brainlegacy.mgz
          if($status) goto error_exit;
        endif
      endif
      set aseg = $subjdir/mri/aseg
      if(-e $aseg.mgz) then
        cp $aseg.mgz $aseg.legacy.mgz
        if($status) goto error_exit;
      else
        if(-e $aseg/COR-.info) then
          mri_convert $aseg $aseg.mgz
          if($status) goto error_exit;
          cp $aseg.mgz $aseg.legacy.mgz
          if($status) goto error_exit;
        endif
      endif
      set wm = $subjdir/mri/wm
      if(-e $wm.mgz) then
        cp $wm.mgz $wm.legacy.mgz
        if($status) goto error_exit;
      else
        if(-e $wm/COR-.info) then
          mri_convert $wm $wm.mgz
          if($status) goto error_exit;
          cp $wm.mgz $wm.legacy.mgz
          if($status) goto error_exit;
        endif
      endif
      if(-e $subjdir/mri/orig) then
        pushd $subjdir/mri/orig > /dev/null
        ls -d [0-9][0-9][0-9] > /dev/null
        if(! $status) then
          set srclist = `ls -d [0-9][0-9][0-9]`;
          foreach src ($srclist)
            if(! -e $src.mgz) then
              set cmd = (mri_convert $src $src.mgz)
              echo $cmd
              $cmd
              if($status) exit 1;
            endif
          end
        endif
        popd > /dev/null
      endif
      mv $subjdir/scripts/recon-all.status \
         $subjdir/scripts/recon-all.legacy.status
    endif

    #----------------------------------------------------------------#
    if($#InputList == 0) then
      if(! -e $subjdir) then
        echo "ERROR: cannot find $subjdir"
        exit 1;
      endif
      if(! -w $subjdir) then
        echo "ERROR: you do not have write permission to  $subjdir"
        exit 1;
      endif
    else
      if( -e $subjdir) then
        if(! $Force) then
          echo "ERROR: $subjdir exists, delete or re-run with -force"
          exit 1;
        else
          echo "INFO: $subjdir exists with -i, but -force specified."
          echo "Deleting any previous source volumes"
          rm -f $subjdir/src/[0-9][0-9][0-9].mgz >& /dev/null
          rm -f $subjdir/mri/orig/[0-9][0-9][0-9].mgz >& /dev/null
        endif
      endif
      mkdir -p $subjdir
    endif
  else
    set subjdir = /tmp
  endif

  if(! $?FREESURFER_HOME ) then
    echo "ERROR: environment variable FREESURFER_HOME not set."
    exit 1;
  endif

  if(! -e $FREESURFER_HOME ) then
    echo "ERROR: FREESURFER_HOME $FREESURFER_HOME does not exist."
    exit 1;
  endif

  if(! -e $FREESURFER_HOME/average/$GCA ) then
    echo "ERROR: cannot find $FREESURFER_HOME/average/$GCA" |& tee -a $LF
    exit 1;
  endif

  if(! -e $FREESURFER_HOME/average/$GCASkull ) then
    echo "ERROR: cannot find $FREESURFER_HOME/average/$GCASkull" \
      |& tee -a $LF
    exit 1;
  endif

  foreach hemi ($hemilist)
    set avgtif = ${AvgCurvTifPath}/$hemi.${AvgCurvTif};
    if(! -e $avgtif) then
      echo "ERROR: cannot find $avgtif."
      exit 1;
    endif
    set GCSHemi = $FREESURFER_HOME/average/$hemi.$GCS
    if(! -e $GCSHemi) then
      echo "ERROR: cannot find $GCSHemi."
      exit 1;
    endif
    set CPAtlas = $FREESURFER_HOME/average/$hemi.$GCS
    if(! -e $CPAtlas) then
      echo "ERROR: cannot find $CPAtlas."
      exit 1;
    endif
  end

  if($XOptsUse == 1 && $XOptsClean == 1) then
    echo "ERROR: cannot specify both -xopts-clean and -xopts-use"
    exit(1);
  endif

  if($IsMPRAGE == 1 && $IsWashuMPRAGE == 1) then
    echo "ERROR: cannot specify both -mprage and -washu_mprage"
    exit(1);
  endif

  set XOptsPreExist = $subjdir/scripts/expert-options
  if(-e $XOptsPreExist) then
    # There is a pre-existing xopts file
    if($#XOptsFile == 0) then
      # XOpts not passed on cmd line
      if($XOptsUse == 0 && $XOptsClean == 0) then
        echo "ERROR: there is a pre-existing expert options file."
        echo "You must explicitly specify whether to:"
        echo "  1. Use the pre-existing file (-xopts-use)"
        echo "  2. Delete the pre-existing file (-xopts-clean)"
        exit(1);
      endif
      if($XOptsClean == 1) then
        rm -f $XOptsPreExist
        set XOptsFile = ();
      endif
      if($XOptsUse == 1) then
        set XOptsFile = $XOptsPreExist;
      endif
    else
      # XOpts was passed on cmd line, but pre-existing xopts file
      if(! $XOptsOverwrite) then
        echo "ERROR: there is a pre-existing expert options file and"
        echo "you have specified an expert options file on the command-line."
        echo "If you want to use the file specified on the command-line,"
        echo "you must run with -xopts-overwrite."
        exit(1);
      endif
      # If it gets here, then overwrite
      rm -f $XOptsPreExist
      cp $XOptsFile $XOptsPreExist
      if($status) goto error_exit;
    endif
  else
    # No pre-existing file
    if($#XOptsFile != 0) then
      # Expert options file specified on cmd line, make copy
      cp $XOptsFile $XOptsPreExist
      if($status) goto error_exit;
    endif
  endif

  if($#NotifyFile != 0) then
    rm -f $NotifyFile;
    set tmpdir = `dirname $NotifyFile`;
    mkdir -p $tmpdir;
    pushd $tmpdir > /dev/null;
    set tmpdir = `$PWD`;
    set NotifyFile = $tmpdir/`basename $NotifyFile`;
    popd > /dev/null;
  endif

  if($#WaitForFile != 0) then
    set tmpdir = `dirname $WaitForFile`;
    mkdir -p $tmpdir;
    pushd $tmpdir > /dev/null;
    set tmpdir = `$PWD`;
    set WaitForFile = $tmpdir/`basename $WaitForFile`;
    popd > /dev/null;
  endif

  if(! $DoCleanTal && ! $DoCleanCP && ! $DoCleanBM && ! $DoConvertInput &&\
     ! $DoCleanASeg && ! $DoCleanWM && ! $DoCleanSeed && \
     ! $DoCortParc && ! $DoCortParc2 && ! $DoGCAReg && ! $DoCARegInv &&\
     ! $DoMotionCor && ! $DoTalairach && ! $DoTalCheck && \
     ! $DoNormalization  && \
     ! $DoNormalization2  && ! $DoParcStats && ! $DoParcStats2 && \
     ! $DoVersionsOnly && ! $DoDeface &&  ! $DoCleanPFH && \
     ! $DoSkullStrip && ! $DoSegmentation && ! $DoNuIntensityCor &&\
     ! $DoFill && ! $DoTessellate && ! $DoAParc2ASeg && \
     ! $DoSmooth1  && ! $DoInflate1 && ! $DoQSphere && ! $DoRemoveNeck &&\
     ! $DoFix  && ! $DoSmooth2 && ! $DoInflate2  && ! $DoSphere &&\
     ! $DoSkullLTA && ! $DoQdecCache  && ! $DoVnoMatchCheck &&\
     ! $DoSurfReg  && ! $DoContraSurfReg  && ! $DoAvgCurv && ! $DoSegStats &&\
     ! $DoMorphRGB && ! $DoFinalSurfs && ! $DoContraSurfRegWithinSubject &&\
     ! $DoCortRibbonVolMask && ! $DoJacobianWhite && ! $DoJacobianDist0 && \
     ! $DoCANormalize && ! $DoCAReg && ! $DoCALabel && ! $DoMaskBFS && \
     ! $DoMakefile && ! $DoAsegStatsDiff && ! $DoAparcStatsDiff ) then
     echo "ERROR: nothing to do"
     exit 1;
  endif

  if($WSMore && $WSLess) then
    echo "ERROR: cannot specify both -wsmore and -wsless"
    exit 1;
  endif

  if( ($WSMore || $WSLess) && $WSPctPreFlood ) then
    echo "ERROR: cannot specify -wsmore or -wsless and -wsthresh"
    exit 1;
  endif

  if ($DoAsegStatsDiff) then
    if ( $#tp1id != 1 ) then
      echo "ERROR: -asegstatsdiff requires -tp1 <subjid>"
      exit 1;
    endif
  endif
  if ($DoAparcStatsDiff) then
    if ( $#tp1id != 1 ) then
      echo "ERROR: -aparcstatsdiff requires -tp1 <subjid>"
      exit 1;
    endif
  endif

goto check_params_return;
############--------------##################

############--------------##################
handle_legacy_brain_mask:
  # With a legacy analysis, there will be a brain.legacy.mgz volume
  # which is a copy of the legacy brain.mgz. The FIRST pass thru,
  # brain.mgz is copied to brainmask.mgz, so brain.legacy.mgz will
  # be the same as brainmask.mgz. This forces brainmask.mgz to
  # be created by masking brainmask.auto.mgz with brain.legacy.mgz.
  # At this point, brainmask.mgz will no longer be the same as
  # brain.legacy.mgz, and this branch will not be followed. However,
  # brainmask.mgz and brainmask.auto.mgz will not be the same,
  # which will trigger the differences to be preserved in subsequent
  # calls.
  set BL = brain.legacy.mgz
  if(-e $BL) then
    # BL exists
    if(! -e $BM) then
      # this can only happen if -clean was run
      goto handle_legacy_brain_mask_return;
    endif
    # Check whether it is the same as BM
    set mridifflog = /tmp/mridiff.tmp.$$.log
    set cmd = (mri_diff $BL $BM --log $mridifflog)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $cmd |& tee -a $LF
      if($status == 1) goto error_exit; # must check status==1
      if(! -e $mridifflog) then
        # Means BL=BM, create new BM by masking BMA with BL
        # Subsequently, BL!=BM, and this will not get run again
        set cmd = (mri_mask -T 1 $BMA $BL $BM)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    endif
  endif
goto handle_legacy_brain_mask_return;


############--------------##################

############--------------##################
usage_exit:
  echo ""
  echo "USAGE: $ProgName"
  echo ""
  echo " Required Arguments:";
  echo "   -subjid <subjid>"
  echo "   -<process directive>"
  echo ""
  echo " Fully-Automated Directive:"
  echo "  -all           : performs all stages of cortical reconstruction"
  echo "  -autorecon-all : same as -all"
  echo ""
  echo " Manual-Intervention Workflow Directives:"
  echo "  -autorecon1    : process stages 1-5 (see below)"
  echo "  -autorecon2    : process stages 6-24"
  echo "                   after autorecon2, check final surfaces:"
  echo "                     a. if wm edit was required, then run -autorecon2-wm"
  echo "                     b. if control points added, then run -autorecon2-cp"
  echo "                     c. if edits made to correct pial, then run -autorecon2-pial"
  echo "                     d. proceed to run -autorecon3"
  echo "  -autorecon2-cp : process stages 12-24 (uses -f w/ mri_normalize, -keep w/ mri_seg)"
  echo "  -autorecon2-wm : process stages 15-24"
  echo "  -autorecon2-inflate1 : 6-18"
  echo "  -autorecon2-perhemi : tess, sm1, inf1, q, fix, sm2, inf2, finalsurf, ribbon"
  echo "  -autorecon3    : process stages 25-31"
  echo "  -hemi ?h       : just do lh or rh (default is to do both)"
  echo ""
  echo "  Autorecon Processing Stages (see -autorecon# flags above):"
  echo "    1.  Motion Correction and Conform"
  echo "    2.  NU (Non-Uniform intensity normalization)"
  echo "    3.  Talairach transform computation"
  echo "    4.  Intensity Normalization 1"
  echo "    5.  Skull Strip"
  echo ""
  echo "    6.  EM Register (linear volumetric registration)"
  echo "    7.  CA Intensity Normalization"
  echo "    8.  CA Non-linear Volumetric Registration "
  echo "    9.  Remove neck"
  echo "    10. EM Register, with skull"
  echo "    11. CA Label (Aseg: Volumetric Labeling) and Statistics"
  echo ""
  echo "    12. Intensity Normalization 2 (start here for control points)"
  echo "    13. White matter segmentation"
  echo "    14. Edit WM With ASeg"
  echo "    15. Fill (start here for wm edits)"
  echo "    16. Tessellation (begins per-hemisphere operations)"
  echo "    17. Smooth1"
  echo "    18. Inflate1"
  echo "    19. QSphere"
  echo "    20. Automatic Topology Fixer"
  echo "    21. Final Surfs (start here for brain edits for pial surf)"
  echo "    22. Smooth2"
  echo "    23. Inflate2"
  echo "    24. Cortical Ribbon Mask"
  echo ""
  echo "    25. Spherical Mapping"
  echo "    26. Spherical Registration "
  echo "    27. Spherical Registration, Contralater hemisphere"
  echo "    28. Map average curvature to subject"
  echo "    29. Cortical Parcellation (Labeling)"
  echo "    30. Cortical Parcellation Statistics"
  echo "    31. Cortical Parcellation mapped to ASeg"
  echo ""
  echo " Step-wise Directives"
  echo "  See -help"
  echo ""
  echo " Expert Preferences"
  echo "  -pons-crs C R S : col, row, slice of seed point for pons, used in fill"
  echo "  -cc-crs C R S : col, row, slice of seed point for corpus callosum, used in fill"
  echo "  -lh-crs C R S : col, row, slice of seed point for left hemisphere, used in fill"
  echo "  -rh-crs C R S : col, row, slice of seed point for right hemisphere, used in fill"
  echo "  -nofill        : do not use the automatic subcort seg to fill"
  echo "  -watershed cmd : control skull stripping/watershed program"
  echo "  -wsless : decrease watershed threshold (shrinks skull surface)"
  echo "  -wsmore : increase watershed threshold (expands skull surface)"
  echo "  -wsatlas : use atlas when skull stripping"
  echo "  -no-wsatlas : do not use atlas when skull stripping"
  echo "  -wsthresh pct : explicity set watershed threshold"
  echo "  -wsseed C R S : identify an index (C, R, S) point in the skull"
  echo "  -nuiterations N : set number of iterations for nu intensity "
  echo "                    correction (default is $NuIterations)"
  echo "  -norm3diters niters : number of 3d iterations for mri_normalize"
  echo "  -normmaxgrad maxgrad : max grad (-g) for mri_normalize. Default is 1."
  echo "  -cm           : conform COR volumes to the min voxel size "
  echo "  -no-fix-with-ga : do not use genetic algorithm when fixing topology"
  echo "  -fix-diag-only  : topology fixer runs until ?h.defect_labels files"
  echo "                    are created, then stops"
  echo "  -seg-wlo wlo : set wlo value for mri_segment"
  echo "  -seg-ghi ghi : set ghi value for mri_segment"
  echo "  -nothicken   : pass '-thicken 0' to mri_segment"
  echo "  -no-ca-align-after : turn off -align-after with mri_ca_register"
  echo "  -no-ca-align : turn off -align with mri_ca_label"
  echo "  -deface      : deface subject, written to orig_defaced.mgz"
  echo ""
  echo "  -expert file     : read-in expert options file"
  echo "  -xopts-use       : use pre-existing expert options file"
  echo "  -xopts-clean     : delete pre-existing expert options file"
  echo "  -xopts-overwrite : overwrite pre-existing expert options file"
  echo ""
  echo "  -mprage : assume scan parameters are MGH MP-RAGE protocol"
  echo "  -washu_mprage : assume scan parameters are Wash.U. MP-RAGE protocol"
  echo ""
  echo " Notification Files (Optional)"
  echo "  -waitfor file : wait for file to appear before beginning"
  echo "  -notify  file : create this file after finishing"
  echo ""
  echo " Status and Log files (Optional)"
  echo "  -log     file : default is scripts/recon-all.log"
  echo "  -status  file : default is scripts/recon-all-status.log"
  echo "  -noappend     : start new log and status files instead of appending"
  echo ""
  echo " Other Arguments (Optional)"
  echo "  -force          : with -i, allows pre-existing subjdir. Deletes source."
  echo "  -sd subjectsdir : specify subjects dir (default env SUBJECTS_DIR)"
  echo "  -mail username  : mail user when done"
  echo "  -umask umask    : set unix file permission mask (default 002)"
  echo "  -grp groupid    : check that current group is alpha groupid "
  echo "  -onlyversions   : print version of each binary and exit"
  echo "  -debug          : print out lots of info"
  echo "  -allowcoredump  : set coredump limit to unlimited"
  echo "  -dontrun        : do everything but execute each command"
  echo "  -version        : print version of this script and exit"
  echo "  -help           : voluminous bits of wisdom"
  echo ""

  if(! $PrintHelp) exit 1;

  echo $VERSION
  echo ""

  cat $0 | awk 'BEGIN{prt=0}{if(prt) print $0;if($1 == "BEGINHELP") prt=1}'

exit 1;

#---- Everything below here is printed out as part of help -----#
BEGINHELP

Performs all, or any part of, the FreeSurfer cortical reconstruction
process. This help only gives some simple information. For more
detailed documentation, see https://surfer.nmr.mgh.harvard.edu

Basic usages:

1. Subject dir does not exist:

  recon-all -subject subjectname -i invol1 <-i invol2> -all

Creates analysis directory $SUBJECTS_DIR/subjectname, converts one or
more input volumes to MGZ format in subjectname/mri/orig, and runs
all processing steps. If subjectname exists, then an error is returned
when -i is used; but this can be overridden with -force (in which
case any pre-existing source volumes are deleted).

2. Manual conversion into mgz:

  mkdir -p $SUBJECTS_DIR/subjectname/mri/orig
  mri_convert invol1 $SUBJECTS_DIR/subjectname/mri/orig/001.mgz
  mri_convert invol2 $SUBJECTS_DIR/subjectname/mri/orig/002.mgz
  recon-all -subject subjectname -all

If no input volumes are given, then it is assumed that the subject
directory has already been created and that the raw data already
exists in MGZ format in subjid/mri/orig as XXX.mgz, where XXX is a
3-digit, zero-padded number.

3. Legacy Data

  recon-all -subject subjectname -all -legacy


SUBJECT IDENTIFICATION STRING

-s subjectname
-sid subjectname
-subjid subjectname
-subject subjectname

'subjectname' is the FreeSurfer subject identification string which doubles
as the name of the reconstruction root directory for this subject. This
reconstruction should be referenced by this string for all FreeSurfer
commands and in the register.dat matrix (for functional interfacing).


SPECIFYING DIRECTIVES

Directives instruct recon-all which part(s) of the reconstruction
stream to run. While it is possible to do everything in one shot (using
the -all flag), there can be some benefits to customizing the
stream. These benefits include stopping to perform manual editing as
well as parallelization. Directives are either clustered or step-wise.
Clustered directives are sets of steps that can be performed by
specifying a single flag. A step-wise directive refers to a single
step.  Directives accumulate. A step can be removed from a cluster by
adding -no<step> after the cluster flag. For example, specifying
-all followed by -notalairach will perform all the reconstruction
steps except talairaching. However, note that if -notalairach *preceeded*
-all, talairaching would still be performed.


CLUSTERED DIRECTIVES

-all
-autorecon-all

Perform all reconstruction steps.

-autorecon1

Motion correction through skull strip.

-autorecon2

Subcortical segmentation through make final surfaces.

-autorecon2-cp

Normalization2 through make final surfaces.

-autorecon2-wm

Fill through make final surfaces. Used after editing wm volume after running
-autorecon2.

-autorecon2-pial

Makes final surfaces. Used after editing brain volume after running
-autorecon2. The brain volume may be edited to fix problems with the
pial surface.

-autorecon3

Spherical morph and automatic cortical parcellation.


STEP-WISE DIRECTIVES

Step-wise directives allow the user to implement a single step in the
reconstruction process. See also STEP DESCRIPTION SUMMARIES below.
They also allow users to include/exclude a step from a clustered
DIRECTIVE. To include a step, use -step (eg, -skullstrip). To exclude
a step, use -nostep (eg -noskullstrip).

Run times are approximate for an AMD Opteron 64bit 2.5GHz processor:

  -<no>motioncor        < 5 min
  -<no>nuintensitycor     3 min
  -<no>talairach          4 min
  -<no>normalization      3 min
  -<no>skullstrip         1 min
  -<no>gcareg             8 min
  -<no>canorm             1 min
  -<no>careg             10 hours
  -<no>rmneck             3 min
  -<no>skull-lta          9 min
  -<no>calabel           30 min
  -<no>normalization2     3 min
  -<no>segmentation       4 min
  -<no>fill               1 min
  -<no>tessellate       < 1 min     per hemisphere
  -<no>smooth1          < 1 min     per hemisphere
  -<no>inflate1           1 min     per hemisphere
  -<no>qsphere           16 min     per hemisphere
  -<no>fix              1-9 hours   per hemisphere
  -<no>euler            < 1 min     per hemisphere
  -<no>smooth2          < 1 min     per hemisphere
  -<no>inflate2           2 min     per hemisphere
  -<no>finalsurfs       1-2 hours   per hemisphere
  -<no>cortribbon       < 1 min     per hemisphere
  -<no>sphere           1-2 hours   per hemisphere
  -<no>surfreg            1 hour    per hemisphere
  -<no>jacobian_white   < 1 min     per hemisphere
  -<no>contrasurfreg      1 hour    per hemisphere
  -<no>avgcurv          < 1 min     per hemisphere
  -<no>cortparc           1 min     per hemisphere
  -<no>parcstats        < 1 min     per hemisphere
  -<no>cortparc2          1 min     per hemisphere
  -<no>parcstats2       < 1 min     per hemisphere
  -<no>aparc2aseg         1 min

  -all                20-40 hours   both hemipheres


EXPERT PREFERENCES

-pons-crs C R S

Specify a seed point for the pons during the fill operation. This is
used to cut the brain stem from brain. By default, this point will be
determined automatically. It should only be specified if there is a
cut failure. To determine what this point should be, find the center
of the pons in the T1 volume (in tkmedit) and record the column, row,
and slice. Creates a file called scripts/seed-ponscrs.man.dat
with the CRS.

-cc-crs C R S

Specify a seed point for the corpus callosum during the fill
operation. This is used to help separate the hemispheres.  By default,
this point will be determined automatically. It should only be
specified if there is a cut failure.  To determine what this point
should be, find the center of the CC in the T1 volume (in tkmedit) and
record the column, row, and slice. Creates a file called
scripts/seed-cccrs.man.dat with the CRS.

-lh-crs C R S

Specify a seed point for the left hemisphere during the fill
operation. This is used to help identify the left hemisphere.  By
default, this point will be determined automatically. It should only
be specified if there is a cut failure.  To determine what this point
should be, find a point in the white matter mass of the left
hemisphere in the T1 volume (in tkmedit) and record the column, row,
and slice. Creates a file called scripts/seed-cccrs.man.dat with the
CRS. Remember that tkmedit displays the volume in radiological
convention (ie, left is right).

-rh-crs C R S

Same as -lh-crs but for the right hemisphere. Creates a file called
scripts/seed-rhcrs.man.dat with the CRS.

-watershed cmd

This controls how the skull stripping will be performed. Legal values are
normal (the default), atlas, nowatershed, watershedonly, and watershedtemplate.

-wsmore/-wsless

Increase/decrease the preflooding height (threshold) when skull
stripping. -wsmore will expand the skull surface; -wsless will shrink
the skull surface.  See also -wsthresh.

-wsthresh pctheight

Explicitly set the preflooding height when skull stripping.

-wsseed R C S

Supply a point in the volume that the user believes to be in the white
matter.  By default, this point will be determined automatically. It
should only be specified if there is a strip failure. To determine
what this point should be, find a point in the white matter using
tkmedit and record the Volume Index values (NOT the XYZ coordinates).

-gca gcafile

Specify the full path to the gaussian classifier array (GCA) file
to be used with GCA registration and automatic subcortical
segmentation. Default is RB_all_2006-02-15.gca located in
FREESURFER_HOME/average. This has no effect unless the GCA registration
or subcortical segmentation stages are to be performed.

-gca-skull gcafile

Specify the full path to the gaussian classifier array (GCA) file
to be used with registration with skull. Default is
RB_all_withskull_2006-02-15.gca located in
FREESURFER_HOME/average.

-nuiterations

Number of iterations in the non-uniform intensity correction.
Default is 2.

-norm3diters niters

Use niters 3d normalization iterations (passes as -n to mri_normalize).

-normmaxgrad maxgrad

Passes "-g maxgrad" to mri_normalize. Max grad default is 1.

-noaseg

Skips subcortical segmentation steps (same as -nosubcortseg), and does
not use aseg.mgz for inorm2, wm segmentation, or filling. Use this flag
for brains that do not support usage of Freesurfers subcortical
segmentation, such as baby brains, or non-human primates.

-noaseg-inorm2

Does not use aseg.mgz for the second mri_normalize step.

-norandomness

The random number generator used by certain binaries is seeded with the
same number, thus producing identical results from run to run.

-cropsize256

Include this flag after -autorecon1 if images have a FOV > 256.  The
flag causes mri_convert to crop the image to dimensions of 256^3.

-notal-check

Skip the automatic failure detection of Talairach alignment.

-qcache

Produce the pre-cached files required by the Qdec utility.  These files
are created by running mris_preproc, which creates smoothed surface data
files sampled to the 'fsaverage' common-space surface. By default, the surface
data for thickness, curv, sulc, area and jacobian_white are smoothed at 
0, 5, 10, 15, 20, and 25 mm FWHM.  
If just one set of surface data needs to be processed, then the option 
-measure <surfmeas> can follow -qcache, where <surfmeas> is one of: thickness, 
curv, sulc, area, jacobian_white or any surface measure. Another option is 
-fwhm <num> where <num> is a value in mm.  Also, -target <name> allows
specifying a common-space target other than fsaverage (the default).

-make target

Runs recon-all through 'make', the standard utility used to create a file
only if its dependencies are out-of-date.  This -make option makes use of the
file recon-all.makefile, where the dependency chain is specified.  
A 'target' argument must be specified.  The valid targets are:

  all
  autorecon1
  autorecon2
  autorecon2-volonly
  autorecon2-perhemi
  autorecon3
  qcache

These targets correspond to their flag equivalents in recon-all.  The 
difference in behaviour is that files are created only if the file does not
exist or if an input file used to create it has a newer date than the file
in need of creation.  It is also possible to supply the full pathname to a
particular file as a target.

The flag -dontrun can also be specified to show the commands that will run
without excuting them.


EXPERT OPTIONS FILE

While the expert preferences flags supported by recon-all cover most of
the instances where special flags need to be passed to a FreeSurfer binary,
to allow passing an arbitrary flag to a binary, recon-all supports the
reading of a user-created file containing special options to include in
the command string (in addition to, not in place of).  The file should
contain as the first item the name of the command, and the items following
it on rest of the line will be passed as the extra options.  For example,
if a file called expert.opts is created containing these lines:

  mri_em_register -p .5
  mris_topo_fixer -asc

then the option "-p .5" will be passed to mri_em_register, and "-asc"
will be passed to mris_topo_fixer.  The name of the expert options file
is passed to recon-all with the -expert flag, eg.

  recon-all -expert expert.opts

When an expert options is passed, it will be copied to scripts/expert-options.
Future calls to recon-all, the user MUST explicitly specify how to treat this file.
Options are (1) use the file (-xopts-use), or (2) delete it (-xopts-clean). If
this file exsts and the user specifies another expert options file, then
the user must also specify -xopts-overwrite.

The following FreeSurfer binaries will accept an expert option:

  talairach_avi
  mri_normalize
  mri_watershed
  mri_em_register
  mri_ca_normalize
  mri_ca_register
  mri_remove_neck
  mri_ca_label
  mri_segstats
  mri_mask
  mri_segment
  mri_edit_wm_with_aseg
  mri_pretess
  mri_fill
  mri_tessellate
  mris_smooth
  mris_inflate
  mris_sphere
  mris_fix_topology
  mris_topo_fixer
  mris_remove_intersection
  mris_make_surfaces
  mris_surf2vol
  mris_register
  mris_jacobian
  mrisp_paint
  mris_ca_label
  mris_anatomical_stats
  mri_aparc2aseg


NOTIFICATION FILES

Notification files allow the user to cascade invocations to recon-all,
with one invocation waiting until another one terminates. This is done
by specifying a file that must exist before an invocation can precede
(-waitfor) and/or specifying a file that is created when an invocation
terminates (-notify). This type of interprocess communication can
allow users to parallelize the stream. If this is to be done, note
that each hemisphere can be run separately by specifying the -hemi
flag.


LOG AND STATUS FILES

By default, log and status files are created in subjid/scripts. The
log file contains all the output from all the programs that have been
run during the invocation to recon-all. The status file has a list of
all the programs that have been run and the time at which each
started. The log file is intended to be a record of what was done
whereas the status file allows the user to easily see where in the
stream a currently running process is. The log file should be sent
with all bug reports. By default, these files are called recon-all.log
and recon-all-status.log, but this can be changed with the -log and
-status options. By default, the log and status are appended to. New
log and status files can be forced with the -noappend flag.


OTHER ARGUMENTS

-sd subjectsdir

This allows the user to specify the root of the FreeSufer subjects
directory. If unspecified, the environment variable SUBJECTS_DIR
is used.

-mail username

Send email to username when the process terminates.


STEP DESCRIPTION SUMMARIES

Motion Correction (-<no>motioncor)

When there are multiple source volumes, this step will correct for
small motions between them and then average them together. The input
are the volumes found in file(s) mri/orig/XXX.mgz. The output will be
the volume mri/orig.mgz. If no runs are found, then it looks for
a volume in mri/orig (or mri/orig.mgz). If that volume is there, then
it is used in subsequent processes as if it was the motion corrected
volume. If no volume is found, then the process exits with errors.

NU Intensity Correction (-<no>nuintensitycor)

Non-parametric Non-uniform intensity Normalization (N3), corrects for
intensity non-uniformity in MR data,  making relatively few assumptions
about the data.  This runs the MINC tool 'nu_correct'.  By default, four
iterations of nu_correct are run.  The flag -nuiterations specification
of some other number of iterations.

Talairach (-<no>talairach)

This computes the affine transform from the orig volume to the MNI305
atlas using Avi Snyders 4dfp suite of image registration tools,
through a FreeSurfer script called talairach_avi. Several of the downstream
programs use talairach coordinates as seed points. You can/should check
how good the talairach registration is using
"tkregister2 --s subjid --fstal". You must have an "fsaverage" subject in
your SUBJECTS_DIR. tkregister2 allows you to compare the orig volume
against the talairach volume resampled into the orig space. If you modify
the registration, it will change the talairach.xfm file. Your edits will
be *not* be overwritten unless you run recon-all specifying -clean-tal.
Run "tkregister2 --help" for more information.
Creates the files mri/transform/talairach.auto.xfm and talairach.xfm.
The flag -tal-check will check the registration against known-good transforms.
Adding the flag -use-mritotal after -talairach will use the MINC program 
mritotal (see Collins, et al., 1994) to perform the transform.

Normalization (-<no>normalization)

Performs intensity normalization of the orig volume and places the
result in mri/T1.mgz. Attempts to correct for fluctuations in
intensity that would otherwise make intensity-based segmentation much
more difficult. Intensities for all voxels are scaled so that the mean
intensity of the white matter is 110. If there are problems with the
normalization, users can add control points. See also Normalization2.

Skull Strip (-<no>skullstrip)

Removes the skull from mri/T1.mgz and stores the result in
mri/brainmask.auto.mgz and mri/brainmask.mgz.
Runs the mri_watershed program. If the strip fails, users can specify
seed points (-wsseed) or change the threshold (-wsthresh, -wsmore, -wsless).
The -autorecon1 stage ends here.

Automatic Subcortical Segmentation (-<no>subcortseg)

This is done in six stages. (1) CGA linear registration
(-gcareg). This is an initial registration to a template. (2)
Canonical Normalization (-canorm), (3) Canonical Registration
(-careg). (4) Neck removal (-rmneck), (5) Registration, w/skull
(-skull-lta), and (6) Subcortical labeling (-calabel).
The stages are listed next.

EM (GCA) Registration (-<no>gcareg)

Computes transform to align the mri/nu.mgz volume to the default GCA atlas
found in FREESURFER_HOME/average (see -gca flag for more info).
Creates the file mri/transforms/talairach.lta.
The -autorecon2 stage starts here.

CA Normalize (-<no>canorm)

Further normalization, based on GCA model.
Creates mri/norm.mgz.

CA Register (-<no>careg)

Computes a nonlinear transform to align with GCA atlas.
Creates the file mri/transform/talairach.m3z.

CA Register Inverse (-<no>careginv)

Computes the inverse of the nonlinear transform to align with GCA
atlas.  Creates the files mri/transform/talairach.m3z.{x,y,z}.mgz.

Remove neck (-<no>rmneck)

The neck region is removed from the NU-corrected volume mri/nu.mgz.
Makes use of transform computed from prior CA Register stage.
Creates the file mri/nu_noneck.mgz.

EM Registration, with Skull (-<no>skull-lta)

Computes transform to align volume mri/nu_noneck.mgz with GCA volume
possessing the skull.
Creates the file mri/transforms/talairach_with_skull.lta.

CA Label (-<no>calabel)

Labels subcortical structures, based in GCA model.
Creates the files mri/aseg.auto.mgz and mri/aseg.mgz.

ASeg Stats (-<no>segstats)

Computes statistics on the segmented subcortical structures found
in mri/aseg.mgz. Writes output to file stats/aseg.stats.

Normalization2 (-<no>normalization)

Performs a second (major) intensity correction using only the brain
volume as the input (so that it has to be done after the skull strip).
Intensity normalization works better when the skull has been removed.
Creates a new brain.mgz volume. The -autorecon2-cp stage begins here.
If -noaseg flag is used, then aseg.mgz is not used by mri_normalize.

WM Segmentation (-<no>segmentation)

Attempts to separate white matter from everything else. The input is
mri/brain.mgz, and the output is mri/wm.mgz.  Uses intensity,
neighborhood, and smoothness constraints.  This is the volume that is
edited when manually fixing defects. Calls mri_segment,
mri_edit_wm_with_aseg, and mri_pretess. To keep previous edits, run
with -keep. If -noaseg is used, them mri_edit_wm_aseg is skipped.

Cut/Fill (-<no>fill)

This creates the subcortical mass from which the orig surface is
created. The mid brain is cut from the cerebrum, and the hemispheres
are cut from each other. The left hemisphere is binarized to 255.
The right hemisphere is binarized to 127.  The input is mri/wm.mgz
and the output is mri/filled.mgz. Calls mri_fill. If the cut fails,
then seed points can be supplied (see -cc-crs, -pons-crs, -lh-crs,
-rh-crs). The actual points used for the cutting planes in the
corpus callosum and pons can be found in scripts/ponscc.cut.log.
The stage -autorecon2-wm begins here.  This is the last stage of
volumetric processing. If -noaseg is used, then aseg.mgz is not used
by mri_fill.

Tessellation (-<no>tessellate)

This is the step where the orig surface (ie, surf/?h.orig.nofix) is
created. The surface is created by covering the filled hemisphere with
triangles. Runs mri_tessellate. The places where the points of the
triangles meet are called vertices. Creates the file surf/?h.orig.nofix
Note: the topology fixer will create the surface ?h.orig.

Orig Surface Smoothing (-<no>smooth1, -<no>smooth2)

After tesselation, the orig surface is very jagged because each
triangle is on the edge of a voxel face and so are at right angles to
each other. The vertex positions are adjusted slightly here to reduce
the angle. This is only necessary for the inflation processes.
Creates surf/?h.smoothwm(.nofix). Calls mris_smooth. Smooth1 is the step
just after tessellation, and smooth2 is the step just after topology
fixing.

Inflation (-<no>inflate1, -<no>inflate2)

Inflation of the surf/?h.smoothwm(.nofix) surface to create
surf/?h.inflated. The inflation attempts to minimize metric distortion
so that distances and areas are perserved (ie, the surface is not
stretched). In this sense, it is like inflating a paper bag and not a
balloon.  Inflate1 is the step just after tessellation, and inflate2
is the step just after topology fixing. Calls mris_inflate. Creates
?h.inflated, ?h.sulc, ?h.curv, and ?h.area.

QSphere (-<no>qsphere)

This is the initial step of automatic topology fixing. It is a
quasi-homeomorphic spherical transformation of the inflated surface designed
to localize topological defects for the subsequent automatic topology fixer.
Calls mris_sphere. Creates surf/?h.qsphere.nofix.

Automatic Topology Fixer (-<no>fix)

Finds topological defects (ie, holes in a filled hemisphere) using
surf/?h.qsphere.nofix, and changes the orig surface (surf/?h.orig.nofix)
to remove the defects. Changes the number of vertices.  All the defects
will be removed, but the user should check the orig surface in the volume
to make sure that it looks appropriate. Calls mris_topo_fixer.
Creates surf/?h.orig (by iteratively fixing surf/?h.orig.nofix).

Final Surfaces (-<no>finalsurfs)

Creates the ?h.white and ?h.pial surfaces as well as the thickness
file (?h.thickness) and curvature file (?h.curv). The white surface
is created by "nudging" the orig surface so that it closely follows
the white-gray intensity gradient as found in the T1 volume. The pial
surface is created by expanding the white surface so that it closely
follows the gray-CSF intensity gradient as found in the T1 volume.
Calls mris_make_surfaces.

Cortical Ribbon Mask (-<no>cortribbon)

Creates binary volume masks of the cortical ribbon, ie, each voxel is
either a 1 or 0 depending upon whether it falls in the ribbon or not.
Saved as ?h.ribbon.mgz.  Uses mgz regardless of whether the -mgz
option is used.  The -autorecon2 stage ends here.

Spherical Inflation (-<no>sphere)

Inflates the orig surface into a sphere while minimizing metric
distortion.  This step is necessary in order to register the surface
to the spherical atlas. (also known as the spherical morph). Calls
mris_sphere. Creates surf/?h.sphere.  The -autorecon3 stage begins here.

Ipsilateral Surface Registation (Spherical Morph) (-<no>surfreg)

Registers the orig surface to the spherical atlas through
surf/?h.sphere. The surfaces are first coarsely registered by aligning
the large scale folding patterns found in ?h.sulc and then fine tuned
using the small-scale patterns as in ?h.curv.
Calls mris_register. Creates surf/?h.sphere.reg.

Jacobian (-<no>jacobian_white)

Computes how much the white surface was distorted in order to register
to the spherical atlas during the -surfreg step. Creates ?h.jacobian_white 
(a curv formatted file). This step follows the surface registration step.

Surface Registation, maximal distortion, with Jacobian (-<no>jacobian_dist0)

Run spherical registration with no metric distortion penalty. This will 
cause surface geometry to align regardless of the amount of distortion 
induced (ie, distance contraints are turned off). The distortion will then 
be quantified by the Jacobian of the transform. Creates ?h.jacobian_dist0 (a
curv formatted file) and ?h.sphere.dist0.jacobian.reg (a surface file). This 
step is not run automatically because it can add about an hour per hemi.  
Note: the file ?h.jacobian_white (see prior help text) is the Jacobian of 
the white surface to spherical atlas alignment from -surfreg.

Contralateral Surface Registation (Spherical Morph) (-<no>contrasurfreg)

Same as ipsilateral but registers to the contralateral atlas.
Creates lh.rh.sphere.reg and rh.lh.sphere.reg.

Average Curvature (-<no>avgcurv)

Resamples the average curvature from the atlas to that of the subject.
Allows the user to display activity on the surface of an individual
with the folding pattern (ie, anatomy) of a group. Calls mrisp_paint.
Creates surf/?h.avg_curv.

Cortical Parcellation (-<no>cortparc, -<no>cortparc2)

Assigns a neuroanatomical label to each location on the cortical surface.
Incorporates both geometric information derived from the cortical model
(sulcus and curvature), and neuroanatomical convention.
Calls mris_ca_label.  -cortparc creates label/?h.aparc.annot, and
-cortparc2 creates /label/?h.aparc.a2005s.annot.

Parcellation Statistics (-<no>parcstats, -<no>parcstats2)

Runs mris_anatomical_stats to create a summary table of cortical
parcellation statistics for each structure, including 1. structure
name 2. number of vertices 3. total surface area (mm^2) 4. total gray
matter volume (mm^3) 5. average cortical thickness (mm) 6. standard
error of cortical thicknessr (mm) 7. integrated rectified mean
curvature 8. integrated rectified Gaussian curvature 9. folding index
10. intrinsic curvature index.
For -parcstats, the file is saved in stats/?h.aparc.stats.
For -parcstats2, the file is saved in stats/?h.aparc.a2005s.stats.


LONGITUDINAL PROCESSING

The longitudinal processing scheme aims to incorporate the subject-wise
correlation of longitudinal data into the processing stream in order to
further reduce the measurement noise.  The longitudinal scheme differs
from the default stream in three major steps: preprocessing, intensity
normalization and surface deformation. Assuming that a series of scans
of the same subject are obtained at different time points, the data from
time point one is first processed using the default procedure. For the
processing of later time points, the three major steps mentioned above
are modified. First, a linear registration is computed between the image
volume of a later time point and that of the first time point. Note that
the volume itself is not transformed, but only the registration matrix is
stored and will be used in later steps. Second, at the intensity
normalization step, instead of re-computing the WM control points, the
control points (automatically computed) from time point one are mapped to
the current volume using the previously computed linear registration,
which are then used to estimate the bias field. Third, at the surface
deformation step, instead of starting the deformation from the topology-
corrected WM tessellation, the gray/white and pial surfaces reconstructed
from time point one are first transformed using the linear registration
and then used to initialize the deformation for the gray/white and pial
surfaces respectively for the current time point. Such an initialization
scheme reduces the problem of deformable model methods being sensitive to
initialization and local optimality. It also eliminates variation in
initial surface tessellation and topology correction since these two
steps are no longer needed in the processing of later time points. See [12].

-long
-longitudinal

Enables longitudinal processing. The 'time point one' subject must be
specified by the -tp1id option, along with the current subject (a scan of
the same subject at a later time point).

-tp1 subjid
-tp1id subjid

Specifies the subject id of the first 'time point' in a longitudinal study.
This subject should have been fully processed by the default processing
stream, ie 'recon-all -all'.

-s subjid
-sid subjid

Specifies the subject id of a later 'time point' scan in a longitudinal
study.  This subject is processed in a different manner from the default
processing stream, as described above.

-reg registration_file
-regfile registration_file

Optionally specify the registration matrix aligning the currently specified
subject with the 'time point one' subject.  The default is
${tp1id}_to_${subjid}.lta, and is computed automatically when -long is
specified.

-reg-method registration_method_type

Optionally specify the registration method used in the second registration
step : fsl_rigid, linear_align, or nonlinear_align. The default is fsl_rigid.

-reg-cost cost_function_for_fsl_rigid

Optionally specify the cost function used by the FSL rigid registration
method if fsl_rigid is the reg-method selected for the second registration
step.  The cost functions are: mutualinfo, corratio, normcorr, normmi,
or leastsq.  The default is corratio.

-reg-dof degree_of_freedom_for_fsl_rigid

Optionally specify the DOF used by the FSL rigid registration method if
fsl_rigid is the reg-method selected for the second registration step. The
DOF options are: 6 or 12.  The default is 6.

-reg-file-type file_type

Optionally specify the Freesurfer file-type to use in the second registration
step: orig, brainmask, or norm.  The default is norm.

-no-orig-pial

If the orig pial surface data is not available, then specify this flag so that
mris_make_surfaces does not attempt to use it.

Example:

  recon-all -all -long -tp1 <subjidtp1> -s <subjid>

(Notice that the -all flag is included. A work directive flag is required.)


MANUAL CHECKING AND EDITING OF SURFACES

To manually edit segmenation, run the following command (make sure
that your SUBJECTS_DIR environment variable is properly set).

  tkmedit subjid wm.mgz -aux T1.mgz

The surfaces can be loaded through the menu item
File->LoadMainSurface. To enable editing, set Tools->EditVoxels.  It
may also be convenient to bring up the reconstruction toolbar with
View->ToolBars->Reconstruction. Alt-C toggles between the main (wm)
and auxiliary (T1) volumes. Middle clicking will set a voxel value to
255; left clicking will set a voxel value to 0. Only edit the wm
volume. When finished, File->SaveMainVolume.

To view the inflated surface simultaneosly with the volume, run the
following command from a different shell:

  tksurfer subjid lh inflated

To goto a point on the surface inside the volume, click on the point
and hit SavePoint (icon looks like a floppy disk), then, in tkmedit,
hit GotoSavedPoint (icon looks like an open file).

Be sure to see the tutorials found at:
https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial


TOUCH FILES

This script creates a directory called "touch". Each time a stage is
run a "touch file" is created (eg, skull_strip.touch). This will be
used in the future to automatically determine which stages need to be
run or re-run. The modification time of the touch file is important.
The content is irrelevent, though it often contains a command-line.


FLATTENING

Flattening is not actually done in this script. This part just documents
how one would go about performing the flattening. First, load the subject
surface into tksurfer:

  tksurfer subjid lh inflated

Load the curvature through the File->Curvature->Load menu (load
lh.curv). This should show a green/red curvature pattern. Red = sulci.

Right click before making a cut; this will clear previous points. This
is needed because it will string together all the previous places you
have clicked to make the cut. To make a line cut, left click on a line
of points. Make the points fairly close together; if they are too far
appart, the cut fails. After making your line of points, execute the
cut by clicking on the Cut icon (scissors with an open triangle for a
line cut or scissors with a closed triangle for a closed cut). To make
a plane cut, left click on three points to define the plane, then left
click on the side to keep. Then hit the CutPlane icon.

Fill the patch. Left click in the part of the surface that you want to
form your patch. Then hit the Fill Uncut Area button (icon = filled
triangle). This will fill the patch with white. The non-patch area
will be unaccessible through the interface.  Save the patch through
File->Patch->SaveAs. For whole cortex, save it to something like
lh.cort.patch.3d. For occipital patches, save it to lh.occip.patch.3d.

Cd into the subject surf directory and run

  mris_flatten -w N -distances Size Radius lh.patch.3d lh.patch.flat

where N instructs mris_flatten to write out an intermediate surface
every N interations. This is only useful for making movies; otherwise
set N=0.  Size is maximum number of neighbors; Radius radius (mm) in
which to search for neighbors. In general, the more neighbors that are
taken into account, the less the metric distortion but the more
computationally intensive. Typical values are Size=12 for large
patches, and Size=20 for small patches. Radius is typically 7.
Note: flattening may take 12-24 hours to complete. The patch can be
viewed at any time by loading the subjects inflated surface, then
loading the patch through File->Patch->LoadPatch...


GETTING HELP

Send email to freesurfer@nmr.mgh.harvard.edu. Also see
https://surfer.nmr.mgh.harvard.edu. In particular, there is both a
reconstruction guide and tutorial as well as manuals for tkmedit and
tksurfer.


REFERENCES

[1] Collins, DL, Neelin, P., Peters, TM, and Evans, AC. (1994)
Automatic 3D Inter-Subject Registration of MR Volumetric Data in
Standardized Talairach Space, Journal of Computer Assisted Tomography,
18(2) p192-205, 1994 PMID: 8126267; UI: 94172121

[2] Cortical Surface-Based Analysis I: Segmentation and Surface
Reconstruction Dale, A.M., Fischl, Bruce, Sereno, M.I.,
(1999). Cortical Surface-Based Analysis I: Segmentation and Surface
Reconstruction.  NeuroImage 9(2):179-194

[3] Fischl, B.R., Sereno, M.I.,Dale, A. M.  (1999) Cortical
Surface-Based Analysis II: Inflation, Flattening, and Surface-Based
Coordinate System. NeuroImage, 9, 195-207.

[4] Fischl, Bruce, Sereno, M.I., Tootell, R.B.H., and Dale, A.M.,
(1999). High-resolution inter-subject averaging and a coordinate
system for the cortical surface. Human Brain Mapping, 8(4): 272-284

[5] Fischl, Bruce, and Dale, A.M., (2000).  Measuring the Thickness of
the Human Cerebral Cortex from Magnetic Resonance Images.  Proceedings
of the National Academy of Sciences, 97:11044-11049.

[6] Fischl, Bruce, Liu, Arthur, and Dale, A.M., (2001). Automated
Manifold Surgery: Constructing Geometrically Accurate and
Topologically Correct Models of the Human Cerebral Cortex. IEEE
Transactions on Medical Imaging, 20(1):70-80

[7] Non-Uniform Intensity Correction.
http://www.bic.mni.mcgill.ca/software/N3/node6.html

[8] Fischl B, Salat DH, Busa E, Albert M, Dieterich M, Haselgrove C,
van der Kouwe A, Killiany R, Kennedy D, Klaveness S, Montillo A,
Makris N, Rosen B, Dale AM. Whole brain segmentation: automated
labeling of neuroanatomical structures in the human
brain. Neuron. 2002 Jan 31;33(3):341-55.

[9] Bruce Fischl, Andre van der Kouwe, Christophe Destrieux, Eric
Halgren, Florent Segonne, David H. Salat, Evelina Busa, Larry
J. Seidman, Jill Goldstein, David Kennedy, Verne Caviness, Nikos
Makris, Bruce Rosen, and Anders M. Dale.  Automatically Parcellating
the Human Cerebral Cortex. Cerebral Cortex January 2004; 14:11-22.

[10] Fischl B, Salat DH, van der Kouwe AJW, Makris N, Sgonne F, Dale
AM. Sequence-Independent  Segmentation of Magnetic Resonance Images.
NeuroImage 23 Suppl 1, S69-84.

[11] Segonne F, Dale, AM, Busa E, Glessner M, Salvolini U, Hahn HK,
Fischl B, A Hybrid Approach to the Skull-Stripping Problem in MRI.
NeuroImage, 22,  pp. 1160-1075, 2004

[12] Han et al.,  Reliability of MRI-derived measurements of human
cerebral cortical thickness: The effects of field strength, scanner
upgrade and manufacturer, (2006) NeuroImage, 32(1):180-194.
