#!/usr/bin/python
import warnings
warnings.filterwarnings('ignore', '.*negative int.*')
import os, sys, optparse
from sets import Set
import fsutils

# Original Version - Douglas Greve, MGH
# Rewrite - Krish Subramaniam, MGH
# $Id: asegstats2table,v 1.8.2.5 2009/04/11 19:40:58 krish Exp $

# map of measures and their appropriate columns in .stats file
seg2statcol_map = {'volume':3, 'mean':5, 'std':6}
# map of delimeter choices and string literals
delimiter2char = {'comma':',', 'tab':'\t', 'space':' ', 'semicolon':';'}

helptext = """
Converts a subcortical stats file created by recon-all and/or
mri_segstats (eg, aseg.stats) into a table in which each line is a
subject and each column is a segmentation ( there is an option to transpose that). 
The values are the volume of the segmentation in mm3 or the mean intensity over the structure.
The first row is a list of the segmentation names. The first column
is the subject name. If the measure is volume, then the estimated
intracranial volume (eTIV) is printed as the 2nd to last column 
(if present in the input), and BrainSegVol is the last column.

The subjects list can be specified in one of four ways:
  1. Specify each subject after -s 
  
          -s subject1 -s subject2 ..
  
  2. specify all subjects after --subjects.  
     --subjects does not have
     to be the last argument. Eg:
     
          --subjects subject1 subject2 ... 

  3. Specify each input file after -i 

          -i subject1/stats/aseg.stats -i subject2/stat/aseg.stats ..
  
  4. Specify all the input stat files after --inputs. --inputs does not have
     to be the last argument. Eg:
       
          --inputs subject1/stats/aseg.stats subject2/stats/aseg.stats ...

The first two methods assume the freesurfer directory structure. The
last two are general and can be used with any file produced by
mri_segstats regardless of whether it was created with recon-all or not,
however, the subject name is not printed in the file (just the row
number). Note that the first two and last two are mutually exclusive. i.e
don't specify --subjects when you are providing --inputs and vice versa.

By default, the volume (mm3) of each segmentation is reported. This
can be changed with '--meas measure', where measure can be 
volume or mean. If mean, it reports the mean intensity value from
the 6th column.

By default, all segmentations found in the input stats file are
reported. This can be changed by specifying the maximum segmentation
number with --maxsegno. This can be convenient for removing
segmentations that are always empty.

With methods 1 and 2 above uses stats/aseg.stats by default. 
This can be changed to subdir/statsfile with --subdir subdir
--statsfile statsfile.

The --segno option outputs only the segmentations requested.
This is useful because if the number of segmentations is large,
the table becomes huge.

The --no-segno options doesn't output the segmentations. 
This can be convenient for removing segs that are always empty.

The --transpose flag writes the transpose of the table. 
This might be a useful way to see the table when the number of subjects is
relatively less than the number of segmentations.

The --delimiter option controls what character comes between the measures
in the table. Valid options are 'tab' ( default), 'space', 'comma' and  'semicolon'.

The --skip option skips if it can't find a .stats file. Default behavior is
exit the program.
"""

def options_parse():
    """
    Command Line Options Parser for aparcstats2table
    initiate the option parser and return the parsed object
    """
    parser = optparse.OptionParser(version='$Id: asegstats2table,v 1.8.2.5 2009/04/11 19:40:58 krish Exp $', usage=helptext)
    
    # help text
    h_sub = '(REQUIRED) subject1 <subject2 subject3..>'
    h_s = ' subjectname'
    h_inp = ' input1 <input2 input3..>'
    h_i = ' inputname'
    h_meas = 'measure: default is vol ( alt: mean, std)'
    h_max = ' maximum segmentation number to report'
    h_seg = 'segno1 <segno2 segno3..> : only include given segmentation numbers'
    h_noseg = 'segno1 <segno2 segno3..> : exclude given segmentation numbers'
    h_stats = 'use `fname` instead of "aseg.stats"'
    h_subdir = 'use `subdir` instead of "stats/"'
    h_tr = 'transpose the table ( default is subjects in rows and segmentations in cols)' 
    h_t = '(REQUIRED) the output tablefile'
    h_deli = 'delimiter between measures in the table. default is tab (alt comma, space, semicolon )' 
    h_skip = 'if a subject does not have stats file, skip it'
    h_v = 'increase verbosity'

    # Add options 
    parser.add_option('--subjects', dest='subjects' ,action='callback',
                      callback=fsutils.callback_var,  help=h_sub)
    parser.add_option('-s', dest='subjects' ,action='append',
                      help=h_s)
    parser.add_option('--inputs', dest='inputs' ,action='callback',
                      callback=fsutils.callback_var,  help=h_inp)
    parser.add_option('-i', dest='inputs' ,action='append',
                      help=h_i)
    parser.add_option('-t', '--tablefile', dest='outputfile',
                      help=h_t)
    parser.add_option('-m', '--meas', dest='meas',
                      choices=('volume','mean','std'),  default='volume', help=h_meas)
    parser.add_option('--maxsegno', dest='maxsegno',
                       help=h_inp)
    parser.add_option('--segno', dest='segnos' ,action='callback',
                      callback=fsutils.callback_var,  help=h_seg)
    parser.add_option('--no-segno', dest='no_segnos' ,action='callback',
                      callback=fsutils.callback_var,  help=h_noseg)
    parser.add_option('--stats', dest='statsfname',
                       help=h_stats)
    parser.add_option('--statsfile', dest='statsfname',
                       help=h_stats)
    parser.add_option('--subdir', dest='subdir',
                       help=h_subdir)
    parser.add_option('-d', '--delimiter', dest='delimiter',
                      choices=('comma','tab','space','semicolon'),
                      default='tab', help=h_deli)
    parser.add_option('', '--transpose', action='store_true', dest='transposeflag',
                      default=False, help=h_tr)
    parser.add_option('--skip', action='store_true', dest='skipflag',
                      default=False, help=h_skip)
    parser.add_option('-v', '--debug', action='store_true', dest='verboseflag',
                      default=False, help=h_v)

    (options, args) = parser.parse_args()
    
    # extensive error checks
    if options.subjects is not None:
        if len(options.subjects) < 1:
            print 'ERROR: subjects are not specified'
            sys.exit(1)
        else:
            options.dodirect = False
    
    if options.inputs is not None:
        if len(options.inputs) < 1:
            print 'ERROR: inputs are not specified'
            sys.exit(1)
        else:
            options.dodirect = True
    
    if options.subjects is None and options.inputs is None: 
        print 'ERROR: Both number of subjects and number of inputs are empty'
        sys.exit(1)
    
    if options.subjects is not None and options.inputs is not None:
        print 'ERROR: Both subjects and inputs are specified. Please specify just one '
        sys.exit(1)

    if not options.outputfile:
        print 'ERROR: output table name should be specified'
        sys.exit(1)

    if options.maxsegno and int(options.maxsegno) < 1:
        print 'ERROR: maximum number of segs reported shouldnt be less than 1'
        sys.exit(1)
    
    if options.segnos is not None  and len(options.segnos) < 1 :
        print 'ERROR: segmentation numbers should be specified with that option'
        sys.exit(1)
    
    if options.no_segnos is not None and len(options.no_segnos) < 1:
        print 'ERROR: to be excluded segmentation numbers should be specified with that option'
        sys.exit(1)
    
    return options

def is_valid_segno(options, seg):
    """
    check whether the segmentation is what the user asked for
    """
    # invalid if doesn't belong to segnos ( only if segnos exists in the first
    # place)
    if options.segnos is not None:
        if seg not in options.segnos:
            return False
    # invalid if it belongs to no_segnos
    if options.no_segnos is not None:
        if seg in options.no_segnos:
            return False
    # invalid if it exceeds max segno 
    if options.maxsegno is not None:
        if int(seg) > int(options.maxsegno):
            return False
    # else
    return True
    
def sanity_check_segs(table, rows):
    """
    primarily, if all the segs in all the subjects are the same (they should
    be! ), the union ( segs ) should be equal to intersection(segs)
    return False otherwise.. the program quits
    """
    union = Set([])
    intersection = Set(table[rows[0]].keys())
    for row in rows:
        union = union | Set(table[row].keys())
        intersection = intersection &  Set(table[row].keys())
    
    if union == intersection:
        return True
    else:
        return False

def build_table(options):
    """
    This function builds the 2d table (spreadsheet )
    of subjects vs segs. The values are given by what the user chose in 
    measure option.
    """
    o = options
    # a devious trick in which all the subject files take the form
    # (subjectnumber, subjectname, subjectpath)
    # the table's first column will have subjectnumber+subjectname ( concat) 
    # since --subjects and --inputs are mut-ex, so are subjectnumber and
    # subjectname
    stats = []
    if options.dodirect:
        for count, inp in enumerate(o.inputs):
            stats.append( (str(count), '', inp) )
    else:
        # check the subjects dir
        subjdir = fsutils.check_subjdirs()
        print 'SUBJECTS_DIR : %s' %subjdir
        if o.subdir is None:
            o.subdir = 'stats'
        if o.statsfname is None:
            o.statsfname = 'aseg.stats'
        for sub in o.subjects:
            stats.append( ('', sub,  os.path.join(subjdir, sub, o.subdir, o.statsfname)) )
    
    rows = []
    # init the table
    table = fsutils.Ddict(dict)
    for statno, subname, statfile in stats:
        if os.path.exists( statfile):
            if o.verboseflag:
                print 'Processing file %s' %statfile
            rows.append(statno+subname)
            fp = open(statfile, 'r')
            cols = []
            for line in fp:
                # valid line
                if line.rfind('#') == -1:
                    strlst = line.split()
                    seg = strlst[1]
                    if is_valid_segno(options, seg):
                        segid = strlst[4]
                        cols.append(segid)
                        table[statno+subname][segid] = float(strlst[seg2statcol_map[o.meas]])
            # unfortunately we do it again because we necessarily put these
            # volumes at the end of the table ( last 2 columns). Since we aren't
            # processing a lot of files, this wouldn't hamper the speed. Also
            # more volume measures can be added easily.
            fp.seek(0)
            for line in fp:
                # if measure is volume, also output ICV and BSV
                if not o.dodirect and o.meas == 'volume':
                    if line.startswith('# Measure IntraCranialVol, ICV,') :
                        strlst = line.split(',')
                        cols.append('IntraCranialVol')
                        table[statno+subname]['IntraCranialVol'] = float(strlst[3])
                    if line.startswith('# Measure BrainSeg, BrainSegVol,') :
                        strlst = line.split(',')
                        cols.append('BrainSegVol')
                        table[statno+subname]['BrainSegVol'] = float(strlst[3])
        else:
            if not o.skipflag:
                print 'ERROR: cannot find %s' %statfile
                print 'Use --skip flag if you want to continue in such cases'
                sys.exit(1)
            else:
                print 'WARNING: cannot find %s. proceeding to next file' %statfile
    
    # check sanity
    if not sanity_check_segs(table, rows):
        print 'ERROR: All stat files should have the same segmentations'
        sys.exit(1)

    # if verbose
    if o.verboseflag:
        for row in rows:
            print table[row]
            print '-'*40
    return rows, cols, table

def write_table(options, rows, cols, table):
    """
    Write the table from memory to disk. Initialize the writer class.
    """
    tw = fsutils.TableWriter(rows, cols, table)
    r1c1 = 'Measure:%s' %( options.meas)
    tw.assign_attributes(filename=options.outputfile, row1col1=r1c1,
                         delimiter=delimiter2char[options.delimiter] )
    if options.transposeflag:
        tw.write_transpose()
    else:
        tw.write()
    

if __name__=="__main__":
    options = options_parse()
    if options.verboseflag:
        print options
    print 'Building the table..'
    (rows, cols, table) = build_table(options)
    print 'Writing the table to %s' %options.outputfile
    write_table(options, rows, cols, table)
    sys.exit(0)
