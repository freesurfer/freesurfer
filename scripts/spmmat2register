#!/bin/csh -f

set SPMMAT2REGISTER_VER = '$Id: spmmat2register,v 1.5 1999/11/16 00:17:59 greve Exp $';

set OutStream = /dev/null;
set funcvol   = ();
set structvol = ();
set regfile = "register.dat"
set subject = ();
set monly = 0;
set target = "spm";
set frows = 256;
set fcols = 256;
set fslices = 20;
set SlcOrient = "RAS";

if($#argv == 0) goto usage_exit;

goto parse_args;
parse_args_return:

goto check_args;
check_args_return:

set UseStructMat = 1;
set structmatfile = $structvol.mat
if(! -e $structmatfile ) then
  set structimgfile = $structvol.img
  if(! -e $structimgfile ) then
   echo "ERROR: cannot find $structmatfile or $structimgfile "
   exit 1;
  endif
  set UseStructMat = 0;
endif

set UseFuncMat = 1;
set funcmatfile = $funcvol.mat
if(! -e $funcmatfile ) then
  set funcimgfile = $funcvol.img
  if(! -e $funcimgfile ) then
   echo "ERROR: cannot find $funcmatfile or $funcimgfile "
   exit 1;
  endif
  set UseFuncMat = 0;
endif

set outdir = `dirname $regfile`;
mkdir -p $outdir
set okfile = "$outdir/tmp_spm2reg.ok"
rm -f $okfile

if($monly) then
  set TARGET = " tee  $mfile "
else
  set TARGET = "matlab -display iconic "
endif 

$TARGET > $OutStream <<EOF

  SlcOrient = '$SlcOrient';

  if($UseStructMat) 
    load ('$structmatfile');
    Ma = M;
  else
    Ma = spm_get_space('$structvol');
  end

  if($UseFuncMat) 
    load ('$funcmatfile');
    Mf = M;
  else
    Mf = spm_get_space('$funcvol');
  end

  dvf = sqrt(sum(Mf(1:3,1:3).^2));
  Qa = zeros(4);
  Qa(1,1) = 1;
  Qa(2,2) = 1;
  Qa(3,3) = 1;
  av = -ones(4,1)*(256+1)/2;
  av(4) = 1;
  Qa(:,4) = av;

  if(strcmp('$target','spm'))
    W = eye(4);
  else
    % This is hardwired for now %
    Ncols = $frows;  
    Nrows = $fcols;  
    Nslices = $fslices;

    Mforig = zeros(4);
    Mforig(1,1) = abs(dvf(1));
    Mforig(2,2) = abs(dvf(2));
    Mforig(3,3) = abs(dvf(3));
    Mforig(4,4) = 1;
    Mforig(1,4) = -abs(dvf(1))*(Ncols+1)/2;
    Mforig(2,4) = -abs(dvf(2))*(Nrows+1)/2;
    Mforig(3,4) = -abs(dvf(3))*(Nslices+1)/2;

    W = Mforig*inv(Mf);
  end

  % Cor to Axial %
  Rac = zeros(4,4);
  if(strcmp(SlcOrient,'RAS'))
    Rac(1,1) =  1;
  else
    Rac(1,1) = -1;
  end
  Rac(2,3) =  1; 
  Rac(3,2) =  1;
  Rac(4,4) =  1;

  Mreg = W*Ma*inv(Qa)*Rac;

  % I dont see why this is necessary %
  % offset = Mreg(:,4);
  % newoffset = Rac'*offset; %'
  % Mreg(:,4) = newoffset;

  SubjName = '$subject';
  fid = fopen('$regfile','w');
  if(fid == -1)
    fprintf(1,'ERROR: could not open $regfile\n');
    error('');
    quit;
  end
  fprintf(fid,'%s\n',SubjName);
  fprintf(fid,'%8.4f\n',dvf(1));
  fprintf(fid,'%8.4f\n',dvf(3));
  fprintf(fid,'%8.4f\n',1.0);
  fprintf(fid,'%8.4f %8.4f %8.4f %8.4f\n',Mreg'); %'
  fclose(fid);
 
  if(~$monly)
    fid = fopen('$okfile','w');
    fclose(fid);
  end

  return;
EOF

if(! $monly) then
  if( -e $okfile ) then
    #echo "spmmat2register finished SUCCESSFULLY"
    rm -f $okfile
    exit 0;
  else
    echo "spmmat2register FAILED"
    exit 1;
  endif
endif


exit 0;
#######-------------------------------------##########

parse_args:

set cmdline = "$argv";
while( $#argv != 0 )

  set flag = $argv[1]; shift;
  
  switch($flag)

    case "-fvol":
      if ( $#argv == 0) goto arg1err;
      set funcvol = $argv[1]; shift;
      breaksw

    case "-svol":
      if ( $#argv == 0) goto arg1err;
      set structvol = $argv[1]; shift;
      breaksw

    case "-o":
      if ( $#argv == 0) goto arg1err;
      set regfile = $argv[1]; shift;
      breaksw

    case "-target":
      if ( $#argv == 0) goto arg1err;
      set target = $argv[1]; shift;
      breaksw

    case "-frows":
      if ( $#argv == 0) goto arg1err;
      set frows = $argv[1]; shift;
      breaksw

    case "-fcols":
      if ( $#argv == 0) goto arg1err;
      set fcols = $argv[1]; shift;
      breaksw

    case "-fslices":
      if ( $#argv == 0) goto arg1err;
      set fslices = $argv[1]; shift;
      breaksw

    case "-subject":
    case "-s":
      if ( $#argv == 0) goto arg1err;
      set subject = $argv[1]; shift;
      breaksw

    case "-LAS":
    case "-las":
      set SlcOrient = "LAS";
      breaksw

    case "-debug":
      set verbose = 1;
      set OutStream = /dev/stdout;
      breaksw

    case "-verbose":
      set OutStream = /dev/stdout;
      breaksw

    case "-monly":
      if ( $#argv == 0) goto arg1err;
      set mfile = $argv[1]; shift;
      set monly = 1;
      breaksw

    case "-umask":
      if ( $#argv == 0) goto arg1err;
      #echo "INFO: Setting umask to $argv[1]"
      set newumask = $argv[1]; shift;
      umask $newumask
      breaksw

    default:
      echo ERROR: Flag $flag unrecognized.
      echo $cmdline
      goto usage_exit;
      breaksw
  endsw

end
goto parse_args_return;

#----------------------------------------------------------------#
check_args:

  if($#funcvol == 0) then
    echo "ERROR: must specify a functional volume";
    exit 1;
  endif  

  if($#structvol == 0) then
    echo "ERROR: must specify a structural volume";
    exit 1;
  endif  

  if($#subject == 0) then
    echo "ERROR: must specify a subject name";
    exit 1;
  endif  

goto check_args_return;

############--------------##################
arg1err:
  echo "ERROR: flag $flag requires one argument"
  exit 1

#----------------------------------------------------------------#
usage_exit:
  echo "\nUSAGE: \n spmmat2register "
  echo "   -svol    structural volume     required"
  echo "   -fvol    functional volume     required"
  echo "   -subject subject name          required"
  echo "   -LAS     Left/Ant/Sup          RAS"
  echo "   -o       output register file  register.dat"
  echo "   -target  spm | mgh             spm";
  echo "   -frows   number of func rows (with target mgh)"
  echo "   -fcols   number of func cols (with target mgh)"
  echo "   -fslices number of func slices (with target mgh)"
  echo "   -umask   newumask"
  echo "   -monly   mfile"
  echo "\n $SPMMAT2REGISTER_VER \n"
exit 1;
