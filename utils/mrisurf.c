/**
 * @file  mrisurf.c
 * @brief utilities operating on surfaces
 *
 */
/*
 * Original Author: Bruce Fischl
 * CVS Revision Info:
 *    $Author: fischl $
 *    $Date: 2013/01/08 15:41:28 $
 *    $Revision: 1.744 $
 *
 * Copyright Â© 2011-2012 The General Hospital Corporation (Boston, MA) "MGH"
 *
 * Terms and conditions for use, reproduction, distribution and contribution
 * are found in the 'FreeSurfer Software License Agreement' contained
 * in the file 'LICENSE' found in the FreeSurfer distribution, and here:
 *
 * https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense
 *
 * Reporting: freesurfer@nmr.mgh.harvard.edu
 *
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <unistd.h>

#include "diag.h"
#include "error.h"
#include "utils.h"
#include "macros.h"
#include "fio.h"
#include "mri.h"
#include "mri_circulars.h"
#include "mri2.h"
#include "mrisurf.h"
#include "matrix.h"
#include "proto.h"
#include "stats.h"
#include "timer.h"
#include "const.h"
#include "mrishash.h"
#include "icosahedron.h"
#include "tritri.h"
#include "timer.h"
#include "chklc.h"
#include "mri_identify.h"
#include "colortab.h"
#include "tags.h"
#include "selxavgio.h"
#include "machine.h"
#include "tags.h"
#include "transform.h"
#include "talairachex.h"
#include "annotation.h"
#include "topology/topo_parms.h"
#include "cma.h"
#include "gifti_local.h"
#include "mri_identify.h"
#include "voxlist.h"

#define DMALLOC 0

#if DMALLOC
#include "dmalloc.h"
#endif

// uncomment this to expose code which shows timings of gpu activities:
//#define FS_CUDA_TIMINGS

extern const char* Progname;

/*---------------------------- STRUCTURES -------------------------*/

/*---------------------------- CONSTANTS -------------------------*/

#define D_DIST  0.05   // sampling distance along tangent plane for computing derivatives
#define MAX_NBRS 10000
#define REPULSE_K   1.0
// if (dist+REPULSE_E) < 1 it will have a big effect
// bigger distances decay rapidly
#define REPULSE_E   0.25 // was .5

#define NO_NEG_DISTANCE_TERM  0
#define ONLY_NEG_AREA_TERM    1
#define ANGLE_AREA_SCALE      0.0

#define ORIG_AREAS          0
#define CURRENT_AREAS       1
#define AVERAGE_AREAS       0

#define CURV_SCALE          1000.0
#define MIN_DT_SCALE        0.01
#if 0
#define MAX_SMALL           10
#define TOTAL_SMALL         (4*MAX_SMALL)
#else
#define MAX_SMALL           50000
#define TOTAL_SMALL         15000
#endif

#define METRIC_SCALE        1

#define MAX_NBHD_SIZE       200
#define MAX_NEG_AREA_PCT    0.005f

/* this definition should come from mrisurf.h
 * #define MRIS_ASCII_FILE     1
 */

static double NEG_AREA_K=10.0 ; /* was 200 */
/* limit the size of the ratio so that the exp() doesn't explode */
#define MAX_NEG_RATIO       (400 / NEG_AREA_K)
#define MAX_ASYNCH_MM       0.3
#define MAX_ASYNCH_NEW_MM   0.3

#define NOT_USED                       0      /* not used */
#define USED_IN_TESSELLATION           1      /*  used in the final
tessellation */
#define USED_IN_ORIGINAL_TESSELLATION  2      /* used in the original
tessellation but not the
new one (at first) */
#define USED_IN_NEW_TESSELLATION       3      /* used in the new
tessellation (was NOT_USED
              before) */
#define USED_IN_BOTH_TESSELLATION      4      /* used in both tessellations
(was USED_IN_NEW_TESSELLATION
 before) */
#define USED_IN_NEW_TEMPORARY_TESSELLATION 5  /* used in a temporary
retessellation (was NOT_USED
                before) */
#define USED_IN_BOTH_TEMPORARY_TESSELLATION 6 /* used in a temporary
retessellation (was
                USED_IN_ORIGINAL_
                RETESSELLATION before) */

/* edge intersection onto the sphere */
#define SPHERE_INTERSECTION 1

/* speeds things up */
#define MATRIX_ALLOCATION 1

/* add extra vertices to avoid topological inconsistencies */
#define ADD_EXTRA_VERTICES 0
/* defect becomes a enclosed patch
   requires ADD_VERTEX_VERTICES to avoid top. inconsistencies */
#define FIND_ENCLOSING_LOOP ADD_EXTRA_VERTICES

/* solve the neighboring defect problem
   becomes obsolet because of ADD_EXTRA_VERTICES */
#define MERGE_NEIGHBORING_DEFECTS 1

/* limit the convex hull to the strict minimum set of first neighbors*/
#define SMALL_CONVEX_HULL 1

/* */
#define MRIS_FIX_TOPOLOGY_ERROR_MODE 1
#define DEBUG_HOMEOMORPHISM 0

#define WHICH_OUTPUT stderr

static float mrisSampleMinimizationEnergy(MRI_SURFACE *mris, 
                                          VERTEX *v, 
                                          INTEGRATION_PARMS *parms,
                                          float cx, float cy, float cz) ;
static int mrisScaleTimeStepByCurvature(MRI_SURFACE *mris) ;
static float mrisSampleSpringEnergy(MRI_SURFACE *mris, 
                                    VERTEX *v, 
                                    INTEGRATION_PARMS *parms,
                                    float cx, float cy, float cz);
static float mrisSampleSpringEnergyAtVertex(MRI_SURFACE *mris,
                                            VERTEX *v,
                                            INTEGRATION_PARMS *parms) ;
static int get_face_axes(MRI_SURFACE *mris,
                         FACE *face,
                         float *pe1x, float *pe1y, float *pe1z,
                         float *pe2x, float *pe2y, float *pe2z) ;
#if 0
static int mrisSamplePialCoordsInTangentPlane(MRI_SURFACE *mris, VERTEX *v,
    float x, float y, float z, float *pxp,
    float *pyp, float *pzp);
#endif
//static int mrisSoapBubbleIntersectingDefects(MRI_SURFACE *mris);
static int mrisCountCompressed(MRI_SURFACE *mris, double min_dist) ;
static int compare_sort_vals(const void *pc1, const void *pc2) ;
int MRISaverageMarkedVertexPositions(MRI_SURFACE *mris, int navgs) ;
int mrisApplyTopologyPreservingGradient(MRI_SURFACE *mris,
                                        double dt,
                                        int which_gradient);
int mrisComputeOptimalPlane(MRI_SURFACE *mris,
                            int *vertices,
                            int nvertices,
                            double *pnx, double *pny, double *pnz,
                            double *pxc, double *pyc, double *pzc);

#ifndef SQR
#define SQR(x) ((x)*(x))
#endif
#define F_DOT(a,b) (a[0]*b[0]+a[1]*b[1]+a[2]*b[2])
#define F_CROSS(a,b,d) (d[0]=a[1]*b[2]-b[1]*a[2],       \
                        d[1]=a[2]*b[0]-b[2]*a[0],       \
                        d[2]=a[0]*b[1]-b[0]*a[1])
#ifdef SIGN
#undef SIGN  /* get rid of silly NRC version */
#endif

#ifndef SIGN
#define SIGN(x) (((x)>0)? 1.0 : -1.0 )
#endif
#ifndef SQR3
#define SQR3(x) (SQR(x[0])+SQR(x[1])+SQR(x[2]))
#endif
#ifndef NORM3
#define NORM3(x) (sqrt(SQR3(x)))
#endif
#ifndef MAX
#define MAX(a,b) (((a)<(b))?b:a)
#endif
#ifndef MIN
#define MIN(a,b) (((a)<(b))?a:b)
#endif
#ifndef MAX3
#define MAX3(a,b,c) (MAX(a,MAX(b,c)))
#endif
#ifndef MIN3
#define MIN3(a,b,c) (MIN(a,MIN(b,c)))
#endif
#if MATRIX_ALLOCATION
//transform Matrix from Surface RAS To Voxel
static MATRIX *VoxelFromSRASmatrix=NULL;
static int mriSurfaceRASToVoxel(double xr, double yr, double zr,
                                double *xv, double *yv, double *zv);
#endif

static int mris_readval_frame = -1;
static int fix_vertex_area = 1;

/*------------------------ STATIC PROTOTYPES -------------------------*/
int MRIScomputeAllDistances(MRI_SURFACE *mris) ;
#if 0
static MRI_SP *MRISPiterative_blur(MRI_SURFACE *mris,
                                   MRI_SP *mrisp_source,
                                   MRI_SP *mrisp_dst,
                                   float sigma, int frame) ;
#endif
static int enforce_links(MRI_SURFACE *mris) ;
static int enforce_link_positions(MRI_SURFACE *mris) ;
static double MRISavgInterVertexDist(MRIS *Surf, double *StdDev);
static int mrisReadAsciiCurvatureFile(MRI_SURFACE *mris, const char *fname) ;
static double mrisComputeSSE_MEF(MRI_SURFACE *mris,
                                 INTEGRATION_PARMS *parms,
                                 MRI *mri30,
                                 MRI *mri5,
                                 double weight30,
                                 double weight5,
                                 MHT *mht) ;
static int mrisMarkIntersections(MRI_SURFACE *mris) ;
static int mrisAverageSignedGradients(MRI_SURFACE *mris, int num_avgs) ;
#if 0
static int mrisAverageWeightedGradients(MRI_SURFACE *mris, int num_avgs) ;
#endif
static int mrisComputeDuraTerm(MRI_SURFACE *mris,
                               double l_dura,
                               MRI *mri_dura,
                               double dura_thresh) ;
static double mrisComputeHistoNegativeLikelihood(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms);
static double mrisComputeNegativeLogPosterior(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, int *pnvox);
static double mrisComputeNegativeLogPosterior2D(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, int *pnvox);
static int mrisComputeHistoTerm(MRI_SURFACE *mris,
                                INTEGRATION_PARMS *parms) ;
static int mrisComputePosteriorTerm(MRI_SURFACE *mris,
                                INTEGRATION_PARMS *parms) ;
static int mrisComputePosterior2DTerm(MRI_SURFACE *mris,
				      INTEGRATION_PARMS *parms) ;
int MRISrestoreExtraGradients(MRI_SURFACE *mris) ;
static int mrisComputePositioningGradients(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms) ;
static int mrisFindGrayWhiteBorderMean(MRI_SURFACE *mris, MRI *mri) ;
static int mrisDumpDefectiveEdge(MRI_SURFACE *mris, int vno1, int vno2) ;
static int mrisMarkBadEdgeVertices(MRI_SURFACE *mris, int mark) ;
static int mrisCheckSurface(MRI_SURFACE *mris) ;
#if 0
static int mrisComputeCanonicalBasis(MRI_SURFACE *mris, int fno,
                                     double origin[3],double e0[3],
                                     double e1[3]);
#endif
static int mrisInitializeNeighborhood(MRI_SURFACE *mris, int vno) ;
static int mrisSetVertexFaceIndex(MRI_SURFACE *mris, int vno, int fno) ;
static int isFace(MRI_SURFACE *mris, int vno0, int vno1, int vno2) ;
static int findFace(MRI_SURFACE *mris, int vno0, int vno1, int vno2) ;
static int mrisAddFace(MRI_SURFACE *mris, int vno0, int vno1, int vno2) ;
#if (!SPHERE_INTERSECTION)
static int mrisComputeCanonicalEdgeBasis(MRI_SURFACE *mris, EDGE *edge1,
    EDGE *edge2, double origin[3],
    double e0[3], double e1[3]);
#endif
#if 0
static int mrisDumpTriangle(MRI_SURFACE *mris, int fno) ;
static int mrisDilateAmbiguousVertices(MRI_SURFACE *mris, int mark,int ndil) ;
static int triangleNeighbors(MRI_SURFACE *mris, int fno1, int fno2) ;
#endif
static int triangleMarked(MRI_SURFACE *mris, int fno) ;
#if 0
static int mrisScaleMaxDimension(MRI_SURFACE *mris, float maxr) ;
#endif
static int mrisCalculateOriginalFaceCentroid(MRI_SURFACE *mris, int fno,
    float *px, float *py, float *pz) ;
static int mrisCalculateFaceCentroid(MRI_SURFACE *mris, int fno,
                                     float *px, float *py, float *pz) ;
static int mrisCalculateCanonicalFaceCentroid(MRI_SURFACE *mris, int fno,
    float *px,float *py,float *pz);
static int mrisDirectionTriangleIntersection(MRI_SURFACE *mris, float x0,
    float y0, float z0, float nx,
    float ny, float nz, MHT *mht,
    double *pdist) ;
static int mrisComputeCurvatureMinMax(MRI_SURFACE *mris) ;
static int
mrisAllNormalDirectionCurrentTriangleIntersections(MRI_SURFACE *mris,
    VERTEX *v, MHT *mht,
    double *pdist,
    int *flist);
static int  load_triangle_vertices(MRI_SURFACE *mris, int fno, double U0[3],
                                   double U1[3], double U2[3], int which) ;
static int  load_orig_triangle_vertices(MRI_SURFACE *mris, int fno,
                                        double U0[3], double U1[3],
                                        double U2[3]) ;
static void    mrisDumpFace(MRI_SURFACE *mris, int fno, FILE *fp) ;
static int    mrisAddEdge(MRI_SURFACE *mris, int vno1, int vno2) ;

#if 0
static int mrisNormalDirectionTriangleIntersection(MRI_SURFACE*mris,VERTEX *v,
    MHT *mht, double *pdist,
    int *flist, int which);
static int mrisAllCurrentTriangleIntersections(MRI_SURFACE *mris, float x,
    float y, float z, float nx,
    float ny, float nz,
    MHT *mht, int *flist) ;
static double mrisFindClosestFilledVoxel(MRI_SURFACE *mris, MRI *mri_filled,
    int vno, double max_dist) ;
static int   mrisCheck(MRI_SURFACE *mris) ;
static int   mrisClipGradient(MRI_SURFACE *mris, float max_len) ;
static int   mrisClipMomentumGradient(MRI_SURFACE *mris, float max_len) ;
#endif
static int   mrisComputeSurfaceDimensions(MRI_SURFACE *mris) ;
static int   mrisFindNeighbors(MRI_SURFACE *mris) ;
static void  mrisNormalize(float v[3]) ;
static float mrisTriangleArea(MRIS *mris, int fac, int n) ;
static int   mrisNormalFace(MRIS *mris, int fac,int n,float norm[]) ;
static int   mrisComputeOrigNormal(MRIS *mris, int vno, float norm[]) ;
static int   mrisComputeWhiteNormal(MRIS *mris, int vno, float norm[]) ;
static int   mrisComputeWhichSurfaceRepulsionTerm
(MRI_SURFACE *mris, double l_repulse,
 MHT *mht, int which, float max_dot) ;
static int   mrisComputePialNormal(MRIS *mris, int vno, float norm[]) ;
static int   mrisOrigNormalFace(MRIS *mris, int fac,int n,float norm[]) ;
static int   mrisPialNormalFace(MRIS *mris, int fac,int n,float norm[]) ;
static int   mrisWhiteNormalFace(MRIS *mris, int fac,int n,float norm[]) ;
static int   mrisReadTransform(MRIS *mris, const char *mris_fname) ;
static MRI_SURFACE *mrisReadAsciiFile(const char *fname) ;
static MRI_SURFACE *mrisReadGeoFile(const char *fname) ;
static MRI_SURFACE *MRISreadVTK(MRI_SURFACE *mris, const char *fname) ;
static MRI_SURFACE *mrisReadSTLfile(const char *fname) ;
static int mrisReadGeoFilePositions(MRI_SURFACE *mris,const char *fname) ;
static MRI_SURFACE *mrisReadTriangleFile(const char *fname, double pct_over) ;
static int         mrisReadTriangleFilePositions(MRI_SURFACE*mris,
    const char *fname) ;
static SMALL_SURFACE
*mrisReadTriangleFileVertexPositionsOnly(const char *fname) ;
/*static int   mrisReadFieldsign(MRI_SURFACE *mris, const char *fname) ;*/
static double mrisComputeNonlinearAreaSSE(MRI_SURFACE *mris) ;
static double mrisComputeNonlinearDistanceSSE(MRI_SURFACE *mris) ;
static double mrisComputeSpringEnergy(MRI_SURFACE *mris) ;
static double mrisComputeLaplacianEnergy(MRI_SURFACE *mris) ;
static double mrisComputeThicknessSmoothnessEnergy(MRI_SURFACE *mris,
    double l_repulse) ;
static double mrisComputeThicknessMinimizationEnergy(MRI_SURFACE *mris,
    double l_thick_min, INTEGRATION_PARMS *parms) ;
static double mrisComputeThicknessNormalEnergy(MRI_SURFACE *mris,
    double l_thick_normal, INTEGRATION_PARMS *parms) ;
static double mrisComputeThicknessSpringEnergy(MRI_SURFACE *mris,
    double l_thick_spring, INTEGRATION_PARMS *parms) ;
static double mrisComputeThicknessParallelEnergy(MRI_SURFACE *mris,
    double l_thick_parallel, INTEGRATION_PARMS *parms) ;
static double mrisComputeAshburnerTriangleEnergy(MRI_SURFACE *mris,
    double l_ashburner_triangle, INTEGRATION_PARMS *parms) ;
static double mrisComputeRepulsiveEnergy(MRI_SURFACE *mris,
    double l_repulse,
    MHT *mht_v_current,
    MHT *mht_f_current);
static int    mrisComputeRepulsiveTerm(MRI_SURFACE *mris, double l_repulse,
                                       MHT *mht_v, MHT *mht_f) ;
static double mrisComputeRepulsiveRatioEnergy(MRI_SURFACE *mris,
    double l_repulse) ;
static int    mrisComputeRepulsiveRatioTerm(MRI_SURFACE *mris,
    double l_repulse, MHT *mht_v) ;
static int    mrisComputeSurfaceRepulsionTerm(MRI_SURFACE *mris,
    double l_repulse, MHT *mht);
static double    mrisComputeSurfaceRepulsionEnergy(MRI_SURFACE *mris,
    double l_repulse, MHT *mht);
static int    mrisComputeThicknessSmoothnessTerm(MRI_SURFACE *mris,
    double l_tsmooth) ;
static int    mrisComputeThicknessMinimizationTerm(MRI_SURFACE *mris,
    double l_thick_min, INTEGRATION_PARMS *parms) ;
static int    mrisComputeThicknessNormalTerm(MRI_SURFACE *mris,
    double l_thick_normal, INTEGRATION_PARMS *parms) ;
static int    mrisComputeThicknessSpringTerm(MRI_SURFACE *mris,
    double l_thick_spring, INTEGRATION_PARMS *parms) ;
static int    mrisComputeThicknessParallelTerm(MRI_SURFACE *mris,
    double l_thick_parallel, INTEGRATION_PARMS *parms) ;
static int    mrisComputeAshburnerTriangleTerm(MRI_SURFACE *mris,
    double l_ashburner_triangle, INTEGRATION_PARMS *parms) ;
static double mrisComputeNonlinearSpringEnergy(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms);
static double mrisComputeTangentialSpringEnergy(MRI_SURFACE *mris);
static double mrisComputeIntensityError(MRI_SURFACE *mris,
                                        INTEGRATION_PARMS *parms);
static double mrisComputeTargetLocationError(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms);
static double mrisComputeDuraError(MRI_SURFACE *mris,
                                   INTEGRATION_PARMS *parms);
#if 0
static int    mrisMarkSulcalVertices(MRI_SURFACE *mris,
                                     INTEGRATION_PARMS *parms) ;
static int    mrisUpdateSulcalGradients(MRI_SURFACE *mris,
                                        INTEGRATION_PARMS *parms) ;
#endif
static int mrisCheckSurfaceNbrs(MRI_SURFACE *mris) ;
static double mrisComputeIntensityGradientError(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms);
static double mrisComputeSphereError(MRI_SURFACE *mris,
                                     double l_sphere,double a);
static double mrisComputeDistanceError(MRI_SURFACE *mris,
                                       INTEGRATION_PARMS *parms) ;
double mrisComputeCorrelationError( MRI_SURFACE *mris,
                                    INTEGRATION_PARMS *parms,
                                    int use_stds );
static int    mrisComputeVertexDistances(MRI_SURFACE *mris) ;
static int    mrisComputeOriginalVertexDistances(MRI_SURFACE *mris) ;
static double mrisComputeError(MRI_SURFACE *mris, INTEGRATION_PARMS *parms,
                               float *parea_rms, float *pangle_rms,
                               float *pcurv_rms, float *pdist_rms,
                               float *pcorr_rms);
static int   mrisIntegrationEpoch(MRI_SURFACE *mris, INTEGRATION_PARMS *parms,
                                  int n_avgs);
static int   mrisRemoveNegativeArea(MRI_SURFACE *mris,INTEGRATION_PARMS *parms,
                                    int n_avgs, float min_area_pct,
                                    int max_passes);
static double mrisLineMinimize(MRI_SURFACE *mris, INTEGRATION_PARMS *parms);
static double mrisLineMinimizeSearch(MRI_SURFACE *mris,
                                     INTEGRATION_PARMS *parms);
static double  mrisAsynchronousTimeStep(MRI_SURFACE *mris, float momentum,
                                        float dt, MHT *mht, float max_mag) ;
static double  mrisAsynchronousTimeStepNew(MRI_SURFACE *mris, float momentum,
    float dt, MHT *mht, float max_mag) ;
static double mrisAdaptiveTimeStep(MRI_SURFACE *mris,INTEGRATION_PARMS*parms);
static int   mrisOrientEllipsoid(MRI_SURFACE *mris) ;
static int   mrisOrientPlane(MRI_SURFACE *mris) ;
#if AVERAGE_AREAS
static int   mrisAverageAreas(MRI_SURFACE *mris, int num_avgs, int which) ;
#endif
static int   transform(float *xptr, float *yptr, float *zptr,
                       float nx, float ny, float nz, float d) ;

static int   mrisComputeTangentPlanes(MRI_SURFACE *mris) ;
static int   mrisRemoveLink(MRI_SURFACE *mris, int vno1, int vno2) ;
static int   mrisRemoveEdge(MRI_SURFACE *mris, int vno1, int vno2) ;
static int   mrisRemoveFace(MRI_SURFACE *mris, int fno) ;
static int   mrisCountTotalNeighbors(MRI_SURFACE *mris) ;
static int   mrisCountValidLinks(MRI_SURFACE *mris, int vno1, int vno2) ;
static int   mrisComputeSpringTerm(MRI_SURFACE *mris, double l_spring);
static int   mrisComputeBorderTerm(MRI_SURFACE *mris, double l_border);
static int   mrisComputeMaxSpringTerm(MRI_SURFACE *mris, double l_spring);
static int   mrisComputeLaplacianTerm(MRI_SURFACE *mris, double l_laplacian);
static int   mrisComputeLinkTerm(MRI_SURFACE *mris, double l_spring, int pial);
static int   mrisComputeNormalizedSpringTerm(MRI_SURFACE *mris,
    double l_spring);
static int   mrisComputeIntensityTerm(MRI_SURFACE*mris,double l_intensity,
                                      MRI *mri_brain, MRI *mri_smooth,
                                      double sigma, INTEGRATION_PARMS *parms);
static int   mrisComputeTargetLocationTerm(MRI_SURFACE*mris,
    double l_location,
    INTEGRATION_PARMS *parms);
static int   mrisComputeIntensityGradientTerm(MRI_SURFACE*mris,
    double l_grad,
    MRI *mri_brain, MRI *mri_smooth);
static int   mrisComputeSphereTerm(MRI_SURFACE *mris, double l_sphere,
                                   float radius) ;
static int   mrisComputeConvexityTerm(MRI_SURFACE *mris, double l_convex) ;
static int   mrisComputeExpansionTerm(MRI_SURFACE *mris, double l_expand) ;
static int   mrisComputeDistanceTerm(MRI_SURFACE *mris,
                                     INTEGRATION_PARMS *parms) ;
static int   mrisComputeNonlinearDistanceTerm(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms) ;
static int   mrisComputeCorrelationTerm(MRI_SURFACE *mris,
                                        INTEGRATION_PARMS *parms) ;
static int   mrisComputeQuadraticCurvatureTerm(MRI_SURFACE *mris,
    double l_curv) ;
static double  mrisComputeQuadraticCurvatureSSE(MRI_SURFACE *mris,
    double l_curv) ;
static int   mrisComputePolarCorrelationTerm(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms) ;
static double mrisComputeVectorCorrelationError(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms,
    int use_stds) ;
static int   mrisComputeVectorCorrelationTerm(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms) ;
static int   mrisComputePolarVectorCorrelationTerm(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms) ;
static int   mrisComputeAngleAreaTerms(MRI_SURFACE *mris,
                                       INTEGRATION_PARMS *parms) ;
static int   mrisComputeNonlinearAreaTerm(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms) ;
static int   mrisClearDistances(MRI_SURFACE *mris) ;
static int   mrisClearExtraGradient(MRI_SURFACE *mris) ;
static int   mrisClearMomentum(MRI_SURFACE *mris) ;
static int   mrisValidFaces(MRI_SURFACE *mris) ;
static int   mrisLabelVertices(MRI_SURFACE *mris, float cx, float cy,
                               float cz, int label, float radius) ;
static int mrisComputeShrinkwrapTerm(MRI_SURFACE *mris,
                                     MRI *mri_brain,
                                     double  l_shrinkwrap) ;
static double mrisComputeShrinkwrapError(MRI_SURFACE *mris,
    MRI *mri_brain,
    double l_shrinkwrap) ;
static int mrisComputeExpandwrapTerm(MRI_SURFACE *mris,
                                     MRI *mri_brain,
                                     double  l_expandwrap) ;
static double mrisComputeExpandwrapError(MRI_SURFACE *mris,
    MRI *mri_brain,
    double l_expandwrap,
    double target_radius) ;
#if 0
static double mrisFindNormalDistance(MRI_SURFACE *mris, MHT *mht, int vno,
                                     double max_dist, int which);
static int    mrisFindNextOutwardFace(MRI_SURFACE *mris, MHT *mht, int vno,
                                      double max_dist);
static int    mrisFindNextInwardFace(MRI_SURFACE *mris, MHT *mht, int vno,
                                     double max_dist);
#endif

static int project_point_onto_sphere(float cx, float cy, float cz,
                                     float radius,
                                     float *pcx, float *pcy, float *pcz) ;
static int mrisProjectOntoSurface(MRI_SURFACE *mris, int which_vertices)  ;
static int mrisProjectSurface(MRI_SURFACE *mris) ;
static int mrisOrientSurface(MRI_SURFACE *mris) ;
static int   mrisComputeBoundaryNormals(MRI_SURFACE *mris) ;
static int   mrisSmoothBoundaryNormals(MRI_SURFACE *mris, int niter) ;
static int   mrisFlipPatch(MRI_SURFACE *mris) ;

static int    mrisPlaceVertexInOrigFace(MRI_SURFACE *mris, VERTEX *v,int fno);

#if 0
static int   mrisAverageDs(MRI_SURFACE *mris, int num_avgs) ;
static int    vertexInFace(MRI_SURFACE *mris, int vno, int fno)  ;
/* not currently used */
static int  mrisNeighborAtVoxel(MRI_SURFACE *mris, MRI *mri, int vno,
                                int xv,int yv,int zv) ;
static int mrisComputeAverageNormalTerm(MRI_SURFACE *mris, int navgs,
                                        double l_thick_normal) ;
static int  mrisFindNormalDistanceLimits(MRI_SURFACE *mris, MRI *mri_filled,
    int vno, float max_dist,
    float *pmax_outward_distance,
    float *pmax_inward_distance) ;
#endif

static int  mrisComputeNonlinearSpringTerm(MRI_SURFACE *mris,double l_nlspring,
    INTEGRATION_PARMS *parms);
static int  mrisComputeTangentialSpringTerm(MRI_SURFACE *mris,double l_spring);
static int  mrisComputeNonlinearTangentialSpringTerm(MRI_SURFACE *mris,
                                                     double l_spring,
                                                     double min_dist);
static int   mrisComputeNormalSpringTerm(MRI_SURFACE *mris, double l_spring) ;
static int   mrisRemoveNeighborGradientComponent(MRI_SURFACE *mris, int vno) ;
static int   mrisRemoveNormalGradientComponent(MRI_SURFACE *mris, int vno) ;
static int   mrisComputeVariableSmoothnessCoefficients(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms);

#if 0
static int   mrisSmoothNormalOutliers(MRI_SURFACE *mris, double nlen) ;
static int   mrisDebugVertex(MRI_SURFACE *mris, int vno) ;
static int    mrisComputeBoundaryTerm(MRI_SURFACE *mris,
                                      INTEGRATION_PARMS *parms) ;
static int   mrisComputeCurvatureTerm(MRI_SURFACE *mris,
                                      INTEGRATION_PARMS *parms) ;
static int   mrisComputeNegTerm(MRI_SURFACE *mris,INTEGRATION_PARMS *parms);
static int   mrisCountNegativeVertices(MRI_SURFACE *mris) ;
static double mrisComputeAverageHeight(MRI_SURFACE *mris) ;


static int   mrisComputeSethianCurvatureTerm(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms) ;
static int   mrisSmoothNormals(MRI_SURFACE *mris, int niterations) ;
static int   mrisComputeCurvatureGradientTerm(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms) ;
static int   mrisStoreCurrentGradient(MRI_SURFACE *mris) ;
static int   mrisFindPoles(MRIS *mris) ;
static int   mrisComputeEllipsoidProperties(MRI_SURFACE *mris) ;
#endif
static int   mrisLogStatus(MRI_SURFACE *mris, INTEGRATION_PARMS *parms,
                           FILE *fp, float dt, float old_sse) ;
static int   mrisWriteSnapshots(MRI_SURFACE *mris, INTEGRATION_PARMS *parms,
                                int t) ;
static int   mrisWriteSnapshot(MRI_SURFACE *mris, INTEGRATION_PARMS *parms,
                               int t) ;
static int   mrisTrackTotalDistance(MRI_SURFACE *mris) ;
static int   mrisTrackTotalDistanceNew(MRI_SURFACE *mris) ;
static int  mrisLimitGradientDistance(MRI_SURFACE *mris, MHT *mht, int vno) ;
static int mrisFillFace(MRI_SURFACE *mris, MRI *mri, int fno) ;
static int mrisHatchFace(MRI_SURFACE *mris, MRI *mri, int fno, int on) ;
#if 0
static int mrisEraseFace(MRI_SURFACE *mris, MRI *mri, int fno) ;
static int  mrisRipVertices(MRI_SURFACE *mris) ;
#endif
static double mrisRmsValError(MRI_SURFACE *mris, MRI *mri) ;
static double mrisRmsDistanceError(MRI_SURFACE *mris) ;
static int mrisRemoveVertexLink(MRI_SURFACE *mris, int vno1, int vno2) ;
static int mrisStoreVtotalInV3num(MRI_SURFACE *mris) ;
static int  mrisFindAllOverlappingFaces(MRI_SURFACE *mris, MHT *mht,int fno,
                                        int *flist) ;

//The following two functions added for processing two channel MEF
static int mrisComputeIntensityTerm_mef(MRI_SURFACE *mris,
                                        double l_intensity,
                                        MRI *mri_30,
                                        MRI *mri_5,
                                        double sigma_global,
                                        float weight30,
                                        float weight5,
                                        INTEGRATION_PARMS *parms);
static double mrisRmsValError_mef(MRI_SURFACE *mris,
                                  MRI *mri_30,
                                  MRI *mri_5,
                                  float weight30,
                                  float weight5);

#if 0
static int   mrisAddVertices(MRI_SURFACE *mris, double max_len) ;
#endif
static int mrisDivideEdge(MRI_SURFACE *mris, int vno1, int vno2) ;
static int mrisDivideFace(MRI_SURFACE *mris, int fno, int vno1, int vno2,
                          int vnew_no) ;

static MATRIX *getSRASToTalSRAS(LT *lt);

#ifdef FS_CUDA

#include "mrisurf_cuda.h"
static int mrisComputeMetricPropertiesCUDA(MRI_CUDA_SURFACE *mrics,
    MRI_SURFACE *mris);
static int mrisIntegrateCUDA(MRI_SURFACE *mris,
                             INTEGRATION_PARMS *parms,
                             int n_averages);
static double mrisLineMinimizeCUDA(MRI_CUDA_SURFACE *mrisc,
                                   MRI_SURFACE *mris,
                                   INTEGRATION_PARMS *parms);
static float mrisComputeDistanceErrorCUDA(MRI_SURFACE *mris,
    MRI_CUDA_SURFACE *mrisc,
    INTEGRATION_PARMS *parms);
static double MRIScomputeSSE_CUDA(MRI_SURFACE *mris,
                                  MRI_CUDA_SURFACE *mrisc,
                                  INTEGRATION_PARMS *parms);

#ifdef FS_CUDA_TIMINGS
/* this stuff is needed for some of the benchmarking I have been doing */
#include <sys/time.h>
#include <stdlib.h>
#include <unistd.h>
static int timeval_subtract (struct timeval *result,
                             struct timeval * x,
                             struct timeval * y)
{
  /* Perform the carry for the later subtraction by updating y. */
  if (x->tv_usec < y->tv_usec)
  {
    int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
    y->tv_usec -= 1000000 * nsec;
    y->tv_sec += nsec;
  }
  if (x->tv_usec - y->tv_usec > 1000000)
  {
    int nsec = (x->tv_usec - y->tv_usec) / 1000000;
    y->tv_usec += 1000000 * nsec;
    y->tv_sec -= nsec;
  }

  /* Compute the time remaining to wait.
     tv_usec is certainly positive. */
  result->tv_sec = x->tv_sec - y->tv_sec;
  result->tv_usec = x->tv_usec - y->tv_usec;

  /* Return 1 if result is negative. */
  return x->tv_sec < y->tv_sec;
}
#endif // FS_CUDA_TIMINGS

/* this stuff could be useful outside FS_CUDA as well */
static INTEGRATION_PARMS *mrisCloneIP(INTEGRATION_PARMS *parms);
static void mrisDeleteIP(INTEGRATION_PARMS *parms);

#endif /* FS_CUDA */


/*--------------------------------------------------------------------*/

/*--------------------- CONSTANTS AND MACROS -------------------------*/

#define QUAD_FILE_MAGIC_NUMBER      (-1 & 0x00ffffff)
#define TRIANGLE_FILE_MAGIC_NUMBER  (-2 & 0x00ffffff)
#define NEW_QUAD_FILE_MAGIC_NUMBER  (-3 & 0x00ffffff)
/* 16777215 = 0xFFFFFF */
//#define NEW_VERSION_MAGIC_NUMBER  16777215 // moved to mrisurf.h
#define START_Y                   (-128)
#define SLICE_THICKNESS           1

#define VERTEX_EDGE(vec, v0, v1) VECTOR_LOAD(vec,v1->x-v0->x,v1->y-v0->y, \
                                               v1->z-v0->z)
#define VERTEX_ORIG_EDGE(vec, v0, v1) VECTOR_LOAD(vec,v1->origx-v0->origx,\
v1->origy-v0->origy, v1->origz-v0->origz)
#define VERTEX_CANONICAL_EDGE(vec, v0, v1) VECTOR_LOAD(vec,v1->cx-v0->cx,\
v1->cy-v0->cy, v1->cz-v0->cz)

/* 77557 is horizontal with positive area */
/* 126906 has dy = 0 with negative area */
/* 102961 has a = 0 */
/* 77115 is > pi/2, face 1 */
/* v 82875, f 0 has negative area and horizontal */
/* v 115365, f 1 has negative area and is vertical */
/* v 75530, f 4 has negative area and is vertical */
#if 0
#define DEBUG_FACE(vno, fno)   (((fno) == 2) && (Gdiag & DIAG_SURFACE) && \
                                 (vno == 79881))
#endif
#define DEBUG_FACE(vno, fno)   (((fno) == 4) && (Gdiag & DIAG_SURFACE) && \
                                (DEBUG_VERTEX(vno)))
#define VDEBUG_FACE(fno)   (DEBUG_FACE(fno) && 0)
#define DEBUG_VERTEX(v)   (((v) == 75530) && (Gdiag & DIAG_SURFACE) && 1)
#define VDEBUG_VERTEX(v)   (((v) == 77115) && (Gdiag & DIAG_SURFACE) && 0)

/*--------------------------------------------------------------------*/
/*------------------------ STATIC DATA -------------------------------*/

int topology_fixing_exit_after_diag = 0 ;

static int vertexIndexOutOfRangeCounter = 0;

/*-------------------------- FUNCTIONS -------------------------------*/
double (*gMRISexternalGradient)(MRI_SURFACE *mris,
                                INTEGRATION_PARMS *parms) = NULL ;
double (*gMRISexternalSSE)(MRI_SURFACE *mris,
                           INTEGRATION_PARMS *parms) = NULL ;
double (*gMRISexternalRMS)(MRI_SURFACE *mris,
                           INTEGRATION_PARMS *parms) = NULL ;
int (*gMRISexternalTimestep)(MRI_SURFACE *mris,
                             INTEGRATION_PARMS *parms) = NULL ;
int (*gMRISexternalRipVertices)(MRI_SURFACE *mris,
                                INTEGRATION_PARMS *parms) = NULL;
int (*gMRISexternalClearSSEStatus)(MRI_SURFACE *mris) = NULL ;
int (*gMRISexternalReduceSSEIncreasedGradients)(MRI_SURFACE *mris,
    double pct) = NULL ;

/*---------------------------------------------------------------
  MRISurfSrcVersion() - returns CVS version of this file.
  ---------------------------------------------------------------*/
const char *MRISurfSrcVersion(void)
{
  return("$Id: mrisurf.c,v 1.744 2013/01/08 15:41:28 fischl Exp $");
}

/*-----------------------------------------------------
  ------------------------------------------------------*/
MRI_SURFACE *MRISreadOverAlloc(const char *fname, double pct_over)
{
  MRI_SURFACE *mris = NULL ;
  int         nquads, nvertices, magic, version, ix, iy, iz, vno, fno, n, m;
  int         imnr, imnr0, imnr1, type, vertices[VERTICES_PER_FACE+1], num ;
  float       x, y, z, xhi, xlo, yhi, ylo, zhi, zlo ;
  FILE        *fp = NULL ;
  VERTEX      *vertex ;
  FACE        *face ;
  int         tag,nread;
  char        tmpstr[2000];
  MRI         *mri;

  // default:
  version = -3;

  chklc() ;    /* check to make sure license.dat is present */
  type = MRISfileNameType(fname) ; /* using extension to get type */
  if (type == MRIS_ASCII_TRIANGLE_FILE)  /* .ASC */
  {
    mris = mrisReadAsciiFile(fname) ;
    if (!mris)
    {
      return(NULL) ;
    }
    version = -3 ;
  }
  else if (type == MRIS_ICO_FILE)        /* .TRI, .ICO */
  {
    mris = ICOreadOverAlloc(fname, pct_over) ;
    if (!mris)
    {
      return(NULL) ;
    }
    return(mris) ;
    version = -2 ;
  }
  else if (type == MRIS_GEO_TRIANGLE_FILE) /* .GEO */
  {
    mris = mrisReadGeoFile(fname) ;
    if (!mris)
    {
      return(NULL) ;
    }
    version = -4;
  }
  else if (type == MRIS_STL_FILE)  /* .STL */
  {
    mris = mrisReadSTLfile(fname) ;
    if (!mris)
    {
      return(NULL) ;
    }
    version = -3 ;
  }
  else if (type == MRIS_VTK_FILE)  /* .vtk */
  {
    mris = MRISreadVTK(mris, fname) ;
    if (!mris)
    {
      return(NULL) ;
    }
    version = -3 ;
  }
  else if (type == MRIS_GIFTI_FILE)  /* .gii */
  {
    mris = mrisReadGIFTIfile(fname, NULL) ;
    if (!mris)
    {
      return(NULL) ;
    }
    version = -3 ; /* Not really sure what is appropriate here */
  }
  else if (type == MRI_MGH_FILE)  /* .mgh */
  {
    ErrorExit
    (ERROR_BADFILE,
     "ERROR: MRISread: cannot read surface data from file %s!\n",
     fname);
  }
  else // default type MRIS_BINARY_QUADRANGLE_FILE ... use magic number
  {
    fp = fopen(fname, "rb") ;
    if (!fp)
      ErrorReturn(NULL,(ERROR_NOFILE,"MRISread(%s): could not open file",
                        fname));

    magic = 0;
    nread = fread3(&magic, fp) ;
    if(nread != 1)
    {
      printf("ERROR: reading %s\n",fname);
      printf("Read %d bytes, expected 1\n",nread);
      fclose(fp);
      return(NULL);
    }
    if (magic == QUAD_FILE_MAGIC_NUMBER)
    {
      version = -1;
      if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      {
        fprintf(stdout, "new surface file format\n");
      }
    }
    else if (magic == NEW_QUAD_FILE_MAGIC_NUMBER)
    {
      version = -2 ;
    }
    else if (magic == TRIANGLE_FILE_MAGIC_NUMBER)
    {
      fclose(fp) ;
      mris = mrisReadTriangleFile(fname, pct_over) ;
      if (!mris)
      {
        ErrorReturn(NULL, (Gerror, "mrisReadTriangleFile failed.\n")) ;
      }
      version = -3 ;
    }
    else /* no magic number assigned */
    {
      rewind(fp);
      version = 0;
      if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      {
        printf("surfer: old surface file format\n");
      }
    }
  }
  /* some type of quadrangle file processing */
  if (version >= -2)
  {
    fread3(&nvertices, fp);
    fread3(&nquads, fp);   /* # of qaudrangles - not triangles */

    if (nvertices <= 0) /* sanity-checks */
      ErrorExit
      (ERROR_BADFILE,
       "ERROR: MRISread: file '%s' has %d vertices!\n"
       "Probably trying to use a scalar data file as a surface!\n",
       fname,nvertices);
    if (nquads > 4*nvertices) /* sanity-checks */
    {
      fprintf(stderr, "nquads=%d,  nvertices=%d\n", nquads, nvertices);
      ErrorExit
      (ERROR_BADFILE,
       "ERROR: MRISread: file '%s' has many more faces than vertices!\n"
       "Probably trying to use a scalar data file as a surface!\n",
       fname);
    }

    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      fprintf(stdout,"reading %d vertices and %d faces.\n",
              nvertices,2*nquads);

    mris = MRISoverAlloc(pct_over*nvertices,pct_over*2*nquads,nvertices,
                         2*nquads);
    mris->type = MRIS_BINARY_QUADRANGLE_FILE ;

    imnr0 = 1000 ;
    imnr1 = 0 ;
    /* read vertices *************************************************/
    for (vno = 0 ; vno < nvertices ; vno++)
    {
      vertex = &mris->vertices[vno] ;
      if (version == -1)        /* QUAD_FILE_MAGIC_NUMBER */
      {
        fread2(&ix,fp);
        fread2(&iy,fp);
        fread2(&iz,fp);
        vertex->x = ix/100.0;
        vertex->y = iy/100.0;
        vertex->z = iz/100.0;
      }
      else  /* version == -2 */ /* NEW_QUAD_FILE_MAGIC_NUMBER */
      {
        vertex->x = freadFloat(fp) ;
        vertex->y = freadFloat(fp) ;
        vertex->z = freadFloat(fp) ;
      }
#if 0
      vertex->label = NO_LABEL ;
#endif
      /* brain-dead code and never used again either */
      imnr = (int)((vertex->y-START_Y)/SLICE_THICKNESS+0.5);
      if (imnr > imnr1)
      {
        imnr1 = imnr ;
      }
      if (imnr < imnr0)
      {
        imnr0 = imnr ;
      }
      if (version == 0)  /* old surface format */
      {
        fread1(&num,fp);   /* # of faces we are part of */
        vertex->num = num ;
        vertex->f = (int *)calloc(vertex->num,sizeof(int));
        if (!vertex->f)
          ErrorExit
          (ERROR_NO_MEMORY,
           "MRISread: could not allocate %d faces",
           vertex->num) ;
        vertex->n = (uchar *)calloc(vertex->num,sizeof(uchar));
        if (!vertex->n)
          ErrorExit
          (ERROR_NO_MEMORY,
           "MRISread: could not allocate %d nbrs",
           vertex->n) ;
        for (n=0; n<vertex->num; n++)
        {
          fread3(&vertex->f[n],fp);
        }
      }
      else
      {
        vertex->num = 0;  /* will figure it out */
      }
    }
    /* read face vertices *******************************************/
    for (fno = 0 ; fno < mris->nfaces ; fno += 2)
    {
      int which ;

      if (fno == 86)
      {
        DiagBreak() ;
      }
      for (n = 0 ; n < 4 ; n++)   /* read quandrangular face */
      {
        fread3(&vertices[n],fp);
        if (vertices[n] == 22)
        {
          DiagBreak() ;
        }
      }

      /* if we're going to be arbitrary,
         we might as well be really arbitrary */
#define WHICH_FACE_SPLIT(vno0, vno1) (1*nint(sqrt(1.9*vno0) + sqrt(3.5*vno1)))
      /*
        NOTE: for this to work properly in the write, the first two
        vertices in the first face (EVEN and ODD) must be 0 and 1.
      */
      which = WHICH_FACE_SPLIT(vertices[0], vertices[1]) ;

      /* 1st triangle */
      if (EVEN(which))
      {
        mris->faces[fno].v[0] = vertices[0] ;
        mris->faces[fno].v[1] = vertices[1] ;
        mris->faces[fno].v[2] = vertices[3] ;

        /* 2nd triangle */
        mris->faces[fno+1].v[0] = vertices[2] ;
        mris->faces[fno+1].v[1] = vertices[3] ;
        mris->faces[fno+1].v[2] = vertices[1] ;
      }
      else
      {
        mris->faces[fno].v[0] = vertices[0] ;
        mris->faces[fno].v[1] = vertices[1] ;
        mris->faces[fno].v[2] = vertices[2] ;

        /* 2nd triangle */
        mris->faces[fno+1].v[0] = vertices[0] ;
        mris->faces[fno+1].v[1] = vertices[2] ;
        mris->faces[fno+1].v[2] = vertices[3] ;
      }
      for (n = 0 ; n < VERTICES_PER_FACE ; n++)
      {
        mris->vertices[mris->faces[fno].v[n]].num++;
        mris->vertices[mris->faces[fno+1].v[n]].num++;
      }
    }
    mris->useRealRAS = 0;

    // read tags
    {
      long long len ;

      while ((tag = TAGreadStart(fp, &len)) != 0)
      {
        switch (tag)
        {
        case TAG_GROUP_AVG_SURFACE_AREA:
          mris->group_avg_surface_area = freadFloat(fp) ;
          fprintf(stdout,
                  "reading group avg surface area %2.0f cm^2 from file\n",
                  mris->group_avg_surface_area/100.0) ;
          break ;
        case TAG_OLD_SURF_GEOM:
          readVolGeom(fp, &mris->vg);
          break ;
        case TAG_OLD_USEREALRAS:
        case TAG_USEREALRAS:
          if (!freadIntEx(&mris->useRealRAS,fp)) // set useRealRAS
          {
            mris->useRealRAS = 0;  // if error, set to default
          }
          break ;
        case TAG_CMDLINE:
          if (mris->ncmds > MAX_CMDS)
            ErrorExit
            (ERROR_NOMEMORY,
             "mghRead(%s): too many commands (%d) in file",
             fname,mris->ncmds);
          mris->cmdlines[mris->ncmds] = calloc(len+1, sizeof(char)) ;
          fread(mris->cmdlines[mris->ncmds], sizeof(char), len, fp) ;
          mris->cmdlines[mris->ncmds][len] = 0 ;
          mris->ncmds++ ;
          break ;
        default:
          TAGskip(fp, tag, (long long)len) ;
          break ;
        }
      }
    }
    fclose(fp);
  }
  /* end of quadrangle file processing */
  /* file is closed now for all types ***********************************/

  /* find out if this surface is lh or rh from fname */
  strcpy(mris->fname, fname) ;
  {
    const char *surf_name ;

    surf_name = strrchr(fname, '/') ;
    if (surf_name == NULL)
    {
      surf_name = fname ;
    }
    else
    {
      surf_name++ ;  /* past the last slash */
    }
    if (toupper(*surf_name) == 'R')
    {
      mris->hemisphere = RIGHT_HEMISPHERE ;
    }
    else if (toupper(*surf_name) == 'L')
    {
      mris->hemisphere = LEFT_HEMISPHERE ;
    }
    else if (toupper(*surf_name) == 'B')
    {
      mris->hemisphere = BOTH_HEMISPHERES ;
    }
    else
    {
      mris->hemisphere = NO_HEMISPHERE ;
    }
  }

  /***********************************************************************/
  /* build members of mris structure                                     */
  /***********************************************************************/
  if ((version<0) || type == MRIS_ASCII_TRIANGLE_FILE)
  {
    for (vno = 0 ; vno< mris->nvertices ; vno++)
    {
      vertex = &mris->vertices[vno] ;
      mris->vertices[vno].f =
        (int *)calloc(mris->vertices[vno].num,sizeof(int));
      if (!mris->vertices[vno].f)
        ErrorExit
        (ERROR_NOMEMORY,
         "MRISread(%s): could not allocate %d faces at %dth vertex",
         fname, vno, mris->vertices[vno].num) ;

      mris->vertices[vno].n =
        (uchar *)calloc(mris->vertices[vno].num,sizeof(uchar));
      if (!mris->vertices[vno].n)
        ErrorExit
        (ERROR_NOMEMORY,
         "MRISread(%s): could not allocate %d indices at %dth vertex",
         fname, vno, mris->vertices[vno].num) ;
      mris->vertices[vno].num = 0 ;
    }
    for (fno = 0 ; fno < mris->nfaces ; fno++)
    {
      face = &mris->faces[fno] ;
      for (n = 0 ; n < VERTICES_PER_FACE ; n++)
        mris->vertices[face->v[n]].f[mris->vertices[face->v[n]].num++]
        = fno;
    }
  }


  xhi=yhi=zhi= -10000;
  xlo=ylo=zlo= 10000;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    mris->vertices[vno].curv = 0;
    mris->vertices[vno].origarea = -1;
    mris->vertices[vno].border = 0;
#if 0
    mris->vertices[vno].origripflag = 0;
    mris->vertices[vno].ripflag = 0;
    mris->vertices[vno].val = 0;
    mris->vertices[vno].dist = 0;
    mris->vertices[vno].mx = 0;
    mris->vertices[vno].my = 0;
    mris->vertices[vno].mz = 0;
    mris->vertices[vno].fieldsign = 0;
    mris->vertices[vno].fsmask = 1;
    mris->vertices[vno].nc = 0;
    mris->vertices[vno].marked = 0;
#endif
    for (n=0; n<mris->vertices[vno].num; n++)
    {
      for (m=0; m<VERTICES_PER_FACE; m++)
      {
        if (mris->faces[mris->vertices[vno].f[n]].v[m] == vno)
        {
          mris->vertices[vno].n[n] = m;
        }
      }
    }
    x = mris->vertices[vno].x;
    y = mris->vertices[vno].y;
    z = mris->vertices[vno].z;
    if (x>xhi)
    {
      xhi=x;
    }
    if (x<xlo)
    {
      xlo=x;
    }
    if (y>yhi)
    {
      yhi=y;
    }
    if (y<ylo)
    {
      ylo=y;
    }
    if (z>zhi)
    {
      zhi=z;
    }
    if (z<zlo)
    {
      zlo=z;
    }
  }
  mris->xlo = xlo ;
  mris->ylo = ylo ;
  mris->zlo = zlo ;
  mris->xhi = xhi ;
  mris->yhi = yhi ;
  mris->zhi = zhi ;
  mris->xctr = (xhi+xlo)/2;
  mris->yctr = (yhi+ylo)/2;
  mris->zctr = (zhi+zlo)/2;
  mrisFindNeighbors(mris);
  MRIScomputeNormals(mris);
  mrisComputeVertexDistances(mris) ;
  mrisReadTransform(mris, fname) ;
  if (type == MRIS_ASCII_TRIANGLE_FILE || type == MRIS_GEO_TRIANGLE_FILE)
  {
#if 0
    MRISsetNeighborhoodSize(mris, 2) ;
    MRIScomputeSecondFundamentalForm(mris) ;
    MRISuseMeanCurvature(mris) ;
#endif
  }
  else
  {
#if 0
    if (MRISreadBinaryCurvature(mris, fname) != NO_ERROR)
    {
      fprintf(stdout, "computing surface curvature directly...\n") ;
      MRISsetNeighborhoodSize(mris, 2) ;
      MRIScomputeSecondFundamentalForm(mris) ;
      MRISuseMeanCurvature(mris) ;
    }

    if (MRISreadBinaryAreas(mris, fname) != NO_ERROR)
    {
      fprintf(stdout, "ignoring area file...\n") ;  /*return(NULL) ;*/
    }
#endif
  }

  mris->radius = MRISaverageRadius(mris) ;
#if 0
  if (IS_QUADRANGULAR(mris))
  {
    MRISremoveTriangleLinks(mris) ;
  }
#endif
  MRIScomputeMetricProperties(mris) ;
  /*  mrisFindPoles(mris) ;*/

  MRISstoreCurrentPositions(mris) ;

  // Check whether there is an area file for group average
  sprintf(tmpstr,"%s.avg.area.mgh",fname);
  if(Gdiag_no >= 0 && DIAG_VERBOSE_ON)
  {
    printf("Trying to read average area %s\n",tmpstr);
  }
  if (fio_FileExistsReadable(tmpstr))
  {
    if(Gdiag_no >= 0 && DIAG_VERBOSE_ON)
    {
      printf("Reading in average area %s\n",tmpstr);
    }
    mri = MRIread(tmpstr);
    if (!mri)
    {
      printf("ERROR: reading in average area %s\n",tmpstr);
      return(NULL);
    }
    MRIScopyMRI(mris,mri,0,"group_avg_area");
    MRIfree(&mri);
    mris->group_avg_vtxarea_loaded=1;
  }
  else
  {
    mris->group_avg_vtxarea_loaded=0;
  }
  if(Gdiag_no >= 0 && DIAG_VERBOSE_ON)
  {
    printf("Average area loaded %d\n",mris->group_avg_vtxarea_loaded);
  }

  return(mris) ;
}

/*-----------------------------------------------------
  MRISfastRead() just calls MRISRead()
  Parameters:
  Returns value:
  Description
  ------------------------------------------------------*/
MRI_SURFACE *MRISfastRead(const char *fname)
{
  /********* why you keep the rest ? ******************/
#if 1
  return(MRISread(fname)) ;
#else
  MRI_SURFACE *mris ;
  int         nquads, nvertices, magic, version, ix, iy, iz, vno, fno, n, m;
  int         imnr, imnr0, imnr1, type, vertices[4], num ;
  float       x, y, z, xhi, xlo, yhi, ylo, zhi, zlo ;
  FILE        *fp ;
  VERTEX      *vertex ;
  FACE        *face ;

  mris = NULL ;
  fp = NULL ;
  type = MRISfileNameType(fname) ;
  if (type == MRIS_ASCII_TRIANGLE_FILE)
  {
    mris = mrisReadAsciiFile(fname) ;
    if (!mris)
    {
      return(NULL) ;
    }
    version = -3 ;
  }
  else if (type == MRIS_ICO_FILE)
  {
    mris = ICOread(fname) ;
    if (!mris)
    {
      return(NULL) ;
    }
    return(mris) ;
    version = -2 ;
  }
  else if (type == MRIS_GEO_TRIANGLE_FILE)
  {
    mris = mrisReadGeoFile(fname) ;
    if (!mris)
    {
      return(NULL) ;
    }
    version = -4 ;
  }
  else   /* custom binary file - find out which type using magic # */
  {
    fp = fopen(fname, "rb") ;
    if (!fp)
      ErrorReturn(NULL,(ERROR_NOFILE,"MRISread(%s): could not open file",
                        fname));

    fread3(&magic, fp) ;
    if (magic == TRIANGLE_FILE_MAGIC_NUMBER)
    {
      fclose(fp) ;
      mris = mrisReadTriangleFile(fname, 0.0) ;
      if (!mris)
      {
        ErrorReturn(NULL, (Gerror, "mrisReadTriangleFile failed.\n")) ;
      }
      version = -3 ;
    }
    else if (magic == QUAD_FILE_MAGIC_NUMBER)
    {
      version = -1;
      if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      {
        fprintf(stdout, "new surface file format\n");
      }
    }
    else if (magic == NEW_QUAD_FILE_MAGIC_NUMBER)
    {
      version = -2;
      if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      {
        fprintf(stdout, "new surface file format\n");
      }
    }
    else
    {
      rewind(fp);
      version = 0;
      if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      {
        printf("surfer: old surface file format\n");
      }
    }
  }
  if (version >= -2)
  {
    fread3(&nvertices, fp);
    fread3(&nquads, fp);

    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      fprintf(stdout,
              "reading %d vertices and %d faces.\n",nvertices,2*nquads);

    mris = MRISalloc(nvertices, 2*nquads) ;
    mris->type = MRIS_BINARY_QUADRANGLE_FILE ;

    imnr0 = 1000 ;
    imnr1 = 0 ;
    for (vno = 0 ; vno < nvertices ; vno++)
    {
      vertex = &mris->vertices[vno] ;
      if (version == -1)
      {
        fread2(&ix,fp);
        fread2(&iy,fp);
        fread2(&iz,fp);
        vertex->x = ix/100.0;
        vertex->y = iy/100.0;
        vertex->z = iz/100.0;
      }
      else  /* version == -2 */
      {
        vertex->x = freadFloat(fp) ;
        vertex->y = freadFloat(fp) ;
        vertex->z = freadFloat(fp) ;
      }
#if 0
      vertex->label = NO_LABEL ;
#endif
      imnr = (int)((vertex->y-START_Y)/SLICE_THICKNESS+0.5);
      if (imnr > imnr1)
      {
        imnr1 = imnr ;
      }
      if (imnr < imnr0)
      {
        imnr0 = imnr ;
      }
      if (version == 0)  /* old surface format */
      {
        fread1(&num,fp);
        vertex->num = num ;
        vertex->f = (int *)calloc(vertex->num,sizeof(int));
        if (!vertex->f)
          ErrorExit
          (ERROR_NO_MEMORY,
           "MRISread: could not allocate %d faces",
           vertex->num) ;
        vertex->n = (uchar *)calloc(vertex->num,sizeof(uchar));
        if (!vertex->n)
          ErrorExit
          (ERROR_NO_MEMORY,
           "MRISread: could not allocate %d nbrs",
           vertex->n) ;
        for (n=0; n<vertex->num; n++)
        {
          fread3(&vertex->f[n],fp);
        }
      }
      else
      {
        vertex->num = 0;
      }
    }

    for (fno = 0 ; fno < mris->nfaces ; fno += 2)
    {
      for (n = 0 ; n < 4 ; n++)   /* read quandrangular face */
      {
        fread3(&vertices[n],fp);
      }

      /* 1st triangle */
      mris->faces[fno].v[0] = vertices[0] ;
      mris->faces[fno].v[1] = vertices[1] ;
      mris->faces[fno].v[2] = vertices[3] ;
      if (version < 0)
        for (n = 0 ; n < VERTICES_PER_FACE ; n++)
        {
          mris->vertices[mris->faces[fno].v[n]].num++;
        }

      /* 2nd triangle */
      mris->faces[fno+1].v[0] = vertices[2] ;
      mris->faces[fno+1].v[1] = vertices[3] ;
      mris->faces[fno+1].v[2] = vertices[1] ;
      if (version < 0)
        for (n = 0 ; n < VERTICES_PER_FACE ; n++)
        {
          mris->vertices[mris->faces[fno+1].v[n]].num++;
        }
    }
    fclose(fp);
  }
  strcpy(mris->fname, fname) ;
  {
    char *surf_name ;

    surf_name = strrchr(fname, '/') ;
    if (surf_name == NULL)
    {
      surf_name = fname ;
    }
    else
    {
      surf_name++ ;  /* past the last slash */
    }
    if (toupper(*surf_name) == 'R')
    {
      mris->hemisphere = RIGHT_HEMISPHERE ;
    }
    else
    {
      mris->hemisphere = LEFT_HEMISPHERE ;
    }
  }
  if ((version<0) || type == MRIS_ASCII_TRIANGLE_FILE)
  {
    for (vno = 0 ; vno< mris->nvertices ; vno++)
    {
      vertex = &mris->vertices[vno] ;
      mris->vertices[vno].f =
        (int *)calloc(mris->vertices[vno].num,sizeof(int));
      if (!mris->vertices[vno].f)
        ErrorExit
        (ERROR_NOMEMORY,
         "MRISread(%s): could not allocate %d faces at %dth vertex",
         fname, vno, mris->vertices[vno].num) ;

      mris->vertices[vno].n =
        (uchar *)calloc(mris->vertices[vno].num,sizeof(uchar));
      if (!mris->vertices[vno].n)
        ErrorExit
        (ERROR_NOMEMORY,
         "MRISread(%s): could not allocate %d indices at %dth vertex",
         fname, vno, mris->vertices[vno].num) ;
      mris->vertices[vno].num = 0 ;
    }
    for (fno = 0 ; fno < mris->nfaces ; fno++)
    {
      face = &mris->faces[fno] ;
      for (n = 0 ; n < VERTICES_PER_FACE ; n++)
      {
        vertex = &mris->vertices[face->v[n]] ;
        vertex->f[vertex->num++] = fno;
      }
    }
  }

  xhi=yhi=zhi= -10000;
  xlo=ylo=zlo= 10000;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].curv = 0;
    mris->vertices[vno].origarea = -1;
    mris->vertices[vno].border = 0;
#if 0
    mris->vertices[vno].origripflag = 0;
    mris->vertices[vno].ripflag = 0;
    mris->vertices[vno].val = 0;
    mris->vertices[vno].dist = 0;
    mris->vertices[vno].mx = 0;
    mris->vertices[vno].my = 0;
    mris->vertices[vno].mz = 0;
    mris->vertices[vno].fieldsign = 0;
    mris->vertices[vno].fsmask = 1;
    mris->vertices[vno].nc = 0;
    mris->vertices[vno].marked = 0;
#endif
    for (n=0; n<mris->vertices[vno].num; n++)
    {
      for (m=0; m<VERTICES_PER_FACE; m++)
      {
        if (mris->faces[mris->vertices[vno].f[n]].v[m] == vno)
        {
          mris->vertices[vno].n[n] = m;
        }
      }
    }
    x = mris->vertices[vno].x;
    y = mris->vertices[vno].y;
    z = mris->vertices[vno].z;
    if (x>xhi)
    {
      xhi=x;
    }
    if (x<xlo)
    {
      xlo=x;
    }
    if (y>yhi)
    {
      yhi=y;
    }
    if (y<ylo)
    {
      ylo=y;
    }
    if (z>zhi)
    {
      zhi=z;
    }
    if (z<zlo)
    {
      zlo=z;
    }
  }
  mris->xlo = xlo ;
  mris->ylo = ylo ;
  mris->zlo = zlo ;
  mris->xhi = xhi ;
  mris->yhi = yhi ;
  mris->zhi = zhi ;
  mris->xctr = (xhi+xlo)/2;
  mris->yctr = (yhi+ylo)/2;
  mris->zctr = (zhi+zlo)/2;
  mrisFindNeighbors(mris);
  MRIScomputeNormals(mris);
#if 0
  mrisComputeVertexDistances(mris) ;
  mrisReadTransform(mris, fname) ;
#endif
  if (type == MRIS_ASCII_TRIANGLE_FILE || type == MRIS_GEO_TRIANGLE_FILE)
  {
    MRISsetNeighborhoodSize(mris, 2) ;
    MRIScomputeSecondFundamentalForm(mris) ;
    MRISuseMeanCurvature(mris) ;
  }
  else
  {
    if (MRISreadBinaryCurvature(mris, fname) != NO_ERROR)
    {
      fprintf(stdout, "ignoring curvature file...\n") ;  /*return(NULL) ;*/
    }
#if 0
    if (MRISreadBinaryAreas(mris, fname) != NO_ERROR)
    {
      return(NULL) ;
    }
#endif
  }

#if 0
  if (IS_QUADRANGULAR(mris))
  {
    MRISremoveTriangleLinks(mris) ;
  }
#endif
  MRISstoreCurrentPositions(mris) ;
  return(mris) ;
#endif
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI_SURFACE *
MRISread(const char *fname)
{
  MRI_SURFACE  *mris ;

  mris = MRISreadOverAlloc(fname, 0.0) ;
  if (mris == NULL)
  {
    return(NULL) ;
  }
  MRISsetNeighborhoodSize(mris, 3) ;   // find nbhds out to 3-nbrs
  MRISresetNeighborhoodSize(mris, 1) ; // reset current size to 1-nbrs
  return(mris) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#define USE_NEW_QUAD_FILE 1  // new style stores float instead of int
int
MRISwrite(MRI_SURFACE *mris, const char *name)
{
  int   k, type ;
  float x,y,z;
  FILE  *fp;
  char  fname[STRLEN] ;

  chklc() ;
  MRISbuildFileName(mris, name, fname) ;
  type = MRISfileNameType(fname) ;
  if (type == MRIS_ASCII_TRIANGLE_FILE)
  {
    return(MRISwriteAscii(mris, fname)) ;
  }
  else if (type == MRIS_VTK_FILE)
  {
    return(MRISwriteVTK(mris, fname)) ;
  }
  else if (type == MRIS_GEO_TRIANGLE_FILE)
  {
    return(MRISwriteGeo(mris, fname)) ;
  }
  else if (type == MRIS_ICO_FILE)
  {
    return MRISwriteICO(mris, fname);
  }
  else if (type == MRIS_STL_FILE)
  {
    return MRISwriteSTL(mris, fname);
  }
  else if (type == MRIS_GIFTI_FILE)
  {
    return MRISwriteGIFTI(mris, NIFTI_INTENT_POINTSET, fname, NULL);
  }

  if (mris->type == MRIS_TRIANGULAR_SURFACE)
  {
    return(MRISwriteTriangularSurface(mris, fname)) ;
  }

  fp = fopen(fname,"w");
  if (fp==NULL)
    ErrorReturn(ERROR_BADFILE,
                (ERROR_BADFILE,"MRISwrite(%s): can't create file\n",fname));

#if USE_NEW_QUAD_FILE
  fwrite3(NEW_QUAD_FILE_MAGIC_NUMBER,fp);
#else
  fwrite3(QUAD_FILE_MAGIC_NUMBER,fp);
#endif
  fwrite3(mris->nvertices,fp);
  fwrite3(mris->nfaces/2,fp);   /* # of quadrangles */
  for (k = 0 ; k < mris->nvertices ; k++)
  {
    x = mris->vertices[k].x;
    y = mris->vertices[k].y;
    z = mris->vertices[k].z;
#if USE_NEW_QUAD_FILE
    fwriteFloat(x, fp) ;
    fwriteFloat(y, fp) ;
    fwriteFloat(z, fp) ;
#else
    fwrite2((int)(x*100),fp);
    fwrite2((int)(y*100),fp);
    fwrite2((int)(z*100),fp);
#endif
  }
  for (k = 0 ; k < mris->nfaces ; k+=2)
  {
    int which ;
    FACE *f ;

    f = &mris->faces[k] ;
    {
      int n ;
      for (n = 0 ; n < VERTICES_PER_FACE ; n++)
      {
        if ((mris->faces[k].v[n] == 22) || (mris->faces[k+1].v[n] == 22))
        {
          DiagBreak() ;
        }
      }
    }
    which = WHICH_FACE_SPLIT(f->v[0], f->v[1]) ;
    if (EVEN(which))
    {
      fwrite3(mris->faces[k].v[0],fp);
      fwrite3(mris->faces[k].v[1],fp);
      fwrite3(mris->faces[k+1].v[0],fp);
      fwrite3(mris->faces[k].v[2],fp);
    }
    else
    {
      fwrite3(mris->faces[k].v[0],fp);
      fwrite3(mris->faces[k].v[1],fp);
      fwrite3(mris->faces[k].v[2],fp);
      fwrite3(mris->faces[k+1].v[2],fp);
    }
  }
  /* write whether vertex data was using the
     real RAS rather than conformed RAS */
  fwriteInt(TAG_OLD_USEREALRAS, fp);
  fwriteInt(mris->useRealRAS, fp);
  // volume info
  fwriteInt(TAG_OLD_SURF_GEOM, fp);
  writeVolGeom(fp, &mris->vg);

  if (!FZERO(mris->group_avg_surface_area))
  {
    long long here ;
    printf("writing group avg surface area %2.0f cm^2 into surface file\n",
           mris->group_avg_surface_area/100.0) ;
    TAGwriteStart(fp, TAG_GROUP_AVG_SURFACE_AREA, &here, sizeof(float)) ;
    fwriteFloat(mris->group_avg_surface_area, fp) ;
    TAGwriteEnd(fp, here) ;
  }
  // write other tags
  {
    int i ;

    for (i = 0 ; i < mris->ncmds ; i++)
      TAGwrite(fp,
               TAG_CMDLINE,
               mris->cmdlines[i],
               strlen(mris->cmdlines[i])+1) ;
  }
  fclose(fp);
  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI_SURFACE  *
MRISoverAlloc(int max_vertices, int max_faces, int nvertices, int nfaces)
{
  MRI_SURFACE  *mris ;

  if (max_vertices <= 0)
  {
    max_vertices = nvertices ;
  }
  if (max_faces <= 0)
  {
    max_faces = nfaces ;
  }
  mris = MRISalloc(max_vertices, max_faces) ;
  mris->nvertices = nvertices ;
  mris->nfaces = nfaces ;
  mris->max_vertices = max_vertices ;
  mris->max_faces = max_faces ;
  mris->useRealRAS = 0; /* just initialize */
  mris->vg.valid = 0; /* mark as invalid */

  return(mris) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI_SURFACE *
MRISalloc(int nvertices, int nfaces)
{
  MRI_SURFACE   *mris ;

  if (nvertices < 0)
    ErrorExit(ERROR_BADPARM,
              "ERROR: MRISalloc: nvertices=%d < 0\n", nvertices);

  if (nfaces < 0)
    ErrorExit(ERROR_BADPARM,
              "ERROR: MRISalloc: nfaces=%d < 0\n", nfaces);

  mris = (MRI_SURFACE *)calloc(1, sizeof(MRI_SURFACE)) ;
  if (!mris)
    ErrorExit(ERROR_NO_MEMORY,
              "MRISalloc(%d, %d): could not allocate mris structure",
              nvertices, nfaces);
  else
  {
    memset(mris,0,sizeof(MRI_SURFACE));
  }

  mris->nsize = 1 ;  /* only 1-connected neighbors initially */
  mris->nvertices = nvertices ;
  mris->nfaces = nfaces ;
  mris->vertices = (VERTEX *)calloc(nvertices, sizeof(VERTEX)) ;
  if (!mris->vertices)
    ErrorExit(ERROR_NO_MEMORY,
              "MRISalloc(%d, %d): could not allocate vertices",
              nvertices, sizeof(VERTEX));
  else
  {
    memset(mris->vertices,0,nvertices * sizeof(VERTEX));
  }

  mris->faces = (FACE *)calloc(nfaces, sizeof(FACE)) ;
  if (!mris->faces)
    ErrorExit(ERROR_NO_MEMORY,
              "MRISalloc(%d, %d): could not allocate faces",
              nfaces, sizeof(FACE));
  else
  {
    memset(mris->faces,0,nfaces*sizeof(FACE));
  }

  mris->useRealRAS = 0; /* just initialize */
  mris->vg.valid = 0;   /* mark invalid */

  return(mris) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISfree(MRI_SURFACE **pmris)
{
  MRI_SURFACE  *mris ;
  int          vno ;

  mris = *pmris ;
  *pmris = NULL ;

  if (mris->dx2)
  {
    free(mris->dx2) ;
  }
  if (mris->dy2)
  {
    free(mris->dy2) ;
  }
  if (mris->dz2)
  {
    free(mris->dz2) ;
  }
  if (mris->labels)
  {
    free(mris->labels) ;
  }
  if (mris->ct)
  {
    CTABfree(&mris->ct) ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    if (mris->vertices[vno].f)
    {
      free(mris->vertices[vno].f) ;
      mris->vertices[vno].f = NULL ;
    }
    if (mris->vertices[vno].n)
    {
      free(mris->vertices[vno].n) ;
      mris->vertices[vno].n = NULL ;
    }
    if (mris->vertices[vno].dist)
    {
      free(mris->vertices[vno].dist) ;
      mris->vertices[vno].dist = NULL ;
    }
    if (mris->vertices[vno].dist_orig)
    {
      free(mris->vertices[vno].dist_orig) ;
      mris->vertices[vno].dist_orig = NULL ;
    }
    if (mris->vertices[vno].v)
    {
      free(mris->vertices[vno].v) ;
      mris->vertices[vno].v = NULL ;
    }
  }

  if (mris->vertices)
  {
    free(mris->vertices) ;
  }
  if (mris->faces)
  {
    free(mris->faces) ;
  }

  if (mris->free_transform)
  {
    if (mris->SRASToTalSRAS_)
    {
      MatrixFree(&(mris->SRASToTalSRAS_));
    }
    if (mris->TalSRASToSRAS_)
    {
      MatrixFree(&(mris->TalSRASToSRAS_));
    }
    if (mris->lta)
    {
      LTAfree(&(mris->lta));
    }
  }

  {
    int i ;
    for (i = 0 ; i < mris->ncmds ; i++)
    {
      free(mris->cmdlines[i]) ;
    }
  }
  if (mris->m_sras2vox)
  {
    MatrixFree(&mris->m_sras2vox) ;
  }

  free(mris) ;
  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISfreeDists(MRI_SURFACE *mris)
{
  int          vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    if (mris->vertices[vno].dist)
    {
      free(mris->vertices[vno].dist) ;
    }
    if (mris->vertices[vno].dist_orig)
    {
      free(mris->vertices[vno].dist_orig) ;
    }
    mris->vertices[vno].dist = mris->vertices[vno].dist_orig = NULL ;
    mris->vertices[vno].vtotal = 0 ;
  }

  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  if nsize <=0 then neighborhood size gets reset back to whatever
  it's max was.
  ------------------------------------------------------*/
int
MRISresetNeighborhoodSize(MRI_SURFACE *mris, int nsize)
{
  int      vno ;
  VERTEX   *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    switch (nsize)
    {
    default:   /* reset back to original */
      switch (v->nsize)
      {
      default:
      case 1:
        v->vtotal = v->vnum ;
        break ;
      case 2:
        v->vtotal = v->v2num ;
        break ;
      case 3:
        v->vtotal = v->v3num ;
        break ;
      }
      break ;
    case 1:
      v->vtotal = v->vnum ;
      break ;
    case 2:
      v->vtotal = v->v2num ;
      break ;
    case 3:
      v->vtotal = v->v3num ;
      break ;
    }
  }
  mris->nsize = nsize ;
  return(NO_ERROR) ;
}


#define MAX_4_NEIGHBORS     100
#define MAX_3_NEIGHBORS     70
#define MAX_2_NEIGHBORS     20
#define MAX_1_NEIGHBORS     8
#define MAX_NEIGHBORS       (10000)
static int
mrisFindNeighbors(MRI_SURFACE *mris)
{
  int          n0,n1,i,k,m,n, vno, vtotal, ntotal, vtmp[MAX_NEIGHBORS] ;
  FACE         *f;
  VERTEX       *v ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "finding surface neighbors...") ;
  }

  for (k=0; k<mris->nvertices; k++)
  {
    if (k == Gdiag_no)
    {
      DiagBreak() ;
    }
    v = &mris->vertices[k];
    v->vnum = 0;
    for (m=0; m<v->num; m++)
    {
      n = v->n[m];     /* # of this vertex in the mth face that it is in */
      f = &mris->faces[v->f[m]];  /* ptr to the mth face */
      /* index of vertex we are connected to */
      n0 = (n == 0)                   ? VERTICES_PER_FACE-1 : n-1;
      n1 = (n == VERTICES_PER_FACE-1) ? 0                   : n+1;
      for (i=0; i<v->vnum && vtmp[i]!=f->v[n0]; i++)
      {
        ;
      }
      if (i==v->vnum)
      {
        vtmp[(int)v->vnum++] = f->v[n0];
      }
      for (i=0; i<v->vnum && vtmp[i]!=f->v[n1]; i++)
      {
        ;
      }
      if (i==v->vnum)
      {
        vtmp[(int)v->vnum++] = f->v[n1];
      }
    }
    if (mris->vertices[k].v)
    {
      free(mris->vertices[k].v) ;
    }
    mris->vertices[k].v = (int *)calloc(mris->vertices[k].vnum,sizeof(int));
    if (!mris->vertices[k].v)
      ErrorExit(ERROR_NOMEMORY,
                "mrisFindNeighbors: could not allocate nbr array") ;

    v->vtotal = v->vnum ;
    v->nsize = 1 ;
    for (i=0; i<v->vnum; i++)
    {
      v->v[i] = vtmp[i];
    }

    if (v->dist)
    {
      free(v->dist) ;
    }
    if (v->dist_orig)
    {
      free(v->dist_orig) ;
    }

    v->dist = (float *)calloc(v->vnum, sizeof(float)) ;
    if (!v->dist)
      ErrorExit(ERROR_NOMEMORY,
                "mrisFindNeighbors: could not allocate list of %d "
                "dists at v=%d", v->vnum, k) ;
    v->dist_orig = (float *)calloc(v->vnum, sizeof(float)) ;
    if (!v->dist_orig)
      ErrorExit(ERROR_NOMEMORY,
                "mrisFindNeighbors: could not allocate list of %d "
                "dists at v=%d", v->vnum, k) ;
    /*
      if (v->num != v->vnum)
      printf("%d: num=%d vnum=%d\n",k,v->num,v->vnum);
    */
  }
  for (k=0; k<mris->nfaces; k++)
  {
    f = &mris->faces[k];
    for (m=0; m<VERTICES_PER_FACE; m++)
    {
      v = &mris->vertices[f->v[m]];
      for (i=0; i<v->num && k!=v->f[i]; i++)
      {
        ;
      }
      if (i==v->num)   /* face has vertex, but vertex doesn't have face */
        ErrorExit(ERROR_BADPARM,
                  "mrisFindNeighbors: %s: face[%d].v[%d] = %d, "
                  "but face %d not in vertex %d "
                  "face list\n", mris->fname,k,m,f->v[m], k, f->v[m]);
    }
  }

  for (vno = ntotal = vtotal = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    vtotal += v->vtotal ;
    ntotal++ ;
  }

  mris->avg_nbrs = (float)vtotal / (float)ntotal ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISsampleAtEachDistance(MRI_SURFACE *mris,int nbhd_size,int nbrs_per_distance)
{
  int  n, nbrs_array[MAX_NBHD_SIZE] ;

  if (!nbhd_size)
  {
    return(NO_ERROR) ;
  }

  if (Gdiag & (DIAG_HEARTBEAT | DIAG_SHOW))
  {
    fprintf(stdout, "sampling long-range distances") ;
  }
  for (n = 0 ; n <= nbhd_size ; n++)
  {
    nbrs_array[n] = nbrs_per_distance ;
  }
  return(MRISsampleDistances(mris, nbrs_array, nbhd_size)) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Expand the list of neighbors of each vertex, reallocating
  the v->v array to hold the expanded list.
  ------------------------------------------------------*/
#define MAX_VERTICES  20000
#define MAX_V         1000  /* max for any one node, actually way too big */
#define TRIANGLE_DISTANCE_CORRECTION  1.09f /*1.1f*/
/*1.066f*/ /*1.12578*/ /* 1.13105f*/ /*1.1501f  (1.1364f)*/
#define QUADRANGLE_DISTANCE_CORRECTION  ((1+sqrt(2)) / 2) /* 1.2071  */
int
MRISsampleDistances(MRI_SURFACE *mris, int *nbrs, int max_nbhd)
{
  int          i,n, vno, vnum, old_vnum, total_nbrs, max_possible,max_v,vtotal;
  VERTEX       *v, *vn, *vn2 ;
  int          *vnbrs, *vall, *vnb,found, n2, vnbrs_num,
               vall_num, nbhd_size,done, checks = 0 ;
  float        xd, yd, zd, min_dist, dist, dist_scale, old_dist[MAX_V];
  float        old_v[MAX_V], min_angle, angle ;
  VECTOR       *v1, *v2 ;
  float        c[100] ;
  int          nc[100] ;
  int          diag_vno1, diag_vno2 ;
  char         *cp ;

  if ((cp = getenv("VDIAG1")) != NULL)
  {
    diag_vno1 = atoi(cp) ;
  }
  else
  {
    diag_vno1 = -1 ;
  }
  if ((cp = getenv("VDIAG2")) != NULL)
  {
    diag_vno2 = atoi(cp) ;
  }
  else
  {
    diag_vno2 = -1 ;
  }
  if (diag_vno1 >= 0)
  {
    printf("\nlooking for vertex pair %d, %d\n", diag_vno1, diag_vno2) ;
  }

  memset(c, 0, 100*sizeof(float)) ;
  memset(nc, 0, 100*sizeof(int)) ;
  v1 = VectorAlloc(3, MATRIX_REAL) ;
  v2 = VectorAlloc(3, MATRIX_REAL) ;

  /* adjust for Manhattan distance */
  if (IS_QUADRANGULAR(mris))
  {
    dist_scale = (1.0 + sqrt(2.0)) / 2.0f ;
  }
  else
  {
    dist_scale = TRIANGLE_DISTANCE_CORRECTION ;
  }

  vnbrs = (int *)calloc(MAX_VERTICES, sizeof(int)) ;
  vall = (int *)calloc(MAX_VERTICES, sizeof(int)) ;
  vnb = (int *)calloc(MAX_VERTICES, sizeof(int)) ;
  vtotal = total_nbrs = 0 ;
  for (vtotal = max_possible = 0, n = 1 ; n <= max_nbhd ; n++)
  {
    max_possible += nbrs[n] ;
    if (n > mris->nsize)
    {
      vtotal += nbrs[n] ;
    }
  }
  if (Gdiag & DIAG_HEARTBEAT)
    fprintf(stdout,
            "\nsampling %d dists/vertex (%2.1f at each dist) = %2.1fMB\n",
            vtotal,
            (float)vtotal/((float)max_nbhd-(float)mris->nsize),
            (float)vtotal*MRISvalidVertices(mris)*sizeof(float)*3.0f /
            (1024.0f*1024.0f)) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    if ((Gdiag & DIAG_HEARTBEAT) && (!(vno % (mris->nvertices/10))))
      fprintf(stdout, "%%%1.0f done\n",
              100.0f*(float)vno / (float)mris->nvertices) ;
    if ((vno > 139000 || (!(vno % 100))) && 0)
    {
      if (checks++ == 0)
      {
        printf("checking surface at vno %d\n", vno) ;
      }
      if (mrisCheckSurfaceNbrs(mris) != 1)
      {
        printf("surface bad at vertex %d!\n", vno) ;
        DiagBreak() ;
      }
    }
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak()  ;
    }

    if (v->ripflag)
    {
      continue ;
    }

    /* small neighborhood is always fixed, don't overwrite them */
    vtotal = v->vtotal ;
    if (v->nsize == 3)
    {
      v->vtotal = v->v3num ;
    }
    else if (v->nsize == 2)
    {
      v->vtotal = v->v2num ;
    }
    else
    {
      v->vtotal = v->vnum ;
    }

    max_v = v->vtotal+max_possible ;
    if (vtotal < max_v)  /* won't fit in current allocation,
                          reallocate stuff */
    {
      /* save and restore neighbor list */
      memmove(old_v, v->v, v->vtotal*sizeof(v->v[0])) ;
      free(v->v) ;
      v->v = (int *)calloc(max_v, sizeof(int)) ;
      if (!v->v)
        ErrorExit(ERROR_NO_MEMORY,
                  "MRISsampleDistances: could not allocate list of %d "
                  "nbrs at v=%d", max_v, vno) ;
      memmove(v->v, old_v, v->vtotal*sizeof(v->v[0])) ;

      /* save and restore distance vector */
      memmove(old_dist, v->dist, v->vtotal*sizeof(v->dist[0])) ;
      free(v->dist) ;
      v->dist = (float *)calloc(max_v, sizeof(float)) ;
      if (!v->dist)
        ErrorExit(ERROR_NOMEMORY,
                  "MRISsampleDistances: could not allocate list of %d "
                  "dists at v=%d", max_v, vno) ;
      memmove(v->dist, old_dist, v->vtotal*sizeof(v->dist[0])) ;

      /* save and restore original distance vector */
      memmove(old_dist, v->dist_orig, v->vtotal*sizeof(v->dist_orig[0])) ;
      free(v->dist_orig) ;
      v->dist_orig = (float *)calloc(max_v, sizeof(float)) ;
      if (!v->dist_orig)
        ErrorExit(ERROR_NOMEMORY,
                  "MRISsampleDistances: could not allocate list of %d "
                  "dists at v=%d", max_v, vno) ;
      memmove(v->dist_orig, old_dist, v->vtotal*sizeof(v->dist_orig[0])) ;
    }

    if ((vno > 139000 || !(vno % 100)) && 0)
    {
      if (checks++ == 0)
      {
        printf("checking surface at vno %d\n", vno) ;
      }
      if (mrisCheckSurfaceNbrs(mris) != 1)
      {
        printf("surface bad at vertex %d!\n", vno) ;
        DiagBreak() ;
      }
    }
    /*
     find all the neighbors at each extent (i.e. 1-neighbors, then
     2-neighbors, etc..., marking their corrected edge-length distances
     as you go.
    */
    vall[0] = vno ;
    vall_num = 1 ;
    old_vnum = 0 ;
    v->marked = 1 ;  /* a hack - it is a zero neighbor */
    for (nbhd_size = 1 ; vall_num < MAX_VERTICES && nbhd_size <= max_nbhd ;
         nbhd_size++)
    {
      /* expand neighborhood outward by a ring of vertices */
      vnbrs_num = 0 ;  /* will count neighbors in this ring */
      vnum = vall_num ;
      for (found = 0, n = old_vnum;
           vall_num<MAX_VERTICES && n < vall_num;
           n++)
      {
        vn = &mris->vertices[vall[n]] ;
        if (vn->ripflag)
        {
          continue ;
        }

        /* search through vn's neighbors to find an unmarked vertex */
        for (n2 = 0 ; n2 < vn->vnum ; n2++)
        {
          vn2 = &mris->vertices[vn->v[n2]] ;
          if (vn2->ripflag || vn2->marked)
          {
            continue ;
          }

          /* found one, mark it and put it in the vall list */
          found++ ;
          vn2->marked = nbhd_size ;
          vnb[vnum] = vall[n];
          vall[vnum++] = vn->v[n2] ;
          if (nbrs[nbhd_size] > 0)  /* want to store this distance */
          {
            vnbrs[vnbrs_num++] = vn->v[n2] ;
          }
        }
      }  /* done with all neighbors at previous distance */

      /* found all neighbors at this extent - calculate distances */
      old_vnum = vall_num ;  /* old_vnum is index of 1st
                            nbr at this distance*/
      vall_num += found ;    /* vall_num is total # of nbrs */
      for (n = old_vnum ; n < vall_num ; n++)
      {
        vn = &mris->vertices[vall[n]] ;
        if (vn->ripflag)
        {
          continue ;
        }
#define UNFOUND_DIST 1000000.0f
        for (min_dist = UNFOUND_DIST, n2 = 0 ; n2 < vn->vnum ; n2++)
        {
          vn2 = &mris->vertices[vn->v[n2]] ;
          if (vn2->ripflag)
          {
            continue ;
          }
          if (!vn2->marked || vn2->marked == nbhd_size)
          {
            continue ;
          }
          xd = vn2->x - vn->x ;
          yd = vn2->y - vn->y ;
          zd = vn2->z - vn->z ;
          dist = sqrt(xd*xd + yd*yd + zd*zd) ;
#if !MULTI_DIST_SCALING
          if (nbhd_size > 1)
          {
            dist /= dist_scale ;
          }
          if (vn2->d+dist < min_dist)
          {
            min_dist = vn2->d+dist ;
          }
#else
          dist =
            (dist + vn2->d * distance_scale[vn2->marked]) /
            distance_scale[vn2->marked+1] ;
          if (dist < min_dist)
          {
            min_dist = dist ;
          }
#endif
        }
        vn->d = min_dist  ;
        if (nbhd_size <= 2)
        {
          xd = vn->x - v->x ;
          yd = vn->y - v->y ;
          zd = vn->z - v->z ;
          dist = sqrt(xd*xd + yd*yd + zd*zd) ;
          vn->d = dist ;
        }
        if (vn->d >= UNFOUND_DIST/2)
        {
          printf("***** WARNING - surface distance not found at "
                 "vno %d, vall[%d] = %d (vnb[%d] = %d ******",
                 vno, n, vall[n], n, vnb[n]) ;
          mrisCheckSurfaceNbrs(mris) ;
          DiagBreak() ;
          exit(1) ;
        }
        if ((vall[n] == diag_vno1 && vno == diag_vno2) ||
            (vall[n] == diag_vno2 && vno == diag_vno1))
          printf("vn %d is %2.3f mm from v %d at ring %d\n",
                 vall[n], vn->d, vno, nbhd_size) ;
      }

      /*
       now check each to see if a neighbor at the same 'distance'
       is actually closer than neighbors which are 'nearer' (i.e. maybe
       the path through a 3-neighbor is shorter than that through any
       of the 2-neighbors.
      */
      for (n = old_vnum ; n < vall_num ; n++)
      {
        vn = &mris->vertices[vall[n]] ;
        if (vn->ripflag)
        {
          continue ;
        }
        min_dist = vn->d ;
        for (n2 = 0 ; n2 < vn->vnum ; n2++)
        {
          vn2 = &mris->vertices[vn->v[n2]] ;
          if (!vn2->marked || vn2->marked != nbhd_size || vn2->ripflag)
          {
            continue ;
          }
          xd = vn2->x - vn->x ;
          yd = vn2->y - vn->y ;
          zd = vn2->z - vn->z ;
          dist = sqrt(xd*xd + yd*yd + zd*zd) ;
#if !MULTI_DIST_SCALING
          if (nbhd_size > 1)
          {
            dist /= dist_scale ;
          }
          if (vn2->d+dist < min_dist)
          {
            min_dist = vn2->d + dist ;
          }
#else
          dist =
            (dist + vn2->d * distance_scale[vn2->marked]) /
            distance_scale[vn2->marked+1] ;
          if (dist < min_dist)
          {
            min_dist = dist ;
          }
#endif
        }
        vn->d = min_dist ;
        if ((min_dist > 5*nbhd_size) || min_dist > 60)
        {
          DiagBreak() ;
        }
        {
          xd = vn->x - v->x ;
          yd = vn->y - v->y ;
          zd = vn->z - v->z ;
          dist = sqrt(xd*xd + yd*yd + zd*zd) ;
          c[nbhd_size] += vn->d / dist ;
          nc[nbhd_size]++ ;
        }
      }

      /* if this set of neighbors are to be stored, sample from them */
      if (nbrs[nbhd_size] <= 0)
      {
        continue ;
      }

      /* make sure the points are not too close together */
      min_angle = 0.9*2.0*M_PI / (float)nbrs[nbhd_size] ;

      /*
       at this point, the vall list contains all the
       neighbors currently found
       at ALL distances, while the vnbrs list contains ONLY the
       nbhd_size-neighbors.
      */
      if (found <= nbrs[nbhd_size])  /* just copy them all in */
      {
        for (n = 0 ; n < found ; n++, v->vtotal++)
        {
          v->v[v->vtotal] = vnbrs[n] ;
          v->dist_orig[v->vtotal] = mris->vertices[vnbrs[n]].d ;
          if (v->dist_orig[v->vtotal] > 60)
          {
            DiagBreak() ;
          }
        }
      }
      else                   /* randomly sample from them */
      {
        int vstart = v->vtotal ;
        for (n = 0 ; n < nbrs[nbhd_size] ; n++, v->vtotal++)
        {
          int j, niter = 0 ;
          do
          {
            do
            {
              i = nint(randomNumber(0.0, (double)found-1)) ;
            }
            while (vnbrs[i] < 0) ;
            /*
             now check to make sure that the angle between this
             point and the others already selected is not too
             small to make sure the points are not bunched.
            */
            vn = &mris->vertices[vnbrs[i]] ;
            VECTOR_LOAD(v1, vn->x-v->x, vn->y-v->y, vn->z-v->z) ;
            done = 1 ;
            for (j = vstart ; done && j < v->vtotal ; j++)
            {
              vn2 = &mris->vertices[v->v[j]] ;
              VECTOR_LOAD(v2,
                          vn2->x-v->x, vn2->y-v->y, vn2->z-v->z) ;
              angle = Vector3Angle(v1, v2) ;
              if (angle < min_angle)
              {
                done = 0 ;
              }
            }
            if (++niter > found)  /* couldn't find enough at this difference */
            {
              min_angle *= 0.75f ;  /* be more liberal */
              niter = 0 ;
            }
          }
          while (!done && !FZERO(min_angle)) ;
          vn = &mris->vertices[vnbrs[i]] ;
          v->v[v->vtotal] = vnbrs[i] ;
          v->dist_orig[v->vtotal] = vn->d ;
          if (v->dist_orig[v->vtotal] > 60)
          {
            DiagBreak() ;
          }
          if (FZERO(vn->d))
          {
            DiagBreak() ;
          }
          vnbrs[i] = -1 ;
        }
      }
    }

    if ((vno > 9.0*mris->nvertices/10.0) && 0)
    {
      if (checks++ == 0)
      {
        printf("checking surface at vno %d\n", vno) ;
      }
      if (mrisCheckSurfaceNbrs(mris) != 1)
      {
        printf("surface bad at vertex %d!\n", vno) ;
        DiagBreak() ;
      }
    }

    if ((Gdiag_no == vno) && DIAG_VERBOSE_ON)
    {
      FILE  *fp ;
      char  fname[STRLEN] ;

      sprintf(fname, "v%d", vno) ;
      fp = fopen(fname, "w") ;
      fprintf(fp, "%d\n", vall_num) ;
      for (n = 0 ; n < vall_num ; n++)
      {
        fprintf(fp, "%d\n", vall[n]) ;
      }
      fclose(fp) ;

      sprintf(fname, "vn%d", vno) ;
      fp = fopen(fname, "w") ;
      fprintf(fp, "%d\n", v->vtotal) ;
      for (n = 0 ; n < v->vtotal ; n++)
      {
        fprintf(fp, "%d\n", v->v[n]) ;
      }
      fclose(fp) ;
      for (n = 0 ; n < mris->nvertices ; n++)
      {
        vn = &mris->vertices[n] ;
#if 0
        if (vn->ripflag)
        {
          continue ;
        }
#endif
        vn->curv = vn->d ;
      }
      sprintf(fname, "%s.dist",
              mris->hemisphere == LEFT_HEMISPHERE?"lh":"rh");
      MRISwriteCurvature(mris, fname) ;
    }

    /*
     done building arrays - allocate distance vectors and
     sample from the found neighbors list.
    */
    /* now unmark them all */
    for (n = 0 ; n < vall_num ; n++)
    {
      mris->vertices[vall[n]].marked = 0 ;
      mris->vertices[vall[n]].d = 0.0 ;
    }

    total_nbrs += v->vtotal ;
  }

  /* now fill in immediate neighborhood(Euclidean) distances */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak()  ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    if (v->nsize == 3)
    {
      vtotal = v->v3num ;
    }
    else if (v->nsize == 2)
    {
      vtotal = v->v2num ;
    }
    else
    {
      vtotal = v->vnum ;
    }
    for (n = 0 ; n < vtotal ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      xd = v->x - vn->x ;
      yd = v->y - vn->y ;
      zd = v->z - vn->z ;
      v->dist_orig[n] = sqrt(xd*xd+yd*yd+zd*zd) ;
    }
  }

  // make sure distances are symmetric
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (n = 0 ; n < v->vtotal ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      for (i = 0 ; i < vn->vtotal ; i++)
      {
        if (vn->v[i] == vno) // distance in both lists - make it the average
        {
          double dist ;
          dist = (vn->dist_orig[i] + v->dist_orig[n]) / 2 ;
          vn->dist_orig[i] = dist ;
          v->dist_orig[n] = dist ;
          break ;
        }
      }
    }
  }

  /* check reasonableness of distances */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    for (n = 0 ; n < v->vtotal ; n++)
    {
      if (DZERO(v->dist_orig[n]))
        fprintf(stderr, "zero distance at v %d, n %d (vn = %d)\n",
                vno, n, v->v[n]) ;
    }
  }

  if (Gdiag_no >= 0)
  {
    FILE *fp ;
    char fname[STRLEN] ;
    VERTEX *v ;
    int    i ;

    sprintf(fname, "v%d.log", Gdiag_no) ;
    fp = fopen(fname, "w") ;
    v = &mris->vertices[Gdiag_no] ;
    for (i = 0 ; i < v->vtotal ; i++)
    {
      fprintf(fp, "%d: %d, %f\n", i, v->v[i], v->dist_orig[i]) ;
    }
    fclose(fp) ;
  }

  mris->avg_nbrs = (float)total_nbrs / (float)MRISvalidVertices(mris) ;
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "avg_nbrs = %2.1f\n", mris->avg_nbrs) ;
  }

#if MULTI_DIST_SCALING
  if (Gdiag & DIAG_SHOW)
  {
    for (n = 0 ; n <= max_nbhd ; n++)
    {
      if (nc[n])
      {
        c[n] /= (float)nc[n] ;
      }
      fprintf(stdout, "c[%d] = %2.5f (%d samples)\n", n, c[n], nc[n]) ;
    }
    fprintf(stdout, "c[] = { ") ;
    for (n = 0 ; n <= max_nbhd ; n++)
    {
      fprintf(stdout, "%2.5f", c[n]) ;
      if (n < max_nbhd)
      {
        fprintf(stdout, ", ") ;
      }
    }
  }
#endif
  free(vnbrs) ;
  free(vall) ;
  free(vnb) ;
  VectorFree(&v1) ;
  VectorFree(&v2) ;
  if (Gdiag & DIAG_HEARTBEAT)
  {
    fprintf(stdout, " done.\n") ;
  }
  return(NO_ERROR) ;
}

#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Expand the list of neighbors of each vertex, reallocating
  the v->v array to hold the expanded list.
  ------------------------------------------------------*/
#define MAX_VERTICES  20000
#define MAX_V         1000  /* max for any one node, actually way too big */
int
MRISsampleDistances(MRI_SURFACE *mris, int *nbrs, int max_nbhd)
{
  int          i,n, vno, vnum, old_vnum, total_nbrs, max_possible,max_v,vtotal;
  VERTEX       *v, *vn, *vn2 ;
  int          *vnbrs, *vall, found, n2, vnbrs_num, vall_num, nbhd_size,done ;
  float        xd, yd, zd, min_dist, dist, dist_scale, old_dist[MAX_V],
               old_v[MAX_V], min_angle, angle ;
  VECTOR       *v1, *v2 ;

  printf("Starting MRISsampleDistances %d ------ ()\n",max_nbhd);
  for (i = 0; i < max_nbhd ; i++)
  {
    printf("%d %d\n",i,nbrs[i]);
  }
  printf("randSeed %ld",getRandSeed());

  v1 = VectorAlloc(3, MATRIX_REAL) ;
  v2 = VectorAlloc(3, MATRIX_REAL) ;

  dist_scale = (1.0 + sqrt(2.0)) / 2 ;  /* adjust for Manhattan distance */
  vnbrs = (int *)calloc(MAX_VERTICES, sizeof(int)) ;
  vall = (int *)calloc(MAX_VERTICES, sizeof(int)) ;
  total_nbrs = 0 ;
  for (vtotal = max_possible = 0, n = 1 ; n <= max_nbhd ; n++)
  {
    max_possible += nbrs[n] ;
    if (n > mris->nsize)
    {
      vtotal += nbrs[n] ;
    }
  }

  if (Gdiag & DIAG_HEARTBEAT)
    fprintf(stdout,
            "\nsampling %d dists/vertex (%2.1f at each dist) = %2.1fMB\n",
            vtotal,
            (float)vtotal/((float)max_nbhd-(float)mris->nsize),
            (float)vtotal*mris->nvertices*sizeof(float)*3.0f /
            (1024.0f*1024.0f)) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    if ((Gdiag & DIAG_HEARTBEAT) && (!(vno % (mris->nvertices/25))))
      fprintf(stdout, " %%%1.0f",
              100.0f*(float)vno / (float)mris->nvertices) ;
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak()  ;
    }

    if (v->ripflag)
    {
      continue ;
    }

    /* small neighborhood is always fixed, don't overwrite them */
    vtotal = v->vtotal ;
    if (v->nsize == 3)
    {
      v->vtotal = v->v3num ;
    }
    else if (v->nsize == 2)
    {
      v->vtotal = v->v2num ;
    }
    else
    {
      v->vtotal = v->vnum ;
    }

    max_v = v->vtotal+max_possible ;
    if (vtotal < max_v) /* won't fit in current allocation,
                                         reallocate stuff */
    {
      /* save and restore neighbor list */
      memmove(old_v, v->v, v->vtotal*sizeof(v->v[0])) ;
      free(v->v) ;
      v->v = (int *)calloc(max_v, sizeof(int)) ;
      if (!v->v)
        ErrorExit(ERROR_NO_MEMORY,
                  "MRISsampleDistances: could not allocate list of %d "
                  "nbrs at v=%d", max_v, vno) ;
      memmove(v->v, old_v, v->vtotal*sizeof(v->v[0])) ;

      /* save and restore distance vector */
      memmove(old_dist, v->dist, v->vtotal*sizeof(v->dist[0])) ;
      free(v->dist) ;
      v->dist = (float *)calloc(max_v, sizeof(float)) ;
      if (!v->dist)
        ErrorExit(ERROR_NOMEMORY,
                  "MRISsampleDistances: could not allocate list of %d "
                  "dists at v=%d", max_v, vno) ;
      memmove(v->dist, old_dist, v->vtotal*sizeof(v->dist[0])) ;

      /* save and restore original distance vector */
      memmove(old_dist, v->dist_orig, v->vtotal*sizeof(v->dist_orig[0])) ;
      free(v->dist_orig) ;
      v->dist_orig = (float *)calloc(max_v, sizeof(float)) ;
      if (!v->dist_orig)
        ErrorExit(ERROR_NOMEMORY,
                  "MRISsampleDistances: could not allocate list of %d "
                  "dists at v=%d", max_v, vno) ;
      memmove(v->dist_orig, old_dist, v->vtotal*sizeof(v->dist_orig[0])) ;
    }

    vall[0] = vno ;
    vall_num = 1 ;
    old_vnum = 0 ;
    v->marked = 1 ;  /* a hack - it is a zero neighbor */
    for (nbhd_size = 1 ; vall_num < MAX_VERTICES && nbhd_size <= max_nbhd ;
         nbhd_size++)
    {
      /* expand neighborhood outward by a ring of vertices */
      vnbrs_num = 0 ;  /* will count neighbors in this ring */
      vnum = vall_num ;
      for (found = 0, n = old_vnum;
           vall_num<MAX_VERTICES && n < vall_num;
           n++)
      {
        vn = &mris->vertices[vall[n]] ;
        if (vn->ripflag)
        {
          continue ;
        }

        /* search through vn's neighbors to find an unmarked vertex */
        for (n2 = 0 ; n2 < vn->vnum ; n2++)
        {
          vn2 = &mris->vertices[vn->v[n2]] ;
          if (vn2->ripflag || vn2->marked)
          {
            continue ;
          }

          /* found one, mark it and put it in the vall list */
          found++ ;
          vn2->marked = nbhd_size ;
          vall[vnum++] = vn->v[n2] ;
          if (nbrs[nbhd_size] > 0)  /* want to store this distance */
          {
            vnbrs[vnbrs_num++] = vn->v[n2] ;
          }
        }
      }  /* done with all neighbors at previous distance */

      /* found all neighbors at this extent - calculate distances */
      old_vnum = vall_num ;
      vall_num += found ;
      for (n = old_vnum ; n < vall_num ; n++)
      {
        vn = &mris->vertices[vall[n]] ;
        for (min_dist = 10000.0, n2 = 0 ; n2 < vn->vnum ; n2++)
        {
          vn2 = &mris->vertices[vn->v[n2]] ;
          if (!vn2->marked)
          {
            continue ;
          }
          xd = vn2->x - vn->x ;
          yd = vn2->y - vn->y ;
          zd = vn2->z - vn->z ;
          dist = sqrt(xd*xd + yd*yd + zd*zd) ;
          if (nbhd_size > 1)
          {
            dist /= dist_scale ;
          }
          if (vn2->d + dist < min_dist)
          {
            min_dist = vn2->d + dist ;
          }
        }
        vn->d = min_dist  ;
        if (nbhd_size <= 2)
        {
          xd = vn->x - v->x ;
          yd = vn->y - v->y ;
          zd = vn->z - v->z ;
          dist = sqrt(xd*xd + yd*yd + zd*zd) ;
          vn->d = dist ;
        }
      }

      /* if this set of neighbors are to be stored, sample from them */
      if (nbrs[nbhd_size] <= 0)
      {
        continue ;
      }

      /* make sure the points are not too close together */
      min_angle = 0.9*2.0*M_PI / (float)nbrs[nbhd_size] ;

      /*
        at this point, the vall list contains all
        the neighbors currently found
        at ALL distances, while the vnbrs list contains ONLY the
        nbhd_size-neighbors.
      */
      if (found <= nbrs[nbhd_size])  /* just copy them all in */
      {
        for (n = 0 ; n < found ; n++, v->vtotal++)
        {
          v->v[v->vtotal] = vnbrs[n] ;
          v->dist_orig[v->vtotal] = mris->vertices[vnbrs[n]].d ;
        }
      }
      else                   /* randomly sample from them */
      {
        int vstart = v->vtotal ;
        for (n = 0 ; n < nbrs[nbhd_size] ; n++, v->vtotal++)
        {
          int j, niter = 0 ;
          do
          {
            do
            {
              i = nint(randomNumber(0.0, (double)found-1)) ;
            }
            while (vnbrs[i] < 0) ;
            /*
              now check to make sure that the angle between this
              point and the others already selected is not too
              small to make sure the points are not bunched.
            */
            vn = &mris->vertices[vnbrs[i]] ;
            VECTOR_LOAD(v1, vn->x-v->x, vn->y-v->y, vn->z-v->z) ;
            done = 1 ;
            for (j = vstart ; done && j < v->vtotal ; j++)
            {
              vn2 = &mris->vertices[v->v[j]] ;
              VECTOR_LOAD(v2,
                          vn2->x-v->x, vn2->y-v->y, vn2->z-v->z) ;
              angle = Vector3Angle(v1, v2) ;
              if (angle < min_angle)
              {
                done = 0 ;
              }
            }
            if (++niter > found)  /* couldn't find
                                     enough at this difference */
            {
              min_angle *= 0.75f ;  /* be more liberal */
              niter = 0 ;
            }
          }
          while (!done && !FZERO(min_angle)) ;
          vn = &mris->vertices[vnbrs[i]] ;
          v->v[v->vtotal] = vnbrs[i] ;
          v->dist_orig[v->vtotal] = vn->d ;
          vnbrs[i] = -1 ;
        }
      }
    }


    if ((Gdiag_no == vno) && DIAG_VERBOSE_ON)
    {
      FILE  *fp ;
      char  fname[STRLEN] ;

      sprintf(fname, "v%d", vno) ;
      fp = fopen(fname, "w") ;
      fprintf(fp, "%d\n", vall_num) ;
      for (n = 0 ; n < vall_num ; n++)
      {
        fprintf(fp, "%d\n", vall[n]) ;
      }
      fclose(fp) ;

      sprintf(fname, "vn%d", vno) ;
      fp = fopen(fname, "w") ;
      fprintf(fp, "%d\n", v->vtotal) ;
      for (n = 0 ; n < v->vtotal ; n++)
      {
        fprintf(fp, "%d\n", v->v[n]) ;
      }
      fclose(fp) ;
      for (n = 0 ; n < mris->nvertices ; n++)
      {
        vn = &mris->vertices[n] ;
#if 0
        if (vn->ripflag)
        {
          continue ;
        }
#endif
        vn->curv = vn->d ;
      }
      sprintf(fname, "%s.dist",
              mris->hemisphere == LEFT_HEMISPHERE?"lh":"rh");
      MRISwriteCurvature(mris, fname) ;
    }

    /*
      done building arrays - allocate distance vectors and
      sample from the found neighbors list.
    */
    /* now unmark them all */
    for (n = 0 ; n < vall_num ; n++)
    {
      mris->vertices[vall[n]].marked = 0 ;
      mris->vertices[vall[n]].d = 0.0 ;
    }

    total_nbrs += v->vtotal ;
  }

  /* now fill in immediate neighborhood(Euclidean) distances */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak()  ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    if (v->nsize == 3)
    {
      vtotal = v->v3num ;
    }
    else if (v->nsize == 2)
    {
      vtotal = v->v2num ;
    }
    else
    {
      vtotal = v->vnum ;
    }
    for (n = 0 ; n < vtotal ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      xd = v->x - vn->x ;
      yd = v->y - vn->y ;
      zd = v->z - vn->z ;
      v->dist_orig[n] = sqrt(xd*xd+yd*yd+zd*zd) ;
    }
  }

  mris->avg_nbrs = (float)total_nbrs / (float)MRISvalidVertices(mris) ;
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "avg_nbrs = %2.1f\n", mris->avg_nbrs) ;
  }

  free(vnbrs) ;
  free(vall) ;
  VectorFree(&v1) ;
  VectorFree(&v2) ;
  if (Gdiag & DIAG_HEARTBEAT)
  {
    fprintf(stdout, " done.\n") ;
  }
  printf("randSeed %ld",getRandSeed());
  printf("MRISsampleDistances(): done\n");

  return(NO_ERROR) ;
}
#endif

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Expand the list of neighbors of each vertex, reallocating
  the v->v array to hold the expanded list.
  ------------------------------------------------------*/
int
MRISsetNeighborhoodSize(MRI_SURFACE *mris, int nsize)
{
  int          i,n, vno, neighbors, j, vnum, niter, nb_vnum ;
  VERTEX       *v, *vnb, *vnb2 ;
  int          vtmp[MAX_NEIGHBORS], vtotal, ntotal ;

  /*
    now build a list of 2-connected neighbors. After this is done,
    reallocate the v->n list and arrange the 2-connected neighbors
    sequentially after it.
  */
  for (niter = 0 ; niter < nsize-mris->nsize ; niter++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (vno == Gdiag_no)
      {
        DiagBreak()  ;
      }
      if (v->nsize >= nsize)
      {
        continue ;
      }
      vnum = v->vtotal ;
      if (v->ripflag || !vnum)
      {
        continue ;
      }
      memmove(vtmp, v->v, vnum*sizeof(int)) ;

      /* mark 1-neighbors so we don't count them twice */
      v->marked = 1 ;
      for (i = 0 ; i < vnum; i++)
      {
        mris->vertices[v->v[i]].marked = 1 ;
      }

      /* count 2-neighbors */
      for (neighbors = vnum, i = 0;
           neighbors < MAX_NEIGHBORS && i < vnum;
           i++)
      {
        n = v->v[i] ;
        vnb = &mris->vertices[n] ;
        vnb->marked = 1 ;
        if (vnb->ripflag)
        {
          continue ;
        }

        nb_vnum = vnb->vnum ;

        for (j = 0 ; j < nb_vnum ; j++)
        {
          vnb2 = &mris->vertices[vnb->v[j]] ;
          if (vnb2->ripflag || vnb2->marked)
          {
            continue ;
          }
          vtmp[neighbors] = vnb->v[j] ;
          vnb2->marked = 1 ;
          if (++neighbors >= MAX_NEIGHBORS)
          {
            fprintf(stderr,
                    "vertex %d has too many neighbors!\n",vno) ;
            break ;
          }
        }
      }
      /*
        now reallocate the v->v structure and
        place the 2-connected neighbors
        suquentially after the 1-connected neighbors.
      */
      free(v->v) ;
      v->v = (int *)calloc(neighbors, sizeof(int)) ;
      if (!v->v)
        ErrorExit(ERROR_NO_MEMORY,
                  "MRISsetNeighborhoodSize: could not allocate list of %d "
                  "nbrs at v=%d", neighbors, vno) ;

      v->marked = 0 ;
      for (n = 0 ; n < neighbors ; n++)
      {
        v->v[n] = vtmp[n] ;
        mris->vertices[vtmp[n]].marked = 0 ;
      }
      if (v->dist)
      {
        free(v->dist) ;
      }
      if (v->dist_orig)
      {
        free(v->dist_orig) ;
      }

      v->dist = (float *)calloc(neighbors, sizeof(float)) ;
      if (!v->dist)
        ErrorExit(ERROR_NOMEMORY,
                  "MRISsetNeighborhoodSize: could not allocate list of %d "
                  "dists at v=%d", neighbors, vno) ;
      v->dist_orig = (float *)calloc(neighbors, sizeof(float)) ;
      if (!v->dist_orig)
        ErrorExit(ERROR_NOMEMORY,
                  "MRISsetNeighborhoodSize: could not allocate list of %d "
                  "dists at v=%d", neighbors, vno) ;
      v->nsize++ ;
      switch (v->nsize)
      {
      case 2:
        v->v2num = neighbors ;
        break ;
      case 3:
        v->v3num = neighbors ;
        break ;
      default:   /* store old neighborhood size in v3num */
        v->v3num = v->vtotal ;
        break ;
      }
      v->vtotal = neighbors ;
      for (n = 0 ; n < neighbors ; n++)
        for (i = 0 ; i < neighbors ; i++)
          if (i != n && v->v[i] == v->v[n])
            fprintf
            (stderr,
             "warning: vertex %d has duplicate neighbors %d and %d!\n",
             vno, i, n) ;
      if ((vno == Gdiag_no) && (Gdiag & DIAG_SHOW) && DIAG_VERBOSE_ON)
      {
        fprintf(stdout, "v %d: vnum=%d, v2num=%d, vtotal=%d\n",
                vno, v->vnum, v->v2num, v->vtotal) ;
        for (n = 0 ; n < neighbors ; n++)
        {
          fprintf(stdout, "v[%d] = %d\n", n, v->v[n]) ;
        }
      }
    }
  }

  for (vno = ntotal = vtotal = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->vtotal > 0)
    {
      if (v->dist)
      {
        free(v->dist) ;
      }
      if (v->dist_orig)
      {
        free(v->dist_orig) ;
      }
      v->dist = (float *)calloc(v->vtotal, sizeof(float)) ;
      if (!v->dist)
        ErrorExit(ERROR_NOMEMORY,
                  "MRISsetNeighborhoodSize: could not allocate list of %d "
                  "dists at v=%d", v->vtotal, vno) ;
      v->dist_orig = (float *)calloc(v->vtotal, sizeof(float)) ;
      if (!v->dist_orig)
        ErrorExit(ERROR_NOMEMORY,
                  "MRISsetNeighborhoodSize: could not allocate list of %d "
                  "orig dists at v=%d", v->vtotal, vno) ;
    }

    if (v->ripflag)
    {
      continue ;
    }
    vtotal += v->vtotal ;
    ntotal++ ;
  }

  mris->avg_nbrs = (float)vtotal / (float)ntotal ;
  mris->nsize = nsize ;
  if (Gdiag & DIAG_SHOW && mris->nsize > 1 && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "avg_nbrs = %2.1f\n", mris->avg_nbrs) ;
  }
  mrisComputeVertexDistances(mris) ;
  mrisComputeOriginalVertexDistances(mris) ;
  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Remove ripped vertices and faces from the v->v and the
  v->f arrays respectively.
  ------------------------------------------------------*/
int
MRISremoveRipped(MRI_SURFACE *mris)
{
  int     vno, n, fno, nripped, remove, vno2 ;
  VERTEX  *v, *vn ;
  FACE    *face ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "removing ripped vertices and faces...\n") ;
  }
  do
  {
    nripped = 0 ;
    // go through all vertices
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      // if rip flag set
      if (v->ripflag)
      {
        // remove it
#if 0
        if (v->dist)
        {
          free(v->dist) ;
        }
        if (v->dist_orig)
        {
          free(v->dist_orig) ;
        }
        v->dist = v->dist_orig = NULL ;
#endif
        continue ;
      }

      for (n = 0 ; n < v->vnum ; n++)
      {
        /* remove this vertex from neighbor list if it is ripped */
        if (mris->vertices[v->v[n]].ripflag)
        {
          if (n < v->vtotal-1)  /* not the last one in the list */
          {
            memmove(v->v+n, v->v+n+1, (v->vtotal-n-1)*sizeof(int)) ;
            memmove(v->dist+n, v->dist+n+1,
                    (v->vtotal-n-1)*sizeof(float)) ;
            memmove(v->dist_orig+n, v->dist_orig+n+1,
                    (v->vtotal-n-1)*sizeof(float)) ;
          }
          if (n < v->vnum)      /* it was a 1-neighbor */
          {
            v->vnum-- ;
          }
          if (n < v->v2num)     /* it was a 2-neighbor */
          {
            v->v2num-- ;
          }
          if (n < v->v3num)     /* it was a 3-neighbor */
          {
            v->v3num-- ;
          }
          if ((n < v->vnum) ||
              ((n < v->v2num) && mris->nsize >= 2) ||
              (mris->nsize >= 3 && (n < v->v3num)))
          {
            v->vtotal-- ;
          }
          n-- ;
        }
      }

      // make sure every nbr is a member of at least one unripped face
      for (n = 0 ; n < v->vnum ; n++)
      {
        int members, m ;

        vno2 = v->v[n] ;
        if (mris->vertices[v->v[n]].ripflag)
        {
          continue ;
        }

        remove = 1 ;
        for (fno = 0 ; fno < v->num ; fno++)
        {
          face = &mris->faces[v->f[fno]] ;
          if (face->ripflag == 1)   // only consider unripped
          {
            continue ;
          }
          for (members = m = 0 ; m < VERTICES_PER_FACE ; m++)
            if (face->v[m] == vno || face->v[m] == vno2)
            {
              members++ ;
            }
          if (members >= 2)
          {
            remove = 0 ;
            break ;
          }
        }

        if (remove)
        {
          if (n < v->vtotal-1)  /* not the last one in the list */
          {
            memmove(v->v+n, v->v+n+1, (v->vtotal-n-1)*sizeof(int)) ;
            memmove(v->dist+n, v->dist+n+1,
                    (v->vtotal-n-1)*sizeof(float)) ;
            memmove(v->dist_orig+n, v->dist_orig+n+1,
                    (v->vtotal-n-1)*sizeof(float)) ;
          }
          if (n < v->vnum)      /* it was a 1-neighbor */
          {
            v->vnum-- ;
          }
          if (n < v->v2num)     /* it was a 2-neighbor */
          {
            v->v2num-- ;
          }
          if (n < v->v3num)     /* it was a 3-neighbor */
          {
            v->v3num-- ;
          }
          if ((n < v->vnum) ||
              ((n < v->v2num) && mris->nsize >= 2) ||
              (mris->nsize >= 3 && (n < v->v3num)))
          {
            v->vtotal-- ;
          }
          n-- ;
        }
      }

      // go through 2-nbr list and make sure each one is a nbr of a 1-nbr
      for (n = v->vnum ; n < v->v2num ; n++)
      {
        int    n2, n3 ;
        VERTEX *vn2 ;

        remove = 1  ;

        vno2 = v->v[n] ;
        vn = &mris->vertices[vno2] ;
        for (n2 = 0 ; n2 < v->vnum ; n2++)  // 1-nbrs of the central node
        {
          vn2 = &mris->vertices[v->v[n2]] ;
          for (n3 = 0 ; remove && n3 < vn2->vnum ; n3++) // 1 nbrs of nbr
            if (vn2->v[n3] == vno2)
            {
              remove = 0 ;  // they still share a 1-nbr, keep it
              break ;
            }
        }
        if (remove)
        {
          nripped++ ;
          if (n < v->vtotal-1)  /* not the last one in the list */
          {
            memmove(v->v+n, v->v+n+1, (v->vtotal-n-1)*sizeof(int)) ;
            memmove(v->dist+n, v->dist+n+1,
                    (v->vtotal-n-1)*sizeof(float)) ;
            memmove(v->dist_orig+n, v->dist_orig+n+1,
                    (v->vtotal-n-1)*sizeof(float)) ;
          }
          if (n < v->vnum)      /* it was a 1-neighbor */
          {
            v->vnum-- ;
          }
          if (n < v->v2num)     /* it was a 2-neighbor */
          {
            v->v2num-- ;
          }
          if (n < v->v3num)     /* it was a 3-neighbor */
          {
            v->v3num-- ;
          }
          if ((n < v->vnum) ||
              ((n < v->v2num) && mris->nsize >= 2) ||
              (mris->nsize >=3 && (n < v->v3num)))
          {
            v->vtotal-- ;
          }
          n-- ;
        }
      }

      // go through 3-nbr list and make sure each one is a nbr of a 2-nbr
      for (n = v->v2num ; n < v->v3num ; n++)
      {
        int    n2, n3 ;
        VERTEX *vn2 ;

        remove = 1  ;

        vno2 = v->v[n] ;
        vn = &mris->vertices[vno2] ;
        for (n2 = v->vnum ;
             n2 < v->v2num ;
             n2++)  // 2-nbrs of the central node
        {
          vn2 = &mris->vertices[v->v[n2]] ;
          for (n3 = 0 ; remove && n3 < vn2->vnum ; n3++) // 1 nbrs of nbr
            if (vn2->v[n3] == vno2)
            {
              remove = 0 ;  // they still share a 1- or 2-nbr, keep it
              break ;
            }
        }
        if (remove)
        {
          if (n < v->vtotal-1)  /* not the last one in the list */
          {
            memmove(v->v+n, v->v+n+1, (v->vtotal-n-1)*sizeof(int)) ;
            memmove(v->dist+n, v->dist+n+1,
                    (v->vtotal-n-1)*sizeof(float)) ;
            memmove(v->dist_orig+n, v->dist_orig+n+1,
                    (v->vtotal-n-1)*sizeof(float)) ;
          }
          if (n < v->vnum)      /* it was a 1-neighbor */
          {
            v->vnum-- ;
          }
          if (n < v->v2num)     /* it was a 2-neighbor */
          {
            v->v2num-- ;
          }
          if (n < v->v3num)     /* it was a 3-neighbor */
          {
            v->v3num-- ;
          }
          if ((n < v->vnum) ||
              ((n < v->v2num) && mris->nsize >= 2) ||
              (mris->nsize >= 3 && (n < v->v3num)))
          {
            v->vtotal-- ;
          }
          n-- ;
        }
      }

      for (fno = 0 ; fno < v->num ; fno++)
      {
        /* remove this face from face list if it is ripped */
        if (mris->faces[v->f[fno]].ripflag)
        {
          if (fno < v->num-1)  /* not the last one in the list */
          {
            memmove(v->f+fno, v->f+fno+1,
                    (v->num-fno-1)*sizeof(int)) ;
            memmove(v->n+fno, v->n+fno+1,
                    (v->num-fno-1)*sizeof(uchar)) ;
          }
          v->num-- ;
          fno-- ;
        }
      }
#if 0
      if (v->num <= 0 || v->vnum <= 0)  /* degenerate vertex */
      {
        v->ripflag = 1 ;
        nripped++ ;
      }
#endif
    }
  }
  while (nripped > 0) ;

  /* now recompute total original area for scaling */
  mris->orig_area = 0.0f ;
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
    mris->orig_area += face->orig_area ;
  }
  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  no triangle area in msurfer, no explodeflag here
  ------------------------------------------------------*/
#define RAN   0.001   /* one thousandth of a millimeter */

int
MRIScomputeNormals(MRI_SURFACE *mris)
{
  int       k,n, num, i ;
  VERTEX    *v ;
  FACE      *f;
  float     norm[3],snorm[3], len ;

  i = 0 ;

#if 0
  if (mris->status == MRIS_PLANE)
  {
    mrisComputeBoundaryNormals(mris);
    mrisSmoothBoundaryNormals(mris,10);
  }
#endif
  for (k=0; k<mris->nfaces; k++) if (mris->faces[k].ripflag)
    {
      f = &mris->faces[k];
      for (n=0; n<VERTICES_PER_FACE; n++)
      {
        mris->vertices[f->v[n]].border = TRUE;
      }
    }

  for (k=0; k<mris->nvertices; k++) if (!mris->vertices[k].ripflag)
    {
      v = &mris->vertices[k];
      snorm[0]=snorm[1]=snorm[2]=0;
      v->area = 0;

      for (num = n=0; n<v->num; n++) if (!mris->faces[v->f[n]].ripflag)
        {
          num++ ;
          mrisNormalFace(mris, v->f[n] , (int)v->n[n] , norm);
          snorm[0] += norm[0];
          snorm[1] += norm[1];
          snorm[2] += norm[2];

          /* Note: overestimates area by *2 !! */
          v->area += mrisTriangleArea(mris, v->f[n], (int)v->n[n]);
        }
      if (!num)
      {
        continue ;
      }
      mrisNormalize(snorm);

      if (fix_vertex_area)
      {
        v->area /= 3.0 ;
      }
      else
      {
        v->area /= 2.0 ;
      }

      if (v->origarea<0)        /* has never been set */
      {
        v->origarea = v->area;
      }

      len = sqrt(snorm[0]*snorm[0] + snorm[1]*snorm[1] + snorm[2]*snorm[2]) ;
      if (!FZERO(len))
      {
        v->nx = snorm[0];
        v->ny = snorm[1];
        v->nz = snorm[2];
        i = 0 ;
      }
      else
      {
        if (i++ > 5)
        {
          continue ;
        }

        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
        {
          fprintf(stderr, "vertex %d: degenerate normal\n", k) ;
        }

        if ((mris->status == MRIS_SPHERICAL_PATCH ||
             mris->status == MRIS_PARAMETERIZED_SPHERE ||
             mris->status == MRIS_SPHERE) && DIAG_VERBOSE_ON)
        {
          fprintf(stderr, "vertex %d: degenerate normal\n", k) ;
        }

        v->x += (float)randomNumber(-RAN, RAN) ;
        v->y += (float)randomNumber(-RAN, RAN) ;
        /* normal is always (0,0,+-1) anyway */
        if (mris->status == MRIS_PLANE || mris->status == MRIS_CUT)
        {
          v->nx = v->ny = 0.0f ;
          v->nz = 1.0f ;
          continue ;
        }

        v->z += (float)randomNumber(-RAN, RAN) ;
        for (n=0; n<v->vnum; n++) /*if (!mris->faces[v->f[n]].ripflag)*/
        {
          mris->vertices[v->v[n]].x += (float)randomNumber(-RAN, RAN) ;
          mris->vertices[v->v[n]].y += (float)randomNumber(-RAN, RAN) ;
          mris->vertices[v->v[n]].z += (float)randomNumber(-RAN, RAN) ;
        }
        k-- ;   /* recalculate the normal for this vertex */
      }
    }
#if 0
  mris->vertices[0].nx = mris->vertices[0].ny = 0 ;
  mris->vertices[0].nz = mris->vertices[0].nz / fabs(mris->vertices[0].nz) ;
#endif

  return(NO_ERROR) ;
}

/*-----------------------------------------------------------------
  Calculate distances between each vertex and all of its neighbors.
  CVD.
  ----------------------------------------------------------------*/
static int
mrisComputeVertexDistances(MRI_SURFACE *mris)
{
  int     vno, n, vtotal, *pv ;
  VERTEX  *v, *vn ;
  float   d, xd, yd, zd, circumference = 0.0f, angle ;
  VECTOR  *v1, *v2 ;

  v1 = VectorAlloc(3, MATRIX_REAL) ;
  v2 = VectorAlloc(3, MATRIX_REAL) ;

  for (vno=0; vno<mris->nvertices; vno++)
  {
    v = &mris->vertices[vno];
    if (v->ripflag || v->dist == NULL)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    vtotal = v->vtotal ;
    switch (mris->status)
    {
    default:   /* don't really know what to do in other cases */
    case MRIS_PLANE:
      for (pv = v->v, n = 0 ; n < vtotal ; n++)
      {
        vn = &mris->vertices[*pv++] ;
        //        if (vn->ripflag) continue ;
        xd = v->x - vn->x ;
        yd = v->y - vn->y ;
        zd = v->z - vn->z ;
        d = xd*xd + yd*yd + zd*zd ;
        v->dist[n] = sqrt(d) ;
      }
      DiagBreak() ;
      break ;
    case MRIS_PARAMETERIZED_SPHERE:
    case MRIS_SPHERE:
      VECTOR_LOAD(v1, v->x, v->y, v->z) ;  /* radius vector */
      if (FZERO(circumference))   /* only calculate once */
      {
        circumference = M_PI * 2.0 * V3_LEN(v1) ;
      }
      for (pv = v->v, n = 0 ; n < vtotal ; n++)
      {
        vn = &mris->vertices[*pv++] ;
        if (vn->ripflag)
        {
          continue ;
        }
        VECTOR_LOAD(v2, vn->x, vn->y, vn->z) ;  /* radius vector */
        angle = fabs(Vector3Angle(v1, v2)) ;
#if 0
        xd = v->x - vn->x ;
        yd = v->y - vn->y ;
        zd = v->z - vn->z ;
        d = sqrt(xd*xd + yd*yd + zd*zd) ;
#endif
        d = circumference * angle / (2.0 * M_PI) ;
        if (angle > M_PI || angle < -M_PI || d > circumference/2 || angle < 0)
        {
          DiagBreak() ;
        }
        v->dist[n] = d ;
      }
      break ;
    }
  }

  VectorFree(&v1) ;
  VectorFree(&v2) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------------------
  Calculate distances between each vertex and all of its neighbors.
  CVD.
  ----------------------------------------------------------------*/
static int
mrisComputeOriginalVertexDistances(MRI_SURFACE *mris)
{
  int     vno, n, vtotal, *pv ;
  VERTEX  *v, *vn ;
  float   d, xd, yd, zd, circumference = 0.0f, angle ;
  VECTOR  *v1, *v2 ;

  v1 = VectorAlloc(3, MATRIX_REAL) ;
  v2 = VectorAlloc(3, MATRIX_REAL) ;

  for (vno=0; vno<mris->nvertices; vno++)
  {
    v = &mris->vertices[vno];
    if (v->ripflag || v->dist_orig == NULL)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    vtotal = v->vtotal ;
    switch (mris->status)
    {
    default:   /* don't really know what to do in other cases */
    case MRIS_PLANE:
      for (pv = v->v, n = 0 ; n < vtotal ; n++)
      {
        vn = &mris->vertices[*pv++] ;
        if (vn->ripflag)
        {
          continue ;
        }
        xd = v->origx - vn->origx ;
        yd = v->y - vn->origy ;
        zd = v->origz - vn->origz ;
        d = xd*xd + yd*yd + zd*zd ;
        v->dist_orig[n] = sqrt(d) ;
      }
      DiagBreak() ;
      break ;
    case MRIS_PARAMETERIZED_SPHERE:
    case MRIS_SPHERE:
      VECTOR_LOAD(v1, v->origx, v->origy, v->origz) ;  /* radius vector */
      if (FZERO(circumference))   /* only calculate once */
      {
        circumference = M_PI * 2.0 * V3_LEN(v1) ;
      }
      for (pv = v->v, n = 0 ; n < vtotal ; n++)
      {
        vn = &mris->vertices[*pv++] ;
        if (vn->ripflag)
        {
          continue ;
        }
        VECTOR_LOAD(v2, vn->origx, vn->origy, vn->origz) ;  /* radius vector */
        angle = fabs(Vector3Angle(v1, v2)) ;
#if 0
        xd = v->x - vn->x ;
        yd = v->y - vn->y ;
        zd = v->z - vn->z ;
        d = sqrt(xd*xd + yd*yd + zd*zd) ;
#endif
        d = circumference * angle / (2.0 * M_PI) ;
        if (angle > M_PI || angle < -M_PI || d > circumference/2 || angle < 0)
        {
          DiagBreak() ;
        }
        v->dist_orig[n] = d ;
      }
      break ;
    }
  }

  VectorFree(&v1) ;
  VectorFree(&v2) ;
  return(NO_ERROR) ;
}



/*-------------------------------------------------------------
  MRISavgInterVertexDist() - computes the average and stddev of
  the distance between neighboring vertices. If StdDev is NULL,
  it is ignored. Requires that mrisComputeVertexDistances()
  have been run in order to comute vertex->dist[n].
  -------------------------------------------------------------*/
static double MRISavgInterVertexDist(MRIS *Surf, double *StdDev)
{
  double Avg, Sum, Sum2, d;
  VERTEX *vtx1,*vtx2;
  int nNNbrs, nthNNbr, NbrVtxNo, VtxNo;
  long N;

  Sum = 0;
  Sum2 = 0;
  N = 0;
  for (VtxNo = 0; VtxNo < Surf->nvertices; VtxNo++)
  {
    vtx1 = &Surf->vertices[VtxNo] ;
    if (vtx1->ripflag)
    {
      continue;
    }
    nNNbrs = Surf->vertices[VtxNo].vnum;
    for (nthNNbr = 0; nthNNbr < nNNbrs; nthNNbr++)
    {
      NbrVtxNo = Surf->vertices[VtxNo].v[nthNNbr];
      vtx2 = &Surf->vertices[NbrVtxNo] ;
      if (vtx2->ripflag)
      {
        continue;
      }
      d = vtx1->dist[nthNNbr];
      /*d = sqrt( (vtx1->x-vtx2->x)*(vtx1->x-vtx2->x) +
        (vtx1->y-vtx2->y)*(vtx1->y-vtx2->y) +
        (vtx1->z-vtx2->z)*(vtx1->z-vtx2->z) );*/
      Sum  += d;
      Sum2 += (d*d);
      N++;
    }
  }
  Avg = Sum/N;
  if (StdDev != NULL)
  {
    *StdDev = sqrt( N*(Sum2/N - Avg*Avg)/(N-1) );
  }

  //printf("\n\nN = %ld, Sum = %g, Sum2 = %g, Avg=%g, Std = %g\n\n",
  // N,Sum,Sum2,Avg,*StdDev);

  return(Avg);
}

/*-------------------------------------------------------------
  MRISavgVetexRadius() - computes the average and stddev of
  the distance from the origin to each vertex. If StdDev is NULL,
  it is ignored.
  -------------------------------------------------------------*/
double MRISavgVetexRadius(MRIS *Surf, double *StdDev)
{
  double Avg, Sum, Sum2, d;
  VERTEX *vtx;
  int VtxNo, N;

  Sum = 0;
  Sum2 = 0;
  for (VtxNo = 0; VtxNo < Surf->nvertices; VtxNo++)
  {
    vtx = &Surf->vertices[VtxNo] ;
    d = sqrt( vtx->x*vtx->x + vtx->y*vtx->y + vtx->z*vtx->z );
    Sum  += d;
    Sum2 += (d*d);
  }

  N = Surf->nvertices;
  Avg = Sum/N;
  if (StdDev != NULL)
  {
    *StdDev = sqrt( N*(Sum2/N - Avg*Avg)/(N-1) );
  }

  //printf("\n\nN = %ld, Sum = %g, Sum2 = %g, Avg=%g, Std = %g\n\n",
  // N,Sum,Sum2,Avg,*StdDev);

  return(Avg);
}



/*-----------------------------------------------------
  ------------------------------------------------------*/
static void
mrisNormalize(float v[3])
{
  float d;

  d = sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
  if (d>0)
  {
    v[0] /= d;
    v[1] /= d;
    v[2] /= d;
  }
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static float
mrisTriangleArea(MRIS *mris, int fac, int n)
{
  int n0,n1;
  face_type *f;
  float v0[3],v1[3],d1,d2,d3;

  n0 = (n == 0)                   ? VERTICES_PER_FACE-1 : n-1;
  n1 = (n == VERTICES_PER_FACE-1) ? 0                   : n+1;
  f = &mris->faces[fac];
  v0[0] = mris->vertices[f->v[n]].x - mris->vertices[f->v[n0]].x;
  v0[1] = mris->vertices[f->v[n]].y - mris->vertices[f->v[n0]].y;
  v0[2] = mris->vertices[f->v[n]].z - mris->vertices[f->v[n0]].z;
  v1[0] = mris->vertices[f->v[n1]].x - mris->vertices[f->v[n]].x;
  v1[1] = mris->vertices[f->v[n1]].y - mris->vertices[f->v[n]].y;
  v1[2] = mris->vertices[f->v[n1]].z - mris->vertices[f->v[n]].z;
  d1 = -v1[1]*v0[2] + v0[1]*v1[2];
  d2 = v1[0]*v0[2] - v0[0]*v1[2];
  d3 = -v1[0]*v0[1] + v0[0]*v1[1];
  return sqrt(d1*d1+d2*d2+d3*d3)/2;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeOrigNormal(MRIS *mris, int vno, float norm[])
{
  float snorm[3] ;
  VERTEX *v ;
  int    n, num ;

  v = &mris->vertices[vno] ;

  norm[0]=norm[1]=norm[2]=0.0;
  for (num = n=0; n<v->num; n++) if (!mris->faces[v->f[n]].ripflag)
    {
      num++ ;
      mrisOrigNormalFace(mris, v->f[n], (int)v->n[n],snorm);
      norm[0] += snorm[0];
      norm[1] += snorm[1];
      norm[2] += snorm[2];

    }
  if (!num)
  {
    return(ERROR_BADPARM) ;
  }
  mrisNormalize(norm);
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeWhiteNormal(MRIS *mris, int vno, float norm[])
{
  float snorm[3] ;
  VERTEX *v ;
  int    n, num ;

  v = &mris->vertices[vno] ;

  norm[0]=norm[1]=norm[2]=0.0;
  for (num = n=0; n<v->num; n++) if (!mris->faces[v->f[n]].ripflag)
    {
      num++ ;
      mrisWhiteNormalFace(mris, v->f[n], (int)v->n[n],snorm);
      norm[0] += snorm[0];
      norm[1] += snorm[1];
      norm[2] += snorm[2];

    }
  if (!num)
  {
    return(ERROR_BADPARM) ;
  }
  mrisNormalize(norm);
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputePialNormal(MRIS *mris, int vno, float norm[])
{
  float snorm[3] ;
  VERTEX *v ;
  int    n, num ;

  v = &mris->vertices[vno] ;

  norm[0]=norm[1]=norm[2]=0.0;
  for (num = n=0; n<v->num; n++) if (!mris->faces[v->f[n]].ripflag)
    {
      num++ ;
      mrisPialNormalFace(mris, v->f[n], (int)v->n[n],snorm);
      norm[0] += snorm[0];
      norm[1] += snorm[1];
      norm[2] += snorm[2];

    }
  if (!num)
  {
    return(ERROR_BADPARM) ;
  }
  mrisNormalize(norm);
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisOrigNormalFace(MRIS *mris, int fac,int n,float norm[])
{
  int     n0,n1, *pv ;
  FACE    *f;
  float   v0[3],v1[3];
  register VERTEX  *v, *vn0, *vn1 ;

  n0 = (n == 0)                   ? VERTICES_PER_FACE-1 : n-1;
  n1 = (n == VERTICES_PER_FACE-1) ? 0                   : n+1;
  f = &mris->faces[fac];
  pv = f->v ;
  vn0 = &mris->vertices[pv[n0]] ;
  vn1 = &mris->vertices[pv[n1]] ;
  v =  &mris->vertices[pv[n]] ;
  v0[0] = v->origx - vn0->origx;
  v0[1] = v->origy - vn0->origy;
  v0[2] = v->origz - vn0->origz;
  v1[0] = vn1->origx - v->origx;
  v1[1] = vn1->origy - v->origy;
  v1[2] = vn1->origz - v->origz;
  mrisNormalize(v0);
  mrisNormalize(v1);
  norm[0] = -v1[1]*v0[2] + v0[1]*v1[2];
  norm[1] = v1[0]*v0[2] - v0[0]*v1[2];
  norm[2] = -v1[0]*v0[1] + v0[0]*v1[1];
  /*
    printf("[%5.2f,%5.2f,%5.2f] x [%5.2f,%5.2f,%5.2f] = [%5.2f,%5.2f,%5.2f]\n",
    v0[0],v0[1],v0[2],v1[0],v1[1],v1[2],norm[0],norm[1],norm[2]);
  */
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisWhiteNormalFace(MRIS *mris, int fac,int n,float norm[])
{
  int     n0,n1, *pv ;
  FACE    *f;
  float   v0[3],v1[3];
  register VERTEX  *v, *vn0, *vn1 ;

  n0 = (n == 0)                   ? VERTICES_PER_FACE-1 : n-1;
  n1 = (n == VERTICES_PER_FACE-1) ? 0                   : n+1;
  f = &mris->faces[fac];
  pv = f->v ;
  vn0 = &mris->vertices[pv[n0]] ;
  vn1 = &mris->vertices[pv[n1]] ;
  v =  &mris->vertices[pv[n]] ;
  v0[0] = v->whitex - vn0->whitex;
  v0[1] = v->whitey - vn0->whitey;
  v0[2] = v->whitez - vn0->whitez;
  v1[0] = vn1->whitex - v->whitex;
  v1[1] = vn1->whitey - v->whitey;
  v1[2] = vn1->whitez - v->whitez;
  mrisNormalize(v0);
  mrisNormalize(v1);
  norm[0] = -v1[1]*v0[2] + v0[1]*v1[2];
  norm[1] = v1[0]*v0[2] - v0[0]*v1[2];
  norm[2] = -v1[0]*v0[1] + v0[0]*v1[1];
  /*
    printf("[%5.2f,%5.2f,%5.2f] x [%5.2f,%5.2f,%5.2f] = [%5.2f,%5.2f,%5.2f]\n",
    v0[0],v0[1],v0[2],v1[0],v1[1],v1[2],norm[0],norm[1],norm[2]);
  */
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisPialNormalFace(MRIS *mris, int fac,int n,float norm[])
{
  int     n0,n1, *pv ;
  FACE    *f;
  float   v0[3],v1[3];
  register VERTEX  *v, *vn0, *vn1 ;

  n0 = (n == 0)                   ? VERTICES_PER_FACE-1 : n-1;
  n1 = (n == VERTICES_PER_FACE-1) ? 0                   : n+1;
  f = &mris->faces[fac];
  pv = f->v ;
  vn0 = &mris->vertices[pv[n0]] ;
  vn1 = &mris->vertices[pv[n1]] ;
  v =  &mris->vertices[pv[n]] ;
  v0[0] = v->pialx - vn0->pialx;
  v0[1] = v->pialy - vn0->pialy;
  v0[2] = v->pialz - vn0->pialz;
  v1[0] = vn1->pialx - v->pialx;
  v1[1] = vn1->pialy - v->pialy;
  v1[2] = vn1->pialz - v->pialz;
  mrisNormalize(v0);
  mrisNormalize(v1);
  norm[0] = -v1[1]*v0[2] + v0[1]*v1[2];
  norm[1] = v1[0]*v0[2] - v0[0]*v1[2];
  norm[2] = -v1[0]*v0[1] + v0[0]*v1[1];
  /*
    printf("[%5.2f,%5.2f,%5.2f] x [%5.2f,%5.2f,%5.2f] = [%5.2f,%5.2f,%5.2f]\n",
    v0[0],v0[1],v0[2],v1[0],v1[1],v1[2],norm[0],norm[1],norm[2]);
  */
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisNormalFace(MRIS *mris, int fac,int n,float norm[])
{
  int     n0,n1, *pv ;
  FACE    *f;
  float   v0[3],v1[3];
  register VERTEX  *v, *vn0, *vn1 ;

  n0 = (n == 0)                   ? VERTICES_PER_FACE-1 : n-1;
  n1 = (n == VERTICES_PER_FACE-1) ? 0                   : n+1;
  f = &mris->faces[fac];
  pv = f->v ;
  vn0 = &mris->vertices[pv[n0]] ;
  vn1 = &mris->vertices[pv[n1]] ;
  v =  &mris->vertices[pv[n]] ;
  v0[0] = v->x - vn0->x;
  v0[1] = v->y - vn0->y;
  v0[2] = v->z - vn0->z;
  v1[0] = vn1->x - v->x;
  v1[1] = vn1->y - v->y;
  v1[2] = vn1->z - v->z;
  mrisNormalize(v0);
  mrisNormalize(v1);
  norm[0] = -v1[1]*v0[2] + v0[1]*v1[2];
  norm[1] = v1[0]*v0[2] - v0[0]*v1[2];
  norm[2] = -v1[0]*v0[1] + v0[0]*v1[1];
  /*
    printf("[%5.2f,%5.2f,%5.2f] x [%5.2f,%5.2f,%5.2f] = [%5.2f,%5.2f,%5.2f]\n",
    v0[0],v0[1],v0[2],v1[0],v1[1],v1[2],norm[0],norm[1],norm[2]);
  */
  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
// here reads mri/transforms/talairach.xfm (MNI style transform)
static int
mrisReadTransform(MRIS *mris, const char *mris_fname)
{
  char transform_fname[STRLEN], fpref[300] ;
  LT *lt = 0;
  MRI *orig = 0;
  struct stat info;
  int rStat;

  // here it is assumed that subjects is set
  FileNamePath(mris_fname, fpref) ;
  sprintf(transform_fname, "%s/../mri/transforms/talairach.xfm", fpref) ;
  if (!FileExists(transform_fname))
  {
    return(ERROR_NO_FILE) ;
  }

  if (!(mris->lta = LTAreadEx(transform_fname)))
  {
    ErrorReturn(ERROR_NO_FILE,
                (ERROR_NOFILE,
                 "mrisReadTransform: could not read xform file '%s'",
                 transform_fname)) ;
  }
  else
  {
    if (mris->lta->type != LINEAR_RAS_TO_RAS)
      ErrorExit(ERROR_BADPARM,
                "the transform is not RAS-TO-RAS.  not supported.");
  }
  //////////////////////////////////////////////////////////////////////
  // thus if transform->src is not set, set it to the orig
  lt = &mris->lta->xforms[0];
  // src information
  if (!lt->src.valid)
  {
    // first try to get it from surface itself
    if (mris->vg.valid)
    {
      if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
        fprintf
        (stderr,
         "INFO: found the orig volume info on %s in the surface data.\n",
         mris->vg.fname);
      lt->src.c_r = mris->vg.c_r;
      lt->src.c_a = mris->vg.c_a;
      lt->src.c_s = mris->vg.c_s;
    }
    else
    {
      // first try to get it from mri/orig
      sprintf(transform_fname,
              "%s/../mri/orig", fpref) ; // reuse of the buffer
      rStat = stat (transform_fname, &info);
      if (!rStat && S_ISREG(info.st_mode))
      {
        orig = MRIreadHeader(transform_fname, -1);
      }
      if (orig)
      {
        getVolGeom(orig, &lt->src);
        getVolGeom(orig, &mris->vg);
        // add orig volume info in the surface
        MRIfree(&orig);
        orig = 0;
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
        {
          fprintf
          (stderr,
           "INFO: found the orig volume (mri/orig) "
           "to get c_(ras) information for src\n");
          fprintf
          (stderr, "INFO: added info to the surface.\n");
        }
      }
      else
      {
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
        {
          fprintf
          (stderr,
           "INFO: cannot find mri/orig volume to "
           "get c_(ras) information.\n");
          fprintf(stderr, "INFO: transform src volume "
                  "information cannot be found. assume c_(ras) = 0\n");
          fprintf(stderr, "INFO: destination surface "
                  "points may be shifted in the volume.\n");
          fprintf(stderr, "INFO: you should put the "
                  "src info in the transform.\n");
        }
        lt->src.c_r = 0;
        lt->src.c_a = 0;
        lt->src.c_s = 0;
      }
    }
  }
  else // lt->src.valid == 1
  {
    // verify
    if (mris->vg.valid)
    {
      if (!FZERO(lt->src.c_r - mris->vg.c_r)
          || !FZERO(lt->src.c_a - mris->vg.c_a)
          || !FZERO(lt->src.c_s - mris->vg.c_s))
      {
        fprintf(stderr, "WARNING: the source volume info "
                "is not consistent between the info contained\n");
        fprintf(stderr, "WARNING: in the surface data (%f,%f,%f) and "
                "that of the transform (%f,%f,%f).\n",
                mris->vg.c_r,mris->vg.c_a,mris->vg.c_s,
                lt->src.c_r,lt->src.c_a,lt->src.c_s);
      }
    }
  }
  // check dst info
  if (!lt->dst.valid)
  {
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    {
      fprintf(stderr, "INFO: transform dst volume information "
              "cannot be found.\n");
      fprintf(stderr, "INFO: if the target is MNI average_305, "
              "then you can do 'setenv USE_AVERAGE305 true'\n");
      fprintf(stderr, "INFO: otherwise c_(ras) is set to 0. "
              "destination surface points may be shifted.\n");
    }
    if (getenv("USE_AVERAGE305"))
    {
      lt->dst.c_r =  -0.0950;
      lt->dst.c_a = -16.5100;
      lt->dst.c_s =   9.7500;
    }
  }
  // cache the transform
  mris->SRASToTalSRAS_ = getSRASToTalSRAS(lt);
  mris->TalSRASToSRAS_ = MatrixInverse(mris->SRASToTalSRAS_, NULL);

  // mark to make sure it is freed
  mris->free_transform = 1;

#if 0
  if (input_transform_file(transform_fname, &mris->transform) != OK)
  {
    ErrorReturn(ERROR_NO_FILE,
                (ERROR_NOFILE,
                 "mrisReadTransform: could not read xform file '%s'",
                 transform_fname)) ;
  }
  else
  {
    mris->linear_transform = get_linear_transform_ptr(&mris->transform) ;
    mris->inverse_linear_transform =
      get_inverse_linear_transform_ptr(&mris->transform) ;
    mris->free_transform = 1 ;
  }
#endif

  return(NO_ERROR) ;
}

// public
int MRISreadTransform(MRIS *mris, const char *fname)
{
  return mrisReadTransform(mris, fname);
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadBinaryCurvature(MRI_SURFACE *mris, const char *mris_fname)
{
  char   fname[STRLEN], fpref[STRLEN], hemi[20] ;

  FileNamePath(mris_fname, fpref) ;
  strcpy(hemi, mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh") ;
  sprintf(fname, "%s/%s.curv", fpref, hemi) ;
  return(MRISreadCurvatureFile(mris, fname)) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadCurvatureFile(MRI_SURFACE *mris, const char *sname)
{
  int    k,i,vnum,fnum;
  float  curv = 0, curvmin, curvmax;
  FILE   *fp;
  char   *cp, path[STRLEN], fname[STRLEN], type ;
  int   mritype, frame, nv, c,r,s,vno;
  MRI *TempMRI;

  cp = strchr(sname, '/') ;
  if (!cp)                 /* no path - use same one as mris was read from */
  {
    cp = strchr(sname, '.') ;
    FileNamePath(mris->fname, path) ;
    if (cp &&
        ((strncmp(cp-2, "lh", 2) == 0) || (strncmp(cp-2, "rh", 2) == 0)))
    {
      sprintf(fname, "%s/%s", path, sname) ;
    }
    else   /* no hemisphere specified */
      sprintf(fname, "%s/%s.%s", path,
              mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh", sname) ;
  }
  else
  {
    strcpy(fname, sname) ;  /* path specified explicitly */
  }
  mritype = mri_identify(sname);
  if (mritype == GIFTI_FILE)
  {
    mris = mrisReadGIFTIfile(fname, mris) ;
    if (mris)
    {
      return(NO_ERROR);
    }
    else
    {
      return(ERROR_BADFILE);
    }
  }
  if (mritype == VTK_FILE)
  {
    mris = MRISreadVTK(mris, fname);
    return(NO_ERROR);
  }
  if (mritype != MRI_VOLUME_TYPE_UNKNOWN)
  {
    frame = MRISgetReadFrame();
    TempMRI = MRIreadHeader(fname,mritype);
    if (TempMRI==NULL)
    {
      return(ERROR_BADFILE);
    }
    if (TempMRI->nframes <= frame)
    {
      printf("ERROR: attempted to read frame %d from %s\n",frame,fname);
      printf("  but this file only has %d frames.\n",TempMRI->nframes);
      return(ERROR_BADFILE);
    }
    nv = TempMRI->width * TempMRI->height * TempMRI->depth;
    if (nv != mris->nvertices)
    {
      printf
      ("ERROR: number of vertices in %s does not match surface (%d,%d)\n",
       sname,nv,mris->nvertices);
      return(1);
    }
    MRIfree(&TempMRI);
    TempMRI = MRIread(fname);
    if (TempMRI==NULL)
    {
      return(ERROR_BADFILE);
    }
    vno = 0;
    curvmin = 10000.0f ;
    curvmax = -10000.0f ;  /* for compiler warnings */
    for (s=0; s < TempMRI->depth; s++)
    {
      for (r=0; r < TempMRI->height; r++)
      {
        for (c=0; c < TempMRI->width; c++)
        {
          curv = MRIgetVoxVal(TempMRI,c,r,s,frame);
          if (s==0&&r==0&&c==0)
          {
            curvmin=curvmax=curv;
          }
          if (curv>curvmax)
          {
            curvmax=curv;
          }
          if (curv<curvmin)
          {
            curvmin=curv;
          }
          mris->vertices[vno].curv = curv;
          vno++;
        }
      }
    }
    MRIfree(&TempMRI);
    mris->max_curv = curvmax ;
    mris->min_curv = curvmin ;
    return(NO_ERROR);
  }

  type = MRISfileNameType(fname) ;
  if (type == MRIS_ASCII_TRIANGLE_FILE)
  {
    return(mrisReadAsciiCurvatureFile(mris, fname)) ;
  }
  else if (type == MRIS_GIFTI_FILE)
  {
    mris = mrisReadGIFTIfile(fname, mris);
    if (mris)
    {
      return(NO_ERROR);
    }
    else
    {
      return(ERROR_BADFILE);
    }
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "reading curvature file...") ;
  }

  fp = fopen(fname,"r");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISreadCurvature: could not open %s",
                 fname)) ;

  fread3(&vnum,fp);
  if (vnum == NEW_VERSION_MAGIC_NUMBER)
  {
    fclose(fp) ;
    return(MRISreadNewCurvatureFile(mris, fname)) ;
  }

  fread3(&fnum,fp);
  if (vnum!= mris->nvertices)
  {
    fclose(fp) ;
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISreadBinaryCurvature: incompatible vertex "
                 "number in file %s", fname)) ;
  }
  curvmin = 10000.0f ;
  curvmax = -10000.0f ;  /* for compiler warnings */
  for (k=0; k<vnum; k++)
  {
    fread2(&i,fp);
    curv = i/100.0;

    if (k==0)
    {
      curvmin=curvmax=curv;
    }
    if (curv>curvmax)
    {
      curvmax=curv;
    }
    if (curv<curvmin)
    {
      curvmin=curv;
    }
    mris->vertices[k].curv = curv;
  }
  mris->max_curv = curvmax ;
  mris->min_curv = curvmin ;
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "done. min=%2.3f max=%2.3f\n", curvmin, curvmax) ;
  }
  fclose(fp);
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
float *
MRISreadCurvatureVector(MRI_SURFACE *mris, const char *sname)
{
  char   *cp, path[STRLEN], fname[STRLEN] ;
  float* cvec = NULL;
  int return_code = ERROR_NONE;

  cp = strchr(sname, '/') ;
  if (!cp)                 /* no path - use same one as mris was read from */
  {
    cp = strchr(sname, '.') ;
    FileNamePath(mris->fname, path) ;
    if (cp)
    {
      sprintf(fname, "%s/%s", path, sname) ;
    }
    else   /* no hemisphere specified */
      sprintf(fname, "%s/%s.%s", path,
              mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh", sname) ;
  }
  else
  {
    strcpy(fname, sname) ;  /* path specified explcitly */
  }

  /* Try to read an array of values from this file. If we get an
     error, return NULL. */
  return_code = MRISreadCurvatureIntoArray (fname, mris->nvertices, &cvec);
  if (NO_ERROR != return_code)
  {
    return NULL;
  }

  /* Return the array we read. */
  return cvec;
}

int
MRISreadCurvatureIntoArray(const char *sname,
                           int in_array_size,
                           float** out_array)
{
  int    k,i,vnum,fnum;
  float  *cvec ;
  FILE   *fp;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "reading curvature file...") ;
  }

  fp = fopen(sname,"r");
  if (fp==NULL)
    ErrorReturn(ERROR_BADFILE,
                (ERROR_BADFILE,
                 "MRISreadCurvatureVectorIntoArray(%s): fopen failed", sname)) ;

  fread3(&vnum,fp);
  if (vnum == NEW_VERSION_MAGIC_NUMBER)
  {
    fclose(fp) ;
    return(MRISreadNewCurvatureIntoArray(sname, in_array_size, out_array)) ;
  }

  /* If that wasn't the magic number, it should be our number of
     vertices, and should match the array size we were passed. */
  if (vnum != in_array_size)
  {
    fclose(fp);
    return(ERROR_BADFILE);
  }

  /* This value is ignored. */
  fread3(&fnum,fp);

  /* Allocate vector to size of vnum. */
  cvec = (float *)calloc(in_array_size, sizeof(float)) ;
  if (!cvec)
  {
    fclose(fp);
    ErrorReturn(
      ERROR_NOMEMORY,
      (ERROR_NOMEMORY,
       "MRISreadCurvatureVectorIntoArray(%s): calloc failed", sname)) ;
  }

  for (k=0; k<vnum; k++)
  {
    fread2(&i,fp);
    cvec[k] = i/100.0 ;
  }
  fclose(fp);

  /* Return what we read. */
  *out_array = cvec;

  return (ERROR_NONE);
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadFloatFile(MRI_SURFACE *mris, const char *sname)
{
  int    k,vnum,fnum;
  float  f, fmin, fmax;
  FILE   *fp;
  char   *cp, path[STRLEN], fname[STRLEN] ;

  cp = strchr(sname, '/') ;
  if (!cp)                 /* no path - use same one as mris was read from */
  {
    cp = strchr(sname, '.') ;
    FileNamePath(mris->fname, path) ;
    if (cp)
    {
      sprintf(fname, "%s/%s", path, sname) ;
    }
    else   /* no hemisphere specified */
      sprintf(fname, "%s/%s.%s", path,
              mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh", sname) ;
  }
  else
  {
    strcpy(fname, sname) ;  /* path specified explcitly */
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "reading float file...") ;
  }

  fp = fopen(fname,"r");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISreadFloatFile: could not open %s",
                 fname)) ;

  vnum = freadInt(fp);
  fnum = freadInt(fp);
  if (vnum!= mris->nvertices)
  {
    fclose(fp) ;
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISreadFloatFile: incompatible # of vertices "
                 "in file %s", fname)) ;
  }
  if (fnum!= mris->nfaces)
  {
    fclose(fp) ;
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISreadFloatFile: incompatible # of faces "
                 "file %s", fname)) ;
  }
  fmin = 10000.0f ;
  fmax = -10000.0f ;  /* for compiler warnings */
  for (k=0; k<vnum; k++)
  {
    f = freadFloat(fp);
    mris->vertices[k].val = f;
  }
  fclose(fp);
  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadBinaryAreas(MRI_SURFACE *mris, const char *mris_fname)
{
  int   k,vnum,fnum;
  float f;
  FILE  *fp;
  char  fname[STRLEN], fpref[STRLEN], hemi[20] ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "reading area file...") ;
  }

  FileNamePath(mris_fname, fpref) ;
  strcpy(hemi, mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh") ;
  sprintf(fname, "%s/%s.area", fpref, hemi) ;

  /*  mris->orig_area = 0.0f ;*/
  fp = fopen(fname,"r");
  if (fp==NULL)
    ErrorReturn(ERROR_BADPARM,
                (ERROR_BADPARM,
                 "MRISreadBinaryAreas: no area file %s\n",fname));
  fread3(&vnum,fp);
  fread3(&fnum,fp);
  if (vnum!=mris->nvertices)
  {
    fclose(fp) ;
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISreadBinaryAreas: incompatible vertex "
                 "number in file %s", fname)) ;
  }

  for (k=0; k<vnum; k++)
  {
    f = freadFloat(fp);
    mris->vertices[k].origarea = f ;
    /*    mris->orig_area += f;*/
  }
  fclose(fp);

  /* hack to correct for overestimation of area in compute_normals */
#if 0
  mris->orig_area /= 2;
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "total area = %2.0f.\n", mris->orig_area) ;
  }
#endif
  return(NO_ERROR) ;
}



int
MRISwriteMarked(MRI_SURFACE *mris, const char *sname)
{
  float  *curv_save ;

  curv_save = (float *)calloc(mris->nvertices, sizeof(float)) ;
  if (!curv_save)
    ErrorExit(ERROR_NOMEMORY,
              "MRISwriteMarked: could not alloc %d vertex curv storage",
              mris->nvertices) ;

  MRISextractCurvatureVector(mris, curv_save) ;
  MRISmarkedToCurv(mris) ;
  MRISwriteCurvature(mris, sname) ;
  MRISimportCurvatureVector(mris, curv_save) ;
  free(curv_save) ;
  return(NO_ERROR) ;
}


int
MRISreadMarked(MRI_SURFACE *mris, const char *sname)
{
  float  *curv_save ;

  curv_save = (float *)calloc(mris->nvertices, sizeof(float)) ;
  if (!curv_save)
    ErrorExit(ERROR_NOMEMORY,
              "MRISwriteMarked: could not alloc %d vertex curv storage",
              mris->nvertices) ;

  MRISextractCurvatureVector(mris, curv_save) ;
  if (MRISreadCurvatureFile(mris, sname) != NO_ERROR)
  {
    return(Gerror) ;
  }
  MRIScurvToMarked(mris) ;
  MRISimportCurvatureVector(mris, curv_save) ;
  free(curv_save) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteArea(MRI_SURFACE *mris, const char *sname)
{
  float  *curv_save ;

  curv_save = (float *)calloc(mris->nvertices, sizeof(float)) ;
  if (!curv_save)
    ErrorExit(ERROR_NOMEMORY,
              "MRISwriteArea: could not alloc %d vertex curv storage",
              mris->nvertices) ;

  MRISextractCurvatureVector(mris, curv_save) ;
  MRISareaToCurv(mris) ;
  MRISwriteCurvature(mris, sname) ;
  MRISimportCurvatureVector(mris, curv_save) ;
  free(curv_save) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
static int
mrisReadFieldsign(MRI_SURFACE *mris, const char *mris_fname)
{
  int k,i,vnum;
  float f;
  FILE *fp;

  printf("surfer: read_fieldsign(%s)\n",fname);
  fp = fopen(fname,"r");
  if (fp==NULL)
  {
    printf("surfer: ### File %s not found\n",fname);
    PR return;
  }
  fread(&vnum,1,sizeof(int),fp);
  printf("surfer: vertex_index = %d, vnum = %d\n",vertex_index,vnum);
  if (vnum!=vertex_index)
  {
    printf("surfer: Warning: incompatible vertex number in file %s\n",fname);
  }
  for (k=0; k<vnum; k++)
  {
    fread(&f,1,sizeof(float),fp);
    vertex[k].fieldsign = f;
  }
  fclose(fp);
  fieldsignflag = TRUE;
  PR
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
normalize_binary_curvature(MRI_SURFACE *mris)
{
  int k;
  float curv,min,max;
  float sum,avg,sq,sum_sq,sd,n;
  FILE *fp;

  if (!curvloaded)
  {
    printf("surfer: ### curv not loaded!\n");
    PR return;
  }

  sum = 0;
  for (k=0; k<vertex_index; k++)
  {
    sum += vertex[k].curv;
  }
  avg = sum/vertex_index;

  n = (float)vertex_index;
  sum = sum_sq = 0.0;
  for (k=0; k<vertex_index; k++)
  {
    vertex[k].curv -= avg;
    curv = vertex[k].curv;
    sum += curv;
    sum_sq += curv*curv;
  }
  sd = sqrt((n*sum_sq - sum*sum)/(n*(n-1.0)));

  for (k=0; k<vertex_index; k++)
  {
    curv = (vertex[k].curv)/sd;
    if (k==0)
    {
      min=max=curv;
    }
    if (curv<min)
    {
      min=curv;
    }
    if (curv>max)
    {
      max=curv;
    }
    if (curv<CURVIM_NORM_MIN)
    {
      curv = CURVIM_NORM_MIN;
    }
    if (curv>CURVIM_NORM_MAX)
    {
      curv = CURVIM_NORM_MAX;
    }
    vertex[k].curv = curv;
  }
  curvmin = CURVIM_NORM_MIN;
  curvmax = CURVIM_NORM_MAX;
  printf("surfer: curvature normalized: avg=%f sd=%f\n",avg,sd);
  printf("surfer: min=%f max=%f trunc to (%f,%f)\n",min,max,curvmin,curvmax);
  PR
}

#endif


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Perform a projection onto a cylinder moving each
  point on the cortical surface to the closest cylindrical
  coordinate.
  ------------------------------------------------------*/
int
MRISprojectOntoCylinder(MRI_SURFACE *mris, float radius)
{
  VERTEX  *v;
  int     k;
  float   x,y,z,x2,z2,dx,dz ;
  float   d ;

  MRIScenter(mris, mris) ;

  for (k=0; k<mris->nvertices; k++)
  {
    v = &mris->vertices[k];
    x = v->x;
    y = v->y;
    z = v->z;

    x2 = x*x;
    z2 = z*z;

    d = (-1.0+(float)radius/sqrt(x2+z2)) ;
    if (!finite(d))
    {
      ErrorPrintf
      (ERROR_BADPARM,
       "point (%2.2f,%2.2f,%2.2f) cannot be projected on cylinder",
       x, y, z) ;

    }
    dx = d*x ;
    dz = d*z ;
    v->x = x+dx ;
    v->z = z+dz;

    if (!finite(v->x) || !finite(v->y) || !finite(v->z))
    {
      DiagBreak() ;
    }

  }
  MRISupdateSurface(mris) ;
  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Perform a projection onto an sphere moving each
  point on the cortical surface to the closest spherical
  coordinate.
  ------------------------------------------------------*/
MRI_SURFACE  *
MRISprojectOntoSphere(MRI_SURFACE *mris_src, MRI_SURFACE *mris_dst, double r)
{
  VERTEX  *v;
  int     vno ;
  double  x, y, z, d, dx, dy, dz, dist, total_dist, x2, y2, z2 ;

  if (FZERO(r))
  {
    r = DEFAULT_RADIUS ;
  }

  if (!mris_dst)
  {
    mris_dst = MRISclone(mris_src) ;
  }

  if ((mris_dst->status != MRIS_SPHERE) &&
      (mris_dst->status != MRIS_PARAMETERIZED_SPHERE))
  {
    MRIScenter(mris_dst, mris_dst) ;
  }

  mris_dst->radius = r ;

  for (total_dist = vno = 0 ; vno < mris_dst->nvertices ; vno++)
  {
    v = &mris_dst->vertices[vno];
    if (v->ripflag)  /* shouldn't happen */
    {
      continue ;
    }
    if (vno == 118009)
    {
      DiagBreak() ;
    }
    x = (double)v->x;
    y = (double)v->y;
    z = (double)v->z;

    x2 = x*x ;
    y2 = y*y ;
    z2 = z*z ;
    dist = sqrt(x2+y2+z2) ;
    if (FZERO(dist))
    {
      d = 0 ;
    }
    else
    {
      d = 1 - r / dist ;
    }
    dx = d*x ;
    dy = d*y;
    dz = d*z;
    v->x = x-dx ;
    v->y = y-dy;
    v->z = z-dz;

    if (!finite(v->x) || !finite(v->y) || !finite(v->z))
    {
      DiagBreak() ;
    }

    /*    if ((Gdiag & DIAG_SHOW) && DIAG_VERBOSE_ON)*/
    {
      dist = sqrt((double)(dx*dx+dy*dy+dz*dz));
      total_dist += dist;
    }
#if 1
    x = (double)v->x;
    y = (double)v->y;
    z = (double)v->z;
    x2 = x*x ;
    y2 = y*y ;
    z2 = z*z ;
    dist = sqrt(x2+y2+z2) ;
#endif

  }
  if ((Gdiag & DIAG_SHOW) && DIAG_VERBOSE_ON)
  {
    fprintf(stdout,  "sphere_project: total dist = %f\n",total_dist);
  }
  MRISupdateEllipsoidSurface(mris_dst) ;
  mris_dst->status = mris_src->status == MRIS_PARAMETERIZED_SPHERE ?
                     MRIS_PARAMETERIZED_SPHERE : MRIS_SPHERE ;
  return(mris_dst) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Perform a projection onto an ellipsoid moving each
  point on the cortical surface to the closest ellipsoidal
  coordinate.
  ------------------------------------------------------*/
extern double sqrt(double) ;

MRI_SURFACE *
MRISprojectOntoEllipsoid(MRI_SURFACE *mris_src, MRI_SURFACE *mris_dst,
                         float a, float b, float c)
{
  VERTEX  *v;
  int     k;
  float   x,y,z,x2,y2,z2,dx,dy,dz,a2,b2,c2,a4,b4,c4,a6,b6,c6;
  float   f,g,h,d,dist,avgdist=0.0f ;

  if (FZERO(a))
  {
    a = DEFAULT_A ;
    b = DEFAULT_B ;
    c = DEFAULT_C ;
  }

  if (!mris_dst)
  {
    mris_dst = MRISclone(mris_src) ;
  }

  MRIScenter(mris_dst, mris_dst) ;

  mris_dst->a = a ;
  mris_dst->b = b ;
  mris_dst->c = c ;

  /*  printf("ellipsoid_project(%f,%f,%f)\n",a,b,c);*/
  a2 = a*a;
  b2 = b*b;
  c2 = c*c;
  a4 = a2*a2;
  b4 = b2*b2;
  c4 = c2*c2;
  a6 = a2*a4;
  b6 = b2*b4;
  c6 = c2*c4;

#if 0
  /* rescale brain so that it is contained within the ellipsoid */
  xscale = mris_dst->xhi / a ;
  yscale = mris_dst->yhi / b ;
  zscale = mris_dst->zhi / c ;
  if ((xscale > yscale) && (xscale > zscale))
  {
    scale = 1.0f / xscale ;
  }
  else if (yscale > zscale)
  {
    scale = 1.0f / yscale ;
  }
  else
  {
    scale = 1.0f / zscale ;
  }

  MRISscaleBrain(mris_dst, mris_dst, scale) ;
#endif

  for (k=0; k<mris_dst->nvertices; k++)
  {
    v = &mris_dst->vertices[k];
    /*
      printf("%6d: before: %6.2f\n",k,SQR(v->x/a)+SQR(v->y/b)+SQR(v->z/c));
    */
    x = v->x;
    y = v->y;
    z = v->z;
#if 0
    if ((fabs(x) > a) || (fabs(y) > b) || (fabs(z) > c))
    {
      return(MRISradialProjectOntoEllipsoid(mris_src, mris_dst, a, b, c)) ;
    }
#endif

    x2 = x*x;
    y2 = y*y;
    z2 = z*z;
    f = x2/a6+y2/b6+z2/c6;
    g = 2*(x2/a4+y2/b4+z2/c4);
    h = x2/a2+y2/b2+z2/c2-1;
    d = (-g+(float)sqrt((double)(g*g-4*f*h)))/(2*f);
    if (!finite(d))
    {
      ErrorPrintf(ERROR_BADPARM,
                  "point (%2.2f,%2.2f,%2.2f) cannot be projected on ell "
                  "(%2.0f,%2.0f,%2.0f...\n",
                  x, y, z, a, b, c) ;

      return(MRISradialProjectOntoEllipsoid(mris_src, mris_dst, a, b, c)) ;
    }
    dx = d*x/a2;
    dy = d*y/b2;
    dz = d*z/c2;
    v->x = x+dx ;
    v->y = y+dy;
    v->z = z+dz;

    if (!finite(v->x) || !finite(v->y) || !finite(v->z))
    {
      DiagBreak() ;
    }

    if ((Gdiag & DIAG_SHOW) && DIAG_VERBOSE_ON)
    {
      dist = (float)sqrt((double)(dx*dx+dy*dy+dz*dz));
      avgdist += dist;
    }
    /*
      printf("%6d: after: %6.2f\n",k,SQR(v->x/a)+SQR(v->y/b)+SQR(v->z/c));
    */
  }
  if ((Gdiag & DIAG_SHOW) && DIAG_VERBOSE_ON)
    fprintf(stdout,
            "ellipsoid_project: avgdist = %f\n",avgdist/mris_dst->nvertices);
  MRISupdateEllipsoidSurface(mris_dst) ;
  if (FZERO(a-b) && FZERO(b-c))
  {
    mris_dst->status = MRIS_SPHERE ;
  }
  else
  {
    mris_dst->status = MRIS_ELLIPSOID ;
  }
  return(mris_dst) ;
}



/*
  this one projects along the line from the origin to the ellipsoidal
  surface - not orthographic unless the ellipsoid is a sphere.
*/
MRI_SURFACE *
MRISradialProjectOntoEllipsoid(MRI_SURFACE *mris_src, MRI_SURFACE *mris_dst,
                               float a, float b, float c)
{
  int    vno ;
  VERTEX *vsrc, *vdst ;
  float  x0, y0, z0, x1, y1, z1, denom,
         asq_bsq, asq_csq, bsq_csq, x1sq, y1sq, z1sq, abc ;

  if (FZERO(a))
  {
    a = DEFAULT_A ;
    b = DEFAULT_B ;
    c = DEFAULT_C ;
  }

  if (!mris_dst)
  {
    mris_dst = MRISclone(mris_src) ;
  }

  x0 = mris_dst->xctr ;
  y0 = mris_dst->yctr ;
  z0 = mris_dst->zctr ;
  asq_bsq = a*a*b*b ;
  bsq_csq= b*b*c*c ;
  asq_csq = a*a*c*c ;
  abc = a * b * c ;

  for (vno = 0 ; vno < mris_src->nvertices ; vno++)
  {
    vsrc = &mris_src->vertices[vno] ;
    vdst = &mris_dst->vertices[vno] ;
    x1 = (vsrc->x-x0) ;
    y1 = (vsrc->y-y0) ;
    z1 = (vsrc->z-z0) ;
    x1sq = x1*x1 ;
    y1sq = y1*y1 ;
    z1sq = z1*z1 ;

    /* right out of mathematica (almost) */
    denom = sqrt(bsq_csq*x1sq + asq_csq*y1sq + asq_bsq*z1sq) ;

    vdst->x = abc*x1 / denom /* + x0 */ ;
    vdst->y = abc*y1 / denom /* + y0 */ ;
    vdst->z = abc*z1 / denom /* + z0 */ ;
  }

  x0 = y0 = z0 = 0 ;   /* set center of ellipsoid at origin */
#if 0
  if (mris_dst->v_temporal_pole)
  {
    mris_dst->v_temporal_pole->x = x0 ;
    mris_dst->v_temporal_pole->y = y0 ;
    mris_dst->v_temporal_pole->z = -c+z0 ;
    mris_dst->v_temporal_pole->tethered = TETHERED_TEMPORAL_POLE ;
  }
  if (mris_dst->v_frontal_pole)
  {
    mris_dst->v_frontal_pole->x = x0 ;
    mris_dst->v_frontal_pole->y = b+y0 ;
    mris_dst->v_frontal_pole->z = z0 ;
    mris_dst->v_frontal_pole->tethered = TETHERED_FRONTAL_POLE ;
  }
  if (mris_dst->v_occipital_pole)
  {
    mris_dst->v_occipital_pole->x = x0 ;
    mris_dst->v_occipital_pole->y = -b+y0 ;
    mris_dst->v_occipital_pole->z = z0 ;
    mris_dst->v_occipital_pole->tethered = TETHERED_OCCIPITAL_POLE ;
  }
#endif

  MRISupdateEllipsoidSurface(mris_dst) ;
  if (FZERO(a-b) && FZERO(b-c))
  {
    mris_dst->status = MRIS_SPHERE ;
  }
  else
  {
    mris_dst->status = MRIS_ELLIPSOID ;
  }
  return(mris_dst) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI_SURFACE *
MRISclone(MRI_SURFACE *mris_src)
{
  MRI_SURFACE *mris_dst ;
  int         vno, fno, n ;
  VERTEX      *vsrc, *vdst ;
  FACE        *fsrc, *fdst ;

  mris_dst = MRISalloc(mris_src->nvertices, mris_src->nfaces) ;

  mris_dst->type = mris_src->type;  // missing
  mris_dst->hemisphere = mris_src->hemisphere ;
  mris_dst->xctr = mris_src->xctr ;
  mris_dst->yctr = mris_src->yctr ;
  mris_dst->zctr = mris_src->zctr ;
  mris_dst->xlo = mris_src->xlo ;
  mris_dst->ylo = mris_src->ylo ;
  mris_dst->zlo = mris_src->zlo ;
  mris_dst->xhi = mris_src->xhi ;
  mris_dst->yhi = mris_src->yhi ;
  mris_dst->zhi = mris_src->zhi ;
  mris_dst->min_curv = mris_src->min_curv ;
  mris_dst->max_curv = mris_src->max_curv ;
  mris_dst->total_area = mris_src->total_area ;
  mris_dst->orig_area = mris_src->orig_area ;

  mris_dst->radius = mris_src->radius; // to be checked

  mris_dst->avg_vertex_area = mris_src->avg_vertex_area;
  mris_dst->avg_vertex_dist = mris_src->avg_vertex_dist;
  mris_dst->std_vertex_dist = mris_src->std_vertex_dist;

  // just copy the pointer ///////////////////////////////////
  mris_dst->lta = mris_src->lta;
  mris_dst->SRASToTalSRAS_ = mris_src->SRASToTalSRAS_;
  mris_dst->TalSRASToSRAS_ = mris_src->TalSRASToSRAS_;
  mris_dst->free_transform = 0 ;  // mark not to try to free them
  /////////////////////////////////////////////////////////////
  if (mris_src->v_frontal_pole)
    mris_dst->v_frontal_pole =
      &mris_dst->vertices[mris_src->v_frontal_pole - mris_src->vertices] ;
  if (mris_src->v_occipital_pole)
    mris_dst->v_occipital_pole =
      &mris_dst->vertices[mris_src->v_occipital_pole - mris_src->vertices] ;
  if (mris_src->v_temporal_pole)
    mris_dst->v_temporal_pole =
      &mris_dst->vertices[mris_src->v_temporal_pole - mris_src->vertices] ;
  for (vno = 0 ; vno < mris_src->nvertices ; vno++)
  {
    if (vno== Gdiag_no)
    {
      DiagBreak() ;
    }
    vsrc = &mris_src->vertices[vno] ;
    vdst = &mris_dst->vertices[vno] ;
    vdst->x = vsrc->x ;
    vdst->y = vsrc->y ;
    vdst->z = vsrc->z ;
    vdst->nx = vsrc->nx ;
    vdst->ny = vsrc->ny ;
    vdst->nz = vsrc->nz ;
    vdst->cx = vsrc->cx ;
    vdst->cy = vsrc->cy ;
    vdst->cz = vsrc->cz ;
    vdst->curv = vsrc->curv ;
    vdst->num = vsrc->num ;
    vdst->vnum = vsrc->vnum ;
    vdst->v2num = vsrc->v2num ;
    vdst->v3num = vsrc->v3num ;
    vdst->vtotal = vsrc->vtotal ;
#if 0
    vdst->ox = vsrc->ox ;
    vdst->oy = vsrc->oy ;
    vdst->oz = vsrc->oz ;
#endif

    if (vdst->num)
    {
      vdst->f = (int *)calloc(vdst->num,sizeof(int));
      if (!vdst->f)
        ErrorExit(ERROR_NO_MEMORY, "MRISclone: could not allocate %d faces",
                  vdst->num) ;
      vdst->n = (uchar *)calloc(vdst->num,sizeof(uchar));
      if (!vdst->n)
        ErrorExit(ERROR_NO_MEMORY, "MRISclone: could not allocate %d num",
                  vdst->num) ;
      vdst->dist = (float *)calloc(vdst->vtotal, sizeof(float)) ;
      if (!vdst->dist )
        ErrorExit
        (ERROR_NO_MEMORY,
         "MRISclone: could not allocate %d num",
         vdst->vtotal) ;
      vdst->dist_orig = (float *)calloc(vdst->vtotal, sizeof(float)) ;
      if (!vdst->dist_orig )
        ErrorExit
        (ERROR_NO_MEMORY,
         "MRISclone: could not allocate %d num",
         vdst->vtotal) ;
      for (n = 0; n < vdst->num; n++)
      {
        vdst->n[n] = vsrc->n[n] ;
        vdst->f[n] = vsrc->f[n] ;
      }
      if (vsrc->dist)
        for (n = 0; n < vdst->vtotal; n++)
        {
          vdst->dist[n] = vsrc->dist[n] ;
        }
      if (vsrc->dist_orig)
        for (n = 0 ; n < vdst->vtotal; n++)
        {
          vdst->dist_orig[n] = vsrc->dist_orig[n] ;
        }
    }
    if (vdst->vnum)
    {
      vdst->v = (int *)calloc(vdst->vtotal, sizeof(int)) ;
      if (!vdst->v)
        ErrorExit(ERROR_NO_MEMORY, "MRISclone: could not allocate %d nbrs",
                  vdst->vtotal) ;
      for (n = 0; n < vdst->vtotal; n++)
      {
        vdst->v[n] = vsrc->v[n] ;
      }
    }
    vdst->ripflag = vsrc->ripflag ;
    vdst->border = vsrc->border ;
    vdst->area = vsrc->area ;
    vdst->origarea = vsrc->origarea ;
#if 0
    vdst->oripflag = vsrc->oripflag ;
    vdst->origripflag = vsrc->origripflag ;
    memmove(vdst->coord, vsrc->coord, sizeof(vsrc->coord)) ;
#endif
  }

  for (fno = 0 ; fno < mris_src->nfaces ; fno++)
  {
    fsrc = &mris_src->faces[fno] ;
    fdst = &mris_dst->faces[fno] ;
    memmove(fdst, fsrc, sizeof(FACE)) ;
  }
  // copy geometry info
  copyVolGeom(&mris_src->vg, &mris_dst->vg);

  return(mris_dst) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI_SURFACE *
MRIScenter(MRI_SURFACE *mris_src, MRI_SURFACE *mris_dst)
{
  int         vno ;
  VERTEX      *vdst ;
  float       x, y, z, x0, y0, z0, xlo, xhi, zlo, zhi, ylo, yhi ;

  if (!mris_dst)
  {
    mris_dst = MRISclone(mris_src) ;
  }

  x = y = z = 0 ;   /* silly compiler warning */
  xhi=yhi=zhi= -10000;
  xlo=ylo=zlo= 10000;
  for (vno = 0 ; vno < mris_src->nvertices ; vno++)
  {
    vdst = &mris_dst->vertices[vno] ;
    if (vdst->ripflag)
    {
      continue ;
    }
    x = vdst->x;
    y = vdst->y;
    z = vdst->z;
    if (x>xhi)
    {
      xhi=x;
    }
    if (x<xlo)
    {
      xlo=x;
    }
    if (y>yhi)
    {
      yhi=y;
    }
    if (y<ylo)
    {
      ylo=y;
    }
    if (z>zhi)
    {
      zhi=z;
    }
    if (z<zlo)
    {
      zlo=z;
    }
  }
  x0 = (xlo+xhi)/2.0f ;
  y0 = (ylo+yhi)/2.0f ;
  z0 = (zlo+zhi)/2.0f ;
  xhi=yhi=zhi= -10000;
  xlo=ylo=zlo= 10000;
  for (vno = 0 ; vno < mris_src->nvertices ; vno++)
  {
    vdst = &mris_dst->vertices[vno] ;
    if (vdst->ripflag)
    {
      continue ;
    }
    vdst->x -= x0 ;
    vdst->y -= y0 ;
    vdst->z -= z0 ;
    if (x>xhi)
    {
      xhi=x;
    }
    if (x<xlo)
    {
      xlo=x;
    }
    if (y>yhi)
    {
      yhi=y;
    }
    if (y<ylo)
    {
      ylo=y;
    }
    if (z>zhi)
    {
      zhi=z;
    }
    if (z<zlo)
    {
      zlo=z;
    }
  }

  mris_dst->xctr = mris_dst->yctr = mris_dst->zctr = 0 ;
  mris_dst->xlo = xlo ;
  mris_dst->ylo = ylo ;
  mris_dst->zlo = zlo ;
  mris_dst->xhi = xhi ;
  mris_dst->yhi = yhi ;
  mris_dst->zhi = zhi ;

  return(mris_dst) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description

  The following function is broken, since it is applying a
  transform for surfaceRAS space.  If transform has c_(ras)
  values, the result would be different.

  conformed -----> surfaceRAS
  |                |        [ 1 Csrc]
  V                V        [ 0  1  ]
  src    ----->    RAS
  |                |
  |                |  Xfm
  V                V
  talvol   ----->  talRAS
  |                |        [ 1 -Ctal]
  |                |        [ 0  1   ]
  V                V
  conformed -----> surfaceRAS

  Thus

  surfRASToTalSurfRAS = [ 1 -Ctal ]*[ R  T ]*[ 1 Csrc ]=
  [ R  T + R*Csrc - Ctal ]
  [ 0   1   ] [ 0  1 ] [ 0   1  ]  [ 0         1          ]

  We need to know the Csrc and Ctal values
  ------------------------------------------------------*/
MRI_SURFACE *
MRIStalairachTransform(MRI_SURFACE *mris_src, MRI_SURFACE *mris_dst)
{
  int         vno ;
  VERTEX      *v ;
  double        x, y, z, xt, yt, zt ;
  float       xlo, ylo, zlo, xhi, yhi, zhi ;

  if (!mris_dst)
  {
    mris_dst = MRISclone(mris_src) ;
  }

  if (!mris_src->lta)
  {
    return (mris_dst);
  }

#if 0
  if (!mris_src->linear_transform)
  {
    return(mris_dst) ;
  }

  ErrorReturn(mris_dst,
              (ERROR_BADPARM, "MRIStalairachTransform: no xform loaded")) ;
#endif


  xhi=yhi=zhi= -10000;
  xlo=ylo=zlo= 10000;
  for (vno = 0 ; vno < mris_src->nvertices ; vno++)
  {
    v = &mris_dst->vertices[vno] ;

    x = v->x ;
    y = v->y ;
    z = v->z ; // we cloned the src
    TransformWithMatrix(mris_src->SRASToTalSRAS_, x, y, z, &xt, &yt, &zt);
    // transform_point(mris_src->linear_transform, -x, z, y, &xt, &yt, &zt) ;
    // v->x = -xt ; v->y = zt ; v->z = yt ;
    v->x = xt;
    v->y = yt;
    v->z = zt;

    if (v->x > xhi)
    {
      xhi = v->x;
    }
    if (v->x < xlo)
    {
      xlo = v->x;
    }
    if (v->y > yhi)
    {
      yhi = v->y;
    }
    if (v->y < ylo)
    {
      ylo = v->y;
    }
    if (v->z > zhi)
    {
      zhi = v->z;
    }
    if (v->z < zlo)
    {
      zlo = v->z;
    }
  }

  mris_dst->xlo = xlo ;
  mris_dst->ylo = ylo ;
  mris_dst->zlo = zlo ;
  mris_dst->xctr = (xhi + xlo)/2 ;
  mris_dst->yctr = (yhi + ylo)/2 ;
  mris_dst->zctr = (zhi + zlo)/2 ;

  return(mris_dst) ;
}

#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisCountNegativeVertices(MRI_SURFACE *mris)
{
  int     vno, neg ;
  VERTEX  *v ;

  for (neg = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (v->neg)
    {
      neg++ ;
    }
  }

  return(neg) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI_SURFACE *
MRISremoveNegativeVertices(MRI_SURFACE *mris, INTEGRATION_PARMS *parms,
                           int min_neg, float min_neg_pct)
{
  int   t, niterations, write_iterations, neg, total_vertices, base_avgs ;
  float pct_neg, delta_t, scale, pct_neg_area, l_dist ;

  if (min_neg < 0)
  {
    min_neg = 0 ;
  }
  if (min_neg_pct < 0.0f)
  {
    min_neg_pct = 0.0f ;
  }

  if (Gdiag & DIAG_WRITE && parms->fp == NULL)
  {
    char fname[STRLEN] ;

    sprintf
    (fname, "%s.%s.out",
     mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",parms->base_name);
    parms->fp = fopen(fname, "w") ;
    if (!parms->fp)
      ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                Progname, fname) ;
    mrisLogIntegrationParms(parms->fp, mris, parms) ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogIntegrationParms(stderr, mris, parms) ;
  }

  parms->start_t = 0 ;
  mrisProjectSurface(mris) ;
  if (Gdiag & DIAG_WRITE)
  {
    mrisLogStatus(mris, parms, parms->fp, 0.0f, -1) ;
  }
  mrisClearMomentum(mris) ;
  niterations = parms->niterations ;
  write_iterations = parms->write_iterations ;
  if (Gdiag & DIAG_WRITE && write_iterations > 0)
  {
    mrisWriteSnapshot(mris, parms, 0) ;
  }
  total_vertices = MRISvalidVertices(mris) ;
  neg = mrisCountNegativeVertices(mris) ;
  pct_neg = (float)neg / (float)total_vertices ;
  l_dist = parms->l_dist ;
  pct_neg_area =
    (float)mris->neg_area / (float)(mris->total_area+mris->neg_area) ;
  base_avgs = parms->n_averages ;
  for (t = 0 ;
       (t < niterations) && (neg > min_neg) && (pct_neg_area > min_neg_pct) ;
       t++)
  {
    if (pct_neg_area < 0.001)  /* hack!!, but it speeds things up */
    {
      parms->l_dist *= 1.1 ;
      if (parms->l_dist > 10*l_dist)
      {
        parms->l_dist = 10*l_dist ;
      }
      if (parms->l_dist > 1.0)
      {
        parms->l_dist = 1.0 ;
      }
    }
    if (pct_neg_area < 0.001)  /* another hack!!, but it speeds things up */
    {
      static int first = 1 ;
      /* don't want big steps or momentum for fine-scale stuff */
      parms->momentum = 0.0f ;
      parms->dt = 0.1 ;
      if (Gdiag & DIAG_SHOW && first)
        fprintf(stdout, "setting momentum=%2.1f, dt=%2.1f, l_dist=%2.2f\n",
                parms->momentum, parms->dt, parms->l_dist) ;
      first = 0 ;
    }

    if (mris->patch)  /* area is constant so spring force doesn't decrease */
    {
      scale = sqrt(mris->orig_area / (mris->total_area+mris->neg_area)) ;
      MRISscaleBrain(mris, mris, scale) ;
      MRIScomputeMetricProperties(mris) ;
    }
    else
    {
      mrisComputeVertexDistances(mris) ;
    }
    MRISclearGradient(mris) ;
    mrisComputeSpringTerm(mris, parms->l_spring) ;
    mrisComputeLaplacianTerm(mris, parms->l_lap) ;
    mrisComputeDistanceTerm(mris, parms) ;
    mrisComputeAngleAreaTerms(mris, parms) ;
    /*    mrisAverageGradient(mris, parms->n_averages) ;*/

    switch (parms->integration_type)
    {
    case INTEGRATE_LM_SEARCH:
      delta_t = mrisLineMinimizeSearch(mris, parms) ;
      break ;
    default:
    case INTEGRATE_LINE_MINIMIZE:
      delta_t = mrisLineMinimize(mris, parms) ;
      break ;
    case INTEGRATE_MOMENTUM:
      delta_t = MRISmomentumTimeStep(mris, parms->momentum, parms->dt,
                                     parms->tol, parms->n_averages) ;
      break ;
    case INTEGRATE_ADAPTIVE:
      delta_t = mrisAdaptiveTimeStep(mris, parms);
      break ;
    }
    mrisProjectSurface(mris) ;
    MRIScomputeMetricProperties(mris) ;
    neg = mrisCountNegativeVertices(mris) ;
    pct_neg = (float)neg / (float)total_vertices ;
    pct_neg_area =
      (float)mris->neg_area / (float)(mris->total_area+mris->neg_area) ;
    if (Gdiag & DIAG_SHOW)
      fprintf(stdout,
              "%3.3d: count: %d (%2.2f%%), area: %2.2f (%2.2f%%)   \n",
              t, neg, 100.0f*pct_neg, mris->neg_area, 100.0f*pct_neg_area) ;
    if ((write_iterations > 0) &&
        !((t+1)%write_iterations)&&(Gdiag&DIAG_WRITE))
    {
      mrisWriteSnapshot(mris, parms, t+1) ;
    }
    if (parms->n_averages == 0)
    {
      parms->n_averages = base_avgs ;
    }
    else
    {
      parms->n_averages /= 2 ;
    }
  }

  parms->n_averages = base_avgs ;
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "\n") ;
    if (Gdiag & DIAG_WRITE)
    {
      fclose(parms->fp) ;
      parms->fp = NULL ;
    }
  }
  mrisProjectSurface(mris) ;
  return(mris) ;
}
#endif


#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI_SURFACE  *
MRISflatten(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int     base_averages, n_averages, done, steps, total_steps ;
  float   base_tol ;
  double  starting_sse, ending_sse ;

  base_averages = parms->n_averages ;


  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    sprintf(fname, "%s.out", parms->base_name) ;
    parms->fp = fopen(fname, "w") ;
    if (!parms->fp)
      ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                Progname, fname) ;
    mrisLogIntegrationParms(parms->fp, mris, parms) ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogIntegrationParms(stderr, mris, parms) ;
  }


  parms->start_t = 0 ;
  base_tol = parms->tol ;
  do
  {
    done = 0 ;
    mrisClearMomentum(mris) ;
    starting_sse = MRIScomputeSSE(mris, parms) ;
    for (total_steps = 0, n_averages = base_averages; !done ; n_averages /= 2)
    {
      steps = MRISintegrate(mris, parms, n_averages) ;
      parms->start_t += steps ;
      total_steps += steps ;
      done = n_averages == 0 ;   /* finished integrating
                                                    at smallest scale */
    }
    parms->dt = parms->base_dt ;         /* reset time step */
    ending_sse = MRIScomputeSSE(mris, parms) ;
  }
  while (!FZERO(ending_sse) && ((starting_sse-ending_sse) > parms->tol)) ;


  if (Gdiag & DIAG_WRITE)
  {
    fclose(parms->fp) ;
    parms->fp = NULL ;
  }

  mrisProjectSurface(mris) ;
  return(mris) ;
}
#endif


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static float sigmas_default[] =
{
  //    16.00, 4.0f, 2.0f, 1.0f, 0.5f
  //    8.00f, 4.00f, 2.0f, 0.5f
  4.00f, 2.0f, 1.0f, 0.5f
} ;
static float *sigmas = sigmas_default ;  // can be changed by caller
#define NSIGMAS  (sizeof(sigmas_default)  / sizeof(sigmas_default[0]))
static double nsigmas = NSIGMAS ;

int
MRISsetRegistrationSigmas(float *sigmas_local, int nsigmas_local)
{
  if (sigmas_local == NULL)
  {
    nsigmas = NSIGMAS ;
    sigmas = sigmas_default ;
  }
  else
  {
    nsigmas = nsigmas_local ;
    sigmas = sigmas_local ;
  }
  return(NO_ERROR) ;
}

static char *surface_names[] =
{
  "inflated",
  "smoothwm",
  "smoothwm"
} ;

static char *curvature_names[] =
{
  "inflated.H",
  "sulc",
  NULL
} ;

int MRISsetCurvatureName(int nth, char *name)
{
  if(nth > 2){
    printf("ERROR: MRISsetCurvatureName() nth=%d > 2\n",nth);
    return(1);
  }
  curvature_names[nth] = strcpyalloc(name);
  return(0);
}
int MRISprintCurvatureNames(FILE *fp)
{
  int k;
  for(k=0; k < sizeof(curvature_names)/sizeof(curvature_names[0]); k++)
    printf("%d %s\n",k,curvature_names[k]);
  return(0);
}

int
MRISsetInflatedFileName(char *inflated_name)
{
  char fname[STRLEN] ;

  surface_names[0] = inflated_name ;
  sprintf(fname, "%s.H", inflated_name) ;
  curvature_names[0] = (char *)calloc(strlen(fname)+1, sizeof(char)) ;
  strcpy(curvature_names[0], fname) ;
  return(NO_ERROR) ;
}

int
MRISsetSulcFileName(const char *sulc_name)
{
  curvature_names[1] = (char *)calloc(strlen(sulc_name)+1, sizeof(char)) ;
  strcpy(curvature_names[1], sulc_name) ;
  return(NO_ERROR) ;
}

int
MRISsetOriginalFileName(char *orig_name)
{
  surface_names[1] = surface_names[2] = orig_name ;
  return(NO_ERROR) ;
}


#define IMAGES_PER_SURFACE   3   /* mean, variance, and dof */
#define SURFACES         sizeof(curvature_names) / sizeof(curvature_names[0])
#define PARAM_IMAGES         (IMAGES_PER_SURFACE*SURFACES)

/*
  Note that at the start of this function, the ORIGINAL_VERTICES must
  contain the surface that has the metric properties to be preserved (e.g.
  smoothwm, white), and the CANONICAL_VERTICES must contain the uniform
  spherical surface (e.g. ?h.sphere).
*/
int
MRISregister(MRI_SURFACE *mris, MRI_SP *mrisp_template,
             INTEGRATION_PARMS *parms,
             int max_passes, float min_degrees, float max_degrees, int nangles)
{
  float   sigma /*, target_sigma, dof*/ ;
  int     i, start_t, done, sno, ino, msec, min_averages=0,
    nsurfaces, using_big_averages=0 ;
  MRI_SP  *mrisp ;
  char    fname[STRLEN], base_name[STRLEN], path[STRLEN] ;
  double  base_dt ;
  struct  timeb start ;
  int first = 1 ;
  INTEGRATION_PARMS saved_parms ;

  printf("MRISregister() -------\n");
  printf("max_passes = %d \n",max_passes);
  printf("min_degrees = %f \n",min_degrees);
  printf("max_degrees = %f \n",max_degrees);
  printf("nangles = %d \n",nangles);
  mrisLogIntegrationParms(stdout, mris, parms) ;
  printf("--------------------\n");

  saved_parms = *parms ;

  if (IS_QUADRANGULAR(mris))
  {
    MRISremoveTriangleLinks(mris) ;
  }
  TimerStart(&start) ;
  FileNamePath(mris->fname, path) ;
  sprintf(base_name, "%s/%s.%s", path,
          mris->hemisphere == LEFT_HEMISPHERE ? "lh":"rh", parms->base_name);

  if (parms->nbhd_size > 3)
  {
    int nbrs[MAX_NBHD_SIZE] ;

    printf("sampling long-range distances\n") ;
    memset(nbrs, 0, MAX_NBHD_SIZE*sizeof(nbrs[0])) ;
    for (i = mris->nsize+1 ; i <= parms->nbhd_size ; i++)
    {
      nbrs[i] = parms->max_nbrs ;
    }
    MRISsaveVertexPositions(mris, TMP_VERTICES) ;
    MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
    MRISsampleDistances(mris, nbrs, parms->nbhd_size) ;
    MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
    MRIScomputeMetricProperties(mris) ;
  }
  base_dt = parms->dt ;
  if (Gdiag & DIAG_WRITE)
  {
    sprintf
    (fname, "%s.%s.out",
     mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",parms->base_name);
    if (!parms->start_t)
    {
      parms->fp = fopen(fname, "w") ;
    }
    else
    {
      parms->fp = fopen(fname, "a") ;
    }
    if (!parms->fp)
      ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                Progname, fname) ;
    mrisLogIntegrationParms(parms->fp, mris,parms) ;
  }
//  if (Gdiag & DIAG_SHOW)
  mrisLogIntegrationParms(stderr, mris,parms) ;

  if (parms->flags & IP_NO_SULC)
  {
    fprintf(stderr,"will not use the sulcal depth map\n");
    fprintf(stderr,"will not rigidly align the surface\n");
    first = 0 ;
    sno = 2 ;
  }
  else if (parms->flags & IP_USE_INFLATED)
  {
    sno = 0 ;
  }
  else
  {
    sno = 1 ;
  }

  if (parms->nsurfaces > 0)
  {
    nsurfaces = parms->nsurfaces ;
  }
  else
  {
    nsurfaces = SURFACES ;
  }

  using_big_averages = ((parms->start_t == 0) && 
                        (parms->first_pass_averages > 0)) ;
  for (; sno < nsurfaces ; sno++)
  {
    if (!first && ((parms->flags & IP_USE_CURVATURE) == 0))
    {
      break ;
    }

    ino = parms->frame_no = sno*IMAGES_PER_SURFACE ;
    if (curvature_names[sno])  /* read in precomputed curvature file */
    {
      sprintf(fname, "%s.%s",
              mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",
              curvature_names[sno]) ;
      printf("%d Reading %s\n",sno,fname);
      if (MRISreadCurvatureFile(mris, fname) != NO_ERROR)
        ErrorExit(Gerror, "%s: could not read curvature file '%s'\n",
                  "MRISregister", fname) ;
      MRISnormalizeCurvature(mris, parms->which_norm) ;
      if (parms->trinarize_thresh > 0)
      {
        MRIStrinarizeCurvature(mris, parms->trinarize_thresh) ;
      }
    }
    else                       /* compute curvature of surface */
    {
      sprintf(fname, "%s", surface_names[sno]) ;
      MRISsaveVertexPositions(mris, TMP_VERTICES) ;
      printf("%d Reading %s\n",sno,fname);
      if (MRISreadVertexPositions(mris, fname) != NO_ERROR)
        ErrorExit(ERROR_NOFILE, "%s: could not read surface file %s",
                  "MRISregister", fname) ;

      MRISresetNeighborhoodSize(mris, -1) ;  /* back to max */
      MRIScomputeMetricProperties(mris) ;
      MRIScomputeSecondFundamentalForm(mris) ;
      MRISuseMeanCurvature(mris) ;
      MRISnormalizeCurvature(mris, parms->which_norm) ;
      MRISresetNeighborhoodSize(mris,1);/*only use nearest neighbor distances*/

      MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
      MRIScomputeMetricProperties(mris) ;
    }
    MRISstoreMeanCurvature(mris) ; // store current curv target in H

    if (Gdiag & DIAG_SHOW)
    {
      if (curvature_names[sno])
      {
        printf("reading precomputed curvature from %s\n",fname) ;
      }
      else
      {
        printf("calculating curvature of %s surface\n",fname) ;
      }
    }

    if (Gdiag & DIAG_WRITE)
    {
      if (curvature_names[sno])
      {
        fprintf(parms->fp,"using precomputed curvature from %s\n",fname);
      }
      else
      {
        fprintf(parms->fp,"calculating curvature of %s surface\n",fname);
      }
    }

    if (sno == 2 && parms->flags & IP_USE_CURVATURE)
    {
      /* only small adjustments needed after 1st time around */
      parms->tol *= 2.0f ;
      parms->l_corr /= 20.0f ;  // should be more adaptive - used to be 20
#if 1
      parms->l_spring = .5 ;     // regularize mesh
#else
      MRISclearOrigDistances(mris) ;  // replicates old bug
#endif
      if (Gdiag & DIAG_WRITE)
      {
        mrisLogIntegrationParms(parms->fp, mris, parms) ;
      }
//      if (Gdiag & DIAG_SHOW)
      mrisLogIntegrationParms(stderr, mris, parms) ;
    }
    else if (!first) /* don't do curvature alignment */
    {
      break ;  /* finished */
    }

    if (sno == 0) // doing inflated - make it fairly rigid
    {
      /* only small adjustments needed after 1st time around */
      min_averages = parms->min_averages ;
      parms->min_averages = 256;
      parms->l_corr /= 3.0f ;  /* should be more adaptive */
      if (Gdiag & DIAG_WRITE)
      {
        mrisLogIntegrationParms(parms->fp, mris, parms) ;
      }
//      if (Gdiag & DIAG_SHOW)
      mrisLogIntegrationParms(stderr, mris, parms) ;
    }

    for (i = 0 ; i < nsigmas ; i++)  /* for each spatial scale (blurring) */
    {
      parms->sigma = sigma = sigmas[i] ;
      parms->dt = base_dt ;
      if (Gdiag & DIAG_SHOW)
        fprintf(stdout,
                "\nblurring surfaces with sigma=%2.2f...\n", sigma) ;
      if (Gdiag & DIAG_WRITE)
        fprintf(parms->fp,"\ncorrelating surfaces with with sigma=%2.2f\n",
                sigma) ;
      if ((Gdiag & DIAG_WRITE) && !i && (!parms->start_t || sno <= 1))
      {
        fprintf(parms->fp,
                "writing target curvature, i=%d, start_t=%d, "
                "sno=%d, v0=(%2.1f, %2.1f, %2.1f)\n",
                i, parms->start_t, sno,
                mris->vertices[0].cx,
                mris->vertices[0].cy,
                mris->vertices[0].cz) ;
        fflush(parms->fp) ;
        MRISsaveVertexPositions(mris, TMP_VERTICES) ;
        MRISrestoreVertexPositions(mris, CANONICAL_VERTICES) ;
        MRIScomputeMetricProperties(mris) ;
        MRISfromParameterization(mrisp_template, mris, ino);
        MRISnormalizeCurvature(mris, parms->which_norm) ;
        sprintf
        (fname,
         "%s/%s.%s.target%d",
         path, mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",
         parms->base_name, sno) ;
        MRISwriteCurvature(mris, fname) ;
        MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
        MRIScomputeMetricProperties(mris) ;
      }
      MRISuseMeanCurvature(mris) ;  // restore current target
      mrisp = MRIStoParameterization(mris, NULL, 1, 0) ;
#if 1
      parms->mrisp = MRISPblur(mrisp, NULL, sigma, 0) ;
      parms->mrisp_template = MRISPblur(mrisp_template, NULL, sigma, ino) ;
      MRISPblur(parms->mrisp_template,
                parms->mrisp_template,
                sigma,
                ino+1) ; /* variances */
#else
      dof = *IMAGEFseq_pix(mrisp_template->Ip, 0, 0, 2)  ;
      if (dof < 1)
      {
        dof = 1 ;
      }
      target_sigma = sigma / dof ;
      target_sigma = sigma ;
      printf("template has %2.0f dofs - setting target sigma to %2.2f\n",
             dof, target_sigma) ;
      parms->mrisp = MRISPiterative_blur(mris, mrisp, NULL, sigma, 0) ;
      parms->mrisp_template =
        MRISPiterative_blur(mris, mrisp_template, NULL, target_sigma, ino) ;
      MRISPiterative_blur(mris,
                          parms->mrisp_template,
                          parms->mrisp_template,
                          target_sigma,
                          ino+1) ; /* variances */
#endif
      if (Gdiag & DIAG_SHOW)
      {
        fprintf(stdout, "done.\n") ;
      }
      /* normalize curvature intensities for both source and target */
      MRISfromParameterization(parms->mrisp_template, mris, ino);
      MRISnormalizeCurvature(mris, parms->which_norm) ;
      MRIStoParameterization(mris, parms->mrisp_template, 1, ino) ;

#if 0
      /* normalize variances for both source and target */
      MRISfromParameterization(parms->mrisp_template, mris, ino+1);
      MRISnormalizeCurvature(mris, parms->which_norm) ;
      MRIStoParameterization(mris, parms->mrisp_template, 1, ino+1) ;
#endif

      if (Gdiag & DIAG_WRITE)
      {
#if 1
        MRISsaveVertexPositions(mris, TMP_VERTICES) ;
        MRISrestoreVertexPositions(mris, CANONICAL_VERTICES) ;
        MRIScomputeMetricProperties(mris) ;
#endif
        MRISfromParameterization(mrisp_template, mris, ino);
        sprintf(fname, "%s/%s.%s.sno%d_target_blur%2.2f",
                path,
                mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",
                parms->base_name, sno, sigma) ;
        MRISwriteCurvature(mris, fname) ;
#if 1
        MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
        MRIScomputeMetricProperties(mris) ;
#endif
      }

      MRISfromParameterization(parms->mrisp, mris, 0);
      MRISnormalizeCurvature(mris, parms->which_norm) ;
      MRIStoParameterization(mris, parms->mrisp, 1, 0) ;
      MRISPfree(&mrisp) ;

      if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
      {
        MRISPwrite(parms->mrisp, "mrisp_blur.hipl") ;
        MRISPwrite(parms->mrisp_template, "mrisp_template_blur.hipl") ;
      }
      mris->vp = (void *)parms->mrisp ;  /* hack to get it
                                  to projectSurface */

      if (Gdiag & DIAG_WRITE)
      {
        sprintf(fname, "%s/%s.%s.sno%d_blur%2.2f",
                path,
                mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",
                parms->base_name, sno, sigma) ;
        MRISwriteCurvature(mris, fname) ;
      }
      if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
      {
        sprintf(fname, "%s/%s.%s.%4.4dblur%2.2f",
                path, mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",
                parms->base_name, parms->start_t, sigma) ;
        if (Gdiag & DIAG_SHOW)
        {
          fprintf(stdout, "writing curvature file %s...", fname) ;
        }
        MRISwriteCurvature(mris, fname) ;
        if (Gdiag & DIAG_SHOW)
        {
          fprintf(stdout, "done.\n") ;
        }
        sprintf(fname, "target.%s.%4.4d.hipl",
                parms->base_name,parms->start_t);
        if (Gdiag & DIAG_SHOW)
        {
          fprintf(stdout, "writing parameterization file %s...", fname) ;
        }
        MRISPwrite(parms->mrisp_template, fname) ;
        if (Gdiag & DIAG_SHOW)
        {
          fprintf(stdout, "done.\n") ;
        }
      }
      if (first && i == 0)  /* only do rigid alignment first time through */
      {
        if (sno >= 1)  // do global rigid for both inflated and sulc
        {
          first = 0 ;
        }
        if ((parms->flags & IP_NO_RIGID_ALIGN) == 0)
        {
          if (Gdiag & DIAG_SHOW)
          {
            fprintf(stdout, "finding optimal rigid alignment\n") ;
          }
          if (Gdiag & DIAG_WRITE)
          {
            fprintf(parms->fp, "finding optimal rigid alignment\n") ;
          }
          MRISrigidBodyAlignGlobal(mris, parms,
                                   min_degrees, max_degrees, nangles) ;
          /* MRISrigidBodyAlignGlobal(mris, parms, 0.5f, 32.0f, 8) ;*/
          if (Gdiag & DIAG_WRITE && parms->write_iterations != 0)
          {
            char fname[STRLEN], path[STRLEN] ;
            FileNamePath(mris->fname, path) ;
            sprintf(fname, "%s/%s.%s.sno%d.rotated",
                    path,
                    mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",
                    parms->base_name, sno) ;
            printf("writing rigid aligned surface to %s\n",fname);
            MRISwrite(mris, fname) ;
          }
          MRISsaveVertexPositions(mris, TMP2_VERTICES) ;
          if (parms->niterations == 0)  // only rigid
          {
            break ;
          }
        }
      }

      mrisClearMomentum(mris) ;
      done = 0 ;
      if (using_big_averages)
      {
        float sigma = 4.0 ;
        MRISsetRegistrationSigmas(&sigma, 1) ;
        mrisIntegrationEpoch(mris, parms, parms->first_pass_averages) ;
        MRISsetRegistrationSigmas(NULL, 0) ;
        using_big_averages = 0 ;
      }
      mrisIntegrationEpoch(mris, parms, parms->n_averages) ;
    }
    if (parms->niterations == 0)  // only rigid
    {
      break ;
    }
    if (sno == 0) // doing inflated - was fairly rigid - restore orig values
    {
      /* only small adjustments needed after 1st time around */
      parms->min_averages = min_averages ;
      parms->l_corr *= 3.0f ;  /* should be more adaptive */
      if (Gdiag & DIAG_WRITE)
      {
        mrisLogIntegrationParms(parms->fp, mris, parms) ;
      }
      if (Gdiag & DIAG_SHOW)
      {
        mrisLogIntegrationParms(stderr, mris, parms) ;
      }
    }
  }

#if 1
  if (mris->neg_area > 0)
  {
    parms->tol /= 10 ;  /* remove everything possible pretty much */
    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, "\nRemoving remaining folds...\n") ;
    }
    if (Gdiag & DIAG_WRITE)
    {
      fprintf(parms->fp, "removing remaining folds...\n") ;
    }
    parms->l_nlarea *= 100  ;
    parms->n_averages = 64 ;  // don't let averaging effect too much of surface
    parms->l_parea /= 100 ;
    parms->l_spring /= 100 ;
    parms->l_corr /= 100 ;
    parms->l_dist /= 100;
    mrisIntegrationEpoch(mris, parms, parms->n_averages) ;
  }
#else
  parms->l_nlarea = 1 ;
  parms->l_corr /= 10.0 ;
  parms->l_area = parms->l_parea = parms->l_spring = 0.0 ;
  mrisRemoveNegativeArea(mris,parms,parms->n_averages,MAX_NEG_AREA_PCT,3);
#endif
#if 0
  MRISPfree(&parms->mrisp) ;
  MRISPfree(&parms->mrisp_template) ;
#endif
  msec = TimerStop(&start) ;
  if (Gdiag & DIAG_SHOW)
    fprintf(stdout, "registration took %2.2f hours\n",
            (float)msec/(1000.0f*60.0f*60.0f));
  if (Gdiag & DIAG_WRITE)
  {
    fprintf(parms->fp, "registration took %2.2f hours\n",
            (float)msec/(1000.0f*60.0f*60.0f));
    fclose(parms->fp) ;
    parms->fp = NULL ;
  }

  start_t = parms->start_t ;
  *parms = *(&saved_parms) ;
  parms->start_t = start_t ;
  printf("MRISregister() return, current seed %ld\n",getRandomSeed());
  fflush(stdout);
  return(NO_ERROR) ;
}


void MRISsetCurvaturesToValues(MRIS *mris,int fno)
{
  int n;
  VERTEX *v;
  for (n=0; n < mris->nvertices; n++)
  {
    v=&mris->vertices[n];
    if (v->ripflag)
    {
      continue;
    }
    ((VALS_VP*)v->vp)->vals[fno] = v->curv;
  }
}

void MRISsetCurvaturesToOrigValues(MRIS *mris,int fno)
{
  int n;
  VERTEX *v;
  for (n=0; n < mris->nvertices; n++)
  {
    v=&mris->vertices[n];
    if (v->ripflag)
    {
      continue;
    }
    ((VALS_VP*)v->vp)->orig_vals[fno] = v->curv;
  }
}

void MRISsetOrigValuesToCurvatures(MRIS *mris,int fno)
{
  int n;
  VERTEX *v;
  for (n=0; n < mris->nvertices; n++)
  {
    v=&mris->vertices[n];
    if (v->ripflag)
    {
      continue;
    }
    v->curv = ((VALS_VP*)v->vp)->orig_vals[fno];
  }
}

void MRISsetOrigValuesToValues(MRIS *mris,int fno)
{
  int n;
  VERTEX *v;
  for (n=0; n < mris->nvertices; n++)
  {
    v=&mris->vertices[n];
    if (v->ripflag)
    {
      continue;
    }
    ((VALS_VP*)v->vp)->vals[fno] = ((VALS_VP*)v->vp)->orig_vals[fno];
  }
}

void MRISsetValuesToCurvatures(MRIS *mris,int fno)
{
  int n;
  VERTEX *v;
  for (n=0; n < mris->nvertices; n++)
  {
    v=&mris->vertices[n];
    if (v->ripflag)
    {
      continue;
    }
    v->curv = ((VALS_VP*)v->vp)->vals[fno];
  }
}


void MRISnormalizeField(MRIS *mris , int distance_field, int which_norm)
{
  int n;
  VERTEX *v;
  float max_value;

  if (which_norm == NORM_NONE)
  {
    return ;
  }

  if (distance_field || which_norm == NORM_MAX)
  {
    /* distance fields have their max value set to 1 */
    for (max_value=0.0f,n=0; n < mris->nvertices; n++)
    {
      v=&mris->vertices[n];
      if (v->ripflag)
      {
        continue;
      }
      if (v->curv>max_value)
      {
        max_value=v->curv;  //fabs(v->curv);
      }
    }
    if (!FZERO(max_value)) /* normalize the max value to 1.0f */
    {
      printf("normalizing max %2.1f to be in [0 1]\n", max_value) ;
      for (n=0; n < mris->nvertices; n++)
      {
        v=&mris->vertices[n];
        if (v->ripflag)
        {
          continue;
        }
        v->curv=v->curv/max_value;
      }
    }
  }
  else /* gaussian */
  {
    MRISnormalizeCurvature(mris, which_norm);
  }
}


int MRISvectorRegister(MRI_SURFACE *mris,
                       MRI_SP *mrisp_template,
                       INTEGRATION_PARMS *parms,
                       int max_passes, float min_degrees, float max_degrees,
                       int nangles)
{
  float   sigma ;
  int     i,/*steps,*/ done, msec ;
  MRI_SP  *mrisp ;
  VERTEX *v;
  char    fname[STRLEN], base_name[STRLEN], path[STRLEN] ;
  double  base_dt ;
  struct  timeb start ;
  static  int first = 1 ;
  int n,fno,ncorrs;
  int *frames,nframes,nf,*indices;
  float l_corr;
  int pdone = 1 ;
  VALS_VP *vp;

  if (IS_QUADRANGULAR(mris))
  {
    MRISremoveTriangleLinks(mris) ;
  }
  TimerStart(&start) ;
  MRISsaveVertexPositions(mris, ORIGINAL_VERTICES) ;
  FileNamePath(mris->fname, path) ;
  sprintf(base_name, "%s/%s.%s", path,
          mris->hemisphere == LEFT_HEMISPHERE ? "lh":"rh", parms->base_name);

  base_dt = parms->dt ;
  if (Gdiag & DIAG_WRITE)
  {
    sprintf
    (fname, "%s.%s.out",
     mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",parms->base_name);
    if (!parms->start_t)
    {
      parms->fp = fopen(fname, "w") ;
      if (!parms->fp)
        ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                  Progname, fname) ;
    }
    mrisLogIntegrationParms(parms->fp, mris,parms) ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogIntegrationParms(stderr, mris,parms) ;
  }


  /*    for ( nframes = n = 0 ; n < parms->nfields ; n++){ */
  /*            parms->fields[n].l_corr=0.0f; */
  /*            parms->fields[n].l_pcorr=0.0f; */
  /*    } */
  /*    parms->l_corrs[5]=1.0f; // only one structure at a time */

  /* excluding frames with zero correlation coefficients */
  for ( nframes = n = 0 ; n < parms->nfields ; n++)
  {
    l_corr = parms->fields[n].l_corr+parms->fields[n].l_pcorr ;
    if (FZERO(l_corr))
    {
      continue;
    }
    nframes++;
  }
  if (!nframes)
  {
    return NO_ERROR;
  }

  fprintf(stderr,"MRISvectorRegister will use %d fields\n",nframes);

  indices =(int*)malloc(nframes*sizeof(int));
  frames=(int*)malloc(2*nframes*sizeof(int));
  for ( nf = n = 0 ; n < parms->nfields ; n++ )
  {
    l_corr = parms->fields[n].l_corr+parms->fields[n].l_pcorr ;
    if (FZERO(l_corr))
    {
      continue;
    }
    fno = parms->fields[n].frame * IMAGES_PER_SURFACE;
    frames[nf]= fno; /* mean */
    frames[nf+nframes]= fno+1 ; /* variance */
    indices[nf]=n;
    nf++;
  }

  ncorrs=parms->nfields;
  /* allocate the VALS_VP structure */
  for ( n = 0; n < mris->nvertices ; n++)
  {
    v=&mris->vertices[n];
    vp=calloc(1,sizeof(VALS_VP));
    vp->nvals=ncorrs;
    vp->orig_vals=(float*)calloc(ncorrs,sizeof(float)); /* before blurring */
    vp->vals=(float*)malloc(ncorrs*sizeof(float));/* values used by
                                                             MRISintegrate */
    v->vp=(void*)vp;
  }

  /* load the fields into vertex->vp */
  for (n = 0 ; n < ncorrs ; n++)
  {
    l_corr = parms->fields[n].l_corr+parms->fields[n].l_pcorr ;
    if (FZERO(l_corr))
    {
      continue;  /* don't load useless fields */
    }

    fprintf
    (stderr,
     "  -loading field %d with correlation coefficients "
     "( %2.1f , %2.1f )...\n",
     n,parms->fields[n].l_corr,parms->fields[n].l_pcorr);
    if (parms->fields[n].name != NULL)
    {
      char path[STRLEN] ;
      FileNamePath(mris->fname, path) ;
      if (parms->overlay_dir == NULL)
      {
        sprintf(fname, "%s/../label/%s.%s",
                path, mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",
                parms->fields[n].name) ;
      }
      else
      {
        sprintf(fname, "%s/../%s/%s.%s",
                path, parms->overlay_dir,
                mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",
                parms->fields[n].name) ;
      }
      printf("reading overlay file %s...\n", fname) ;
      if (MRISreadValues(mris, fname) != NO_ERROR)
        ErrorExit(ERROR_BADPARM,
                  "%s: could not read overlay file %s",  Progname, fname) ;
      if (mris->ct)
      {
        MRISripMedialWall(mris) ;
      }
      MRIScopyValuesToCurvature(mris) ;
    }
    else if (ReturnFieldName(parms->fields[n].field))
    {
      /* read in precomputed curvature file */
      sprintf(fname, "%s.%s",
              mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",
              ReturnFieldName(parms->fields[n].field)) ;
      if (MRISreadCurvatureFile(mris, fname) != NO_ERROR)
      {
        fprintf
        (stderr,
         "%s: could not read curvature file '%s'\n","MRISvectorRegister",
         fname) ;
        fprintf(stderr,"setting up correlation coefficient to zero\n");
        parms->fields[n].l_corr=parms->fields[n].l_pcorr=0.0;
        continue;
      }
    }
    else
    {
      /* compute curvature of surface */
      sprintf(fname, "%s", surface_names[parms->fields[n].field]) ;
      /*                        if(parms->fields[n].field==0) */
      /*                                sprintf(fname, "inflated") ; */
      /*                        else */
      /*                                sprintf(fname, "smoothwm") ; */
      MRISsaveVertexPositions(mris, TMP_VERTICES) ;
      if (MRISreadVertexPositions(mris, fname) != NO_ERROR)
      {
        ErrorPrintf(ERROR_NOFILE, "%s: could not read surface file %s",
                    "MRISvectorRegister", fname) ;
        fprintf(stderr,"setting up correlation coefficient to zero\n");
        parms->fields[n].l_corr=parms->fields[n].l_pcorr=0.0;
        continue;
      }
      MRISsetNeighborhoodSize(mris, -1) ;  /* back to max */
      MRIScomputeMetricProperties(mris) ;
      MRIScomputeSecondFundamentalForm(mris) ;
      MRISuseMeanCurvature(mris) ;
      MRISresetNeighborhoodSize(mris,1);/*only use nearest neighbor distances*/
      MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
    }
    MRISnormalizeField(mris,parms->fields[n].type,
                       parms->fields[n].which_norm);
    MRISsetCurvaturesToOrigValues(mris,n);
  }
  MRISaverageCurvatures(mris, parms->fields[n].navgs) ;

  /* multiscale registration */
  parms->mrisp_template=MRISPclone(mrisp_template);
  parms->mrisp = MRISPclone(mrisp_template);
  mris->vp = (void *)parms->mrisp ; /* hack to get it to projectSurface */

#define DEBUG_NO_BLURRING 0

  for (i = 0 ; i < nsigmas ; i++)  /* for each spatial scale (blurring) */
  {
#if (DEBUG_NO_BLURRING)
    i = nsigmas-1;
    first=0;
#endif

    if (Gdiag & DIAG_WRITE && !i && !parms->start_t)
    {
      MRISfromParameterizations(parms->mrisp_template, mris,
                                frames,indices , nframes);
      //      MRISnormalizeCurvature(mris, parms->fields[0].which_norm) ;
      sprintf
      (fname,
       "%s/%s.%s.target",
       path,mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",parms->base_name);
      if (Gdiag & DIAG_SHOW)
      {
        fprintf(stdout, "writing curvature file %s...\n", fname) ;
      }
      MRISwriteCurvature(mris, fname) ;
      if (Gdiag & DIAG_SHOW)
      {
        fprintf(stdout, "done.\n") ;
      }
    }
    if ((parms->flags & IP_NO_RIGID_ALIGN)) /* no rigid alignment */
    {
      first = 0 ;
    }

    parms->sigma = sigma = sigmas[i] ;
    parms->dt = base_dt ;
    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, "\nblurring surfaces with sigma=%2.2f...\n", sigma) ;
    }
    if (Gdiag & DIAG_WRITE)
      fprintf(parms->fp,"\ncorrelating surfaces with with sigma=%2.2f\n",
              sigma) ;

    if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
    {
      sprintf(fname, "%s/%s.%s.%4.4dtarget%2.2f",
              path, mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",
              parms->base_name, parms->start_t, sigma) ;
      if (Gdiag & DIAG_SHOW)
      {
        fprintf(stdout, "writing curvature file %s...", fname) ;
      }
      MRISwriteCurvature(mris, fname) ;
      if (Gdiag & DIAG_SHOW)
      {
        fprintf(stdout, "done.\n") ;
      }
    }


#if (!DEBUG_NO_BLURRING)
    /* blurring only the used frames */
    fprintf(stderr,"blurring %d target fields (means and variances)...\n",
            nframes);
    if (*IMAGEFseq_pix(mrisp_template->Ip, 0, 0, 2) <= 1.0)  /* 1st time */
      MRISPblurFrames(mrisp_template, parms->mrisp_template,
                      sigma, frames, nframes); /* means only */
    else
      MRISPblurFrames(mrisp_template, parms->mrisp_template,
                      sigma, frames, 2*nframes); /* means and variances */
#else
    parms->mrisp_template=MRISPclone(mrisp_template);
#endif

    /* normalize mean (only) intensities for target */
    MRISfromParameterizations(parms->mrisp_template, mris,
                              frames,indices , nframes);
    if (Gdiag & DIAG_WRITE)
    {
      sprintf
      (fname,
       "%s.target_%d_%d",
       mris->hemisphere ==
       RIGHT_HEMISPHERE ? "rh":"lh",n,(int)(2*sigma));
      fprintf(stderr,"writing target curvature for field %d\n",n);
      MRISwriteCurvature(mris,fname);
    }
    for ( n = 0 ; n < nframes ; n++)
    {
      fprintf
      (stderr,
       "normalized target field %d (frame = %d(%d) - field = %d)...\n",
       indices[n],
       parms->fields[indices[n]].frame,frames[n],
       parms->fields[indices[n]].field);
      MRISsetValuesToCurvatures(mris,indices[n]);
      MRISnormalizeField(mris,parms->fields[indices[n]].type,
                         parms->fields[indices[n]].which_norm) ;
      MRISsetCurvaturesToValues(mris,indices[n]);

      if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
      {
        sprintf
        (fname,
         "%s.target_%d_%d",
         mris->hemisphere ==
         RIGHT_HEMISPHERE ? "rh":"lh",n,(int)(2*sigma));
        fprintf(stderr,"writing target curvature for field %d\n",n);
        MRISwriteCurvature(mris,fname);
      }
    }
    MRIStoParameterizations(mris, parms->mrisp_template,
                            1, frames,indices,nframes) ;

    for ( n = 0 ; n < nframes ; n++)
    {
      MRISsetOrigValuesToValues(mris,indices[n]);
    }

    mrisp = MRISPclone(mrisp_template);
    MRIStoParameterizations(mris, mrisp  , 1 , frames, indices, nframes);
#if (!DEBUG_NO_BLURRING)
    /* blur source intensities for frame #n */
    fprintf(stderr,"blurring %d source field (means only)...\n",nframes);
    MRISPblurFrames(mrisp , parms->mrisp ,
                    sigma , frames, nframes) ; /* only mean fields */
#else
    parms->mrisp = MRISPclone(mrisp);
#endif
    MRISPfree(&mrisp);

    /* normalize mean intensities for source */
    MRISfromParameterizations(parms->mrisp, mris, frames,indices,nframes);
    for ( n = 0 ; n < nframes ; n++)
    {
      fprintf
      (stderr,
       "normalized source field %d (frame = %d(%d) - field = %d)...\n",
       indices[n],
       parms->fields[indices[n]].frame,frames[n],
       parms->fields[indices[n]].field);
      MRISsetValuesToCurvatures(mris,indices[n]);
      MRISnormalizeField(mris,parms->fields[indices[n]].type,
                         parms->fields[indices[n]].which_norm) ;
      MRISsetCurvaturesToValues(mris,indices[n]);
      if (Gdiag & DIAG_WRITE)
      {
        sprintf
        (fname,
         "%s.source_%d_%d",
         mris->hemisphere ==
         RIGHT_HEMISPHERE ? "rh":"lh",n,(int)(2*sigma));
        fprintf(stderr,"writing source curvature for field %d\n",n);
        MRISwriteCurvature(mris,fname);
      }
    }
    /*MRIStoParameterizations(mris, parms->mrisp,
      1, frames,indices,nframes) ; */

    /* use the frame #indices[0] (sulc) to write out snapshots */
    MRISsetValuesToCurvatures(mris,indices[0]);
    if (mris->ct)
    {
      MRISripMedialWall(mris) ;
    }
    MRIStoParameterization(mris,parms->mrisp,1,0);

    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, "done.\n") ;
    }

#if 0
    if (!first)
    {
      // TO BE CHECKED XXX
      if (pdone)
      {
        /* only once */
        pdone=0;
        /* only small adjustments needed after 1st time around */
        parms->tol *= 2.0f ;

        for ( n = 0 ; n < nframes ; n++)
        {
          parms->fields[indices[n]].l_corr /= 20.0f; /* should be more
                                                        adaptive */
          parms->fields[indices[n]].l_pcorr /= 20.0f; /* should be more
                                                         adaptive */
        }
      }
    }
#else
    pdone = 0 ;
#endif

    if (first)
    {
      /* do rigid registration the first time only */
      first=0;
      if ((parms->flags & IP_NO_RIGID_ALIGN) == 0)
      {
        if (Gdiag & DIAG_SHOW)
        {
          fprintf(stdout, "finding optimal rigid alignment\n") ;
        }
        if (Gdiag & DIAG_WRITE)
        {
          fprintf(parms->fp, "finding optimal rigid alignment\n") ;
        }

        MRISrigidBodyAlignVectorGlobal(mris, parms,
                                       min_degrees, max_degrees, nangles) ;
        MRISsaveVertexPositions(mris, TMP2_VERTICES) ;
        if (Gdiag & DIAG_WRITE && parms->write_iterations != 0)
        {
          MRISwrite(mris, "rotated") ;
        }

      }
    }

    mrisClearMomentum(mris) ;
    done = 0 ;

    mrisIntegrationEpoch(mris, parms, parms->n_averages) ;
  }


  parms->tol /= 10 ;  /* remove everything possible pretty much */
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "\nRemoving remaining folds...\n") ;
  }
  if (Gdiag & DIAG_WRITE)
  {
    fprintf(parms->fp, "\nRemoving remaining folds...\n") ;
  }
  parms->l_nlarea *= 5 ;
  mrisIntegrationEpoch(mris, parms, parms->n_averages) ;


#if 0
  /* free everything */
  MRISPfree(&parms->mrisp) ;
  MRISPfree(&parms->mrisp_template) ;

  /* free the VALS_VP structure */
  for ( n = 0; n < mris->nvertices ; n++)
  {
    v=&mris->vertices[n];
    vp=(VALS_VP*)v->vp;
    free(vp->orig_vals);
    free(vp->vals);
    free(vp);
    v->vp=NULL;
  }
#endif

  free(frames);
  free(indices);

  msec = TimerStop(&start) ;
  if (Gdiag & DIAG_SHOW)
    fprintf(stdout, "registration took %2.2f hours\n",
            (float)msec/(1000.0f*60.0f*60.0f));
  if (Gdiag & DIAG_WRITE)
    fprintf(parms->fp, "registration took %2.2f hours\n",
            (float)msec/(1000.0f*60.0f*60.0f));
  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static float area_coefs[] =
{
  1.0f,  1.0f, 0.1f
} ;
static float dist_coefs[] =
{
  0.1f,  1.0f, 1.0f
} ;

#define NCOEFS  sizeof(area_coefs) / sizeof(area_coefs[0])

#define MAX_NBHD_SIZE  200
#define NBR_COEF       (M_PI*1.0f)

MRI_SURFACE *
MRISunfold(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, int max_passes)
{
  int     base_averages, i, nbrs[MAX_NBHD_SIZE], niter,
          passno, msec, use_nl_area ;
  double  starting_sse, ending_sse, l_area, pct_error ;
  struct  timeb start ;

  printf("MRISunfold() max_passes = %d -------\n",max_passes);
  mrisLogIntegrationParms(stdout, mris, parms) ;
  printf("--------------------\n");

  use_nl_area = (!FZERO(parms->l_nlarea));

  if (IS_QUADRANGULAR(mris))
  {
    MRISremoveTriangleLinks(mris) ;
  }
  TimerStart(&start) ;
  starting_sse = ending_sse = 0.0f ;   /* compiler warning */
  memset(nbrs, 0, MAX_NBHD_SIZE*sizeof(nbrs[0])) ;
#if 0
  if (mris->nsize < 2)
  {
    nbrs[2] = nint(NBR_COEF*2.0) ;
  }
  for (i = 4 ; i <= parms->nbhd_size ; i*= 2)
  {
    nbrs[i] = nint(NBR_COEF*(float)i) ;
  }
#else
  for (i = mris->nsize+1 ; i <= parms->nbhd_size ; i++)
  {
    nbrs[i] = parms->max_nbrs ;
  }
#endif

  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    sprintf(fname, "%s.%s.out",
            mris->hemisphere == RIGHT_HEMISPHERE ? "rh" : "lh",
            parms->base_name);
    if (!parms->fp)
    {
      if (!parms->start_t)
      {
        parms->fp = fopen(fname, "w") ;
      }
      else
      {
        parms->fp = fopen(fname, "a") ;
      }

      if (!parms->fp)
        ErrorExit(ERROR_NOFILE, "MRISunfold: could not open log file %s\n",
                  fname) ;
    }
    mrisLogIntegrationParms(parms->fp, mris,parms) ;
    int valid_vertices = MRISvalidVertices(mris);
    if (parms->complete_dist_mat)
      fprintf(parms->fp, "using complete distance matrix (%d x %d)\n",
              valid_vertices, valid_vertices) ;
    else
    {
      for (i = mris->nsize+1 ; i <= parms->nbhd_size ; i++)
        if (nbrs[i])
        {
          fprintf(parms->fp, "%d: %d | ", i, nbrs[i]) ;
        }
      fprintf(parms->fp, "\n") ;

    }
  }
  if (Gdiag & DIAG_SHOW)
  {
    int valid_vertices = MRISvalidVertices(mris);
    if (parms->complete_dist_mat)
      printf("using complete distance matrix (%d x %d)\n",
             valid_vertices, valid_vertices) ;
    else
    {
      for (i = mris->nsize+1 ; i <= parms->nbhd_size ; i++)
        if (nbrs[i])
        {
          fprintf(stdout, "%d: %d | ", i, nbrs[i]) ;
        }
      fprintf(stdout, "\n") ;
    }
    mrisLogIntegrationParms(stderr, mris, parms) ;
  }

  /*  parms->start_t = 0 ;*/
  /*
    integrate until no improvement can be made at ANY scale, or until
    the error is effectively zero.
  */
  base_averages = parms->n_averages ;
  l_area = parms->l_area ;
  niter = parms->niterations ;
  passno = 0 ;
  for (passno = 0 ; passno < max_passes ; passno++)
  {
#if 0
    if (mris->nsize < parms->nbhd_size)  /* resample distances on surface */
#endif
    {
      if (Gdiag & DIAG_SHOW)
      {
        fprintf(stdout, "resampling long-range distances") ;
      }
      MRISsaveVertexPositions(mris, TMP_VERTICES) ;
      MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
      MRIScomputeMetricProperties(mris) ;
      if (parms->complete_dist_mat)
      {
        MRIScomputeAllDistances(mris) ;
      }
      else
      {
        MRISsampleDistances(mris, nbrs, parms->nbhd_size) ;
      }
      MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
      MRIScomputeMetricProperties(mris) ;
      mrisClearMomentum(mris) ;
    }

    {
      char   *cp ;
      int    vno, n ;
      VERTEX *v, *vn ;
      float  d ;
      FILE   *fp ;

      cp = getenv("FS_MEASURE_DISTANCES") ;
      if (cp)
      {
        fprintf(stdout,
                "outputting distance errors to distance.log...\n") ;
        fp = fopen("distance.log", "w") ;
        for (vno = 0 ; vno < mris->nvertices ; vno++)
        {
          v = &mris->vertices[vno] ;
          if (v->ripflag)
          {
            continue ;
          }
          for (n = 0 ; n < v->vtotal ; n++)
          {
            vn = &mris->vertices[v->v[n]] ;
            if (vn->ripflag)
            {
              continue ;
            }
            d = sqrt(SQR(vn->origx-v->origx)+SQR(vn->origy-v->origy)+
                     SQR(vn->origz-v->origz)) ;
            fprintf(fp, "%2.4f  %2.4f\n", d, v->dist_orig[n]) ;
          }
        }
        fclose(fp) ;
        exit(1) ;
      }
    }
    {
      char   *cp ;
      double max_pct ;

      cp = getenv("FS_DISTURB_DISTANCES") ;
      if (cp)
      {
        max_pct = atof(cp) ;
        fprintf(stdout,
                "disturbing distances by %%%2.1f\n", (float)max_pct) ;
        if (Gdiag & DIAG_WRITE)
          fprintf(parms->fp, "disturbing distances by %%%2.1f\n",
                  (float)max_pct);
        MRISdisturbOriginalDistances(mris, max_pct) ;
      }
    }

    {
      char   *cp ;

      cp = getenv("FS_SPHERE") ;
      if (cp)
      {
        MRISstoreAnalyticDistances(mris, MRIS_SPHERE) ;
      }
      cp = getenv("FS_PLANE") ;
      if (cp)
      {
        MRISstoreAnalyticDistances(mris, MRIS_PLANE) ;
      }
    }

    //    if (!passno && ((parms->flags & IPFLAG_QUICK) == 0))
    if (((parms->flags & IPFLAG_QUICK) == 0))
    {
      double tol = parms->tol ;
      parms->tol = 0.5 ;
      if (niter > 30)
      {
        parms->niterations = 30 ;
      }
      printf("  mrisRemoveNegativeArea()\n");
      mrisRemoveNegativeArea(mris, parms,
                             base_averages, MAX_NEG_AREA_PCT, 2);
      parms->niterations = niter ;
      parms->tol = tol ;
    }


    for (i = 0 ; i < NCOEFS ; i++)
    {
      if (mris->status == MRIS_SPHERE && i == NCOEFS-1)
      {
        continue ;
      }

      pct_error = MRISpercentDistanceError(mris) ;
      if (Gdiag & DIAG_WRITE)
        fprintf
        (parms->fp,
         "pass %d: epoch %d of %d starting distance error %%%2.2f\n",
         passno, i+1, (int)(NCOEFS), (float)pct_error);
      fprintf
      (stdout,
       "pass %d: epoch %d of %d starting distance error %%%2.2f\n",
       passno+1, i+1, (int)(NCOEFS), (float)pct_error);

      parms->l_dist = dist_coefs[i] ;
      if (use_nl_area)
      {
        parms->l_nlarea = area_coefs[i] ;
      }
      else
      {
        parms->l_area = area_coefs[i] ;
      }
      parms->l_angle = ANGLE_AREA_SCALE * parms->l_area ;
      if (i == NCOEFS-1)  /* see if distance alone
                               can make things better */
      {
        starting_sse = MRIScomputeSSE(mris, parms) ;
      }
      mrisIntegrationEpoch(mris, parms, base_averages) ;
    }

    if (use_nl_area)
    {
      parms->l_nlarea = area_coefs[NCOEFS-1] ;
    }
    else
    {
      parms->l_area = area_coefs[NCOEFS-1] ;
    }
    parms->l_dist = dist_coefs[NCOEFS-1] ;
    ending_sse = MRIScomputeSSE(mris, parms) ;
    if (Gdiag & DIAG_SHOW)
    {
#if 0
      fprintf(stdout, "pass %d: start=%2.1f, end=%2.1f, ratio=%2.3f\n",
              passno+1, starting_sse, ending_sse,
              (starting_sse-ending_sse)/starting_sse) ;
      if (Gdiag & DIAG_WRITE)
        fprintf
        (parms->fp,
         "pass %d: start=%2.4f, end=%2.4f, ratio=%2.4f\n",
         passno+1, starting_sse, ending_sse,
         (starting_sse-ending_sse)/starting_sse) ;
#endif
    }
  }
#if 0
  while (
    !FZERO(ending_sse) &&
    (((starting_sse-ending_sse)/starting_sse) > parms->tol) &&
    (++passno < max_passes)
  )
  {
    ;
  }
#endif


  fprintf(stdout, "unfolding complete - removing small folds...\n") ;
  pct_error = MRISpercentDistanceError(mris) ;
  if (Gdiag & DIAG_WRITE)
    fprintf(parms->fp,
            "starting distance error %%%2.2f\n", (float)pct_error);
  fprintf(stdout,
          "starting distance error %%%2.2f\n", (float)pct_error);

  /* finally, remove all the small holes */
  parms->l_nlarea = 1.0f ;
  parms->l_area = 0.0 ;
  parms->l_dist = 0.1f ;  /* was 0.001 */
  parms->l_angle = ANGLE_AREA_SCALE * parms->l_nlarea ;
  parms->niterations = niter ;
#if 1
  parms->tol = 1e-2 ;  /* try and remove as much negative stuff as possible */
#else
  parms->tol = 1e-1 ;  /* try and remove as much negative stuff as possible */
#endif
  mrisStoreVtotalInV3num(mris) ;  /* hack to speed up neg. area removal */
  MRISresetNeighborhoodSize(mris, 1) ;
  fprintf(stdout, "removing remaining folds...\n") ;
  mrisRemoveNegativeArea(mris, parms, base_averages > 32 ? 32 : base_averages,
                         MAX_NEG_AREA_PCT, 2);
  MRISresetNeighborhoodSize(mris, 3) ;

  if (mris->status == MRIS_PLANE &&
      parms->complete_dist_mat == 0)  /* smooth out remaining folds */
  {
    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, "smoothing final surface...\n") ;
    }
    if (Gdiag & DIAG_WRITE)
    {
      fprintf(parms->fp, "smoothing final surface...\n") ;
    }
    parms->l_spring = 1.0f ;
    parms->l_area = parms->l_nlarea = 0.0f ;
    parms->niterations = 5 ;
    parms->integration_type = INTEGRATE_MOMENTUM ;
    parms->dt = 0.5f ;
    parms->momentum = 0.0f ;
    parms->n_averages = 0 ;
#ifdef FS_CUDA
    mrisIntegrateCUDA(mris, parms, 0) ;
#else
    MRISintegrate(mris, parms, 0) ;
#endif /* FS_CUDA */
    /*    mrisRemoveNegativeArea(mris, parms, 0, MAX_NEG_AREA_PCT, 1);*/
  }

  pct_error = MRISpercentDistanceError(mris) ;
  fprintf(stdout, "final distance error %%%2.2f\n", (float)pct_error);
  mrisProjectSurface(mris) ;
  msec = TimerStop(&start) ;
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogStatus(mris, parms, stderr, 0,-1) ;
    fprintf(stdout, "optimization complete.\n") ;
    fprintf(stdout, "unfolding took %2.2f hours\n",
            (float)msec/(1000.0f*60.0f*60.0f));
  }
  if (Gdiag & DIAG_WRITE)
  {
    fprintf(parms->fp, "unfolding took %2.2f hours\n",
            (float)msec/(1000.0f*60.0f*60.0f));
    mrisLogStatus(mris, parms, parms->fp, 0,-1) ;
    fprintf(parms->fp, "final distance error %%%2.2f\n", pct_error);
    fclose(parms->fp) ;
    parms->fp = NULL ;
  }
  printf("MRISunfold() return, current seed %ld\n",getRandomSeed());
  fflush(stdout);

  return(mris) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI_SURFACE *
MRISquickSphere(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, int max_passes)
{
  int     niter, passno, msec, nbrs[MAX_NBHD_SIZE],i,use_dists, base_averages ;
  double  pct_error, orig_k, last_sse, sse, pct_change ;
  struct  timeb start ;

  orig_k = NEG_AREA_K ;

  TimerStart(&start) ;

  if (IS_QUADRANGULAR(mris))
  {
    MRISremoveTriangleLinks(mris) ;
  }

  use_dists = (!DZERO(parms->l_dist) || !DZERO(parms->l_nldist)) &&
              (parms->nbhd_size > mris->nsize) ;

  memset(nbrs, 0, MAX_NBHD_SIZE*sizeof(nbrs[0])) ;
  for (i = mris->nsize+1 ; i <= parms->nbhd_size ; i++)
  {
    nbrs[i] = parms->max_nbrs ;
  }

  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    sprintf(fname, "%s.%s.out",
            mris->hemisphere == RIGHT_HEMISPHERE ? "rh" : "lh",
            parms->base_name);
    if (!parms->fp)
    {
      if (!parms->start_t)
      {
        parms->fp = fopen(fname, "w") ;
      }
      else
      {
        parms->fp = fopen(fname, "a") ;
      }
      if (!parms->fp)
        ErrorExit
        (ERROR_NOFILE,
         "MRISquickSphere: could not open log file %s\n",
         fname) ;
    }
    mrisLogIntegrationParms(parms->fp, mris,parms) ;
    if (use_dists)
    {
      for (i = mris->nsize+1 ; i <= parms->nbhd_size ; i++)
        if (nbrs[i])
        {
          fprintf(parms->fp, "%d: %d | ", i, nbrs[i]) ;
        }
      fprintf(parms->fp, "\n") ;
    }
  }
  if (Gdiag & DIAG_SHOW)
  {
    if (use_dists)
    {
      for (i = mris->nsize+1 ; i <= parms->nbhd_size ; i++)
        if (nbrs[i])
        {
          fprintf(stdout, "%d: %d | ", i, nbrs[i]) ;
        }
      fprintf(stdout, "\n") ;
    }
    mrisLogIntegrationParms(stderr, mris, parms) ;
  }

  /* resample distances on surface */
  if (use_dists && mris->nsize < parms->nbhd_size)
  {
    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, "resampling long-range distances") ;
    }
    MRISsaveVertexPositions(mris, TMP_VERTICES) ;
    MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
    MRISsampleDistances(mris, nbrs, parms->nbhd_size) ;
    MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
    mrisClearMomentum(mris) ;
  }

  /*
    integrate until no improvement can be made at ANY scale, or until
    the error has asymptoted.
  */
  base_averages = parms->n_averages ;
  parms->flags |= IP_RETRY_INTEGRATION ;
  niter = parms->niterations ;
  passno = 0 ;

#if 1
  if ((parms->flags & IPFLAG_QUICK) == 0)
  {
    parms->tol = parms->tol * 1024 / (sqrt((double)base_averages+1)) ;
  }
#endif

  for (i = 0, NEG_AREA_K = orig_k ; i < 4 ; NEG_AREA_K *= 4, i++)
  {
    passno = 0 ;
    do
    {
      last_sse = MRIScomputeSSE(mris, parms) ;
      printf("epoch %d (K=%2.1f), pass %d, starting sse = %2.2f\n",
             i+1, NEG_AREA_K, passno+1, last_sse) ;
      niter = mrisIntegrationEpoch(mris, parms, base_averages) ;
      sse = MRIScomputeSSE(mris, parms) ;
      pct_change = (last_sse - sse) / (last_sse*niter) ; /* per timestep */
      passno++ ;
      printf("pass %d complete, delta sse/iter = %2.2f/%d = %2.5f\n",
             passno, (last_sse-sse)/last_sse, niter, pct_change) ;
    }
    while (pct_change > parms->tol) ;
#if 0
    if (passno == 1)   /* couldn't make any progress at all */
    {
      break ;
    }
#endif
  }

  NEG_AREA_K = orig_k ;
  pct_error = MRISpercentDistanceError(mris) ;
  fprintf(stdout, "final distance error %%%2.2f\n", (float)pct_error);
  mrisProjectSurface(mris) ;
  msec = TimerStop(&start) ;
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogStatus(mris, parms, stderr, 0,-1) ;
    fprintf(stdout, "optimization complete.\n") ;
    fprintf(stdout, "unfolding took %2.2f hours\n",
            (float)msec/(1000.0f*60.0f*60.0f));
  }
  if (Gdiag & DIAG_WRITE)
  {
    fprintf(parms->fp, "unfolding took %2.2f hours\n",
            (float)msec/(1000.0f*60.0f*60.0f));
    mrisLogStatus(mris, parms, parms->fp, 0,-1) ;
    fprintf(parms->fp, "final distance error %%%2.2f\n", pct_error);
#if 0
    fclose(parms->fp) ;
#endif
  }

  return(mris) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
#if 0
static float area_scoefs[] =
{
  1.0f,    1.0f,   1.0f,  1.0f, 1.0f, 0.1f, 0.01f, 0.001f
};
static float dist_scoefs[] =
{
  0.0001f, 0.001f, 0.01f, 0.1f, 1.0f, 1.0f, 1.0f,  1.0f
} ;
#else
static float area_scoefs[] =
{
  1.0f,  0.1f, 0.01f
} ;
static float dist_scoefs[] =
{
  1.0f,  1.0f, 1.0f
} ;
#endif

#define NSCOEFS  sizeof(area_scoefs) / sizeof(area_scoefs[0])

MRI_SURFACE *
MRISunfoldOnSphere(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, int max_passes)
{
  int     base_averages, i, nbrs[MAX_NBHD_SIZE], niter, passno, msec ;
  double  starting_sse, ending_sse ;
  struct  timeb start ;

  starting_sse = ending_sse = 0.0f ;   /* compiler warning */
  memset(nbrs, 0, MAX_NBHD_SIZE*sizeof(nbrs[0])) ;
  for (i = mris->nsize+1 ; i <= parms->nbhd_size ; i++)
  {
    nbrs[i] = parms->max_nbrs ;
  }

  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    sprintf(fname, "%s.out", parms->base_name) ;
    if (!parms->fp)
    {
      if (!parms->start_t)
      {
        parms->fp = fopen(fname, "w") ;
      }
      else
      {
        parms->fp = fopen(fname, "a") ;
      }
      if (!parms->fp)
        ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                  Progname, fname) ;
    }
    mrisLogIntegrationParms(parms->fp, mris,parms) ;
    for (i = mris->nsize+1 ; i <= parms->nbhd_size ; i++)
      if (nbrs[i])
      {
        fprintf(parms->fp, "%d: %d | ", i, nbrs[i]) ;
      }
    fprintf(parms->fp, "\n") ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    for (i = mris->nsize+1 ; i <= parms->nbhd_size ; i++)
      if (nbrs[i])
      {
        fprintf(stdout, "%d: %d | ", i, nbrs[i]) ;
      }
    fprintf(stdout, "\n") ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogIntegrationParms(stderr, mris, parms) ;
  }

  /*
    integrate until no improvement can be made at ANY scale, or until
    the error has asymptoted.
  */
  base_averages = parms->n_averages ;
  niter = parms->niterations ;
  passno = 0 ;
  mrisProjectSurface(mris) ;
  MRIScomputeMetricProperties(mris) ;
  do
  {
    if (passno++ >= max_passes)
    {
      break ;
    }

    /* first time through only - use big ratio to remove folds */
    TimerStart(&start) ;
    for (i = 0 ; i < NSCOEFS ; i++)
    {
      if (mris->nsize < parms->nbhd_size)  /* resample distances on surface */
      {
        if (Gdiag & DIAG_SHOW)
        {
          fprintf(stdout, "resampling long-range distances") ;
        }
        MRISsaveVertexPositions(mris, TMP_VERTICES) ;
        MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
        MRISsampleDistances(mris, nbrs, parms->nbhd_size) ;
        MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
        mrisClearMomentum(mris) ;
      }
      if (!i)  /* record starting error */
      {
        parms->l_nlarea = area_scoefs[NSCOEFS-1] ;
        parms->l_dist = dist_scoefs[NSCOEFS-1] ;
        starting_sse = MRIScomputeSSE(mris, parms) ;
      }

      /* remove any folds in the surface */
      mrisRemoveNegativeArea(mris, parms, base_averages,
                             MAX_NEG_AREA_PCT, 2) ;

      parms->l_dist = dist_scoefs[i] ;
      parms->l_nlarea = area_scoefs[i] ;
      parms->l_angle = ANGLE_AREA_SCALE * area_scoefs[i] ;
      mrisIntegrationEpoch(mris, parms, base_averages) ;
    }

    parms->l_area = area_scoefs[NSCOEFS-1] ;
    parms->l_dist = dist_scoefs[NSCOEFS-1] ;
    ending_sse = MRIScomputeSSE(mris, parms) ;
    if (Gdiag & DIAG_SHOW)
    {
#if 0
      fprintf(stdout, "pass %d: start=%2.1f, end=%2.1f, ratio=%2.3f\n",
              passno, starting_sse, ending_sse,
              (starting_sse-ending_sse)/ending_sse) ;
      if (Gdiag & DIAG_WRITE)
        fprintf(parms->fp,
                "pass %d: start=%2.4f, end=%2.4f, ratio=%2.4f\n",
                passno, starting_sse, ending_sse,
                (starting_sse-ending_sse)/starting_sse) ;
#endif
    }
    msec = TimerStop(&start) ;
    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout,
              "epoch took %2.2f minutes\n",(float)msec/(1000.0f*60.0f));
      if (Gdiag & DIAG_WRITE)
        fprintf(parms->fp,
                "epoch took %2.2f minutes\n",(float)msec/(1000.0f*60.0f));
    }
  }
  while (!FZERO(ending_sse) &&
         (((starting_sse-ending_sse)/starting_sse) > parms->tol)) ;

#if 0
  if (Gdiag & DIAG_SHOW)
    fprintf(stdout,
            "initial unfolding complete - settling to equilibrium...\n") ;
  parms->niterations = 1000 ;  /* let it go all the way to equilibrium */
  mrisIntegrationEpoch(mris, parms, parms->n_averages = 0) ;
#endif

  /* finally, remove all the small holes */
  parms->l_nlarea = 1.0f ;
  parms->l_area = 0.0 ;
  parms->l_dist = 0.001f ;
  parms->l_angle = ANGLE_AREA_SCALE * area_scoefs[0] ;
  parms->niterations = niter ;
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "removing remaining folds...\n") ;
  }
  mrisRemoveNegativeArea(mris, parms, base_averages, MAX_NEG_AREA_PCT, 3);
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogStatus(mris, parms, stderr, 0,-1) ;
  }
  if (Gdiag & DIAG_WRITE)
  {
    mrisLogStatus(mris, parms, parms->fp, 0,-1) ;
  }

  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "unfolding complete.\n") ;
  }
  if (Gdiag & DIAG_WRITE)
  {
    fclose(parms->fp) ;
    parms->fp = NULL ;
  }

  mrisProjectSurface(mris) ;
  return(mris) ;
}
#endif


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description

  ------------------------------------------------------*/
static float neg_area_ratios[] =
{
  //    1e-3, 1e-4, 1e-5, 1e-6, 1e-7, 1e-8, 1e-3, 1e-2, 5e-2,1e-1
  1e-6, 1e-5, 1e-3, 1e-2, 1e-1
} ;
#define MAX_PASSES (sizeof(neg_area_ratios) / sizeof(neg_area_ratios[0]))
static int
mrisRemoveNegativeArea(MRI_SURFACE *mris, INTEGRATION_PARMS *parms,
                       int base_averages, float min_area_pct, int max_passes)
{
  int    total_steps, done, steps, n_averages, old_averages, npasses, niter ;
  float  pct_neg, ratio ;
  char   *snum, *sdenom ;
  float  l_area, l_parea, l_corr, l_spring, l_dist, l_nlarea,
         *pnum, *pdenom, cmod ;
  double tol ;

  if (Gdiag & DIAG_WRITE && parms->fp == NULL)
  {
    char fname[STRLEN] ;

    sprintf
    (fname, "%s.%s.out",
     mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",parms->base_name);
    if (!parms->start_t)
    {
      parms->fp = fopen(fname, "w") ;
    }
    else
    {
      parms->fp = fopen(fname, "a") ;
    }
    if (!parms->fp)
      ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                Progname, fname) ;
    mrisLogIntegrationParms(parms->fp, mris, parms) ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogIntegrationParms(stderr, mris, parms) ;
  }
  pct_neg = 100.0*mris->neg_area/(mris->neg_area+mris->total_area) ;
  if (pct_neg <= min_area_pct)
  {
    return(0) ;  /* no steps */
  }

  tol = parms->tol ;
#if 0
  parms->tol = 1e-2 ;
#endif
  niter = parms->niterations ;
  old_averages = parms->n_averages ;
  /*  parms->integration_type = INTEGRATE_LINE_MINIMIZE ;*/
  /* parms->niterations = 25 ;*/
  /*  base_averages = 1024 ;*/
  l_area = parms->l_area ;
  l_parea = parms->l_parea ;
  l_nlarea = parms->l_nlarea ;
  l_spring = parms->l_spring ;
  l_dist = parms->l_dist ;
  l_corr = parms->l_corr ;
  parms->l_area =
    parms->l_parea =
      parms->l_dist =
        parms->l_corr =
          parms->l_spring =
            parms->l_nlarea = 0.0 ;

  /* there is one negative area removing term (area, nlarea, parea, spring),
     and one term we are seaking to retain (corr, dist).
  */
  cmod = 1.0f ;
  if (!FZERO(l_corr))
  {
    sdenom = "corr" ;
    pdenom = &parms->l_corr  ; /*cmod = 10.0f ;*/
  }
  else
  {
    sdenom = "dist" ;
    pdenom = &parms->l_dist  ;
  }

  if (!FZERO(l_area))
  {
    snum = "area" ;
    pnum = &parms->l_area ;
  }
  else if (!FZERO(l_nlarea))
  {
    snum = "nlarea" ;
    pnum = &parms->l_nlarea  ;
  }
  else if (!FZERO(l_parea))
#if 0
  {
    snum = "parea" ;
    pnum = &parms->l_parea  ;
  }
#else
  {
    snum = "area" ;
    pnum = &parms->l_area  ;
  }
#endif
  else
  {
    snum = "spring" ;
    pnum = &parms->l_spring  ;
  }

  for (total_steps = npasses = 0  ; npasses < MAX_PASSES ; npasses++)
  {
    *pnum = 1.0 ;
    *pdenom =
      cmod * (npasses >= MAX_PASSES ?
              neg_area_ratios[MAX_PASSES-1] : neg_area_ratios[npasses]) ;

    ratio = *pnum / *pdenom ;

    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, "%s/%s = %2.3f\n", snum, sdenom, ratio) ;
    }
    if (Gdiag & DIAG_WRITE)
    {
      fprintf(parms->fp, "%s/%s = %2.3f\n", snum, sdenom, ratio) ;
    }
    if (ratio > 10000)
    {
      DiagBreak() ;
    }
    for (done=0, n_averages = base_averages; !done ; n_averages /= 4)
    {
      parms->n_averages = n_averages ;
#ifdef FS_CUDA
      steps = mrisIntegrateCUDA(mris, parms, n_averages) ;
#else
      steps = MRISintegrate(mris, parms, n_averages) ;
#endif /* FS_CUDA */
      parms->start_t += steps ;
      total_steps += steps ;
      pct_neg = 100.0*mris->neg_area/(mris->neg_area+mris->total_area) ;
#if 0
      if (pct_neg < min_area_pct)
      {
        break ;
      }
#endif
      done = n_averages == 0 ;
      /* finished integrating at smallest scale */
    }
#if 0
    if (pct_neg < min_area_pct)
    {
      break ;
    }
#endif
  }
#if 0
  MRIScomputeNormals(mris) ;
  mrisComputeVertexDistances(mris) ;
  MRIScomputeTriangleProperties(mris) ;  /* compute areas and normals */
  mrisOrientSurface(mris) ;
#endif
  parms->n_averages = old_averages  ;   /* hack, but no time to clean up now */
  parms->l_area = l_area ;
  parms->l_parea = l_parea ;
  parms->l_spring = l_spring ;
  parms->l_dist = l_dist ;
  parms->l_corr = l_corr ;
  parms->niterations = niter ;
  parms->tol = tol ;
  return(total_steps) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description

  ------------------------------------------------------*/
static int
mrisIntegrationEpoch(MRI_SURFACE *mris,
                     INTEGRATION_PARMS *parms,int base_averages)
{
  int   total_steps, done, steps, n_averages, old_averages ;
  char  *snum, *sdenom ;
  float ratio, *pdenom, *pnum ;

  if (!FZERO(parms->l_corr))
  {
    sdenom = "corr" ;
    pdenom = &parms->l_corr  ;
  }
  else
  {
    sdenom = "dist" ;
    pdenom = &parms->l_dist  ;
  }

  if (!FZERO(parms->l_nlarea))
  {
    snum = "nlarea" ;
    pnum = &parms->l_nlarea  ;
  }
  else if (!FZERO(parms->l_area))
  {
    snum = "area" ;
    pnum = &parms->l_area ;
  }
  else if (!FZERO(parms->l_parea))
  {
    snum = "parea" ;
    pnum = &parms->l_parea  ;
  }
  else
  {
    snum = "spring" ;
    pnum = &parms->l_spring  ;
  }

  if (Gdiag & DIAG_SHOW)
  {
    mrisLogIntegrationParms(stderr, mris, parms) ;
  }
  if (Gdiag & DIAG_WRITE)
  {
    mrisLogIntegrationParms(parms->fp, mris, parms) ;
  }
  if (!FZERO(*pdenom))
  {
    ratio = *pnum / *pdenom ;
    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, "%s/%s = %2.3f\n", snum, sdenom, ratio) ;
    }
    if (Gdiag & DIAG_WRITE)
    {
      char fname[STRLEN] ;
      if (!parms->fp)
      {
        sprintf(fname, "%s.%s.out",
                mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",
                parms->base_name);
        if (!parms->start_t)
        {
          parms->fp = fopen(fname, "w") ;
        }
        else
        {
          parms->fp = fopen(fname, "a") ;
        }
        if (!parms->fp)
          ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                    Progname, fname) ;
      }
      fprintf(parms->fp, "%s/%s = %2.3f\n", snum, sdenom, ratio) ;
    }
  }

  old_averages = parms->n_averages ;
  for (done = total_steps = 0, n_averages = base_averages ; !done ;
       n_averages /= 4)
  {
    parms->n_averages = n_averages ;
#ifdef FS_CUDA
    steps = mrisIntegrateCUDA(mris, parms, n_averages) ;
#else
    steps = MRISintegrate(mris, parms, n_averages) ;
#endif /* FS_CUDA */

    if (n_averages > 0 && parms->flags & IP_RETRY_INTEGRATION &&
        ((parms->integration_type == INTEGRATE_LINE_MINIMIZE) ||
         (parms->integration_type == INTEGRATE_LM_SEARCH)))
    {
      int niter = parms->niterations ;
      int integration_type = parms->integration_type ;

      fprintf(stdout, "taking momentum steps...\n") ;
      parms->integration_type = INTEGRATE_MOMENTUM ;
      parms->niterations = 10 ;
      parms->start_t += steps ;
      total_steps += steps ;
#ifdef FS_CUDA
      steps = mrisIntegrateCUDA(mris, parms, n_averages) ;
#else
      steps = MRISintegrate(mris, parms, n_averages) ;
#endif /* FS_CUDA */
      parms->integration_type = integration_type ;
      parms->niterations = niter ;
      parms->start_t += steps ;
      total_steps += steps ;
#ifdef FS_CUDA
      steps = mrisIntegrateCUDA(mris, parms, n_averages) ;
#else
      steps = MRISintegrate(mris, parms, n_averages) ;
#endif /* FS_CUDA */
    }
    parms->start_t += steps ;
    total_steps += steps ;
    done = n_averages == parms->min_averages ;
    if (mris->status == MRIS_SPHERE)
    {
      if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      {
        MRISprintTessellationStats(mris, stderr) ;
      }
      parms->scale *= parms->dt_decrease ;
      if (parms->scale < 1.0f)
      {
        parms->scale = 1.0f ;
      }
    }
  }
#if 0
  MRIScomputeNormals(mris) ;
  mrisComputeVertexDistances(mris) ;
  MRIScomputeTriangleProperties(mris) ;  /* compute areas and normals */
  mrisOrientSurface(mris) ;
#endif
  parms->n_averages = old_averages  ;  /* hack, but no time to clean up now */
  return(total_steps) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description

  ------------------------------------------------------*/
int
MRISintegrate(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, int n_averages)
{
  int     t, write_iterations, niterations, nsmall, neg ;
  double  l_dist, l_area, l_spring, sse, old_sse, delta_t, total_small = 0.0;
  double  sse_thresh, pct_neg, pct_neg_area, total_vertices, tol;
  /*, scale, last_neg_area */ ;
  MHT     *mht_v_current = NULL ;

  if (Gdiag & DIAG_WRITE && parms->fp == NULL)
  {
    char fname[STRLEN] ;

    sprintf
    (fname, "%s.%s.out",
     mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",parms->base_name);
    if (!parms->start_t)
    {
      parms->fp = fopen(fname, "w") ;
    }
    else
    {
      parms->fp = fopen(fname, "a") ;
    }
    if (!parms->fp)
      ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                Progname, fname) ;
    mrisLogIntegrationParms(parms->fp, mris, parms) ;
  }
  l_spring = parms->l_spring ;
  l_dist = parms->l_dist ;
  l_area = parms->l_area ;
  write_iterations = parms->write_iterations ;
  niterations = parms->niterations ;
  if (((parms->flags & IPFLAG_QUICK) == 0) &&
      ((parms->flags & IPFLAG_NOSCALE_TOL) == 0))
  {
    tol = parms->tol * sqrt(((double)n_averages + 1.0) / 1024.0);
  }
  else
  {
    tol = parms->tol ;
  }
  sse_thresh = tol ;
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout,"integrating with navgs=%d and tol=%2.3e\n",n_averages,tol);
  }

  mrisProjectSurface(mris) ;
  MRIScomputeMetricProperties(mris) ;

#if AVERAGE_AREAS
  MRISreadTriangleProperties(mris, mris->fname) ;
  mrisAverageAreas(mris, n_averages, ORIG_AREAS) ;
#endif

  parms->starting_sse = sse = old_sse = MRIScomputeSSE(mris, parms) ;

  delta_t = 0.0 ;
  niterations += parms->start_t ;
  parms->t = parms->start_t ;

  if (!parms->start_t)
  {
    mrisLogStatus(mris, parms, stderr, 0.0f, -1) ;
    if (Gdiag & DIAG_WRITE)
    {
      mrisLogStatus(mris, parms, parms->fp, 0.0f, -1) ;
      if (write_iterations > 0)
      {
        mrisWriteSnapshot(mris, parms, 0) ;
      }
    }
  }

  if (Gdiag_no >= 0)
    fprintf(stdout,
            "v %d curvature = %2.5f, position = (%2.3f,%2.3f,%2.3f)\n",
            Gdiag_no, mris->vertices[Gdiag_no].H,
            mris->vertices[Gdiag_no].x,
            mris->vertices[Gdiag_no].y,
            mris->vertices[Gdiag_no].z) ;
  total_small = 0.0 ;
  nsmall = 0 ;


  total_vertices = (double)MRISvalidVertices(mris) ;
  neg = MRIScountNegativeTriangles(mris) ;
  pct_neg = (double)neg / total_vertices ;
  pct_neg_area =
    (float)mris->neg_area / (float)(mris->total_area+mris->neg_area) ;

  /*  mrisClearMomentum(mris) ;*/
  for (parms->t = t = parms->start_t ; t < niterations ; t++)
  {
    if (!FZERO(parms->l_repulse_ratio))
      mht_v_current =
        MHTfillVertexTableRes(mris, mht_v_current,CURRENT_VERTICES, 3.0);

    if (!FZERO(parms->l_curv))
    {
      MRIScomputeSecondFundamentalForm(mris) ;
    }

    MRISclearGradient(mris) ;      /* clear old deltas */
    mrisComputeVariableSmoothnessCoefficients(mris, parms) ;
    mrisComputeDistanceTerm(mris, parms) ;
    if (Gdiag & DIAG_WRITE && parms->write_iterations > 0 && DIAG_VERBOSE_ON)
    {
      MRI *mri ;
      char fname[STRLEN] ;
      sprintf(fname, "dist_dx%04d.mgz", parms->t) ;
      mri = MRISwriteIntoVolume(mris, NULL, VERTEX_DX) ;
      MRIwrite(mri,fname) ;
      sprintf(fname, "dist_dy%04d.mgz", parms->t) ;
      MRISwriteIntoVolume(mris, mri, VERTEX_DY) ;
      MRIwrite(mri,fname) ;
      sprintf(fname, "dist_dz%04d.mgz", parms->t) ;
      MRISwriteIntoVolume(mris, mri, VERTEX_DZ) ;
      MRIwrite(mri,fname) ;
      MRIfree(&mri) ;
    }
    mrisComputeAngleAreaTerms(mris, parms) ;
    mrisComputeCorrelationTerm(mris, parms) ;
    mrisComputePolarCorrelationTerm(mris, parms) ;
    /*    mrisComputeSpringTerm(mris, parms->l_spring) ;*/
    /* vectorial registration */
    if (parms->flags & IP_USE_MULTIFRAMES)
    {
      mrisComputeVectorCorrelationTerm(mris, parms);
      mrisComputePolarVectorCorrelationTerm(mris,parms);
    }



#if 0
    mrisComputeCurvatureTerm(mris, parms) ;
    mrisComputeNegTerm(mris, parms) ;
    mrisComputeBoundaryTerm(mris, parms) ;
#endif
    mrisComputeRepulsiveRatioTerm(mris,
                                  parms->l_repulse_ratio,
                                  mht_v_current);

    mrisComputeLaplacianTerm(mris, parms->l_lap) ;
    MRISaverageGradients(mris, n_averages) ;
    mrisComputeSpringTerm(mris, parms->l_spring) ;
    mrisComputeThicknessMinimizationTerm(mris, parms->l_thick_min, parms) ;
    mrisComputeThicknessParallelTerm(mris, parms->l_thick_parallel, parms) ;
    mrisComputeThicknessNormalTerm(mris, parms->l_thick_normal, parms) ;
    mrisComputeThicknessSpringTerm(mris, parms->l_thick_spring, parms) ;
    mrisComputeAshburnerTriangleTerm(mris, parms->l_ashburner_triangle, parms) ;

    mrisComputeTangentialSpringTerm(mris, parms->l_tspring) ;
    mrisComputeNonlinearTangentialSpringTerm(mris, 
                                             parms->l_nltspring,
                                             parms->min_dist) ;
    mrisComputeNonlinearSpringTerm(mris, parms->l_nlspring, parms) ;
    mrisComputeQuadraticCurvatureTerm(mris, parms->l_curv) ;
    if (Gdiag & DIAG_WRITE && parms->write_iterations > 0 && DIAG_VERBOSE_ON)
    {
      MRI *mri ;
      char fname[STRLEN] ;
      sprintf(fname, "dx%04d.mgz", parms->t) ;
      mri = MRISwriteIntoVolume(mris, NULL, VERTEX_DX) ;
      MRIwrite(mri,fname) ;
      sprintf(fname, "dy%04d.mgz", parms->t) ;
      MRISwriteIntoVolume(mris, mri, VERTEX_DY) ;
      MRIwrite(mri,fname) ;
      sprintf(fname, "dz%04d.mgz", parms->t) ;
      MRISwriteIntoVolume(mris, mri, VERTEX_DZ) ;
      MRIwrite(mri,fname) ;
      MRIfree(&mri) ;
    }

    switch (parms->integration_type)
    {
    case INTEGRATE_LM_SEARCH:
      delta_t = mrisLineMinimizeSearch(mris, parms) ;
      break ;
    default:
    case INTEGRATE_LINE_MINIMIZE:
      delta_t = mrisLineMinimize(mris, parms) ;
      break ;
    case INTEGRATE_MOMENTUM:
      delta_t = MRISmomentumTimeStep(mris, parms->momentum, parms->dt,
                                     tol, parms->n_averages) ;
      break ;
    case INTEGRATE_ADAPTIVE:
      delta_t = mrisAdaptiveTimeStep(mris, parms);
      break ;
    }

    if (!FZERO(parms->l_thick_min))
    {
      int    vno;
      VERTEX *v ;
      double mn, sq ;

      for (mn = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
      {
        v = &mris->vertices[vno] ;
        if (v->ripflag)
        {
          continue ;
        }
        sq = mrisSampleMinimizationEnergy(mris, v, parms, v->x, v->y, v->z) ;
        mn += sqrt(sq) ;
      }
      mn /= (double)MRISvalidVertices(mris) ;
      printf("mean thickness = %2.4f\n", mn) ;
    }


    if (!FZERO(parms->l_pcorr) && (Gdiag & DIAG_SHOW))
    {
      float  alpha, beta, gamma ;

      alpha = DEGREES(delta_t*mris->alpha) ;
      beta = DEGREES(delta_t*mris->beta) ;
      gamma = DEGREES(delta_t*mris->gamma) ;
      fprintf(stdout, "rotating brain by (%2.1f, %2.1f, %2.1f)\n",
              alpha, beta, gamma) ;
    }
    mrisProjectSurface(mris) ;
    MRIScomputeMetricProperties(mris) ;
    if (parms->remove_neg && mris->neg_area > 0)
    {
      INTEGRATION_PARMS p ;
      //      printf("removing overlap with smoothing\n") ;
      memset(&p, 0, sizeof(p)) ;
      p.niterations = 150 ;
      MRISremoveOverlapWithSmoothing(mris,&p) ;

    }
    if (Gdiag_no >= 0 && DIAG_VERBOSE_ON)
      fprintf(stdout, "v %d curvature = %2.3f\n",
              Gdiag_no, mris->vertices[Gdiag_no].H) ;
    /* only print stuff out if we actually took a step */
    sse = MRIScomputeSSE(mris, parms) ;
    if (!FZERO(old_sse) && ((old_sse-sse)/(old_sse) < sse_thresh))
    {
      if (++nsmall > MAX_SMALL)
      {
        break ;
      }
      if (++total_small > TOTAL_SMALL)
      {
        break ;
      }
    }
    else
    {
      if (total_small > 0.0)  /* if error increases more
                                 than 1/4 time quit */
      {
        total_small -= .25 ;
      }
      nsmall = 0 ;
    }

    parms->t++ ;
    mrisLogStatus(mris, parms, stderr, delta_t, old_sse) ;
    if (Gdiag & DIAG_WRITE)
    {
      mrisLogStatus(mris, parms, parms->fp, delta_t, -1) ;
    }

    if ((Gdiag & DIAG_SHOW) && !((t+1)%10) &&  DIAG_VERBOSE_ON)
    {
      MRISprintTessellationStats(mris, stderr) ;
    }

    if ((write_iterations > 0) &&
        !((t+1)%write_iterations)&&(Gdiag&DIAG_WRITE))
    {
      mrisWriteSnapshot(mris, parms, t+1) ;
    }
    if (mris->status == MRIS_PLANE && mris->neg_area > 4*mris->total_area)
    {
      fprintf(stdout, "flipping flattened patch...\n") ;
      mrisClearMomentum(mris) ;
      mrisFlipPatch(mris) ;
      MRIScomputeMetricProperties(mris) ;
    }

    if (FZERO(sse))
    {
      break ;
    }
    if ((parms->integration_type == INTEGRATE_LINE_MINIMIZE) ||
        (parms->integration_type == INTEGRATE_LM_SEARCH) ||
        (parms->integration_type == INTEGRATE_MOMENTUM))
    {
      if ((100*(old_sse - sse) / sse) < tol)
      {
        break ;
      }
    }
    old_sse = sse ;
    if (FZERO(delta_t))   /* reached the minimum */
    {
      break ;
    }
  }

  if (!FZERO(parms->l_repulse))
  {
    MHTfree(&mht_v_current) ;
  }

  parms->ending_sse = MRIScomputeSSE(mris, parms) ;
  /*  mrisProjectSurface(mris) ;*/

  return(parms->t-parms->start_t) ;  /* return actual # of steps taken */
}


#ifdef FS_CUDA
/* mrisIntegrateCUDA

   this is basically a fork of MRISIntegrate, but it shouldn't be.
   In future this should be merged into MRISIntegrate with the according ifdefs
*/
int
mrisIntegrateCUDA(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, int n_averages)
{
  int     t, write_iterations, niterations, nsmall, neg ;
  double  l_dist, l_area, l_spring, sse, old_sse, delta_t, total_small = 0.0;
  double  sse_thresh, pct_neg, pct_neg_area, total_vertices, tol;
  /*, scale, last_neg_area */ ;
  MHT     *mht_v_current = NULL ;
#ifdef FS_CUDA_TIMINGS
  struct timeval tv1,tv2,result;
#endif // FS_CUDA_TIMINGS

  /* Get some device info */
  //NJS no need to call this every loop: MRISCdeviceInfo();

  /* Okay the neighborhood of the surface will not change anywhere in here,
     so we can upload this all at once
     This is the important part, no function called by this function should
     change the vertices or the neighborhood at all
  */
  MRI_CUDA_SURFACE mris_cuda;
  MRI_CUDA_SURFACE *mrisc = &mris_cuda;
  MRISCinitSurface(mrisc);
  MRISCuploadVertices(mrisc,mris);
  MRISCuploadTotalNeighborArray(mrisc,mris);
  MRISCallocDistances(mrisc,mris);
  MRISCuploadDistOrigArray(mrisc,mris);

  if (Gdiag & DIAG_WRITE && parms->fp == NULL)
  {
    char fname[STRLEN] ;
    sprintf(fname, "%s.%s.out",
            mris->hemisphere == RIGHT_HEMISPHERE ? "rh":"lh",parms->base_name);
    if (!parms->start_t)
    {
      parms->fp = fopen(fname, "w") ;
    }
    else
    {
      parms->fp = fopen(fname, "a") ;
    }
    if (!parms->fp)
      ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                Progname, fname) ;
    mrisLogIntegrationParms(parms->fp, mris, parms) ;
  }
  l_spring = parms->l_spring ;
  l_dist = parms->l_dist ;
  l_area = parms->l_area ;
  write_iterations = parms->write_iterations ;
  niterations = parms->niterations ;
  if (((parms->flags & IPFLAG_QUICK) == 0) &&
      ((parms->flags & IPFLAG_NOSCALE_TOL) == 0))
  {
    tol = parms->tol * sqrt(((double)n_averages + 1.0) / 1024.0);
  }
  else
  {
    tol = parms->tol ;
  }
  sse_thresh = tol ;
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout,"integrating with navgs=%d and tol=%2.3e\n",n_averages,tol);
  }

  mrisProjectSurface(mris) ;
  mrisComputeMetricPropertiesCUDA(mrisc,mris) ;

#if AVERAGE_AREAS
  MRISreadTriangleProperties(mris, mris->fname) ;
  mrisAverageAreas(mris, n_averages, ORIG_AREAS) ;
#endif

  parms->starting_sse = sse = old_sse = MRIScomputeSSE(mris, parms) ;
  delta_t = 0.0 ;
  niterations += parms->start_t ;
  parms->t = parms->start_t ;

  if (!parms->start_t)
  {
    mrisLogStatus(mris, parms, stderr, 0.0f, -1) ;
    if (Gdiag & DIAG_WRITE)
    {
      mrisLogStatus(mris, parms, parms->fp, 0.0f, -1) ;
      if (write_iterations > 0)
      {
        mrisWriteSnapshot(mris, parms, 0) ;
      }
    }
  }

  if (Gdiag_no >= 0)
    fprintf(stdout,
            "v %d curvature = %2.5f, position = (%2.3f,%2.3f,%2.3f)\n",
            Gdiag_no, mris->vertices[Gdiag_no].H,
            mris->vertices[Gdiag_no].x,
            mris->vertices[Gdiag_no].y,
            mris->vertices[Gdiag_no].z) ;
  total_small = 0.0 ;
  nsmall = 0 ;

  total_vertices = (double)MRISvalidVertices(mris) ;
  neg = MRIScountNegativeTriangles(mris) ;
  pct_neg = (double)neg / total_vertices ;
  pct_neg_area =
    (float)mris->neg_area / (float)(mris->total_area+mris->neg_area) ;

  /*  mrisClearMomentum(mris) ;*/
  for (parms->t = t = parms->start_t ; t < niterations ; t++)
  {
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    if (!FZERO(parms->l_repulse_ratio))
      mht_v_current =
        MHTfillVertexTableRes(mris, mht_v_current,CURRENT_VERTICES, 3.0);
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("MHTfillVertexTableRes: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    if (!FZERO(parms->l_curv))
    {
      MRIScomputeSecondFundamentalForm(mris) ;
    }
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("MRIScomputeSecondFundamentalForm: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);
#endif // FS_CUDA_TIMINGS

    MRISclearGradient(mris) ;      /* clear old deltas */
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    mrisComputeVariableSmoothnessCoefficients(mris, parms) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("mrisComputeVariableSmoothnessCoefficient: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    mrisComputeDistanceTerm(mris, parms) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("mrisComputeDistanceTerm: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    if (Gdiag & DIAG_WRITE && parms->write_iterations > 0 && DIAG_VERBOSE_ON)
    {
      MRI *mri ;
      char fname[STRLEN] ;
      sprintf(fname, "dist_dx%04d.mgz", parms->t) ;
      mri = MRISwriteIntoVolume(mris, NULL, VERTEX_DX) ;
      MRIwrite(mri,fname) ;
      sprintf(fname, "dist_dy%04d.mgz", parms->t) ;
      MRISwriteIntoVolume(mris, mri, VERTEX_DY) ;
      MRIwrite(mri,fname) ;
      sprintf(fname, "dist_dz%04d.mgz", parms->t) ;
      MRISwriteIntoVolume(mris, mri, VERTEX_DZ) ;
      MRIwrite(mri,fname) ;
      MRIfree(&mri) ;
    }
    mrisComputeAngleAreaTerms(mris, parms) ;
    mrisComputeCorrelationTerm(mris, parms) ;
    mrisComputePolarCorrelationTerm(mris, parms) ;
    /*    mrisComputeSpringTerm(mris, parms->l_spring) ;*/
    /* vectorial registration */
    if (parms->flags & IP_USE_MULTIFRAMES)
    {
      mrisComputeVectorCorrelationTerm(mris, parms);
      mrisComputePolarVectorCorrelationTerm(mris,parms);
    }

#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("Preparation phase A: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);
#endif // FS_CUDA_TIMINGS

#if 0
    mrisComputeCurvatureTerm(mris, parms) ;
    mrisComputeNegTerm(mris, parms) ;
    mrisComputeBoundaryTerm(mris, parms) ;
#endif
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    mrisComputeRepulsiveRatioTerm(mris,
                                  parms->l_repulse_ratio,
                                  mht_v_current);
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("mrisComputeRepulsiveRatioTerm: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    mrisComputeLaplacianTerm(mris, parms->l_lap) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("mrisComputeLaplacianTerm: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);
#endif // FS_CUDA_TIMINGS

    /* Due to the overhead for uploading and downloading the gradients,
       this is only worthwile for more than 4 averages, I think
    */
    if(n_averages > 4)
    {
#ifdef FS_CUDA_TIMINGS
      gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
      /* now we have to put all the overhead here */
      MRISCuploadGradients(mrisc,mris);
      MRISCaverageGradients(mrisc,mris,n_averages);
      MRISCdownloadGradients(mrisc,mris);
#ifdef FS_CUDA_TIMINGS
      gettimeofday(&tv2,NULL);
      timeval_subtract(&result,&tv2,&tv1);
      printf("CUDA MRISCverageGradients: %ld ms\n",
             result.tv_sec*1000+result.tv_usec/1000);
      fflush(stdout);
#endif // FS_CUDA_TIMINGS
    }
    else
    {
#ifdef FS_CUDA_TIMINGS
      gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
      MRISaverageGradients(mris, n_averages) ;
#ifdef FS_CUDA_TIMINGS
      gettimeofday(&tv2,NULL);
      timeval_subtract(&result,&tv2,&tv1);
      printf("CPU MRISaverageGradients: %ld ms\n",
             result.tv_sec*1000+result.tv_usec/1000);
      fflush(stdout);
#endif // FS_CUDA_TIMINGS
    }

#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    mrisComputeSpringTerm(mris, parms->l_spring) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("mrisComputeSpringTerm: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    mrisComputeThicknessMinimizationTerm(mris, parms->l_thick_min, parms) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("mrisComputeThicknessMinimizationTerm: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    mrisComputeAshburnerTriangleTerm(mris, parms->l_ashburner_triangle, parms);
    mrisComputeThicknessParallelTerm(mris, parms->l_thick_parallel, parms) ;
    mrisComputeThicknessNormalTerm(mris, parms->l_thick_normal, parms) ;
    mrisComputeThicknessSpringTerm(mris, parms->l_thick_spring, parms) ;
    mrisComputeAshburnerTriangleTerm(mris, parms->l_ashburner_triangle, parms) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("mrisComputeThicknessParallelTerm: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    mrisComputeTangentialSpringTerm(mris, parms->l_tspring) ;
    mrisComputeNonlinearTangentialSpringTerm(mris,
                                             parms->l_nltspring,
                                             parms->min_dist) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("mrisComputeTangentialSpringTerm: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    mrisComputeNonlinearSpringTerm(mris, parms->l_nlspring, parms) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("mrisComputeNonlinearSpringTerm: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    mrisComputeQuadraticCurvatureTerm(mris, parms->l_curv) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("mrisComputeQuadraticCurvatureTerm: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);
#endif // FS_CUDA_TIMINGS

    if (Gdiag & DIAG_WRITE && parms->write_iterations > 0 && DIAG_VERBOSE_ON)
    {
      MRI *mri ;
      char fname[STRLEN] ;
      sprintf(fname, "dx%04d.mgz", parms->t) ;
      mri = MRISwriteIntoVolume(mris, NULL, VERTEX_DX) ;
      MRIwrite(mri,fname) ;
      sprintf(fname, "dy%04d.mgz", parms->t) ;
      MRISwriteIntoVolume(mris, mri, VERTEX_DY) ;
      MRIwrite(mri,fname) ;
      sprintf(fname, "dz%04d.mgz", parms->t) ;
      MRISwriteIntoVolume(mris, mri, VERTEX_DZ) ;
      MRIwrite(mri,fname) ;
      MRIfree(&mri) ;
    }

#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    switch (parms->integration_type)
    {
    case INTEGRATE_LM_SEARCH:
      printf("mrisLineMinimizeSearch()\n");
      delta_t = mrisLineMinimizeSearch(mris, parms) ;
      break ;
    default:
    case INTEGRATE_LINE_MINIMIZE:
      printf("mrisLineMinimize()\n");
      delta_t = mrisLineMinimizeCUDA(mrisc, mris, parms) ;
      break ;
    case INTEGRATE_MOMENTUM:
      printf("MRISmomentumTimeStep()\n");
      delta_t = MRISmomentumTimeStep(mris, parms->momentum, parms->dt,
                                     tol, parms->n_averages) ;
      break ;
    case INTEGRATE_ADAPTIVE:
      printf("mrisAdaptiveTimeStep()\n");
      delta_t = mrisAdaptiveTimeStep(mris, parms);
      break ;
    }

#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("Search phase: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    if (!FZERO(parms->l_pcorr) && (Gdiag & DIAG_SHOW))
    {
      float  alpha, beta, gamma ;

      alpha = DEGREES(delta_t*mris->alpha) ;
      beta = DEGREES(delta_t*mris->beta) ;
      gamma = DEGREES(delta_t*mris->gamma) ;
      fprintf(stdout, "rotating brain by (%2.1f, %2.1f, %2.1f)\n",
              alpha, beta, gamma) ;
    }

    /* add one more here */
    mrisProjectSurface(mris) ;
    mrisComputeMetricPropertiesCUDA(mrisc,mris) ;
    if (Gdiag_no >= 0)
      fprintf(stdout, "v %d curvature = %2.3f\n",
              Gdiag_no, mris->vertices[Gdiag_no].H) ;

    /* only print stuff out if we actually took a step */
    sse = MRIScomputeSSE_CUDA(mris, mrisc, parms) ;
    if (!FZERO(old_sse) && ((old_sse-sse)/(old_sse) < sse_thresh))
    {
      if (++nsmall > MAX_SMALL)
      {
        break ;
      }
      if (++total_small > TOTAL_SMALL)
      {
        break ;
      }
    }
    else
    {
      if (total_small > 0.0)  /* if error increases more
                                 than 1/4 time quit */
      {
        total_small -= .25 ;
      }
      nsmall = 0 ;
    }

    parms->t++ ;

    mrisLogStatus(mris, parms, stderr, delta_t, old_sse) ;

    if (Gdiag & DIAG_WRITE)
    {
      mrisLogStatus(mris, parms, parms->fp, delta_t, -1) ;
    }

    if ((Gdiag & DIAG_SHOW) && !((t+1)%10))
    {
      MRISprintTessellationStats(mris, stderr) ;
    }

    if ((write_iterations > 0) &&
        !((t+1)%write_iterations)&&(Gdiag&DIAG_WRITE))
    {
      mrisWriteSnapshot(mris, parms, t+1) ;
    }

    if (mris->status == MRIS_PLANE && mris->neg_area > 4*mris->total_area)
    {
      fprintf(stdout, "flipping flattened patch...\n") ;
      mrisClearMomentum(mris) ;
      mrisFlipPatch(mris) ;
      MRIScomputeMetricProperties(mris) ;
    }
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);

    timeval_subtract(&result,&tv2,&tv1);
    printf("Application phase: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);
#endif // FS_CUDA_TIMINGS

    if (FZERO(sse))
    {
      break ;
    }
    if ((parms->integration_type == INTEGRATE_LINE_MINIMIZE) ||
        (parms->integration_type == INTEGRATE_LM_SEARCH) ||
        (parms->integration_type == INTEGRATE_MOMENTUM))
    {
      if ((100*(old_sse - sse) / sse) < tol)
      {
        break ;
      }
    }
    old_sse = sse ;
    if (FZERO(delta_t))   /* reached the minimum */
    {
      break ;
    }

  }

  if (!FZERO(parms->l_repulse))
  {
    MHTfree(&mht_v_current) ;
  }

  // If this is a plane, its possible the CPU Metric Properties were called
  // last and the distance vector on the GPU is outdated.
  if(mris->status != MRIS_PLANE)
  {
    parms->ending_sse = MRIScomputeSSE_CUDA(mris, mrisc, parms);
  }
  else
  {
    parms->ending_sse = MRIScomputeSSE(mris, parms) ;
  }
  /*  mrisProjectSurface(mris) ;*/
  MRISCcleanupSurface(mrisc);
  return(parms->t-parms->start_t) ;  /* return actual # of steps taken */
}

#endif /* FS_CUDA */

/*-----------------------------------------------------
  Parameters:


  Returns value:

  Description
  This routine is solely for reporting purposes - it is
  not used by any of the numerical integration routines.
  ------------------------------------------------------*/
static double
mrisComputeError(MRI_SURFACE *mris, INTEGRATION_PARMS *parms,
                 float *parea_rms, float *pangle_rms,
                 float *pcurv_rms, float *pdist_rms,
                 float *pcorr_rms)
{
  double  rms, sse_area, sse_angle, sse_curv, delta, area_scale, sse_dist,
          sse_corr ;
  int     ano, fno, ntriangles, total_neighbors ;
  FACE    *face ;
  float   nv ;

#if METRIC_SCALE
  if (mris->patch)
  {
    area_scale = 1.0 ;
  }
  else
  {
    area_scale = mris->orig_area / mris->total_area ;
  }
#else
  area_scale = 1.0 ;
#endif

  sse_angle = sse_area = 0.0 ;
  for (ntriangles = fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
    ntriangles++ ;
    delta = (double)(area_scale * face->area - face->orig_area) ;
    sse_area += delta*delta ;
    for (ano = 0 ; ano < ANGLES_PER_TRIANGLE ; ano++)
    {
      delta = deltaAngle(face->angle[ano], face->orig_angle[ano]);
      sse_angle += delta*delta ;
    }
    if (!finite(sse_area) || !finite(sse_angle))
      ErrorExit(ERROR_BADPARM,
                "sse (%f, %f) is not finite at face %d!\n",
                sse_area,sse_angle,fno);
  }

  sse_corr = mrisComputeCorrelationError(mris, parms, 1) ;
  if (!DZERO(parms->l_dist))
  {
    sse_dist = mrisComputeDistanceError(mris, parms) ;
  }
  else
  {
    sse_dist = 0 ;
  }

#if 0
  if (!FZERO(parms->l_spring))
  {
    sse_spring = mrisComputeSpringEnergy(mris) ;
  }
  if (!FZERO(parms->l_tspring))
  {
    sse_tspring = mrisComputeTangentialSpringEnergy(mris) ;
  }
#endif
  sse_curv = mrisComputeQuadraticCurvatureSSE(mris, parms->l_curv) ;

  total_neighbors = mrisCountTotalNeighbors(mris) ;

  nv = (float)MRISvalidVertices(mris) ;
  if  (mris->status != MRIS_PLANE)
  {
    *pcurv_rms = (float)sqrt(sse_curv / nv) ;
  }
  else
  {
    *pcurv_rms = 0.0f ;
  }
  *pdist_rms = (float)sqrt(sse_dist / (double)total_neighbors) ;
  *parea_rms = (float)sqrt(sse_area/(double)ntriangles) ;
  *pangle_rms =(float)sqrt(sse_angle/(double)(ntriangles*ANGLES_PER_TRIANGLE));
  *pcorr_rms = (float)sqrt(sse_corr / (double)nv) ;

#ifdef FS_CUDA
  INTEGRATION_PARMS *tparms;

  /* Change the parameters such that the distance error won't be calculated in
     MRIScomputeSSE

     This optimization doesn't buy really anything, but serves to test a lazy
     evaluation scheme.
  */
  tparms = mrisCloneIP(parms);
  tparms->l_dist = 0.0;
  tparms->l_corr = 0.0;
  tparms->l_curv = 0.0;

  rms = MRIScomputeSSE(mris, tparms);

  mrisDeleteIP(tparms);

  /* Now add the distance error */
  rms +=
    sse_dist * parms->l_dist +
    sse_corr * parms->l_corr +
    sse_curv * parms->l_curv * CURV_SCALE;

#else
  rms = MRIScomputeSSE(mris, parms) ;
#endif /* FS_CUDA */

#if 0
  rms =
    *pdist_rms * parms->l_dist +
    *parea_rms * parms->l_area +
    *parea_rms * parms->l_parea +
    *pangle_rms * parms->l_angle +
    *pcorr_rms * (parms->l_corr+parms->l_pcorr) +
    sqrt(sse_spring/nv) * parms->l_spring ;
#endif
  return(rms) ;
}


static double
mrisComputeSSE_MEF(MRI_SURFACE *mris,
                   INTEGRATION_PARMS *parms,
                   MRI *mri30,
                   MRI *mri5,
                   double weight30,
                   double weight5,
                   MHT *mht)
{
  double sse, l_intensity, rms;

  l_intensity = parms->l_intensity ;
  parms->l_intensity = 0 ;

  sse = MRIScomputeSSE(mris, parms) ;
  parms->l_intensity = l_intensity ;
  rms = mrisRmsValError_mef(mris, mri30, mri5, weight30, weight5) ;
  sse += l_intensity*rms*mris->nvertices ;
  if (!FZERO(parms->l_surf_repulse))
    sse += parms->l_surf_repulse *
           mrisComputeSurfaceRepulsionEnergy(mris, parms->l_surf_repulse, mht);

  return(sse) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  this is the routine actually used for the numerical integration.
  As such, it must represent the exact error function being
  minimized (as opposed to computeError above).
  ------------------------------------------------------*/
double
MRIScomputeSSE(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  double  sse, sse_area, sse_angle, delta, sse_curv, sse_spring, sse_dist,
    area_scale, sse_corr, sse_neg_area, l_corr,
    sse_val, sse_sphere, sse_thick_min, sse_thick_parallel,
    sse_ashburner_triangle,
    sse_grad, sse_nl_area, sse_nl_dist, sse_tspring,
    sse_repulse, sse_tsmooth, sse_loc, sse_thick_spring,
    sse_repulsive_ratio, sse_shrinkwrap, sse_expandwrap,
    sse_lap, sse_dura, sse_nlspring, sse_thick_normal, sse_histo, sse_map, sse_map2d ;
  int     ano, fno ;
  FACE    *face ;
  MHT     *mht_v_current = NULL ;
  MHT     *mht_f_current = NULL ;


#if METRIC_SCALE
  if (mris->patch || mris->noscale)
  {
    area_scale = 1.0 ;
  }
  else
  {
    area_scale = mris->orig_area / mris->total_area ;
  }
#else
  area_scale = 1.0 ;
#endif

  sse_repulse =
    sse_repulsive_ratio =
      sse_tsmooth =
        sse_thick_parallel =
          sse_thick_normal =
            sse_thick_spring =
              sse_nl_area =
                sse_nl_dist =
                  sse_corr =
                    sse_angle =
                      sse_ashburner_triangle =
                        sse_neg_area =
                          sse_val =
                            sse_sphere =
                              sse_shrinkwrap =
                                sse_expandwrap =
                                  sse_area =
                                    sse_dura =
                                      sse_histo =
                                        sse_lap =
                                          sse_spring =
                                              sse_curv =
                                                  sse_dist =
                                                      sse_tspring =
                                                          sse_loc =
                                                              sse_nlspring =
                                                                  sse_map =
                                                                    sse_map2d =
                                                                      sse_grad=0.0;

  if (!FZERO(parms->l_repulse))
  {
    mht_v_current = MHTfillVertexTable(mris, mht_v_current,CURRENT_VERTICES);
    mht_f_current = MHTfillTable(mris, mht_f_current);
  }

  if (!FZERO(parms->l_angle)||!FZERO(parms->l_area)||(!FZERO(parms->l_parea)))
  {
    for (fno = 0 ; fno < mris->nfaces ; fno++)
    {
      face = &mris->faces[fno] ;
      if (face->ripflag)
      {
        continue ;
      }

      delta = (double)(area_scale*face->area - face->orig_area) ;
#if ONLY_NEG_AREA_TERM
      if (face->area < 0.0f)
      {
        sse_neg_area += delta*delta ;
      }
#endif
      sse_area += delta*delta ;
      for (ano = 0 ; ano < ANGLES_PER_TRIANGLE ; ano++)
      {
        delta = deltaAngle(face->angle[ano],face->orig_angle[ano]);
#if ONLY_NEG_AREA_TERM
        if (face->angle[ano] >= 0.0f)
        {
          delta = 0.0f ;
        }
#endif
        sse_angle += delta*delta ;
      }
      if (!finite(sse_area) || !finite(sse_angle))
      {
        ErrorExit(ERROR_BADPARM, "sse not finite at face %d!\n",fno);
      }
    }
  }
  if (parms->l_repulse > 0)
    sse_repulse
    = mrisComputeRepulsiveEnergy(mris, parms->l_repulse, mht_v_current,
                                 mht_f_current) ;
  sse_repulsive_ratio =
    mrisComputeRepulsiveRatioEnergy(mris, parms->l_repulse_ratio) ;
  sse_tsmooth = mrisComputeThicknessSmoothnessEnergy(mris, parms->l_tsmooth) ;
  sse_thick_min =
    mrisComputeThicknessMinimizationEnergy(mris, parms->l_thick_min, parms) ;
  sse_ashburner_triangle =
    mrisComputeAshburnerTriangleEnergy(mris,parms->l_ashburner_triangle,parms) ;
  sse_thick_parallel =
    mrisComputeThicknessParallelEnergy(mris, parms->l_thick_parallel, parms) ;
  sse_thick_normal =
    mrisComputeThicknessNormalEnergy(mris, parms->l_thick_normal, parms) ;
  sse_thick_spring =
    mrisComputeThicknessSpringEnergy(mris, parms->l_thick_spring, parms) ;
  if (!FZERO(parms->l_nlarea))
  {
    sse_nl_area = mrisComputeNonlinearAreaSSE(mris) ;
  }
  if (!DZERO(parms->l_nldist))
  {
    sse_nl_dist = mrisComputeNonlinearDistanceSSE(mris) ;
  }
  if (!DZERO(parms->l_dist))
  {
    sse_dist = mrisComputeDistanceError(mris, parms) ;
  }
  if (!DZERO(parms->l_spring))
  {
    sse_spring = mrisComputeSpringEnergy(mris) ;
  }
  if (!DZERO(parms->l_lap))
  {
    sse_lap = mrisComputeLaplacianEnergy(mris) ;
  }
  if (!DZERO(parms->l_tspring))
  {
    sse_tspring = mrisComputeTangentialSpringEnergy(mris) ;
  }
  if (!DZERO(parms->l_nlspring))
  {
    sse_nlspring = mrisComputeNonlinearSpringEnergy(mris, parms) ;
  }
  if (!DZERO(parms->l_curv))
  {
    sse_curv = mrisComputeQuadraticCurvatureSSE(mris, parms->l_curv) ;
  }
  l_corr = (double)(parms->l_corr + parms->l_pcorr) ;
  if (!DZERO(l_corr))
  {
    sse_corr = mrisComputeCorrelationError(mris, parms, 1) ;
  }
  if (!DZERO(parms->l_intensity))
  {
    sse_val = mrisComputeIntensityError(mris, parms) ;
  }
  if (!DZERO(parms->l_location))
  {
    sse_loc = mrisComputeTargetLocationError(mris, parms) ;
  }
  if (!DZERO(parms->l_dura))
  {
    sse_dura = mrisComputeDuraError(mris, parms) ;
  }
  if (!DZERO(parms->l_histo))
  {
    sse_histo = mrisComputeHistoNegativeLikelihood(mris, parms) ;
  }
  if (!DZERO(parms->l_map))
  {
    sse_map = mrisComputeNegativeLogPosterior(mris, parms, NULL) ;
  }
  if (!DZERO(parms->l_map2d))
  {
    sse_map2d = mrisComputeNegativeLogPosterior2D(mris, parms, NULL) ;
  }
  if (!DZERO(parms->l_grad))
  {
    sse_grad = mrisComputeIntensityGradientError(mris, parms) ;
  }
  if (!DZERO(parms->l_sphere))
  {
    sse_sphere = mrisComputeSphereError(mris, parms->l_sphere, parms->a) ;
  }
  if (!DZERO(parms->l_shrinkwrap))
    sse_shrinkwrap =
      mrisComputeShrinkwrapError(mris, parms->mri_brain, parms->l_shrinkwrap) ;
  if (!DZERO(parms->l_expandwrap))
    sse_expandwrap =
      mrisComputeExpandwrapError(mris, parms->mri_brain, parms->l_expandwrap,
                                 parms->target_radius) ;

  sse = 0 ;

  if (gMRISexternalSSE)
  {
    sse = (*gMRISexternalSSE)(mris, parms) ;
  }
  sse +=
    (double)parms->l_area      * sse_neg_area + sse_repulse +
    (double)parms->l_tsmooth   * sse_tsmooth +
    (double)parms->l_thick_min * sse_thick_min +
    (double)parms->l_thick_parallel * sse_thick_parallel +
    (double)parms->l_thick_spring * sse_thick_spring +
    (double)parms->l_thick_normal * sse_thick_normal +
    (double)parms->l_sphere    * sse_sphere + sse_repulsive_ratio +
    (double)parms->l_intensity * sse_val +
    (double)parms->l_location  * sse_loc +
    (double)parms->l_lap       * sse_lap +
    (double)parms->l_ashburner_triangle * sse_ashburner_triangle +
    (double)parms->l_shrinkwrap * sse_shrinkwrap +
    (double)parms->l_expandwrap * sse_expandwrap +
    (double)parms->l_map       * sse_map +
    (double)parms->l_map2d     * sse_map2d +
    (double)parms->l_grad      * sse_grad +
    (double)parms->l_parea     * sse_area +
    (double)parms->l_nldist    * sse_nl_dist +
    (double)parms->l_nlarea    * sse_nl_area +
    (double)parms->l_angle     * sse_angle +
    (double)parms->l_dist      * sse_dist +
    (double)parms->l_nlspring  * sse_nlspring +
    (double)parms->l_spring    * sse_spring +
    (double)parms->l_dura      * sse_dura +
    (double)parms->l_tspring   * sse_tspring +
    (double)l_corr             * sse_corr +
    (double)parms->l_curv      * CURV_SCALE * sse_curv ;

  if (parms->flags & IP_USE_MULTIFRAMES)
  {
    sse += (double)mrisComputeVectorCorrelationError(mris, parms, 1) ;
  }

  if (mht_v_current)
  {
    MHTfree(&mht_v_current) ;
  }
  if (mht_f_current)
  {
    MHTfree(&mht_f_current) ;
  }

  if (!devFinite(sse))
  {
    DiagBreak() ;
  }
  return(sse) ;
}

#ifdef FS_CUDA
static double
MRIScomputeSSE_CUDA(MRI_SURFACE *mris,
                    MRI_CUDA_SURFACE *mrisc,
                    INTEGRATION_PARMS *parms)
{
  double  sse, sse_area, sse_angle, delta, sse_curv, sse_spring, sse_dist,
    area_scale, sse_corr, sse_neg_area, l_corr, sse_val, sse_sphere,
    sse_thick_min, sse_thick_parallel,sse_ashburner_triangle,
    sse_grad, sse_nl_area, sse_nl_dist, sse_tspring, sse_repulse,
    sse_tsmooth, sse_loc,
    sse_repulsive_ratio, sse_shrinkwrap, sse_expandwrap, sse_lap,
    sse_dura, sse_nlspring, sse_thick_normal, sse_thick_spring,
    sse_histo, sse_map = 0.0, sse_map2d = 0.0  ;
  int     ano, fno ;
  FACE    *face ;
  MHT     *mht_v_current = NULL ;
  MHT     *mht_f_current = NULL ;

#if METRIC_SCALE
  if (mris->patch || mris->noscale)
  {
    area_scale = 1.0 ;
  }
  else
  {
    area_scale = mris->orig_area / mris->total_area ;
  }
#else
  area_scale = 1.0 ;
#endif

  sse_repulse =
    sse_repulsive_ratio =
      sse_tsmooth =
        sse_nl_area =
          sse_nl_dist =
            sse_corr =
              sse_angle =
                sse_neg_area =
                  sse_val =
                    sse_sphere =
                      sse_shrinkwrap =
                        sse_expandwrap =
                          sse_area =
                            sse_dura =
                              sse_histo =
                                sse_lap =
                                  sse_spring =
                                    sse_curv =
                                      sse_dist =
                                        sse_tspring =
                                          sse_loc =
                                              sse_nlspring =
                                                  sse_thick_parallel =
                                                      sse_thick_min =
                                                          sse_thick_normal =
                                                              sse_thick_spring =
                                                                  sse_grad = 0.0;

  if (!FZERO(parms->l_repulse))
  {
    mht_v_current = MHTfillVertexTable(mris, mht_v_current,CURRENT_VERTICES);
    mht_f_current = MHTfillTable(mris, mht_f_current);
  }

  if (!FZERO(parms->l_angle)||!FZERO(parms->l_area)||(!FZERO(parms->l_parea)))
  {
    for (fno = 0 ; fno < mris->nfaces ; fno++)
    {
      face = &mris->faces[fno] ;
      if (face->ripflag)
      {
        continue ;
      }

      delta = (double)(area_scale*face->area - face->orig_area) ;
#if ONLY_NEG_AREA_TERM
      if (face->area < 0.0f)
      {
        sse_neg_area += delta*delta ;
      }
#endif
      sse_area += delta*delta ;
      for (ano = 0 ; ano < ANGLES_PER_TRIANGLE ; ano++)
      {
        delta = deltaAngle(face->angle[ano],face->orig_angle[ano]);
#if ONLY_NEG_AREA_TERM
        if (face->angle[ano] >= 0.0f)
        {
          delta = 0.0f ;
        }
#endif
        sse_angle += delta*delta ;
      }
      if (!finite(sse_area) || !finite(sse_angle))
      {
        ErrorExit(ERROR_BADPARM, "sse not finite at face %d!\n",fno);
      }
    }
  }
  if (parms->l_repulse > 0)
    sse_repulse
    = mrisComputeRepulsiveEnergy(mris, parms->l_repulse, mht_v_current,
                                 mht_f_current) ;
  sse_repulsive_ratio =
    mrisComputeRepulsiveRatioEnergy(mris, parms->l_repulse_ratio) ;
  sse_tsmooth = mrisComputeThicknessSmoothnessEnergy(mris, parms->l_tsmooth) ;
  sse_thick_min =
    mrisComputeThicknessMinimizationEnergy(mris, parms->l_thick_min, parms) ;
  sse_thick_parallel =
    mrisComputeThicknessParallelEnergy(mris, parms->l_thick_parallel, parms) ;
  sse_ashburner_triangle =
    mrisComputeAshburnerTriangleEnergy(mris, parms->l_ashburner_triangle, parms) ;
  sse_thick_normal =
    mrisComputeThicknessNormalEnergy(mris, parms->l_thick_normal, parms) ;
  sse_thick_spring =
    mrisComputeThicknessSpringEnergy(mris, parms->l_thick_spring, parms) ;
  if (!FZERO(parms->l_nlarea))
  {
    sse_nl_area = mrisComputeNonlinearAreaSSE(mris) ;
  }
  if (!DZERO(parms->l_nldist))
  {
    sse_nl_dist = mrisComputeNonlinearDistanceSSE(mris) ;
  }
  if (!DZERO(parms->l_dist))
  {
    sse_dist = mrisComputeDistanceErrorCUDA(mris, mrisc, parms) ;
  }
  if (!DZERO(parms->l_spring))
  {
    sse_spring = mrisComputeSpringEnergy(mris) ;
  }
  if (!DZERO(parms->l_lap))
  {
    sse_lap = mrisComputeLaplacianEnergy(mris) ;
  }
  if (!DZERO(parms->l_tspring))
  {
    sse_tspring = mrisComputeTangentialSpringEnergy(mris) ;
  }
  if (!DZERO(parms->l_nlspring))
  {
    sse_nlspring = mrisComputeNonlinearSpringEnergy(mris, parms) ;
  }
  if (!DZERO(parms->l_curv))
  {
    sse_curv = mrisComputeQuadraticCurvatureSSE(mris, parms->l_curv) ;
  }
  l_corr = (double)(parms->l_corr + parms->l_pcorr) ;
  if (!DZERO(l_corr))
  {
    sse_corr = mrisComputeCorrelationError(mris, parms, 1) ;
  }
  if (!DZERO(parms->l_intensity))
  {
    sse_val = mrisComputeIntensityError(mris, parms) ;
  }
  if (!DZERO(parms->l_location))
  {
    sse_loc = mrisComputeTargetLocationError(mris, parms) ;
  }
  if (!DZERO(parms->l_dura))
  {
    sse_dura = mrisComputeDuraError(mris, parms) ;
  }
  if (!DZERO(parms->l_histo))
  {
    sse_histo = mrisComputeHistoNegativeLikelihood(mris, parms) ;
  }
  if (!DZERO(parms->l_map))
  {
    sse_map = mrisComputeNegativeLogPosterior(mris, parms, NULL) ;
  }
  if (!DZERO(parms->l_map2d))
  {
    sse_map2d = mrisComputeNegativeLogPosterior2D(mris, parms, NULL) ;
  }
  if (!DZERO(parms->l_grad))
  {
    sse_grad = mrisComputeIntensityGradientError(mris, parms) ;
  }
  if (!DZERO(parms->l_sphere))
  {
    sse_sphere = mrisComputeSphereError(mris, parms->l_sphere, parms->a) ;
  }
  if (!DZERO(parms->l_shrinkwrap))
    sse_shrinkwrap =
      mrisComputeShrinkwrapError(mris, parms->mri_brain, parms->l_shrinkwrap) ;
  if (!DZERO(parms->l_expandwrap))
    sse_expandwrap =
      mrisComputeExpandwrapError(mris, parms->mri_brain, parms->l_expandwrap,
                                 parms->target_radius) ;

  sse = 0 ;

  if (gMRISexternalSSE)
  {
    sse = (*gMRISexternalSSE)(mris, parms) ;
  }
  sse +=
    (double)parms->l_area      * sse_neg_area + sse_repulse +
    (double)parms->l_tsmooth   * sse_tsmooth +
    (double)parms->l_thick_min * sse_thick_min +
    (double)parms->l_thick_parallel * sse_thick_parallel +
    (double)parms->l_ashburner_triangle * sse_ashburner_triangle +
    (double)parms->l_thick_normal * sse_thick_normal +
    (double)parms->l_thick_spring * sse_thick_spring +
    (double)parms->l_sphere    * sse_sphere + sse_repulsive_ratio +
    (double)parms->l_intensity * sse_val +
    (double)parms->l_location  * sse_loc +
    (double)parms->l_lap       * sse_lap +
    (double)parms->l_shrinkwrap * sse_shrinkwrap +
    (double)parms->l_expandwrap * sse_expandwrap +
    (double)parms->l_grad      * sse_grad +
    (double)parms->l_parea     * sse_area +
    (double)parms->l_nldist    * sse_nl_dist +
    (double)parms->l_nlarea    * sse_nl_area +
    (double)parms->l_angle     * sse_angle +
    (double)parms->l_dist      * sse_dist +
    (double)parms->l_nlspring  * sse_nlspring +
    (double)parms->l_spring    * sse_spring +
    (double)parms->l_dura      * sse_dura +
    (double)parms->l_histo     * sse_histo +
    (double)parms->l_tspring   * sse_tspring +
    (double)l_corr             * sse_corr +
    (double)parms->l_map       * sse_map +
    (double)parms->l_map2d     * sse_map2d +
    (double)parms->l_curv      * CURV_SCALE * sse_curv ;

  if (parms->flags & IP_USE_MULTIFRAMES)
  {
    sse += (double)mrisComputeVectorCorrelationError(mris, parms, 1) ;
  }

  if (mht_v_current)
  {
    MHTfree(&mht_v_current) ;
  }
  if (mht_f_current)
  {
    MHTfree(&mht_f_current) ;
  }

  if (!devFinite(sse))
  {
    DiagBreak() ;
  }
  return(sse) ;
}

#endif /* FS_CUDA */

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  this is the routine actually used for the numerical integration.
  As such, it must represent the exact error function being
  minimized (as opposed to computeError above).
  ------------------------------------------------------*/
double
MRIScomputeSSEExternal(MRI_SURFACE *mris,
                       INTEGRATION_PARMS *parms,
                       double *ext_sse)
{
  double  sse ;

  if (gMRISexternalSSE)
  {
    sse = (*gMRISexternalSSE)(mris, parms) ;
  }
  else
  {
    sse = 0 ;
  }
  *ext_sse = sse ;
  sse = MRIScomputeSSE(mris, parms) ;  /* throw out ext_sse
                                          as it will be recomputed */

  return(sse) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeNonlinearAreaSSE(MRI_SURFACE *mris)
{
  double  sse, area_scale, error, ratio ;
  int     fno ;
  FACE    *face ;

#if METRIC_SCALE
  if (mris->patch)
  {
    area_scale = 1.0 ;
  }
  else
  {
    area_scale = mris->orig_area / mris->total_area ;
  }
#else
  area_scale = 1.0 ;
#endif

  sse = 0.0 ;
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
#define SCALE_NONLINEAR_AREA 0
#if SCALE_NONLINEAR_AREA
    if (!FZERO(face->orig_area))
    {
      ratio = area_scale*face->area / face->orig_area ;
    }
    else
    {
      ratio = 0.0f ;
    }
#else
    ratio = area_scale*face->area ;
#endif
    if (ratio > MAX_NEG_RATIO)
    {
      ratio = MAX_NEG_RATIO ;
    }
    else if (ratio < -MAX_NEG_RATIO)
    {
      ratio = -MAX_NEG_RATIO ;
    }
#if 0
    error = (1.0 / NEG_AREA_K) * log(1.0+exp(-NEG_AREA_K*ratio)) ;
#else
    error = (log(1.0+exp(NEG_AREA_K*ratio)) / NEG_AREA_K) - ratio ;
#endif

    sse += error ;
    if (!finite(sse) || !finite(error))
    {
      ErrorExit(ERROR_BADPARM, "nlin area sse not finite at face %d!\n",fno);
    }
  }
  return(sse) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISscaleBrainArea(MRI_SURFACE *mris)
{
  float   scale ;

  scale = sqrt(mris->orig_area / (mris->total_area+mris->neg_area)) ;
  MRISscaleBrain(mris, mris, scale) ;
  MRIScomputeMetricProperties(mris) ;
  return(NO_ERROR) ;
}


#if 0
/////////////// not used ////////////////////////////////////////////////
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Find the 3 poles (temporal, occipital, and frontal) of
  the cortical surface.
  ------------------------------------------------------*/
#define MIN_Z_DISTANCE       30.0f
#define MIN_Y_DISTANCE       30.0f
#define MIN_ANGLE_VARIATION  RADIANS(30.0f)

static int
mrisFindPoles(MRIS *mris)
{
  int     vno, n, neigh, local_max ;
  VERTEX  *vertex, *v_neigh ;
  double    x, y, z, xt, yt, zt ;
  float   temporal_y_hi = -1000, zfront, yfront, angle ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    fprintf(stdout, "(%2.0f, %2.0f, %2.0f) --> (%2.0f, %2.0f, %2.0f), ctr "
            "(%2.0f, %2.0f, %2.0f)\n",
            mris->xlo, mris->ylo, mris->zlo, mris->xhi, mris->yhi, mris->zhi,
            mris->xctr, mris->yctr, mris->zctr);
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "finding cortical poles...") ;
  }

  /* first find frontal and occipital poles */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->y >= mris->yhi)
    {
      mris->v_frontal_pole = vertex ;
    }
    else if (vertex->y <= mris->ylo)
    {
      mris->v_occipital_pole = vertex ;
    }
  }

  /* now find temporal pole */
  zfront = mris->v_frontal_pole->z ;
  yfront = mris->v_frontal_pole->y ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    x = (double)vertex->x ;
    y = (double)vertex->y ;
    z = (double)vertex->z ;
    // get the talairach point (RAS)
    if (mris->lta)
    {
      TransformWithMatrix(mris->SRASToTalSRAS_, x, y, z, &xt, &yt, &zt);
    }
    else
    {
      // assume that talRAS and RAS are the same
      xt = x;
      yt = y;
      zt = z;
    }
#if 0
    // I don't understand the reasoning of flip x, exchange y and z
    // since surface vertex is already a RAS.
    if (mris->linear_transform)
    {
      transform_point(mris->linear_transform, -x, z, y, &xt, &yt, &zt) ;
    }
    else
    {
      xt = -x ;
      yt = z ;
      zt = y ;
    }
#endif
    /*
      some rules for finding the temporal pole:

      1. must be a local max in y (posterior-anterior) direction.    y <-- A
      2. Must be below some absolute y talairach coordinate.
      3. Must be a minimum distance from the frontal pole
      in y and z directions.
      4. Must have a normal vector within 30 degrees of (0,1,0).
    */
    if ((yt < MAX_TALAIRACH_Y) &&  /* low enough to be temporal pole */
        ((zfront - vertex->z) > MIN_Z_DISTANCE) &&
        ((yfront - vertex->y) > MIN_Y_DISTANCE))
    {
      local_max = 1 ;
      if (vertex->y > temporal_y_hi)  /* check neighbors positions */
      {
        for (n = 0 ; n < vertex->vnum ; n++)
        {
          neigh = vertex->v[n] ;
          v_neigh = &mris->vertices[neigh] ;
          if (v_neigh->y > vertex->y)
          {
            local_max = 0 ;
            break ;
          }
        }

        angle = acos(vertex->ny) ;
        if (local_max && (angle < MIN_ANGLE_VARIATION))
        {
          mris->v_temporal_pole = vertex ;
          temporal_y_hi = vertex->y ;
        }
      }
    }
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    if (mris->v_temporal_pole)
      fprintf(stdout, "F: (%2.0f,%2.0f,%2.0f), T: (%2.0f,%2.0f,%2.0f) "
              "O: (%2.0f,%2.0f,%2.0f).\n",
              mris->v_frontal_pole->x, mris->v_frontal_pole->y,
              mris->v_frontal_pole->z,
              mris->v_temporal_pole->x, mris->v_temporal_pole->y,
              mris->v_temporal_pole->z,
              mris->v_occipital_pole->x, mris->v_occipital_pole->y,
              mris->v_occipital_pole->z) ;
    else
      fprintf(stdout, "F: (%2.0f,%2.0f,%2.0f), T: (NOT FOUND), "
              "O: (%2.0f,%2.0f,%2.0f).\n",
              mris->v_frontal_pole->x, mris->v_frontal_pole->y,
              mris->v_frontal_pole->z,
              mris->v_occipital_pole->x, mris->v_occipital_pole->y,
              mris->v_occipital_pole->z) ;
  }
  return(NO_ERROR) ;
}
///////////// not used ////////////////////////////////////////////////////
#endif


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisOrientEllipsoid(MRI_SURFACE *mris)
{
  int     fno, ano ;
  VERTEX  *v0, *v1, *v2 ;
  FACE    *face ;
  float   dot, xc, yc, zc ;

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
    if (fno == Gdiag_no)
    {
      DiagBreak();
    }

    /* now give the area an orientation: if the unit normal is pointing
       inwards on the ellipsoid then the area should be negative.
    */
    v0 = &mris->vertices[face->v[0]] ;
    v1 = &mris->vertices[face->v[1]] ;
    v2 = &mris->vertices[face->v[2]] ;
    xc = (v0->x+v1->x+v2->x)/3 ;
    yc = (v0->y+v1->y+v2->y)/3 ;
    zc = (v0->z+v1->z+v2->z)/3 ;
    dot = xc * face->nx + yc * face->ny + zc * face->nz;
    if (dot < 0.0f)   /* not in same direction, area < 0 and reverse n */
    {
      face->area *= -1.0f ;
      face->nx *= -1.0f;
      face->ny *= -1.0f;
      face->nz *= -1.0f;
      for (ano = 0 ; ano < ANGLES_PER_TRIANGLE ; ano++)
      {
        face->angle[ano] *= -1.0f ;
      }
    }
  }

  /* now recompute the total surface area, ignoring negative areas */
#if 0
  if ((mris->status != MRIS_PARAMETERIZED_SPHERE) || (!mris->total_area))
#endif
  {
    mris->total_area = mris->neg_orig_area = mris->neg_area = 0.0f ;
    for (fno = 0 ; fno < mris->nfaces ; fno++)
    {
      face = &mris->faces[fno] ;
      if (face->ripflag)
      {
        continue ;
      }
      if (face->area >= 0.0f)
      {
        mris->total_area += face->area ;
      }
      else
      {
        mris->neg_area += -face->area ;
        mris->neg_orig_area += face->orig_area ;
      }
    }
  }

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisOrientPlane(MRI_SURFACE *mris)
{
  int     fno, ano, vno ;
  FACE    *face ;
  VERTEX  *v ;

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }

    /* now give the area an orientation: if the unit normal is pointing
       downwards in the plane then the area should be negative.
    */
    if (face->nz < 0.0f)
    {
      /* not in same direction, area < 0 and reverse n */
      face->area *= -1.0f ;
      face->nx *= -1.0f;
      face->ny *= -1.0f;
      face->nz *= -1.0f;
      for (ano = 0 ; ano < ANGLES_PER_TRIANGLE ; ano++)
      {
        face->angle[ano] *= -1.0f ;
      }
    }
  }

  /* now recompute the total surface area, ignoring negative areas */
  mris->total_area = mris->neg_orig_area = mris->neg_area = 0.0f ;
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
    if (face->area >= 0.0f)
    {
      mris->total_area += face->area ;
    }
    else
    {
      mris->neg_area += -face->area ;
      mris->neg_orig_area += face->orig_area ;
    }
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    if (v->nz < 0)
    {
      v->nz *= -1 ;
      v->neg = 1 ;
    }
    else
    {
      v->neg = 0 ;
    }
    v->area = 0 ;
    for (fno = 0 ; fno < v->num ; fno++)
    {
      face = &mris->faces[v->f[fno]] ;
      v->area += face->area ;
    }
    if (fix_vertex_area)
    {
      v->area /= 3.0 ;
    }
    else
    {
      v->area /= 2.0 ;
    }
  }

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScountNegativeTriangles(MRI_SURFACE *mris)
{
  int     fno, negative ;
  FACE    *face ;

  negative = 0 ;
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
    if (face->area < 0.0f)
    {
      negative++ ;
    }
  }

  return(negative) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISupdateEllipsoidSurface(MRI_SURFACE *mris)
{
#if 0
  MRIScomputeTriangleProperties(mris) ;  /* recompute areas and normals */
#endif
  if (mris->status != MRIS_UNORIENTED_SPHERE)
  {
    mrisOrientEllipsoid(mris) ;  /* orient the normals and angles */
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  MRISaverageGradients() - spatially smooths gradients (dx,dy,dz)
  using num_avgs nearest-neighbor averages. See also
  MRISaverageGradientsFast()
  ------------------------------------------------------*/
int MRISaverageGradients(MRI_SURFACE *mris, int num_avgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  dx, dy, dz, num, sigma ;
  VERTEX *v;
  const VERTEX *vn ;
  MRI_SP *mrisp, *mrisp_blur ;
  char *UFSS;

  // Must explicity "setenv USE_FAST_SURF_SMOOTHER 0" to turn off fast
  UFSS = getenv("USE_FAST_SURF_SMOOTHER");
  if(!UFSS)
  {
    UFSS = "1";
  }
  if(strcmp(UFSS,"0"))
  {
    i=MRISaverageGradientsFast(mris,num_avgs);
    return(i);
  }
  if(Gdiag_no > 0)
  {
    printf("MRISaverageGradients()\n");
  }

  // Below is not used if using Fast
  if (num_avgs <= 0)
  {
    return(NO_ERROR) ;
  }

  if (Gdiag_no >= 0)
  {
    v = &mris->vertices[Gdiag_no] ;
    fprintf(stdout, "before averaging dot = %2.2f ",
            v->dx*v->nx+v->dy*v->ny+v->dz*v->nz) ;
  }
  if (0 && mris->status == MRIS_PARAMETERIZED_SPHERE)  /* use convolution */
  {
    sigma = sqrt((float)num_avgs) / 4.0 ;
    mrisp = MRISgradientToParameterization(mris, NULL, 1.0) ;
    mrisp_blur = MRISPblur(mrisp, NULL, sigma, -1) ;
    MRISgradientFromParameterization(mrisp_blur, mris) ;
    MRISPfree(&mrisp) ;
    MRISPfree(&mrisp_blur) ;
  }
  else for (i = 0 ; i < num_avgs ; i++)
    {
      for (vno = 0 ; vno < mris->nvertices ; vno++)
      {
        v = &mris->vertices[vno] ;
        if (v->ripflag)
        {
          continue ;
        }
        dx = v->dx ;
        dy = v->dy ;
        dz = v->dz ;
        pnb = v->v ;
        /*      vnum = v->v2num ? v->v2num : v->vnum ;*/
        vnum = v->vnum ;
        for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
        {
          vn = &mris->vertices[*pnb++] ; /* neighboring vertex pointer */
          if (vn->ripflag)
          {
            continue ;
          }
          num++ ;
          dx += vn->dx ;
          dy += vn->dy ;
          dz += vn->dz ;
        }
        num++ ;
        v->tdx = dx / num ;
        v->tdy = dy / num ;
        v->tdz = dz / num ;
      }
      for (vno = 0 ; vno < mris->nvertices ; vno++)
      {
        v = &mris->vertices[vno] ;
        if (v->ripflag)
        {
          continue ;
        }
        v->dx = v->tdx ;
        v->dy = v->tdy ;
        v->dz = v->tdz ;
      }
    }
  if (Gdiag_no >= 0)
  {
    float dot ;
    v = &mris->vertices[Gdiag_no] ;
    dot = v->nx*v->dx + v->ny*v->dy + v->nz*v->dz ;
    fprintf(stdout, " after dot = %2.2f D = (%2.2f, %2.2f, %2.2f), N = (%2.1f, %2.1f, %2.1f)\n",
            dot,v->dx, v->dy, v->dz, v->nx, v->ny, v->nz) ;
    if (fabs(dot) > 50)
    {
      DiagBreak() ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  MRISaverageGradientsFast() - spatially smooths gradients (dx,dy,dz)
  using num_avgs nearest-neighbor averages. This is a faster version
  of MRISaverageGradients(). Should be about 40% faster. It also gives
  identical results as can be verified with MRISaverageGradientsFastCheck().
  ------------------------------------------------------*/
int MRISaverageGradientsFast(MRI_SURFACE *mris, int num_avgs)
{
  int    vno, vnb, *pnb, num, nthavg ;
  VERTEX *v, *vn ;
  float **pdx,**pdy,**pdz, sumdx, sumdy, sumdz;
  float **pdx0,**pdy0,**pdz0;
  float *tdx, *tdy, *tdz, *tdx0, *tdy0, *tdz0;
  int *nNbrs, *nNbrs0, *rip, *rip0, nNbrsMax;

  if(Gdiag_no > 0 && DIAG_VERBOSE_ON)
  {
    printf("MRISaverageGradientsFast()\n");
  }

  // Alloc arrays. If there are ripped vertices, then only rip
  // needs nvertices elements
  nNbrsMax = 12; // Should measure this, but overalloc does not hurt
  pdx = (float **) calloc(mris->nvertices*nNbrsMax,sizeof(float *));
  pdy = (float **) calloc(mris->nvertices*nNbrsMax,sizeof(float *));
  pdz = (float **) calloc(mris->nvertices*nNbrsMax,sizeof(float *));
  tdx = (float *) calloc(mris->nvertices,sizeof(float));
  tdy = (float *) calloc(mris->nvertices,sizeof(float));
  tdz = (float *) calloc(mris->nvertices,sizeof(float));
  nNbrs = (int *) calloc(mris->nvertices,sizeof(int));
  rip = (int *) calloc(mris->nvertices,sizeof(int));

  pdx0 = pdx;
  pdy0 = pdy;
  pdz0 = pdz;
  tdx0 = tdx;
  tdy0 = tdy;
  tdz0 = tdz;
  rip0 = rip;
  nNbrs0 = nNbrs;

  // Set up pointers
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if(v->ripflag)
    {
      rip[vno] = 1;
      continue ;
    }
    rip[vno] = 0;
    *pdx++ = &(v->dx);
    *pdy++ = &(v->dy);
    *pdz++ = &(v->dz);
    pnb = v->v;
    num = 1;
    for (vnb = 0 ; vnb < v->vnum ; vnb++)
    {
      vn = &mris->vertices[*pnb++] ; /* neighboring vertex pointer */
      if(vn->ripflag)
      {
        continue ;
      }
      *pdx++ = &(vn->dx);
      *pdy++ = &(vn->dy);
      *pdz++ = &(vn->dz);
      num++ ;
    }
    *nNbrs++ = num;
  }

  //Loop through the iterations
  for(nthavg = 0; nthavg < num_avgs; nthavg++)
  {
    // Init pointers for this iteration
    pdx = pdx0;
    pdy = pdy0;
    pdz = pdz0;
    rip = rip0;
    nNbrs = nNbrs0;
    tdx = tdx0;
    tdy = tdy0;
    tdz = tdz0;
    // Loop through vertices, average nearest neighbors
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      if(*rip++)
      {
        continue ;
      }
      sumdx = *(*pdx++);
      sumdy = *(*pdy++);
      sumdz = *(*pdz++);
      for(vnb = 0 ; vnb < (*nNbrs)-1 ; vnb++)
      {
        sumdx += *(*pdx++);
        sumdy += *(*pdy++);
        sumdz += *(*pdz++);
      }
      *tdx++ = sumdx/(*nNbrs);
      *tdy++ = sumdy/(*nNbrs);
      *tdz++ = sumdz/(*nNbrs);
      nNbrs++;
    }
    // Load up for the next round
    rip = rip0;
    tdx = tdx0;
    tdy = tdy0;
    tdz = tdz0;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      if(*rip++)
      {
        continue ;
      }
      v = &mris->vertices[vno] ;
      v->dx = *tdx++;
      v->dy = *tdy++;
      v->dz = *tdz++;
    }
  }

  rip = rip0;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    if(*rip++)
    {
      continue ;
    }
    v = &mris->vertices[vno] ;
    v->tdx = v->dx;
    v->tdy = v->dy;
    v->tdz = v->dz;
  }

  free(pdx0);
  free(pdy0);
  free(pdz0);
  free(tdx0);
  free(tdy0);
  free(tdz0);
  free(rip0);
  free(nNbrs0);

  return(NO_ERROR) ;
}
/*--------------------------------------------------------*/
int MRISaverageGradientsFastCheck(int num_avgs)
{
  char tmpstr[2000], *UFSS;
  MRIS *mrisA, *mrisB;
  int k,msec,nerrs;
  struct timeb mytimer;
  float e;

  // Make sure to turn off override (restored later)
  UFSS = getenv("USE_FAST_SURF_SMOOTHER");
  setenv("USE_FAST_SURF_SMOOTHER","0",1);

  printf("MRISaverageGradientsFastCheck() num_avgs = %d\n",num_avgs);

  sprintf(tmpstr,"%s/subjects/fsaverage/surf/lh.white",
          getenv("FREESURFER_HOME"));
  printf("Reading surface %s\n",tmpstr);
  mrisA = MRISread(tmpstr);
  mrisB = MRISclone(mrisA);

  printf("Init\n");
  for(k=0; k<mrisA->nvertices; k++)
  {
    mrisA->vertices[k].dx = drand48();
    mrisA->vertices[k].dy = drand48();
    mrisA->vertices[k].dz = drand48();
    mrisA->vertices[k].tdx = 0;
    mrisA->vertices[k].tdy = 0;
    mrisA->vertices[k].tdz = 0;
    mrisB->vertices[k].dx = mrisA->vertices[k].dx;
    mrisB->vertices[k].dy = mrisA->vertices[k].dy;
    mrisB->vertices[k].dz = mrisA->vertices[k].dz;
    mrisB->vertices[k].tdx = 0;
    mrisB->vertices[k].tdy = 0;
    mrisB->vertices[k].tdz = 0;
  }
  // Make sure at least 1 is ripped
  printf("ripping vertex 100\n");
  mrisA->vertices[100].ripflag = 1;
  mrisB->vertices[100].ripflag = 1;

  printf("Running Original Version\n");
  TimerStart(&mytimer) ;
  MRISaverageGradients(mrisA, num_avgs);
  msec = TimerStop(&mytimer) ;
  printf("Original %6.2f min\n",msec/(1000*60.0));

  printf("Running Fast Version\n");
  TimerStart(&mytimer) ;
  MRISaverageGradientsFast(mrisB, num_avgs);
  msec = TimerStop(&mytimer) ;
  printf("Fast %6.2f min\n",msec/(1000*60.0));

  printf("Checking for differences\n");
  nerrs = 0;
  for(k=0; k<mrisA->nvertices; k++)
  {
    e = fabs(mrisA->vertices[k].dx - mrisB->vertices[k].dx);
    if(e > .0000001)
    {
      printf("ERROR: dx v=%d, e=%g, %g %g\n",
             k,e,mrisA->vertices[k].dx,mrisB->vertices[k].dx);
      nerrs++;
    }
    e = fabs(mrisA->vertices[k].dy - mrisB->vertices[k].dy);
    if(e > .0000001)
    {
      printf("ERROR: dy v=%d, e=%g, %g %g\n",
             k,e,mrisA->vertices[k].dy,mrisB->vertices[k].dy);
      nerrs++;
    }
    e = fabs(mrisA->vertices[k].dz - mrisB->vertices[k].dz);
    if(e > .0000001)
    {
      printf("ERROR: dz v=%d, e=%g, %g %g\n",
             k,e,mrisA->vertices[k].dz,mrisB->vertices[k].dz);
      nerrs++;
    }
    e = fabs(mrisA->vertices[k].tdx - mrisB->vertices[k].tdx);
    if(e > .0000001)
    {
      printf("ERROR: tdx v=%d, e=%g, %g %g\n",
             k,e,mrisA->vertices[k].tdx,mrisB->vertices[k].tdx);
      nerrs++;
    }
    e = fabs(mrisA->vertices[k].tdy - mrisB->vertices[k].tdy);
    if(e > .0000001)
    {
      printf("ERROR: tdy v=%d, e=%g, %g %g\n",
             k,e,mrisA->vertices[k].tdy,mrisB->vertices[k].tdy);
      nerrs++;
    }
    e = fabs(mrisA->vertices[k].tdz - mrisB->vertices[k].tdz);
    if(e > .0000001)
    {
      printf("ERROR: tdz v=%d, e=%g, %g %g\n",
             k,e,mrisA->vertices[k].tdz,mrisB->vertices[k].tdz);
      nerrs++;
    }
  }
  printf("Found %d differences\n",nerrs);

  MRISfree(&mrisA);
  MRISfree(&mrisB);
  setenv("USE_FAST_SURF_SMOOTHER",UFSS,1);
  return(nerrs);
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadTriangleProperties(MRI_SURFACE *mris, const char *mris_fname)
{
  int     ano, vnum,fnum, fno, vno ;
  FACE    *face ;
  VERTEX  *v ;
  float   f;
  FILE    *fp;
  char    fname[STRLEN], fpref[STRLEN], hemi[20], *cp ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "reading triangle files...") ;
  }

  cp = strrchr(mris_fname, '.') ;
  if (!cp)
    ErrorReturn(ERROR_BADPARM,
                (ERROR_BADPARM,"MRISreadTriangleProperties(%s): could not scan"
                 " hemisphere from fname", mris_fname)) ;
  strncpy(hemi, cp-2, 2) ;
  hemi[2] = 0 ;
  FileNamePath(mris_fname, fpref) ;

  sprintf(fname, "%s/%s.triangle_area", fpref, hemi) ;

  fp = fopen(fname,"r");
  if (fp==NULL)
  {
    fprintf(stdout,
            "\nno precomputed triangle areas and angles - computing...\n");
    return(1) ;  /* doesn't exist */
  }

  fread4(&f,fp);
  vnum = (int)f ;
  fread4(&f,fp);
  fnum = (int)f ;
  if (vnum!=mris->nvertices)
  {
    fclose(fp) ;
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISreadTriangleProperties: incompatible vertex "
                 "number in file %s", fname)) ;
  }

  mris->orig_area = 0.0f ;
  for (fno=0; fno<fnum; fno++)
  {
    face = &mris->faces[fno] ;
    f = freadFloat(fp);
    face->orig_area = f ;
    mris->orig_area += f;
  }

  /* compute original vertex areas from faces */
  for (vno=0; vno<vnum; vno++)
  {
    v = &mris->vertices[vno] ;
    v->origarea = 0.0f ;
    for (fno = 0 ; fno < v->num ; fno++)
    {
      face = &mris->faces[v->f[fno]] ;
      v->origarea += face->orig_area ;
    }
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "total area = %2.0f.\n", mris->orig_area) ;
  }


  /* now open and read the angle file */
  sprintf(fname, "%s/%s.triangle_angle", fpref, hemi) ;
  fp = fopen(fname,"r");
  if (fp==NULL)
  {
    return(1) ;  /* doesn't exist */
  }

  fread4(&f,fp);
  vnum = (int)f ;
  fread4(&f,fp);
  fnum = (int)f ;
  if (vnum!=mris->nvertices)
  {
    fclose(fp) ;
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISreadTriangleProperties: incompatible vertex "
                 "number in file %s", fname)) ;
  }

  for (fno=0; fno<fnum; fno++)
  {
    face = &mris->faces[fno] ;
    for (ano = 0 ; ano < ANGLES_PER_TRIANGLE ; ano++)
    {
      f = freadFloat(fp);
      face->orig_angle[ano] = f ;
    }
  }

#if 0
  /* read in the distances to all neighboring vertices */
  sprintf(fname, "%s/%s.dist", fpref, hemi) ;
  fp = fopen(fname,"rb");
  if (!fp)
    ErrorReturn(ERROR_NO_FILE,
                (ERROR_NO_FILE,
                 "MRISreadTriangleProperties: could not open %s",
                 fname)) ;

  fread4((float *)&vnum,fp);
  fread4((float *)&fnum,fp);
  for (vno = 0; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    for (n = 0 ; n < v->vtotal ; n++)
    {
      v->dist_orig[n] = freadFloat(fp) ;
    }
  }

  fclose(fp);
#endif

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteTriangleProperties(MRI_SURFACE *mris, const char *mris_fname)
{
  int     fno, ano, vno ;
  FACE    *face ;
  FILE    *fp;
  char    fname[STRLEN], fpref[STRLEN], hemi[20], *cp ;

  MRIScomputeTriangleProperties(mris) ;

  cp = strrchr(mris_fname, '.') ;
  if (!cp)
    ErrorReturn(ERROR_BADPARM,
                (ERROR_BADPARM,
                 "MRISwriteTriangleProperties(%s): could not scan"
                 "hemisphere from fname", mris_fname)) ;
  strncpy(hemi, cp-2, 2) ;
  hemi[2] = 0 ;
  FileNamePath(mris_fname, fpref) ;


  sprintf(fname, "%s/%s.triangle_area", fpref, hemi) ;
  fp = fopen(fname,"wb");
  if (!fp)
    ErrorReturn(ERROR_NO_FILE,
                (ERROR_NO_FILE,
                 "MRISwriteTriangleProperties: could not open %s",
                 fname)) ;

  /* write out the distances to all neighboring vertices */
  fwrite4(mris->nvertices,fp);
  fwrite4(mris->nfaces,fp);
  for (fno=0; fno<mris->nfaces; fno++)
  {
    face = &mris->faces[fno] ;
    fwriteFloat(face->area, fp) ;
  }

  fclose(fp);


  sprintf(fname, "%s/%s.triangle_angle", fpref, hemi) ;
  fp = fopen(fname,"wb");
  if (!fp)
    ErrorReturn(ERROR_NO_FILE,
                (ERROR_NO_FILE,
                 "MRISwriteTriangleProperties: could not open %s",
                 fname)) ;

  /* write out the area of all the triangles */
  fwrite4(mris->nvertices,fp);
  fwrite4(mris->nfaces,fp);
  for (vno=0; vno<mris->nfaces; vno++)
  {
    face = &mris->faces[fno] ;
    for (ano = 0 ; ano < ANGLES_PER_TRIANGLE ; ano++)
    {
      fwriteFloat(face->angle[ano], fp) ;
    }
  }

  fclose(fp);

#if 0
  /* write out the distances to all neighboring vertices */
  sprintf(fname, "%s/%s.dist", fpref, hemi) ;
  fp = fopen(fname,"wb");
  if (!fp)
    ErrorReturn(ERROR_NO_FILE,
                (ERROR_NO_FILE,
                 "MRISwriteTriangleProperties: could not open %s",
                 fname)) ;

  fwrite4(mris->nvertices,fp);
  fwrite4(mris->nfaces,fp);
  for (vno = 0; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    for (n = 0 ; n < v->v2num ; n++)
    {
      fwriteFloat(v->dist[n], fp) ;
    }
  }

  fclose(fp);
#endif

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  each face has 2 triangles defined by it:

  V0       d      V3
  o--------------o
  |              |
  | A0           |
  a |              | c
  |              |
  |           A1 |
  o--------------o
  V1      b        V2

  a = V1 - V0
  d = V3 - V0
  e = V3 - V1
  A0 = 0.5 (a x d) . n

  b = V1 - V2
  c = V3 - V2
  A1 = 0.5 (c x b) . n


  each face has 1 triangle defined by it:
  V0    b     V2
  o----------o
  |         /
  | A0    /
  a |     /
  |   /
  | /
  o
  V1

  a = V1 - V0
  b = V2 - V0
  A0 = 0.5 (a x b) . n


  ------------------------------------------------------*/
int
MRIScomputeTriangleProperties(MRI_SURFACE *mris)
{
  VECTOR  *v_a, *v_b, *v_n ;
  VERTEX  *v0, *v1, *v2, *va, *vb, *vo, *v ;
  FACE    *face ;
  int     fno, ano, vno  ;
  float   area, angle, dot, cross, dz ;

  v_a = VectorAlloc(3, MATRIX_REAL) ;
  v_b = VectorAlloc(3, MATRIX_REAL) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;       /* normal vector */

  mris->total_area = 0.0f ;
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
    if (fno == Gx)
    {
      DiagBreak() ;
    }
    v0 = &mris->vertices[face->v[0]] ;
    v1 = &mris->vertices[face->v[1]] ;
    v2 = &mris->vertices[face->v[2]] ;
    VERTEX_EDGE(v_a, v0, v1) ;
    VERTEX_EDGE(v_b, v0, v2) ;

    /* compute metric properties of first triangle */
    V3_CROSS_PRODUCT(v_a, v_b, v_n) ;
    area = V3_LEN(v_n) * 0.5f ;
    dot = V3_DOT(v_a, v_b) ;
    face->area = area ;
    if (area < 0)
    {
      DiagBreak() ;
    }
    V3_NORMALIZE(v_n, v_n) ;             /* make it a unit vector */
    face->nx = V3_X(v_n);
    face->ny = V3_Y(v_n);
    face->nz = V3_Z(v_n);
    if (!devFinite(area) || !devFinite(mris->total_area))
    {
      DiagBreak() ;
    }
    mris->total_area += area ;

    /* now compute angles */
    VECTOR_LOAD(v_n, face->nx, face->ny, face->nz) ;
    if ((V3_X(v_n) < V3_Y(v_n)) && (V3_X(v_n) < V3_Z(v_n)))
    {
      dz = fabs(V3_X(v_n)) ;
    }
    else if (V3_Y(v_n) < V3_Z(v_n))
    {
      dz = fabs(V3_Y(v_n)) ;
    }
    else
    {
      dz = fabs(V3_Z(v_n)) ;
    }
    for (ano = 0 ; ano < ANGLES_PER_TRIANGLE ; ano++)
    {
      switch (ano)   /* vertices for triangle 1 */
      {
      default:
      case 0:
        vo = v0 ;
        va = v2 ;
        vb = v1 ;
        break ;
      case 1:
        vo = v1 ;
        va = v0 ;
        vb = v2 ;
        break ;
      case 2:
        vo = v2 ;
        va = v1 ;
        vb = v0 ;
        break ;
      }

      VERTEX_EDGE(v_a, vo, va) ;
      VERTEX_EDGE(v_b, vo, vb) ;
      cross = VectorTripleProduct(v_b, v_a, v_n) ;
      dot = V3_DOT(v_a, v_b) ;
      angle = atan2(cross, dot) ;
      face->angle[ano] = angle ;

#if 0
      if (angle < 0.0f || angle >= M_PI)
        fprintf(stdout, "angle [%d][%d] = %2.1f\n",
                fno,ano,(float)DEGREES(angle)) ;
#endif
    }
  }

  /* calculate the "area" of the vertices */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->area = 0.0 ;
    for (fno = 0 ; fno < v->num ; fno++)
    {
      face = &mris->faces[v->f[fno]] ;
      if (face->ripflag == 0)
      {
        v->area += face->area ;
      }
    }
    if (fix_vertex_area)
    {
      v->area /= 3.0 ;
    }
    else
    {
      v->area /= 2.0 ;
    }
  }

  VectorFree(&v_a) ;
  VectorFree(&v_b) ;
  VectorFree(&v_n) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
#define MAX_MM           MAX_DIM/10.0f
#else
#define MAX_MM           MAX_DIM/10.0f
#endif
#define MAX_PLANE_MM     100*10.0f
#define MAX_MOMENTUM_MM  1
#define MIN_MM           0.001

static double
mrisAdaptiveTimeStep(MRI_SURFACE *mris,INTEGRATION_PARMS *parms)
{
  double  delta_t, sse, starting_sse ;

  starting_sse = MRIScomputeSSE(mris, parms) ;

  MRISstoreCurrentPositions(mris) ;
  delta_t = MRISmomentumTimeStep(mris, parms->momentum, parms->dt, parms->tol,
                                 parms->n_averages) ;

  sse = MRIScomputeSSE(mris, parms) ;

  if (sse > starting_sse)  /* error increased - turn off momentum */
  {
    mrisClearMomentum(mris) ;
    parms->dt *= parms->dt_decrease ;
    if (parms->dt <= parms->base_dt)
    {
      parms->dt = parms->base_dt ;
    }

    if (sse / starting_sse > parms->error_ratio)  /* undo time step */
    {
      if (Gdiag & DIAG_SHOW)
        fprintf(stdout, "sse increased by %2.0f%%, undoing time step...\n",
                (float)sse/starting_sse * 100.0f) ;
      if (parms->dt > parms->base_dt)    /* reset step size */
      {
        parms->dt = parms->base_dt ;
      }

      /* undo the time step */
      MRISrestoreOldPositions(mris) ;
      mrisProjectSurface(mris) ;
    }
  }
  else   /* error decreased */
  {
    parms->dt *= parms->dt_increase ;
  }

  return(delta_t) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisAsynchronousTimeStep(MRI_SURFACE *mris, float momentum,
                         float delta_t, MHT *mht, float max_mag)
{
  static int direction = 1 ;
  double  mag ;
  int     vno, i ;
  VERTEX  *v ;

  /* take a step in the gradient direction modulated by momentum */
  if (mris->status == MRIS_RIGID_BODY)
  {
    mris->da = delta_t * mris->alpha + momentum * mris->da ;
    mris->db = delta_t * mris->beta + momentum * mris->db ;
    mris->dg = delta_t * mris->gamma + momentum * mris->dg ;
    MRISrotate(mris, mris, mris->da, mris->db, mris->dg) ;
  }
  else for (i = 0 ; i < mris->nvertices ; i++)
    {
      if (direction < 0)
      {
        vno = mris->nvertices - i - 1 ;
      }
      else
      {
        vno = i ;
      }
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      v->odx = delta_t * v->dx + momentum*v->odx ;
      v->ody = delta_t * v->dy + momentum*v->ody ;
      v->odz = delta_t * v->dz + momentum*v->odz ;
      mag = sqrt(v->odx*v->odx + v->ody*v->ody + v->odz*v->odz) ;
      if (mag > max_mag) /* don't let step get too big */
      {
        mag = max_mag / mag ;
        v->odx *= mag ;
        v->ody *= mag ;
        v->odz *= mag ;
      }
      if (vno == Gdiag_no)
      {
        float dist, dot, dx, dy, dz ;

        dx = v->x - v->origx ;
        dy = v->y - v->origy ;
        dz = v->z - v->origz ;
        dist = sqrt(dx*dx+dy*dy+dz*dz) ;
        dot = dx*v->nx + dy*v->ny + dz*v->nz ;
        fprintf(stdout, "moving v %d by (%2.2f, %2.2f, %2.2f) dot=%2.2f-->"
                "(%2.1f, %2.1f, %2.1f)\n", vno, v->odx, v->ody, v->odz,
                v->odx*v->nx+v->ody*v->ny+v->odz*v->nz,
                v->x, v->y, v->z) ;
        fprintf
        (stdout,
         "n = (%2.1f,%2.1f,%2.1f), total dist=%2.3f, total dot = %2.3f\n",
         v->nx, v->ny, v->nz, dist, dot) ;
      }

      /* erase the faces this vertex is part of */
#if 0
      for (fno = 0 ; fno < v->num ; fno++)
      {
        mrisEraseFace(mris, mri_filled, v->f[fno]) ;
      }
#else
      if (mht)
      {
        MHTremoveAllFaces(mht, mris, v) ;
      }
#endif

      if (mht)
      {
        mrisLimitGradientDistance(mris, mht, vno) ;
      }

      v->x += v->odx ;
      v->y += v->ody ;
      v->z += v->odz ;

      if ((fabs(v->x) > 128.0f) ||
          (fabs(v->y) > 128.0f) ||
          (fabs(v->z) > 128.0f))
      {
        DiagBreak() ;
      }

      /* should this be done here????? (BRF) what about undoing step??? */
      v->dx = v->odx ;  /* for mrisTrackTotalDistances */
      v->dy = v->ody ;
      v->dz = v->odz ;

#if 0
      /* write the new face positions into the filled volume */
      for (fno = 0 ; fno < v->num ; fno++)
      {
        mrisFillFace(mris, mri_filled, v->f[fno]) ;
      }
#else
      if (mht)
      {
        MHTaddAllFaces(mht, mris, v) ;
      }
#endif

    }

  direction *= -1 ;
  return(delta_t) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisAsynchronousTimeStepNew(MRI_SURFACE *mris, float momentum,
                            float delta_t, MHT *mht, float max_mag)
{
  static int direction = 1 ;
  double  mag ;
  int     vno, i ;
  VERTEX  *v ;

  /* take a step in the gradient direction modulated by momentum */
  if (mris->status == MRIS_RIGID_BODY)
  {
    mris->da = delta_t * mris->alpha + momentum * mris->da ;
    mris->db = delta_t * mris->beta + momentum * mris->db ;
    mris->dg = delta_t * mris->gamma + momentum * mris->dg ;
    MRISrotate(mris, mris, mris->da, mris->db, mris->dg) ;
  }
  else for (i = 0 ; i < mris->nvertices ; i++)
    {
      if (direction < 0)
      {
        vno = mris->nvertices - i - 1 ;
      }
      else
      {
        vno = i ;
      }
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      v->odx = delta_t * v->dx + momentum*v->odx ;
      v->ody = delta_t * v->dy + momentum*v->ody ;
      v->odz = delta_t * v->dz + momentum*v->odz ;
      mag = sqrt(v->odx*v->odx + v->ody*v->ody + v->odz*v->odz) ;
      if (mag > max_mag) /* don't let step get too big */
      {
        mag = max_mag / mag ;
        v->odx *= mag ;
        v->ody *= mag ;
        v->odz *= mag ;
      }
      if (vno == Gdiag_no)
      {
        float dist, dot, dx, dy, dz ;

        dx = v->x - v->origx ;
        dy = v->y - v->origy ;
        dz = v->z - v->origz ;
        dist = sqrt(dx*dx+dy*dy+dz*dz) ;
        dot = dx*v->nx + dy*v->ny + dz*v->nz ;
        fprintf(stdout, "moving v %d by (%2.2f, %2.2f, %2.2f) dot=%2.2f-->"
                "(%2.1f, %2.1f, %2.1f)\n", vno, v->odx, v->ody, v->odz,
                v->odx*v->nx+v->ody*v->ny+v->odz*v->nz,
                v->x, v->y, v->z) ;
#if 0
        fprintf
        (stdout,
         "n = (%2.1f,%2.1f,%2.1f), total dist=%2.3f, total dot = %2.3f\n",
         v->nx, v->ny, v->nz, dist, dot) ;
#endif
      }

      /* erase the faces this vertex is part of */
#if 0
      for (fno = 0 ; fno < v->num ; fno++)
      {
        mrisEraseFace(mris, mri_filled, v->f[fno]) ;
      }
#else
      if (mht)
      {
        MHTremoveAllFaces(mht, mris, v) ;
      }
#endif

      if (mht)
      {
        mrisLimitGradientDistance(mris, mht, vno) ;
      }

      v->x += v->odx ;
      v->y += v->ody ;
      v->z += v->odz ;

      if ((fabs(v->x) > 128.0f) ||
          (fabs(v->y) > 128.0f) ||
          (fabs(v->z) > 128.0f))
      {
        DiagBreak() ;
      }

#if 0
      /* should this be done here????? (BRF) what about undoing step??? */
      v->dx = v->odx ;  /* for mrisTrackTotalDistances */
      v->dy = v->ody ;
      v->dz = v->odz ;
#endif

#if 0
      /* write the new face positions into the filled volume */
      for (fno = 0 ; fno < v->num ; fno++)
      {
        mrisFillFace(mris, mri_filled, v->f[fno]) ;
      }
#else
      if (mht)
      {
        MHTaddAllFaces(mht, mris, v) ;
      }
#endif

    }

  direction *= -1 ;
  return(delta_t) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRISmomentumTimeStep(MRI_SURFACE *mris, float momentum, float dt, float tol,
                     float n_averages)
{
  double  delta_t, mag ;
  int     vno ;
  VERTEX  *v ;
#if 0
  double  max_delta ;
  float   dx, dy, dz ;
#endif

  delta_t = dt * sqrt((double)n_averages+1.0) ;

#if 0
  /* find the largest delta, and scale the gradient by it */
  max_delta = 0.0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    dx = v->dx ;
    dy = v->dy ;
    dz = v->dz ;
    mag = sqrt(dx*dx+dy*dy+dz*dz) ;
    if (mag > max_delta)
    {
      max_delta = mag ;
    }
  }
  if (FZERO(max_delta))
  {
    max_delta = tol ;
  }

  if (delta_t > MAX_MOMENTUM_MM / max_delta)   /* no bigger than 1mm */
  {
    delta_t = MAX_MOMENTUM_MM / max_delta ;
  }
#endif

  /* take a step in the gradient direction modulated by momentum */
  if (mris->status == MRIS_RIGID_BODY)
  {
    mris->da = delta_t * mris->alpha + momentum * mris->da ;
    mris->db = delta_t * mris->beta + momentum * mris->db ;
    mris->dg = delta_t * mris->gamma + momentum * mris->dg ;
    MRISrotate(mris, mris, mris->da, mris->db, mris->dg) ;
  }
  else if (mris->status == MRIS_SPHERICAL_PATCH)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      v->odx = delta_t * v->dx + momentum*v->odx ;
      v->ody = delta_t * v->dy + momentum*v->ody ;
      v->odz = delta_t * v->dz + momentum*v->odz ;
      mag =
        sqrt(v->odx*v->odx +
             v->ody*v->ody +
             v->odz*v->odz) ;
      if (mag > MAX_MOMENTUM_MM) /* don't let step get too big */
      {
        mag = MAX_MOMENTUM_MM / mag ;
        v->odx *= mag ;
        v->ody *= mag ;
        v->odz *= mag ;
      }
#if DEBUG_HOMEOMORPHISM
      if (mris->patch==2)
      {
        /* bad trick for debugging */
        v->x += v->odx ;
        v->y += v->ody ;
        v->z += v->odz ;
      }
#endif
    }
    if (mris->patch!=2)
    {
      mrisApplyTopologyPreservingGradient(mris,0,1);
    }
  }
  else for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      v->odx = delta_t * v->dx + momentum*v->odx ;
      v->ody = delta_t * v->dy + momentum*v->ody ;
      v->odz = delta_t * v->dz + momentum*v->odz ;
      mag =
        sqrt(v->odx*v->odx +
             v->ody*v->ody +
             v->odz*v->odz) ;
      if (mag > MAX_MOMENTUM_MM) /* don't let step get too big */
      {
        mag = MAX_MOMENTUM_MM / mag ;
        v->odx *= mag ;
        v->ody *= mag ;
        v->odz *= mag ;
      }
      if (vno == Gdiag_no)
      {
        float dist, dot, dx, dy, dz ;

        dx = v->x - v->origx ;
        dy = v->y - v->origy ;
        dz = v->z - v->origz ;
        dist = sqrt(dx*dx+dy*dy+dz*dz) ;
        dot = dx*v->nx + dy*v->ny + dz*v->nz ;
        fprintf(stdout, "moving v %d by (%2.2f, %2.2f, %2.2f) dot=%2.2f-->"
                "(%2.1f, %2.1f, %2.1f)\n", vno, v->odx, v->ody, v->odz,
                v->odx*v->nx+v->ody*v->ny+v->odz*v->nz,
                v->x, v->y, v->z) ;
        fprintf
        (stdout,
         "n = (%2.1f,%2.1f,%2.1f), total dist=%2.3f, total dot = %2.3f\n",
         v->nx, v->ny, v->nz, dist, dot) ;
      }
      v->x += v->odx ;
      v->y += v->ody ;
      v->z += v->odz ;
    }
  if (mris->status != MRIS_SPHERICAL_PATCH)
  {
    mrisProjectSurface(mris) ;
  }

#if DEBUG_HOMEOMORPHISM
  if (mris->patch==2) /* bad trick  for debugging  */
  {
    mrisProjectSurface(mris) ;
  }
#endif

  return(delta_t) ;
}

static int mrisApplyGradientPositiveAreaPreserving
(MRI_SURFACE *mris, double dt);
static int mrisApplyGradientPositiveAreaMaximizing
(MRI_SURFACE *mris, double dt);

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Fit a quadratic form to the error function in the gradient
  direction and use it to predict the location of the minimum.
  Pick the dt which minimizes the error function among the
  sampled points, including the predicted one.
  ------------------------------------------------------*/
#define MAX_ENTRIES  100
static double
mrisLineMinimize(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  char    fname[STRLEN] ;
  FILE    *fp = NULL ;
  double  starting_sse, sse, min_sse, max_dt, min_delta,
          max_delta, mag, grad, delta_t, min_dt, mean_delta ;
  float   dx, dy, dz ;
  int     vno, n ;
  VERTEX  *vertex ;
  VECTOR  *vY ;
  MATRIX  *mX, *m_xTx, *m_xTx_inv, *m_xTy, *mP, *m_xT ;
  int     i, N, mini ;
  double  a, b, c, sse0, sse2, dt0, dt2, dt_in[MAX_ENTRIES],
          sse_out[MAX_ENTRIES] ;


  if ((Gdiag & DIAG_WRITE) && DIAG_VERBOSE_ON)
  {
    sprintf(fname, "%s%4.4d.dat", FileName(parms->base_name), parms->t+1);
    fp = fopen(fname, "w") ;
  }

  min_sse = starting_sse = MRIScomputeSSE(mris, parms) ;

  /* compute the magnitude of the gradient, and the max delta */
  max_delta = grad = mean_delta = 0.0f ;
  for (n = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    dx = vertex->dx ;
    dy = vertex->dy ;
    dz = vertex->dz ;
    mag = sqrt(dx*dx+dy*dy+dz*dz) ;
    grad += dx*dx+dy*dy+dz*dz ;
    mean_delta += mag ;
#if 0
    if (!FZERO(mag))
#endif
      n++ ;
    if (mag > max_delta)
    {
      max_delta = mag ;
    }
  }
  mean_delta /= (float)n ;
  grad = sqrt(grad) ;

  if (FZERO(max_delta))
  {
    return(0.0) ;  /* at a local minimum */
  }

  /* limit the size of the largest time step */
  switch (parms->projection)
  {
  case PROJECT_SPHERE:
  case PROJECT_ELLIPSOID:
    max_dt = MAX_MM / mean_delta ;
    break ;
  case NO_PROJECTION:
    max_dt = 100.0*MAX_MM / max_delta ;
    break ;
  default:
  case PROJECT_PLANE:
    max_dt = MAX_PLANE_MM / max_delta ;
    break ;
  }
  min_dt = MIN_MM / mean_delta ;

  /* write out some data on supposed quadratic form */
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    double  delta ;
    float   predicted_sse ;
    FILE    *fp2 ;

    sprintf(fname, "nn%s%4.4d.dat",FileName(parms->base_name), parms->t+1) ;
    fp2 = fopen(fname, "w") ;

    delta = max_dt / 100.0 ;
    for (delta_t = delta ; delta_t <= max_dt ; delta_t += delta)
    {
      predicted_sse = starting_sse - grad * delta_t ;
      MRISapplyGradient(mris, delta_t) ;
      mrisProjectSurface(mris) ;
      MRIScomputeMetricProperties(mris) ;

      sse = MRIScomputeSSE(mris, parms) ;
      fprintf(fp2, "%f  %f  %f\n", delta_t, sse, predicted_sse) ;
      mrisProjectSurface(mris) ;
      sse = MRIScomputeSSE(mris, parms) ;
      fprintf(fp, "%f  %f  %f\n", delta_t, sse, predicted_sse) ;
      fflush(fp) ;
      MRISrestoreOldPositions(mris) ;
    }
  }

  /* pick starting step size */
  min_delta = 0.0f ; /* to get rid of compiler warning */
  for (delta_t = min_dt ; delta_t < max_dt ; delta_t *= 10.0)
  {
    MRISapplyGradient(mris, delta_t) ;
    mrisProjectSurface(mris) ;
    MRIScomputeMetricProperties(mris) ;
    sse = MRIScomputeSSE(mris, parms) ;

    if (sse <= min_sse)   /* new minimum found */
    {
      min_sse = sse ;
      min_delta = delta_t ;
    }

    /* undo step */
    MRISrestoreOldPositions(mris) ;
  }

  if (FZERO(min_delta))  /* dt=0 is min starting point, look mag smaller */
  {
    min_delta = min_dt/10.0 ;  /* start at smallest step */
    MRISapplyGradient(mris, min_delta) ;
    mrisProjectSurface(mris) ;
    MRIScomputeMetricProperties(mris) ;
    min_sse = MRIScomputeSSE(mris, parms) ;
    MRISrestoreOldPositions(mris) ;
  }

  delta_t = min_delta ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    fprintf(stdout,"grad=%2.3f, max_del=%2.3f, mean=%2.3f, max_dt=%2.1f, "
            "starting dt=%2.3f, min_dt=%2.3f\n",
            (float)grad, (float)max_delta,
            mean_delta,(float)max_dt, (float)delta_t,min_dt) ;

  /* fit a quadratic form to it, and predict location of minimum */
  /* bracket the minimum by sampling on either side */
  N = 3 ;
  dt0 = min_delta - (min_delta/2) ;
  dt2 = min_delta + (min_delta/2) ;
  MRISapplyGradient(mris, dt0) ;
  mrisProjectSurface(mris) ;
  MRIScomputeMetricProperties(mris) ;
  sse0 = MRIScomputeSSE(mris, parms) ;
  MRISrestoreOldPositions(mris) ;

  MRISapplyGradient(mris, dt2) ;
  mrisProjectSurface(mris) ;
  MRIScomputeMetricProperties(mris) ;
  sse2 = MRIScomputeSSE(mris, parms) ;
  MRISrestoreOldPositions(mris) ;

  /* now fit a quadratic form to these values */
  sse_out[0] = sse0 ;
  sse_out[1] = min_sse ;
  sse_out[2] = sse2 ;
  dt_in[0] = dt0 ;
  dt_in[1] = min_delta ;
  dt_in[2] = dt2 ;

  mX = MatrixAlloc(N, 3, MATRIX_REAL) ;
  vY = VectorAlloc(N, MATRIX_REAL) ;

  for (i = 1 ; i <= N ; i++)
  {
    *MATRIX_RELT(mX, i, 1) = dt_in[i-1] * dt_in[i-1] ;
    *MATRIX_RELT(mX, i, 2) = 2*dt_in[i-1] ;
    *MATRIX_RELT(mX, i, 3) = 1.0f ;

    VECTOR_ELT(vY, i) = sse_out[i-1] ;
  }

  m_xT = MatrixTranspose(mX, NULL) ;
  m_xTx = MatrixMultiply(m_xT, mX, NULL) ;
  m_xTx_inv = MatrixInverse(m_xTx, NULL) ;
  if (m_xTx_inv)
  {
    m_xTy = MatrixMultiply(m_xT, vY, NULL) ;
    mP = MatrixMultiply(m_xTx_inv, m_xTy, NULL) ;
    a = RVECTOR_ELT(mP, 1) ;
    b = RVECTOR_ELT(mP, 2) ;
    c = RVECTOR_ELT(mP, 3);
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      fprintf(stdout,
              "(a,b,c) = (%2.3f, %2.3f, %2.3f), predicted min at %2.3f\n",
              a, b, c, -b/a) ;
    if (!finite(a))
    {
      DiagBreak() ;
    }
    MatrixFree(&mX) ;
    MatrixFree(&mP) ;
    VectorFree(&vY) ;
    MatrixFree(&m_xT) ;
    MatrixFree(&m_xTx) ;
    MatrixFree(&m_xTx_inv) ;
    MatrixFree(&m_xTy) ;


    dt_in[N] = 0 ;
    sse_out[N++] = starting_sse ;
    if (finite(a) && !FZERO(a))
    {
      float new_min_delta ;

      new_min_delta = -b/a ;
      if (new_min_delta < 10.0f*min_delta &&
          new_min_delta > min_delta/10.0f)
      {
        MRISapplyGradient(mris, new_min_delta) ;
        mrisProjectSurface(mris) ;
        MRIScomputeMetricProperties(mris) ;
        sse = MRIScomputeSSE(mris, parms) ;
        MRISrestoreOldPositions(mris) ;
        dt_in[N] = new_min_delta ;
        sse_out[N++] = sse ;
      }
    }
  }
  else   /* couldn't invert matrix */
  {
    fprintf(stderr, "singular matrix in quadratic form\n") ;
    MatrixFree(&mX) ;
    VectorFree(&vY) ;
    MatrixFree(&m_xT) ;
    MatrixFree(&m_xTx) ;
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "sses: %2.2f  ", sse_out[0]) ;
  }
  mini = 0 ;
  min_sse = sse_out[mini] ;
  for (i = 1 ; i < N ; i++)
  {
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    {
      fprintf(stdout, "%2.2f  ", sse_out[i]) ;
    }
    if (sse_out[i] < min_sse)
    {
      min_sse = sse_out[i] ;
      mini = i ;
    }
  }


  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "min %d (%2.3f)\n", mini, dt_in[mini]) ;
  }

  if (mris->status==MRIS_PLANE)  // remove global translation component
  {
    double dx, dy, dz ;
    int    nv, vno ;
    VERTEX *v ;

    for (dx = dy = dz = 0.0, nv = vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      dx += v->dx ;
      dy += v->dy ;
      dz += v->dz ;
      nv++ ;
    }
    if (nv == 0)
    {
      nv = 1;
    }
    dx /= nv ;
    dy /= nv ;
    dz /= nv ;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->dx -= dx ;
      v->dy -= dy ;
      v->dz -= dz ;
    }
  }

  if (mris->status==MRIS_SPHERICAL_PATCH &&
      parms->flags & IPFLAG_PRESERVE_TOPOLOGY_CONVEXHULL)
  {
    mrisApplyTopologyPreservingGradient(mris,dt_in[mini],0);
  }
  else if (parms->flags & IPFLAG_PRESERVE_SPHERICAL_POSITIVE_AREA)
  {
    mrisApplyGradientPositiveAreaPreserving(mris, dt_in[mini]) ;
  }
  else if (parms->flags & IPFLAG_MAXIMIZE_SPHERICAL_POSITIVE_AREA)
  {
    mrisApplyGradientPositiveAreaMaximizing(mris, dt_in[mini]) ;
  }
  else
  {
    MRISapplyGradient(mris, dt_in[mini]) ;
  }
  return(dt_in[mini]) ;
}

#ifdef FS_CUDA

/* mrisLineMinimizeCUDA:

   this is a fork of mrisLineMinimize, but it shouldn't be. In the near future
   integrate this into mrisLineMinimize with ifdefs

*/
static double
mrisLineMinimizeCUDA(MRI_CUDA_SURFACE *mrisc,
                     MRI_SURFACE *mris,
                     INTEGRATION_PARMS *parms)
{
  char    fname[STRLEN] ;
  FILE    *fp = NULL ;
  double  starting_sse, sse, min_sse, max_dt, min_delta,
          max_delta, mag, grad, delta_t, min_dt, mean_delta ;
  float   dx, dy, dz ;
  int     vno, n ;
  VERTEX  *vertex ;
  VECTOR  *vY ;
  MATRIX  *mX, *m_xTx, *m_xTx_inv, *m_xTy, *mP, *m_xT ;
  int     i, N, mini ;
  double  a, b, c, sse0, sse2, dt0, dt2, dt_in[MAX_ENTRIES],
          sse_out[MAX_ENTRIES] ;
#ifdef FS_CUDA_TIMINGS
  struct timeval tv1,tv2,tv3,tv4,result;
#endif // FS_CUDA_TIMINGS

  if ((Gdiag & DIAG_WRITE) && DIAG_VERBOSE_ON)
  {
    sprintf(fname, "%s%4.4d.dat", FileName(parms->base_name), parms->t+1);
    fp = fopen(fname, "w") ;
  }
#ifdef FS_CUDA_TIMINGS
  gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS

  min_sse = starting_sse = MRIScomputeSSE(mris, parms) ;

  /* compute the magnitude of the gradient, and the max delta */
  max_delta = grad = mean_delta = 0.0f ;
  for (n = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    dx = vertex->dx ;
    dy = vertex->dy ;
    dz = vertex->dz ;
    mag = sqrt(dx*dx+dy*dy+dz*dz) ;
    grad += dx*dx+dy*dy+dz*dz ;
    mean_delta += mag ;
#if 0
    if (!FZERO(mag))
#endif
      n++ ;
    if (mag > max_delta)
    {
      max_delta = mag ;
    }
  }
  mean_delta /= (float)n ;
  grad = sqrt(grad) ;

  if (FZERO(max_delta))
  {
    return(0.0) ;  /* at a local minimum */
  }

  /* limit the size of the largest time step */
  switch (parms->projection)
  {
  case PROJECT_SPHERE:
  case PROJECT_ELLIPSOID:
    max_dt = MAX_MM / mean_delta ;
    break ;
  case NO_PROJECTION:
    max_dt = 100.0*MAX_MM / max_delta ;
    break ;
  default:
  case PROJECT_PLANE:
    max_dt = MAX_PLANE_MM / max_delta ;
    break ;
  }
  min_dt = MIN_MM / mean_delta ;


  /* write out some data on supposed quadratic form */
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    double  delta ;
    float   predicted_sse ;
    FILE    *fp2 ;

    sprintf(fname, "nn%s%4.4d.dat",FileName(parms->base_name), parms->t+1) ;
    fp2 = fopen(fname, "w") ;

    delta = max_dt / 100.0 ;
    for (delta_t = delta ; delta_t <= max_dt ; delta_t += delta)
    {
      predicted_sse = starting_sse - grad * delta_t ;
      MRISapplyGradient(mris, delta_t) ;
      mrisProjectSurface(mris) ;
      mrisComputeMetricPropertiesCUDA(mrisc,mris) ;

      sse = MRIScomputeSSE_CUDA(mris, mrisc, parms) ;
      fprintf(fp2, "%f  %f  %f\n", delta_t, sse, predicted_sse) ;
      mrisProjectSurface(mris) ;
      sse = MRIScomputeSSE_CUDA(mris, mrisc, parms) ;
      fprintf(fp, "%f  %f  %f\n", delta_t, sse, predicted_sse) ;
      fflush(fp) ;
      MRISrestoreOldPositions(mris) ;
    }
  }

#ifdef FS_CUDA_TIMINGS
  gettimeofday(&tv2,NULL);
  timeval_subtract(&result,&tv2,&tv1);
  printf("mrisLineMinimize phase 1: %ld ms\n",
         result.tv_sec*1000+result.tv_usec/1000);
  fflush(stdout);

  gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
  /* pick starting step size */
  min_delta = 0.0f ; /* to get rid of compiler warning */
  for (delta_t = min_dt ; delta_t < max_dt ; delta_t *= 10.0)
  {
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv3,NULL);
#endif // FS_CUDA_TIMINGS
    MRISapplyGradient(mris, delta_t) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv4,NULL);
    timeval_subtract(&result,&tv4,&tv3);
    printf("mrisLineMinimize->MRISapplyGradient %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv3,NULL);
#endif // FS_CUDA_TIMINGS
    mrisProjectSurface(mris) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv4,NULL);
    timeval_subtract(&result,&tv4,&tv3);
    printf("mrisLineMinimize->mrisProjectSurface %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv3,NULL);
#endif // FS_CUDA_TIMINGS
    mrisComputeMetricPropertiesCUDA(mrisc,mris) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv4,NULL);
    timeval_subtract(&result,&tv4,&tv3);
    printf("mrisLineMinimize->MRIScomputeMetricProperties %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);

    gettimeofday(&tv3,NULL);
#endif // FS_CUDA_TIMINGS
    sse = MRIScomputeSSE_CUDA(mris, mrisc, parms) ;
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv4,NULL);
    timeval_subtract(&result,&tv4,&tv3);
    printf("mrisLineMinimize->MRIScomputeSSE %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);
#endif // FS_CUDA_TIMINGS

    if (sse <= min_sse)   /* new minimum found */
    {
      min_sse = sse ;
      min_delta = delta_t ;
    }

    /* undo step */
    MRISrestoreOldPositions(mris) ;
  }
#ifdef FS_CUDA_TIMINGS
  gettimeofday(&tv2,NULL);
  timeval_subtract(&result,&tv2,&tv1);
  printf("mrisLineMinimize phase try dt: %ld ms\n",
         result.tv_sec*1000+result.tv_usec/1000);
  fflush(stdout);

  gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS

  if (FZERO(min_delta))  /* dt=0 is min starting point, look mag smaller */
  {
    min_delta = min_dt/10.0 ;  /* start at smallest step */
    MRISapplyGradient(mris, min_delta) ;
    mrisProjectSurface(mris) ;
    mrisComputeMetricPropertiesCUDA(mrisc,mris) ;
    min_sse = MRIScomputeSSE_CUDA(mris, mrisc, parms) ;
    MRISrestoreOldPositions(mris) ;
  }

  delta_t = min_delta ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    fprintf(stdout,"grad=%2.3f, max_del=%2.3f, mean=%2.3f, max_dt=%2.1f, "
            "starting dt=%2.3f, min_dt=%2.3f\n",
            (float)grad, (float)max_delta,
            mean_delta,(float)max_dt, (float)delta_t,min_dt) ;

  /* fit a quadratic form to it, and predict location of minimum */
  /* bracket the minimum by sampling on either side */
  N = 3 ;
  dt0 = min_delta - (min_delta/2) ;
  dt2 = min_delta + (min_delta/2) ;
  MRISapplyGradient(mris, dt0) ;
  mrisProjectSurface(mris) ;
  mrisComputeMetricPropertiesCUDA(mrisc,mris) ;
  sse0 = MRIScomputeSSE_CUDA(mris, mrisc, parms) ;
  MRISrestoreOldPositions(mris) ;

  MRISapplyGradient(mris, dt2) ;
  mrisProjectSurface(mris) ;
  mrisComputeMetricPropertiesCUDA(mrisc,mris) ;
  sse2 = MRIScomputeSSE_CUDA(mris, mrisc, parms) ;
  MRISrestoreOldPositions(mris) ;

  /* now fit a quadratic form to these values */
  sse_out[0] = sse0 ;
  sse_out[1] = min_sse ;
  sse_out[2] = sse2 ;
  dt_in[0] = dt0 ;
  dt_in[1] = min_delta ;
  dt_in[2] = dt2 ;

#ifdef FS_CUDA_TIMINGS
  gettimeofday(&tv2,NULL);
  timeval_subtract(&result,&tv2,&tv1);
  printf("mrisLineMinimize phase 2: %ld ms\n",
         result.tv_sec*1000+result.tv_usec/1000);
  fflush(stdout);

  gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
  mX = MatrixAlloc(N, 3, MATRIX_REAL) ;
  vY = VectorAlloc(N, MATRIX_REAL) ;

  for (i = 1 ; i <= N ; i++)
  {
    *MATRIX_RELT(mX, i, 1) = dt_in[i-1] * dt_in[i-1] ;
    *MATRIX_RELT(mX, i, 2) = 2*dt_in[i-1] ;
    *MATRIX_RELT(mX, i, 3) = 1.0f ;

    VECTOR_ELT(vY, i) = sse_out[i-1] ;
  }

  m_xT = MatrixTranspose(mX, NULL) ;
  m_xTx = MatrixMultiply(m_xT, mX, NULL) ;
  m_xTx_inv = MatrixInverse(m_xTx, NULL) ;
  if (m_xTx_inv)
  {
    m_xTy = MatrixMultiply(m_xT, vY, NULL) ;
    mP = MatrixMultiply(m_xTx_inv, m_xTy, NULL) ;
    a = RVECTOR_ELT(mP, 1) ;
    b = RVECTOR_ELT(mP, 2) ;
    c = RVECTOR_ELT(mP, 3);
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      fprintf(stdout,
              "(a,b,c) = (%2.3f, %2.3f, %2.3f), predicted min at %2.3f\n",
              a, b, c, -b/a) ;
    if (!finite(a))
    {
      DiagBreak() ;
    }
    MatrixFree(&mX) ;
    MatrixFree(&mP) ;
    VectorFree(&vY) ;
    MatrixFree(&m_xT) ;
    MatrixFree(&m_xTx) ;
    MatrixFree(&m_xTx_inv) ;
    MatrixFree(&m_xTy) ;

    dt_in[N] = 0 ;
    sse_out[N++] = starting_sse ;
    if (finite(a) && !FZERO(a))
    {
      float new_min_delta ;

      new_min_delta = -b/a ;
      if (new_min_delta < 10.0f*min_delta &&
          new_min_delta > min_delta/10.0f)
      {
        MRISapplyGradient(mris, new_min_delta) ;
        mrisProjectSurface(mris) ;
        mrisComputeMetricPropertiesCUDA(mrisc,mris) ;
        sse = MRIScomputeSSE_CUDA(mris, mrisc,parms) ;
        MRISrestoreOldPositions(mris) ;
        dt_in[N] = new_min_delta ;
        sse_out[N++] = sse ;
      }
    }
  }
  else   /* couldn't invert matrix */
  {
    fprintf(stderr, "singular matrix in quadratic form\n") ;
    MatrixFree(&mX) ;
    VectorFree(&vY) ;
    MatrixFree(&m_xT) ;
    MatrixFree(&m_xTx) ;
  }

#ifdef FS_CUDA_TIMINGS
  gettimeofday(&tv2,NULL);
  timeval_subtract(&result,&tv2,&tv1);
  printf("mrisLineMinimize phase 3: %ld ms\n",
         result.tv_sec*1000+result.tv_usec/1000);
  fflush(stdout);

  gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "sses: %2.2f  ", sse_out[0]) ;
  }
  mini = 0 ;
  min_sse = sse_out[mini] ;
  for (i = 1 ; i < N ; i++)
  {
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    {
      fprintf(stdout, "%2.2f  ", sse_out[i]) ;
    }
    if (sse_out[i] < min_sse)
    {
      min_sse = sse_out[i] ;
      mini = i ;
    }
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "min %d (%2.3f)\n", mini, dt_in[mini]) ;
  }

  if (mris->status==MRIS_PLANE)  // remove global translation component
  {
    double dx, dy, dz ;
    int    nv, vno ;
    VERTEX *v ;

    for (dx = dy = dz = 0.0, nv = vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      dx += v->dx ;
      dy += v->dy ;
      dz += v->dz ;
      nv++ ;
    }
    if (nv == 0)
    {
      nv = 1;
    }
    dx /= nv ;
    dy /= nv ;
    dz /= nv ;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->dx -= dx ;
      v->dy -= dy ;
      v->dz -= dz ;
    }
  }

  if (mris->status==MRIS_SPHERICAL_PATCH &&
      parms->flags & IPFLAG_PRESERVE_TOPOLOGY_CONVEXHULL)
  {
    mrisApplyTopologyPreservingGradient(mris,dt_in[mini],0);
  }
  else if (parms->flags & IPFLAG_PRESERVE_SPHERICAL_POSITIVE_AREA)
  {
    mrisApplyGradientPositiveAreaPreserving(mris, dt_in[mini]) ;
  }
  else if (parms->flags & IPFLAG_MAXIMIZE_SPHERICAL_POSITIVE_AREA)
  {
    mrisApplyGradientPositiveAreaMaximizing(mris, dt_in[mini]) ;
  }
  else
  {
    MRISapplyGradient(mris, dt_in[mini]) ;
  }

#ifdef FS_CUDA_TIMINGS
  gettimeofday(&tv2,NULL);
  timeval_subtract(&result,&tv2,&tv1);
  printf("mrisLineMinimize phase 4: %ld ms\n",
         result.tv_sec*1000+result.tv_usec/1000);
  fflush(stdout);
#endif // FS_CUDA_TIMINGS

  return(dt_in[mini]) ;
}

#endif /* FS_CUDA */

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Use a binary search in the gradient direction to find the
  location of the minimum.
  ------------------------------------------------------*/
static double
mrisLineMinimizeSearch(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  char    fname[STRLEN] ;
  FILE    *fp = NULL ;
  double  starting_sse, sse, min_sse, max_dt, total_delta, min_delta,
          max_delta, mag, grad, delta_t, min_dt, mean_delta ;
  float   dx, dy, dz ;
  int     vno, done = 0, increasing, n ;
  VERTEX  *vertex ;

  if ((Gdiag & DIAG_WRITE) && DIAG_VERBOSE_ON)
  {
    sprintf(fname, "%s%4.4d.dat", FileName(parms->base_name), parms->t+1);
    fp = fopen(fname, "w") ;
  }

  min_sse = starting_sse = MRIScomputeSSE(mris, parms) ;

  /* compute the magnitude of the gradient, and the max delta */
  max_delta = grad = mean_delta = 0.0f ;
  for (n = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    dx = vertex->dx ;
    dy = vertex->dy ;
    dz = vertex->dz ;
    mag = sqrt(dx*dx+dy*dy+dz*dz) ;
    grad += dx*dx+dy*dy+dz*dz ;
    mean_delta += mag ;
    if (!FZERO(mag))
    {
      n++ ;
    }
    if (mag > max_delta)
    {
      max_delta = mag ;
    }
  }
  mean_delta /= (float)n ;
  grad = sqrt(grad) ;

  if (FZERO(max_delta))
  {
    return(0.0) ;  /* at a local minimum */
  }

  /* limit the size of the largest time step */
  switch (parms->projection)
  {
  case PROJECT_SPHERE:
  case PROJECT_ELLIPSOID:
    max_dt = MAX_MM / mean_delta ;
    break ;
  case NO_PROJECTION:
    max_dt = 100.0*MAX_MM / max_delta ;
    break ;
  default:
  case PROJECT_PLANE:
    max_dt = MAX_PLANE_MM / max_delta ;
    break ;
  }
  min_dt = MIN_MM / mean_delta ;

  /* pick starting step size */
  min_delta = 0.0f ; /* to get rid of compiler warning */
  for (delta_t = min_dt ; delta_t < max_dt ; delta_t *= 10.0)
  {
    MRISapplyGradient(mris, delta_t) ;
    mrisProjectSurface(mris) ;
    MRIScomputeMetricProperties(mris) ;
    sse = MRIScomputeSSE(mris, parms) ;
    if (sse <= min_sse)   /* new minimum found */
    {
      min_sse = sse ;
      min_delta = delta_t ;
    }

    /* undo step */
    MRISrestoreOldPositions(mris) ;
  }

  if (FZERO(min_delta))  /* dt=0 is min starting point, look mag smaller */
  {
    min_delta = min_dt/10.0 ;  /* start at smallest step */
    MRISapplyGradient(mris, min_delta) ;
    mrisProjectSurface(mris) ;
    MRIScomputeMetricProperties(mris) ;
    min_sse = MRIScomputeSSE(mris, parms) ;
    MRISrestoreOldPositions(mris) ;
  }

  delta_t = min_delta ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    fprintf(stdout,"grad=%2.3f, max_del=%2.3f, mean=%2.3f, max_dt=%2.1f, "
            "starting dt=%2.3f, min_dt=%2.3f\n",
            (float)grad, (float)max_delta,
            mean_delta,(float)max_dt, (float)delta_t,min_dt) ;

  /* now search for minimum in gradient direction */
  increasing = 1 ;
  total_delta = 0.0 ;
  min_sse = starting_sse ;
  while (!done)
  {
    MRISapplyGradient(mris, delta_t) ;
    mrisProjectSurface(mris) ;
    MRIScomputeMetricProperties(mris) ;
    sse = MRIScomputeSSE(mris, parms) ;
#if 0
    if (Gdiag & DIAG_WRITE)
    {
      fprintf(fp, "%2.8f   %2.8f\n", total_delta+delta_t, sse) ;
    }
#endif
    if (sse <= min_sse)   /* new minimum found */
    {
      if ((parms->projection == PROJECT_ELLIPSOID) &&
          (total_delta+delta_t > max_dt))
      {
        increasing = 0 ;  /* limit size of largest time step */
      }
      min_sse = sse ;
      total_delta += delta_t ;    /* keep track of total time step */
    }
    else       /* error increased - undo it and decrease time step */
    {
      if (increasing)    /* went too far - reverse delta_t change */
      {
        increasing = 0 ;
      }

      MRISrestoreOldPositions(mris) ;
      mrisProjectSurface(mris) ;
      MRIScomputeMetricProperties(mris) ;
    }
    if (total_delta + delta_t >= 10.0*min_delta)
    {
      increasing = 0 ;
    }
    if (increasing)
    {
      delta_t *= 2.0 ;  /* increase time step and search further out */
    }
    else               /* decreasing - reduce time step */
    {
      delta_t *= 0.5 ;
    }
    done = delta_t < min_dt ;
  }

  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON && fp)
  {
    fclose(fp) ;
  }

  return(total_delta) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI_SURFACE *
MRISscaleBrain(MRI_SURFACE *mris_src, MRI_SURFACE *mris_dst, float scale)
{
  VERTEX  *v;
  int     k;
  float   xlo, ylo, zlo, xhi, yhi, zhi, x0, y0, z0 ;

  /*  mris_dst = MRIScenter(mris_src, mris_dst) ;*/
  xhi=yhi=zhi= -10000;
  xlo=ylo=zlo= 10000;

  /* find the center */
  for (k=0; k<mris_dst->nvertices; k++)
  {
    v = &mris_dst->vertices[k];
    if (v->ripflag)
    {
      continue ;
    }
    if (v->x > xhi)
    {
      xhi = v->x;
    }
    if (v->x < xlo)
    {
      xlo = v->x;
    }
    if (v->y > yhi)
    {
      yhi = v->y;
    }
    if (v->y < ylo)
    {
      ylo = v->y;
    }
    if (v->z > zhi)
    {
      zhi = v->z;
    }
    if (v->z < zlo)
    {
      zlo = v->z;
    }
  }

  /* scale around the center */
  x0 = (xlo+xhi)/2.0f ;
  y0 = (ylo+yhi)/2.0f ;
  z0 = (zlo+zhi)/2.0f ;
  for (k=0; k<mris_dst->nvertices; k++)
  {
    v = &mris_dst->vertices[k];
    if (v->ripflag)
    {
      continue ;
    }
    v->x = (v->x - x0) * scale + x0 ;
    v->y = (v->y - y0) * scale + y0 ;
    v->z = (v->z - z0) * scale + z0 ;
    if (v->x > xhi)
    {
      xhi = v->x;
    }
    if (v->x < xlo)
    {
      xlo = v->x;
    }
    if (v->y > yhi)
    {
      yhi = v->y;
    }
    if (v->y < ylo)
    {
      ylo = v->y;
    }
    if (v->z > zhi)
    {
      zhi = v->z;
    }
    if (v->z < zlo)
    {
      zlo = v->z;
    }
  }

  /* recompute the dimensions */
  xhi=yhi=zhi= -10000;
  xlo=ylo=zlo= 10000;
  for (k=0; k<mris_dst->nvertices; k++)
  {
    v = &mris_dst->vertices[k];
    if (v->ripflag)
    {
      continue ;
    }
    if (v->x > xhi)
    {
      xhi = v->x;
    }
    if (v->x < xlo)
    {
      xlo = v->x;
    }
    if (v->y > yhi)
    {
      yhi = v->y;
    }
    if (v->y < ylo)
    {
      ylo = v->y;
    }
    if (v->z > zhi)
    {
      zhi = v->z;
    }
    if (v->z < zlo)
    {
      zlo = v->z;
    }
  }
  mris_dst->xlo = xlo ;
  mris_dst->ylo = ylo ;
  mris_dst->zlo = zlo ;
  mris_dst->xctr = (xhi + xlo)/2 ;
  mris_dst->yctr = (yhi + ylo)/2 ;
  mris_dst->zctr = (zhi + zlo)/2 ;
  /*  MRISupdateSurface(mris_dst) ;*/
  return(mris_dst) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteCurvature(MRI_SURFACE *mris, const char *sname)
{
  int    k, mritype ;
  float  curv;
  char   fname[STRLEN], *cp, path[STRLEN], name[STRLEN], *hemi ;
  FILE   *fp;

  switch (mris->hemisphere)
  {
  case LEFT_HEMISPHERE:
    hemi = "lh" ;
    break ;
  case BOTH_HEMISPHERES:
    hemi = "both" ;
    break ;
  case RIGHT_HEMISPHERE:
    hemi = "rh" ;
    break ;
  default:
    hemi = "unknown" ;
    break ;
  }
  cp = strchr(sname, '/') ;
  if (!cp)                 /* no path - use same one as mris was read from */
  {
    FileNamePath(mris->fname, path) ;
    cp = strchr(sname, '.') ;
    if (!cp || 
        ((cp-sname) != 2) || 
        *(cp-1) != 'h' || 
        ((*(cp-2)!='l'&&*(cp-2)!='r')))
    {
      sprintf(fname, "%s/%s.%s", path, hemi, sname) ;
    }
    else
    {
      sprintf(fname, "%s/%s", path, sname) ;
    }
  }
  else
  {
    FileNamePath(sname, path) ;
    FileNameOnly(sname, name) ;
    cp = strchr(name, '.') ;
    if (!cp || 
        ((cp-name) != 2) || 
        *(cp-1) != 'h' || 
        ((*(cp-2)!='l'&&*(cp-2)!='r')))
    {
      sprintf(fname, "%s/%s.%s", path, hemi, name) ;
    }
    else
    {
      sprintf(fname, "%s/%s", path, name) ;
    }
  }
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "writing curvature file %s\n", fname) ;
  }

  mritype = mri_identify(sname);

  if (mritype == MRI_MGH_FILE)
  {
    int  vno;
    MRI *TempMRI ;
    VERTEX *v ;

    TempMRI = MRIalloc(mris->nvertices, 1, 1, MRI_FLOAT) ;
    if (TempMRI==NULL)
    {
      return(ERROR_NOMEMORY);
    }
    vno = 0;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      MRIsetVoxVal(TempMRI, vno, 0, 0, 0, v->curv) ;
    }

    MRIwrite(TempMRI, fname) ;
    MRIfree(&TempMRI);
    return(NO_ERROR);
  }
  else if (mritype == VTK_FILE)
  {
    MRISwriteVTK(mris, fname);
    MRISwriteCurvVTK(mris, fname);
    return(NO_ERROR);
  }

  fp = fopen(fname,"wb") ;
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISwriteCurvature: could not open %s",
                 fname)) ;

  fwrite3(-1, fp) ;   /* same old trick - mark it as new format */
  fwriteInt(mris->nvertices,fp);
  fwriteInt(mris->nfaces,fp);
  fwriteInt(1, fp) ;    /* 1 value per vertex */
  for (k=0; k<mris->nvertices; k++)
  {
    curv = mris->vertices[k].curv ;
    fwriteFloat(curv, fp) ;
  }
  fclose(fp);
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteDists(MRI_SURFACE *mris, const char *sname)
{
  int    k,i ;
  float  dist ;
  char   fname[STRLEN], *cp, path[STRLEN] ;
  FILE   *fp;

  cp = strchr(sname, '/') ;
  if (!cp)                 /* no path - use same one as mris was read from */
  {
    FileNamePath(mris->fname, path) ;
    cp = strchr(sname, '.') ;
    if (!cp)
      sprintf(fname, "%s/%s.%s", path,
              mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh", sname) ;
    else
    {
      sprintf(fname, "%s/%s", path, sname) ;
    }
  }
  else
  {
    strcpy(fname, sname) ;  /* path specified explcitly */
  }
  fp = fopen(fname,"wb");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISwriteDists: could not open %s",
                 fname)) ;

  fwrite3(mris->nvertices,fp);
  fwrite3(mris->nfaces,fp);
  for (k=0; k<mris->nvertices; k++)
  {
    dist = mris->vertices[k].d ;
    i = nint(dist * 100.0) ;
    fwrite2((int)i,fp);
  }
  fclose(fp);
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI *
MRISwriteIntoVolume(MRI_SURFACE *mris, MRI *mri, int which)
{
  int    vno  ;
  VERTEX *v ;
  float  val=0;

  if (mri == NULL)
  {
    mri = MRIalloc(1, 1, mris->nvertices, MRI_FLOAT) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    switch (which)
    {
    case VERTEX_DX:
      val = v->dx ;
      break ;
    case VERTEX_DY:
      val = v->dy ;
      break ;
    case VERTEX_DZ:
      val = v->dz ;
      break ;
    case VERTEX_LOGODDS:
    case VERTEX_VAL:
      val = v->val ;
      break ;
    case VERTEX_CURV:
      val = v->curv ;
      break ;
    case VERTEX_ANNOTATION:
      val = v->annotation ;
      break ;
    case VERTEX_AREA:
      val = v->area ;
      break ;
    default:
      ErrorExit(ERROR_UNSUPPORTED,
                "MRISwriteIntoVolume: unsupported type %d", which);
      break ;
    }
    MRIFvox(mri, 0, 0, vno) = val ;
  }
  return(mri) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI_SURFACE *
MRISreadFromVolume(MRI *mri, MRI_SURFACE *mris)
{
  return(mris) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI_SURFACE *
MRISrotate(MRI_SURFACE *mris_src, MRI_SURFACE *mris_dst,
           float alpha, float beta, float gamma)
{
  int      vno ;
  VERTEX   *vertex ;
  float    x, y, z, ca, cb, cg, sa, sb, sg, xp, yp, zp ;
  float    cacb, cacgsb, sasg, cgsa ;
  float    casbsg, cbsa, cgsasb, casg ;
  float    cacg, sasbsg, cbcg, cbsg ;

  if (!mris_dst)
  {
    mris_dst = MRISclone(mris_src) ;
  }

  sa = sin(alpha) ;
  sb = sin(beta) ;
  sg = sin(gamma) ;
  ca = cos(alpha) ;
  cb = cos(beta) ;
  cg = cos(gamma) ;
  cacb = ca*cb ;
  cacgsb = ca*cg*sb ;
  sasg = sa*sg ;
  cgsa = cg*sa ;
  casbsg = ca*sb*sg ;
  cbsa = cb*sa ;
  cgsasb = cg*sa*sb ;
  casg = ca*sg ;
  cacg = ca*cg ;
  sasbsg = sa*sb*sg ;
  cbcg = cb*cg ;
  cbsg = cb*sg ;

  for (vno = 0 ; vno < mris_src->nvertices ; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    vertex = &mris_src->vertices[vno] ;
    x = vertex->x ;
    y = vertex->y ;
    z = vertex->z ;
    xp = x*cacb + z*(-cacgsb - sasg) + y*(cgsa-casbsg) ;
    yp = -x*cbsa + z*(cgsasb-casg) + y*(cacg+sasbsg) ;
    zp = z*cbcg + x*sb + y*cbsg ;
    vertex->x = xp ;
    vertex->y = yp ;
    vertex->z = zp ;
  }
  return(mris_dst) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteAreaError(MRI_SURFACE *mris, const char *name)
{
  int    vno, fno, i ;
  float  area, orig_area ;
  FACE   *face ;
  VERTEX *vertex ;
  FILE   *fp;
  char   fname[STRLEN] ;

  MRISbuildFileName(mris, name, fname) ;
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "writing area error file %s...", fname) ;
  }

  fp = fopen(fname,"wb");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISwriteAreaError: could not open %s",
                 fname)) ;

  fwrite3(mris->nvertices,fp);
  fwrite3(mris->nfaces,fp);
  for (vno = 0 ; vno < mris->nvertices; vno++)
  {
    vertex = &mris->vertices[vno] ;
    area = orig_area = 0.0f ;

    /* use average area of all faces this vertex is part of -
       this is not really correct, but should be good enough for
       visualization purposes.
    */
    for (fno = 0 ; fno < vertex->num ; fno++)
    {
      face = &mris->faces[vertex->f[fno]] ;
      area += face->area ;
      orig_area += face->orig_area ;
    }
    i = nint((area-orig_area) * 100.0f / (float)(vertex->num)) ;
    fwrite2((int)i,fp);
  }
  fclose(fp);
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "done.\n") ;
  }

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteAreaErrorToValFile(MRI_SURFACE *mris, const char *name)
{
  int    vno, fno ;
  float  area, orig_area ;
  FACE   *face ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    area = orig_area = 0.0f ;

    /* use average area of all faces this vertex is part of -
       this is not really correct, but should be good enough for
       visualization purposes.
    */
    for (fno = 0 ; fno < v->num ; fno++)
    {
      face = &mris->faces[v->f[fno]] ;
      area += face->area ;
      orig_area += face->orig_area ;
    }
    v->val = (area-orig_area) / (float)(v->num) ;
  }

  MRISwriteValues(mris, name) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteAngleError(MRI_SURFACE *mris, const char *fname)
{
  int    vno, fno, ano, i ;
  float  error ;
  FILE   *fp;
  FACE   *face ;
  VERTEX *v ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "writing angular error file %s...", fname) ;
  }

  fp = fopen(fname,"wb");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISwriteAngleError: could not open %s",
                 fname)) ;

  fwrite3(mris->nvertices,fp);
  fwrite3(mris->nfaces,fp);
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    error = 0.0f ;
    for (fno = 0 ; fno < v->num ; fno++)
    {
      face = &mris->faces[v->f[fno]] ;
      for (ano = 0 ; ano < ANGLES_PER_TRIANGLE ; ano++)
      {
        error +=
          fabs(deltaAngle(face->angle[ano],face->orig_angle[ano]));
      }
      error /= (float)(v->num*ANGLES_PER_TRIANGLE) ;
    }
    i = DEGREES(error) * 100.0 ;
    fwrite2((int)i,fp);
  }
  fclose(fp);
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "done.\n") ;
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if AVERAGE_AREAS
static int
mrisAverageAreas(MRI_SURFACE *mris, int num_avgs, int which)
{
  int    i, vno, vnb, *pnb, fno, num, vf, nfno ;
  float  area ;
  VERTEX *v, *vn ;
  FACE   *f ;

  for (i = 0 ; i < num_avgs ; i++)
  {
    switch (which)
    {
    case ORIG_AREAS:
      for (vno = 0 ; vno < mris->nvertices ; vno++)
      {
        v = &mris->vertices[vno] ;
        if (v->ripflag)
        {
          continue ;
        }

        for (fno = 0 ;
             fno < v->num ;
             fno++) /* each face of this vertex */
        {
          f = &mris->faces[v->f[fno]] ;  /* pointer to the face */
          if (f->ripflag)
          {
            continue ;
          }
          area = 0.0f ;

          /* now go through each vertex associated with this face */
          for (vf = 0 ; vf < VERTICES_PER_FACE ; vf++)
          {
            vn = &mris->vertices[f->v[vf]] ;
            num += vn->num ;
            for (nfno = 0 ; nfno < vn->num ; nfno++)
            {
              area += vn->orig_tri_area[nfno] ;
            }
          }
          area /= (float)num ;
          v->orig_tri_area[fno] = area ;
        }
      }
      break ;
    case CURRENT_AREAS:
      for (vno = 0 ; vno < mris->nvertices ; vno++)
      {
        v = &mris->vertices[vno] ;
        if (v->ripflag)
        {
          continue ;
        }

        for (fno = 0 ;
             fno < v->num ;
             fno++) /* each face of this vertex */
        {
          f = &mris->faces[v->f[fno]] ;  /* pointer to the face */
          if (f->ripflag)
          {
            continue ;
          }
          area = 0.0f ;

          /* now go through each vertex associated with this face */
          for (vf = 0 ; vf < VERTICES_PER_FACE ; vf++)
          {
            vn = &mris->vertices[f->v[vf]] ;
            num += vn->num ;
            for (nfno = 0 ; nfno < vn->num ; nfno++)
            {
              area += vn->tri_area[nfno] ;
            }
          }
          area /= (float)num ;
          v->tri_area[fno] = area ;
        }
      }
      break ;
    }
  }
  return(NO_ERROR) ;
}
#endif


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#include "stats.h"
int
MRISsampleStatVolume(MRI_SURFACE *mris, void *vsv,int time_point,
                     int coords)
{
  VERTEX   *v ;
  int      vno, xv, yv, zv, width, height, depth ;
  double     x, y, z, xt, yt, zt ;
  STAT_VOLUME *sv = (STAT_VOLUME *)vsv ;

  if (time_point >= sv->mri_pvals[0]->nframes)
    ErrorExit(ERROR_BADPARM,
              "MRISsampleStatVolume: time point (%d) out of bounds [%d, %d]\n",
              time_point, 0, sv->mri_pvals[0]->nframes-1) ;
  width  = sv->mri_pvals[0]->width ;
  height  = sv->mri_pvals[0]->height ;
  depth  = sv->mri_pvals[0]->depth ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    if (vno == 47)
    {
      DiagBreak() ;
    }
    v = &mris->vertices[vno] ;
    x = (double)v->x ;
    y = (double)v->y ;
    z = (double)v->z ;

    /* now convert them into talairach space */
    switch (coords)
    {
    case TALAIRACH_COORDS:
      MRIworldToTalairachVoxel(sv->mri_pvals[0], x, y, z, &xt, &yt, &zt) ;
      break ;
    case SPHERICAL_COORDS:
      x = (double)v->cx ;
      y = (double)v->cy ;
      z = (double)v->cz ;
      MRIworldToVoxel(sv->mri_pvals[0], x, y, z, &xt, &yt, &zt) ;
      break ;
    default:
      MRIworldToVoxel(sv->mri_pvals[0], x, y, z, &xt, &yt, &zt) ;
      break ;
    }
    xv = nint(xt) ;
    yv = nint(yt) ;
    zv = nint(zt) ;
    if (xv >= 0 && xv < width && yv >= 0 && yv < height && zv>=0&&zv<depth)
    {
      v->val = MRIFseq_vox(sv->mri_pvals[0], xv, yv, zv, time_point) ;
    }
    if (vno == 1446)
    {
      DiagBreak() ;
    }
  }

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteCurvatureToWFile(MRI_SURFACE *mris, const char *fname)
{
  int k,num;                   /* loop counters */
  float f;
  FILE *fp;
  double sum=0,sum2=0,max= -1000,min=1000;

  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "writing out surface values to %s.\n", fname) ;
  }

  fp = fopen(fname,"wb");
  if (fp==NULL)
  {
    ErrorExit(ERROR_NOFILE, "Can't create file %s\n",fname) ;
  }

  num = mris->nvertices ;
  fwrite2(0,fp);
  fwrite3(num,fp);
  for (k=0; k<mris->nvertices; k++)
  {
    fwrite3(k,fp);
    f = mris->vertices[k].curv;
    if (!finite(f))
      ErrorPrintf(ERROR_BADPARM,
                  "MRISwriteCurvatureToWFile(%s): val at vertex %d is not"
                  "finite", fname, k) ;

    fwriteFloat(f, fp) ;
    sum += f;
    sum2 += f*f;
    if (f>max)
    {
      max=f;
    }
    if (f<min)
    {
      min=f;
    }
  }
  fclose(fp);
  sum /= num;
  sum2 = sqrt(sum2/num-sum*sum);
  if (Gdiag & DIAG_SHOW)
    fprintf(stdout, "avg = %2.3f, stdev = %2.3f, min = %2.3f, max = %2.3f\n",
            sum,sum2,min,max);
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteValues(MRI_SURFACE *mris, const char *sname)
{
  int k,num;                   /* loop counters */
  float f;
  char  fname[STRLEN], *cp ;
  FILE *fp;
  double sum=0,sum2=0,max= -1000,min=1000;
  int   ftype, err;
  MRI *TempMRI;

#if 1
  MRISbuildFileName(mris, sname, fname) ;
#else
  strcpy(fname, sname) ;
#endif

  // Try saving it in a "volume" format -- but not img or nifti
  // as they use shorts for the number of vertices. Should add
  // a reshape.
  ftype = mri_identify(sname);
  if (ftype != MRI_VOLUME_TYPE_UNKNOWN)
  {
    TempMRI = MRIcopyMRIS(NULL,mris,0,"val");
    if (TempMRI==NULL)
    {
      printf("ERROR: MRISwriteValues: could not alloc MRI\n");
      return(1);
    }
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    {
      printf("Saving surf vals in 'volume' format to %s\n",sname);
    }
    err = MRIwrite(TempMRI,sname);
    return(err);
  }

  cp = strrchr(fname, '.') ;
  if (!cp || *(cp+1) != 'w')
  {
    strcat(fname, ".w") ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "writing surface values to %s.\n", fname) ;
  }

  fp = fopen(fname,"wb");
  if (fp==NULL)
  {
    ErrorExit(ERROR_NOFILE, "Can't create file %s\n",fname) ;
  }

  for (k=0,num=0; k<mris->nvertices; k++)
    if (mris->vertices[k].val!=0)
    {
      num++;
    }
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    printf("num = %d\n",num);
  }
  fwrite2(0,fp);
  fwrite3(num,fp);

  for (k=0; k<mris->nvertices; k++)
  {
    if (mris->vertices[k].val != 0)
    {
      fwrite3(k,fp);
      f = mris->vertices[k].val;
      if (!finite(f))
        ErrorPrintf(ERROR_BADPARM,
                    "MRISwriteValues(%s): val at vertex %d is not finite",
                    fname, k) ;

      fwriteFloat(f, fp) ;
      sum += f;
      sum2 += f*f;
      if (f>max)
      {
        max=f;
      }
      if (f<min)
      {
        min=f;
      }
    }
  }
  fclose(fp);

  if (num > 0)
  {
    sum /= num;
    sum2 = (sum2/num-sum*sum);
    if (sum2 > 0)
    {
      sum2 = sqrt(sum2) ;
    }
    else
    {
      sum2 = 0 ;
    }
    printf("avg = %2.3f, stdev = %2.3f, min = %2.3f, max = %2.3f\n",
           sum,sum2,min,max);
  }
  else
  {
    printf("Warning: all vertex values are zero\n");
  }


  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteD(MRI_SURFACE *mris, const char *sname)
{
  int k,num;                   /* loop counters */
  float f;
  char  fname[STRLEN], *cp ;
  FILE *fp;
  double sum=0,sum2=0,max= -1000,min=1000;
  int   ftype, err;
  MRI *TempMRI;

  MRISbuildFileName(mris, sname, fname) ;

  // Try saving it in a "volume" format -- but not img or nifti
  // as they use shorts for the number of vertices. Should add
  // a reshape.
  ftype = mri_identify(sname);
  if (ftype != MRI_VOLUME_TYPE_UNKNOWN)
  {
    TempMRI = MRIcopyMRIS(NULL,mris,0,"d");
    if (TempMRI==NULL)
    {
      printf("ERROR: MRISwriteD: could not alloc MRI\n");
      return(1);
    }
    printf("Saving surf d vals in 'volume' format to %s\n",sname);
    err = MRIwrite(TempMRI,sname);
    return(err);
  }

  cp = strrchr(fname, '.') ;
  if (!cp || *(cp+1) != 'w')
  {
    strcat(fname, ".w") ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "writing surface d values to %s.\n", fname) ;
  }

  fp = fopen(fname,"wb");
  if (fp==NULL)
  {
    ErrorExit(ERROR_NOFILE, "Can't create file %s\n",fname) ;
  }

  for (k=0,num=0; k<mris->nvertices; k++)
    if (mris->vertices[k].d!=0)
    {
      num++;
    }
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    printf("num = %d\n",num);
  }
  fwrite2(0,fp);
  fwrite3(num,fp);

  for (k=0; k<mris->nvertices; k++)
  {
    if (mris->vertices[k].d != 0)
    {
      fwrite3(k,fp);
      f = mris->vertices[k].d;
      if (!finite(f))
        ErrorPrintf(ERROR_BADPARM,
                    "MRISwriteD(%s): v->d at vertex %d is not finite",
                    fname, k) ;

      fwriteFloat(f, fp) ;
      sum += f;
      sum2 += f*f;
      if (f>max)
      {
        max=f;
      }
      if (f<min)
      {
        min=f;
      }
    }
  }
  fclose(fp);

  if (num > 0)
  {
    sum /= num;
    sum2 = (sum2/num-sum*sum);
    if (sum2 > 0)
    {
      sum2 = sqrt(sum2) ;
    }
    else
    {
      sum2 = 0 ;
    }
    printf("avg = %2.3f, stdev = %2.3f, min = %2.3f, max = %2.3f\n",
           sum,sum2,min,max);
  }
  else
  {
    printf("Warning: all vertex d values are zero\n");
  }


  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadAnnotation(MRI_SURFACE *mris, const char *sname)
{
  int vno, need_hemi;
  int return_code;
  char *cp, fname[STRLEN], path[STRLEN], fname_no_path[STRLEN] ;
  int *array;
#if 0
  int   numannothist;
  float f;
  char  histfname[STRLEN], freqfname[STRLEN];
#endif

  // first attempt to read as gifti file
  int mritype = mri_identify(sname);
  if (mritype == GIFTI_FILE)
  {
    mris = mrisReadGIFTIfile(sname, mris);
    if (mris)
    {
      return (NO_ERROR);
    }
    else
    {
      return (ERROR_BADFILE);
    }
  }
  // else fall-thru with default .annot processing...

  cp = strchr(sname, '/') ;
  if (!cp)                 /* no path - use same one as mris was read from */
  {
    FileNameOnly(sname, fname_no_path) ;
    cp = strstr(fname_no_path, ".annot") ;
    if (!cp)
    {
      strcat(fname_no_path, ".annot") ;
    }

    need_hemi =
      stricmp
      (fname_no_path, mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh") ;

    FileNamePath(mris->fname, path) ;
    if (!need_hemi)
    {
      sprintf(fname, "%s/../label/%s", path, fname_no_path) ;
    }
    else   /* no hemisphere specified */
      sprintf
      (fname, "%s/../label/%s.%s", path,
       mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh",fname_no_path);
  }
  else
  {
    strcpy(fname, sname) ;  /* full path specified */
    cp = strstr(fname, ".annot") ;
    if (!cp)
    {
      strcat(fname, ".annot") ;
    }
  }

  // As a last resort, just assume the sname is the path
  if(! fio_FileExistsReadable(fname) && fio_FileExistsReadable(sname))
  {
    sprintf(fname,"%s",sname);
  }


  /* Try to read it into an array. */
  return_code = MRISreadAnnotationIntoArray (fname, mris->nvertices, &array);
  if (NO_ERROR != return_code)
  {
    return return_code;
  }

  /* If we got an array, fill in our annotation values. */
  MRISclearAnnotations(mris) ;
  for (vno = 0; vno < mris->nvertices; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    mris->vertices[vno].annotation = array[vno];
  }

  /* Try to read in a color table. If we read one, it will be
     allocated, otherwise it will stay NULL. */
  return_code = MRISreadCTABFromAnnotationIfPresent (fname, &mris->ct );
  if (NO_ERROR != return_code)
  {
    return return_code;
  }

#if 0
  for (vno=0; vno<vertex_index; vno++)
  {
    vertex[vno].annotfreq=1;
  }

  sprintf(freqfname,"%s.freq",fname);
  fp = fopen(freqfname,"r");
  if (fp!=NULL)
  {
    printf("file %s read\n",freqfname);
    for (vno=0; vno<vertex_index; vno++)
    {
      vertex[vno].annotfreq=0;
    }
    fread(&num,1,sizeof(int),fp);
    printf("surfer: num=%d\n",num);
    for (j=0; j<num; j++)
    {
      fread(&vno,1,sizeof(int),fp);
      fread(&f,1,sizeof(float),fp);
      if (vno>=vertex_index||vno<0)
      {
        printf("surfer: vertex index out of range: %d f=%f\n",vno,f);
      }
      else
      {
        vertex[vno].annotfreq = f;
      }
    }
    fclose(fp);
  }

  sprintf(histfname,"%s.hist",fname);
  fp = fopen(histfname,"r");
  if (fp!=NULL)
  {
    printf("file %s read\n",histfname);
    for (vno=0; vno<vertex_index; vno++)
    {
      vertex[vno].numannothist=0;
    }
    fread(&num,1,sizeof(int),fp);
    printf("surfer: num=%d\n",num);
    for (j=0; j<num; j++)
    {
      fread(&vno,1,sizeof(int),fp);
      fread(&numannothist,1,sizeof(int),fp);
      if (vno>=vertex_index||vno<0)
      {
        printf("surfer: vertex index out of range: %d f=%f\n",vno,f);
      }
      else
      {
        vertex[vno].numannothist = numannothist;
        vertex[vno].annothistlabel = calloc(numannothist,sizeof(int));
        vertex[vno].annothistcount = calloc(numannothist,sizeof(int));
        for (i=0; i<numannothist; i++)
        {
          fread(&vertex[vno].annothistlabel[i],1,sizeof(int),fp);
        }
        for (i=0; i<numannothist; i++)
        {
          fread(&vertex[vno].annothistcount[i],1,sizeof(int),fp);
        }
      }
    }
    fclose(fp);
  }
#endif

  return(NO_ERROR) ;
}

/*-----------------------------------------------------

  Parameters: fname is the file name of the annotation. in_array_size
    is the size of the array to allocate, but also a 'hint' as to the
    number of vertices expected in the file. This will return the
    allocated array in *out_array.

  Returns value: Standard error code.

  Description: Opens an annotation file and attempts to read label
    indices from it. If successful, will allocate an array of ints,
    populate it, and return a pointer to it. Will return an error code
    if not succesful. This could be due to an invalid file, or an
    incorrect number of vertices in the annotation file.

 ------------------------------------------------------*/
int
MRISreadAnnotationIntoArray(const char* fname,
                            int in_array_size,
                            int** out_array )
{
  int   i,j,vno,num;
  FILE  *fp;
  int* array = NULL;

  if (fname == NULL || out_array == NULL)
    ErrorReturn( ERROR_BADPARM,
                 (ERROR_BADPARM, "Parameter was NULL.") );
  if (in_array_size < 0)
    ErrorReturn( ERROR_BADPARM,
                 (ERROR_BADPARM, "in_array_size was negative.") );

  /* Initialize our array. Note that we do it to the size that we got
     passed in, which might be different than the number of values in
     the file. */
  array = (int*) calloc (in_array_size, sizeof(int));
  if (NULL == array)
    ErrorReturn( ERROR_BADPARM,
                 (ERROR_BADPARM, "ERROR: Reading annot value file %s\n"
                  "  Couldn't allocate array of size %s\n",
                  fname, in_array_size) );

  /* Open the file. */
  fp = fopen(fname,"r");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE, (ERROR_NOFILE, "could not read annot file %s",
                               fname)) ;

  /* First int is the number of elements. */
  num = freadInt(fp) ;

  /* For each one, read in a vno and an int for the annotation
     value. Check the vno. */
  for (j=0; j<num; j++)
  {
    vno = freadInt(fp) ;
    i = freadInt(fp) ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    /* Check the index we read to make sure it's less than the size
       we're expecting. */
    if (vno >= in_array_size || vno < 0)
    {
      fprintf(stderr,
              "MRISreadAnnotationIntoArray: vertex index out of range: "
              "%d i=%8.8X, in_array_size=%d\n",
              vno,i,in_array_size);
      fprintf(stderr,"    annot file: %s\n",fname);
      if (++vertexIndexOutOfRangeCounter > 200000)
      {
        // do this check to prevent creating 100GB error files
        ErrorExit(ERROR_BADFILE,
                  "ERROR: Too many out-of-range vertex indices in "
                  "MRISreadAnnotationIntoArray!\n");
      }
    }
    else
    {
      array[vno] = i;
    }
  }

  fclose(fp);

  /* Set the outgoing array. */
  *out_array = array;

  return(NO_ERROR) ;
}

/*-----------------------------------------------------

  Parameters: fname is the file name of the annotation. This will
    return the allocated table in *out_table.

  Returns value: Standard error code. If the file is fine but no color
    table is present, it will return NO_ERROR, but out_table will not
    be set.

  Description: Opens an annotation file and skips to the tag section
    of the file, after the values. Looks for the TAG_OLD_COLORTABLE
    value, and if present, reads in a color table.

*/
int MRISreadCTABFromAnnotationIfPresent(const char *fname,
                                        COLOR_TABLE** out_table)
{

  int   skip,j,num;
  FILE  *fp;
  COLOR_TABLE* ctab = NULL;
  int tag;

  if (fname == NULL || out_table == NULL)
    ErrorReturn( ERROR_BADPARM,
                 (ERROR_BADPARM, "Parameter was NULL.") );

  /* Open the file. */
  fp = fopen(fname,"r");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE, (ERROR_NOFILE, "could not read annot file %s",
                               fname)) ;

  /* First int is the number of elements. */
  num = freadInt(fp) ;

  /* Skip two ints per num, to the end of the values section, where
     the tags are. */
  for (j = 0; j < num; j++)
  {
    skip = freadInt (fp);
    skip = freadInt (fp);
  }

  /* Check for tags. Right now we only have one possibility for tags,
     but if we add in more tags, we'll have to skip past other tags
     and their data sections here. Of course, we don't have an easy
     way to determine the length of the data section for the tag. If
     we hit EOF here, there is no tag. */
  tag = freadInt (fp);
  if (feof(fp))
  {
    fclose (fp);
    return ERROR_NONE;
  }

  if (TAG_OLD_COLORTABLE == tag)
  {
    /* We have a color table, read it with CTABreadFromBinary. If it
    fails, it will print its own error message. */
    fprintf(stderr, "reading colortable from annotation file...\n") ;
    ctab = CTABreadFromBinary (fp);
    if (NULL != ctab)
      fprintf(stderr, "colortable with %d entries read (originally %s)\n",
              ctab->nentries, ctab->fname);
  }

  fclose (fp);

  /* Return the table if we got one. */
  if( NULL != ctab )
  {
    *out_table = ctab;
  }

  return ERROR_NONE;
}

/*-----------------------------------------------------

  Parameters: fname is the file name of the annotation. On successful
    return, *present will be set to 1 if the CTAB has an annotation,
    and 0 if not.

  Returns value: Standard error code.

  Description: Opens an annotation file and skips to the tag section
    of the file, after the values. Looks for the TAG_OLD_COLORTABLE
    value, and if present, sets *present to 1, or 0 if not present.

*/
int MRISisCTABPresentInAnnotation(const char *fname, int* present)
{

  int   skip,j,num;
  FILE  *fp;
  int tag;

  if (fname == NULL || present == NULL)
    ErrorReturn( ERROR_BADPARM,
                 (ERROR_BADPARM, "Parameter was NULL.") );

  /* Open the file. */
  fp = fopen(fname,"r");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE, (ERROR_NOFILE, "could not read annot file %s",
                               fname)) ;

  /* First int is the number of elements. */
  num = freadInt(fp) ;

  /* Skip two ints per num, to the end of the values section, where
     the tags are. */
  for (j = 0; j < num; j++)
  {
    skip = freadInt (fp);
    skip = freadInt (fp);
  }

  /* No tag found yet. */
  *present = 0;

  /* Check for tags. Right now we only have one possibility for tags,
     but if we add in more tags, we'll have to skip past other tags
     and their data sections here. Of course, we don't have an easy
     way to determine the length of the data section for the tag. If
     we hit EOF here, there is no tag. */
  tag = freadInt (fp);
  if (feof(fp))
  {
    fclose (fp);
    return ERROR_NONE;
  }

  if (TAG_OLD_COLORTABLE == tag)
  {
    *present = 1;
  }

  fclose (fp);

  return ERROR_NONE;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteAnnotation(MRI_SURFACE *mris,const char *sname)
{
  int   i,vno, need_hemi ;
  FILE  *fp;
  const char  *cp;
  char fname[STRLEN], path[STRLEN], fname_no_path[STRLEN];

  cp = strchr(sname, '/') ;
  if (!cp)                 /* no path - use same one as mris was read from */
  {
    FileNameOnly(sname, fname_no_path) ;
    cp = strstr(fname_no_path, ".annot") ;
    if (!cp)
    {
      strcat(fname_no_path, ".annot") ;
    }

    need_hemi =
      strncmp
      (fname_no_path, mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh",2) ;

    FileNamePath(mris->fname, path) ;
    if (!need_hemi)
    {
      sprintf(fname, "%s/../label/%s", path, fname_no_path) ;
    }
    else   /* no hemisphere specified */
      sprintf
      (fname, "%s/../label/%s.%s", path,
       mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh",fname_no_path);
  }
  else
  {
    strcpy(fname, sname) ;  /* full path specified */
    cp = strstr(fname, ".annot") ;
    if (!cp)
    {
      strcat(fname, ".annot") ;
    }
  }

  fp = fopen(fname,"wb");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE, (ERROR_NOFILE, "could not write annot file %s",
                               fname)) ;
  fwriteInt(mris->nvertices, fp) ;
  for (vno=0; vno<mris->nvertices; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    i = mris->vertices[vno].annotation ;
    fwriteInt(vno,fp) ;
    i = fwriteInt(i,fp) ;
  }

  if (mris->ct)   /* also write annotation in */
  {
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    {
      printf("writing colortable into annotation file...\n") ;
    }
    fwriteInt(TAG_OLD_COLORTABLE, fp) ;
    CTABwriteIntoBinary(mris->ct, fp);
  }

  fclose(fp);

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadValues(MRI_SURFACE *mris,const char *sname)
{
  float* array = NULL;
  int return_code = 0;
  int vno;

  /* Try to read an array of values from this file. If we get an
     error, pass the code back up. */
  return_code = MRISreadValuesIntoArray (sname, mris->nvertices, &array);
  if (NO_ERROR != return_code)
  {
    return return_code;
  }

  /* Read all the values from the array into our val field. */
  for (vno = 0; vno < mris->nvertices; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    mris->vertices[vno].val = array[vno];
  }

  /* MRISreadValuesIntoArray allocates its own array, so free it
     here. */
  free (array);

  return(NO_ERROR);
}


int
MRISreadValuesIntoArray(const char* sname,
                        int in_array_size,
                        float** out_array)
{
  int   i,k,num,ilat, vno ;
  float f = 0;
  float lat;
  FILE  *fp;
  char  *cp, fname[STRLEN] ;
  int   type, frame, nv, c,r,s;
  MRI *TempMRI;
  float *array;
  int return_code;

  if (sname == NULL || out_array == NULL)
    ErrorReturn( ERROR_BADPARM,
                 (ERROR_BADPARM, "Parameter was NULL.") );
  if (in_array_size < 0)
    ErrorReturn( ERROR_BADPARM,
                 (ERROR_BADPARM, "in_array_size was negative.") );

  /* First try to load it as a volume */
  strncpy( fname, sname, sizeof(fname) );
  type = mri_identify(fname);
  if (type != MRI_VOLUME_TYPE_UNKNOWN)
  {
    frame = MRISgetReadFrame();
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    {
      printf("MRISreadValues: frame=%d\n",frame);
    }
    TempMRI = MRIreadHeader(fname,type);
    if (TempMRI==NULL)
    {
      return(ERROR_BADFILE);
    }
    if (TempMRI->nframes <= frame)
    {
      MRIfree(&TempMRI);
      ErrorReturn(
        ERROR_BADFILE,
        (ERROR_BADFILE,
         "ERROR: attempted to read frame %d from %s\n"
         "but this file only has %d frames.\n",
         frame,fname,TempMRI->nframes));
    }
    nv = TempMRI->width * TempMRI->height * TempMRI->depth;
    MRIfree(&TempMRI);

    /* Make sure the size is what we're expecting. */
    if (nv != in_array_size)
    {
      ErrorReturn(
        ERROR_BADFILE,
        (ERROR_BADFILE,
         "ERROR: Reading %s as volume encoded scalar file,"
         " but size doesn't match expected size of %d\n",
         sname, in_array_size));
    }

    /* Read the MRI of values. */
    TempMRI = MRIread(fname);
    if (TempMRI==NULL)
    {
      return(ERROR_BADFILE);
    }

    /* Initialize our array. */
    array = (float*) calloc (in_array_size, sizeof(float));
    if (NULL == array)
      ErrorReturn( ERROR_BADPARM,
                   (ERROR_BADPARM, "ERROR: Reading file value file %s\n"
                    "  Couldn't allocate array of size %s\n",
                    fname, nv) );

    /* Read all the values into the array. */
    vno = 0;
    for (s=0; s < TempMRI->depth; s++)
    {
      for (r=0; r < TempMRI->height; r++)
      {
        for (c=0; c < TempMRI->width; c++)
        {
          array[vno] = MRIgetVoxVal(TempMRI,c,r,s,frame);
          vno++;
        }
      }
    }
    MRIfree(&TempMRI);

    /* Set the outgoing array and size. */
    *out_array = array;

    return(NO_ERROR);
  }


  /* Next, try reading a curvature file. If we don't get an error, the
     array is filled out, so we can return now.*/
  return_code = MRISreadCurvatureIntoArray(sname, in_array_size, out_array) ;
  if (ERROR_NONE == return_code)
  {
    printf("reading values from curvature-format file...\n") ;
    return ERROR_NONE;
  }


  /* Now we try an old .w file. If the file name doesn't have .w on
     it, append it now. */
  strcpy(fname, sname) ;
  cp = strrchr(fname, '.') ;
  if (!cp || *(cp+1) != 'w')
  {
    strcat(fname, ".w") ;
  }

  /* Try opening the file. */
  fp = fopen(fname,"rb");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISreadValuesIntoArray: File %s not found\n",fname));

  /* Read something... Seems to be ignored now. */
  fread2(&ilat,fp);
  lat = ilat/10.0;

  /* Read the number of values. */
  if (fread3(&num,fp) < 1)
  {
    fclose (fp);
    ErrorReturn(ERROR_BADFILE,
                (ERROR_BADFILE,
                 "MRISreadValues(%s): could not read # of vertices",
                 fname)) ;
  }

  /* The .w format, being sparse, doesn't require the number of values
     in the file to match the expected amount (usually
     mris->vertices), so we don't test that here. We'll test each
     index invidiually later. */

  /* Initialize our array. Note that we do it to the size that we got
     passed in, which might be different than num. */
  array = (float*) calloc (in_array_size, sizeof(float));
  if (NULL == array)
  {
    fclose (fp);
    ErrorReturn( ERROR_BADPARM,
                 (ERROR_BADPARM, "ERROR: Reading file value file %s\n"
                  "  Couldn't allocate array of size %s\n",
                  sname, num) );
  }

  /* Read the values into the array. */
  for (i=0; i<num; i++)
  {
    /* Read the value index. */
    if (fread3(&k,fp) < 1)
      ErrorReturn(ERROR_BADFILE,
                  (ERROR_BADFILE,
                   "MRISreadValues(%s): could not read %dth vno",
                   fname, i)) ;

    /* Check the index we read to make sure it's less than the size
    we're expecting. */
    if (k >= in_array_size || k<0 )
    {
      printf("MRISreadValues: vertex index out of range: %d f=%f\n",k,f);
      continue;
    }

    if (k == Gdiag_no)
    {
      DiagBreak() ;
    }

    /* Read the value. */
    f = freadFloat(fp) ;

    /* Set it in the array. */
    array[k] = f;
  }

  fclose(fp);

  /* Set the outgoing array. */
  *out_array = array;

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadValuesBak(MRI_SURFACE *mris,const char *fname)
{
  int i,k,num,ilat;
  float f;
  float lat;
  FILE *fp;

  fp = fopen(fname,"r");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISreadValuesBak: File %s not found\n",fname));
  fread2(&ilat,fp);
  lat = ilat/10.0;

  for (k=0; k<mris->nvertices; k++)
  {
    mris->vertices[k].valbak=0;
  }
  fread3(&num,fp);
  for (i=0; i<num; i++)
  {
    fread3(&k,fp);
    f = freadFloat(fp) ;
    if (k>=mris->nvertices||k<0)
    {
      printf("MRISreadValuesBak: vertex index out of range: %d f=%f\n",k,f);
    }
    else
    {
      mris->vertices[k].valbak = f;
    }
  }
  fclose(fp);
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadImagValues(MRI_SURFACE *mris,const char *fname)
{
  int i,k,num,ilat;
  float f;
  float lat;
  FILE *fp;

  fp = fopen(fname,"r");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISreadImagValues: File %s not found\n",fname));
  fread2(&ilat,fp);
  lat = ilat/10.0;

  for (k=0; k<mris->nvertices; k++)
  {
    mris->vertices[k].imag_val=0;
  }
  fread3(&num,fp);
  for (i=0; i<num; i++)
  {
    fread3(&k,fp);
    f = freadFloat(fp);
    if (k>=mris->nvertices||k<0)
    {
      printf("MRISreadImagValues: vertex index out of range: %d f=%f\n",k,f);
    }
    /*
      else if (mris->vertices[k].dist!=0)
      printf("MRISreadImagValues: subsample and data file mismatch\n");
    */
    else
    {
      mris->vertices[k].imag_val = f;
      /*      mris->vertices[k].dist=0;*/
    }
  }
  fclose(fp);
  return(NO_ERROR) ;
}
int
MRIScopyMarksToAnnotation(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->annotation = v->marked ;
  }
  return(NO_ERROR) ;
}
int
MRISmaxMarked(MRI_SURFACE *mris)
{
  int    vno, max_marked ;
  VERTEX *v ;


  max_marked = mris->vertices[0].marked ;
  for (vno = 1 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    if (v->marked > max_marked)
    {
      max_marked =  v->marked ;
    } ;
  }
  return(max_marked) ;
}
int
MRIScopyAnnotationsToMarkedIndex(MRI_SURFACE *mris)
{
  int    vno, index ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    CTABfindIndexFromAnnotation(mris->ct, v->annotation, &index) ;
    if (index  < 0)
      ErrorPrintf(ERROR_BADPARM, "%s: could not find index for vno %d annotation %x\n",
                  "MRIScopyAnnotationsToMarkedIndex", vno, v->annotation) ;

    v->marked = index ;
  }
  return(NO_ERROR) ;
}
int
MRIScopyStatsToValues(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = v->stat ;
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyValuesToImagValues(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->imag_val = v->val ;
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyImagValuesToValues(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = v->imag_val ;
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadInflatedCoordinates(MRI_SURFACE *mris,const char *sname)
{
  if (!sname)
  {
    sname = "inflated" ;
  }
  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  if (MRISreadVertexPositions(mris, sname) != NO_ERROR)
  {
    return(Gerror) ;
  }
  MRISsaveVertexPositions(mris, INFLATED_VERTICES) ;
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadFlattenedCoordinates(MRI_SURFACE *mris,const char *sname)
{
  int    vno, fno ;
  VERTEX *v ;
  FACE   *f ;

  if (!sname)
  {
    sname = "patch" ;
  }
  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  if (MRISreadPatchNoRemove(mris, sname) != NO_ERROR)
  {
    return(Gerror) ;
  }
  MRISsaveVertexPositions(mris, FLATTENED_VERTICES) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      v->z = -10000 ;
      v->ripflag = 0 ;
    }
  }
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    if (f->ripflag)
    {
      f->ripflag = 0 ;
    }
  }
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadWhiteCoordinates(MRI_SURFACE *mris, const char *sname)
{
  if (!sname)
  {
    sname = "white" ;
  }
  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  if (MRISreadVertexPositions(mris, sname) != NO_ERROR)
  {
    return(Gerror) ;
  }
  MRISsaveVertexPositions(mris, WHITE_VERTICES) ;
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadPialCoordinates(MRI_SURFACE *mris, const char *sname)
{
  if (!sname)
  {
    sname = "pial" ;
  }
  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  if (MRISreadVertexPositions(mris, sname) != NO_ERROR)
  {
    return(Gerror) ;
  }
  MRISsaveVertexPositions(mris, PIAL_VERTICES) ;
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadCanonicalCoordinates(MRI_SURFACE *mris, const char *sname)
{
  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  if (MRISreadVertexPositions(mris, sname) != NO_ERROR)
  {
    return(Gerror) ;
  }
  MRISsaveVertexPositions(mris, CANONICAL_VERTICES) ;
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  MRIScomputeCanonicalCoordinates(mris) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadPatchNoRemove(MRI_SURFACE *mris, const char *pname)
{
  int         ix, iy, iz, k, i, j, npts ;
  double        rx, ry, rz;
  FILE        *fp=NULL;
  char        fname[STRLEN] ;
  int         type;
  char        line[256];
  char        *cp;

#if 0
  char        path[STRLEN], *cp ;
  cp = strchr(pname, '/') ;
  if (cp)
  {
    strcpy(fname, pname) ;  /* path already specified */
  }
  else                        /* no path - use same as was used in MRISread */
  {
    FileNamePath(mris->fname, path) ;
    sprintf(fname, "%s/%s", path, pname) ;
  }
#else
  MRISbuildFileName(mris, pname, fname) ;
#endif

  // check whether the patch file is ascii or binary
  type = MRISfileNameType(fname) ; /* using extension to get type */
  if (type == MRIS_GIFTI_FILE) /* .gii */
  {
    mris = MRISread(fname);
  }
  else if (type == MRIS_ASCII_TRIANGLE_FILE)  /* .ASC */
  {
    fp = fopen(fname, "r");
    if (!fp)
      ErrorReturn(ERROR_NOFILE,
                  (ERROR_NOFILE,
                   "MRISreadPatch(%s): could not open file", fname));
    cp = fgetl(line, 256, fp);  // this would skip # lines
    sscanf(cp, "%d %*s", &npts);   // get points
    if (Gdiag & DIAG_SHOW)
      fprintf(stdout,
              "reading patch %s with %d vertices (%2.1f%% of total)\n",
              pname, npts, 100.0f*(float)npts/(float)mris->nvertices) ;

    // set all vertices ripflag to be true
    for (k=0; k<mris->nvertices; k++)
    {
      mris->vertices[k].ripflag = TRUE;
    }

    // go through points
    for (j=0; j<npts; j++)
    {
      // read int
      if ((cp = fgetl(line, 256, fp)))
      {
        sscanf(cp, "%d %*s", &i);
      }
      else
        ErrorReturn
        (ERROR_BADPARM,
         (ERROR_BAD_PARM,
          "MRISreadPatch(%s): could not read line for point %d\n",
          fname, j));

      // if negative, flip it
      if (i<0)
      {
        k = -i-1; // convert it to zero based number
        if (k < 0 || k >= mris->nvertices)
          ErrorExit
          (ERROR_BADFILE,
           "MRISreadPatch: bad vertex # (%d) found in patch file", k) ;
        // negative -> set the border to be true
        mris->vertices[k].border = TRUE;
      }
      // if positive
      else
      {
        k = i-1; // vertex number is zero based
        if (k < 0 || k >= mris->nvertices)
          ErrorExit
          (ERROR_BADFILE,
           "MRISreadPatch: bad vertex # (%d) found in patch file", k) ;
        // positive -> set the border to be false
        mris->vertices[k].border = FALSE;
      }
      // rip flag for this vertex to be false
      mris->vertices[k].ripflag = FALSE;
      // read 3 positions
      if ((cp = fgetl(line, 256, fp)))
      {
        sscanf(cp, "%lf %lf %lf", &rx, &ry, &rz);
      }
      else
        ErrorReturn
        (ERROR_BADPARM,
         (ERROR_BADPARM,
          "MRISreadPatch(%s): could not read 3 floating "
          "values line for point %d\n",
          fname, j));

      // convert it to mm, i.e. change the vertex position
      mris->vertices[k].x = rx;
      mris->vertices[k].y = ry;
      mris->vertices[k].z = rz;
      // change the hi, lo values
      if (mris->vertices[k].x > mris->xhi)
      {
        mris->xhi = mris->vertices[k].x;
      }
      if (mris->vertices[k].x < mris->xlo)
      {
        mris->xlo = mris->vertices[k].x;
      }
      if (mris->vertices[k].y > mris->yhi)
      {
        mris->yhi = mris->vertices[k].y;
      }
      if (mris->vertices[k].y < mris->ylo)
      {
        mris->ylo = mris->vertices[k].y;
      }
      if (mris->vertices[k].z > mris->zhi)
      {
        mris->zhi = mris->vertices[k].z;
      }
      if (mris->vertices[k].z < mris->zlo)
      {
        mris->zlo = mris->vertices[k].z;
      }
      if (k == Gdiag_no && Gdiag & DIAG_SHOW)
        fprintf
        (stdout, "vertex %d read @ (%2.2f, %2.2f, %2.2f)\n",k,
         mris->vertices[k].x,mris->vertices[k].y,mris->vertices[k].z) ;
    }

  }
  /////////////////////////////////////////////////////////////////////////
  // here file was binary
  /////////////////////////////////////////////////////////////////////////
  else
  {
    fp = fopen(fname, "rb") ;
    if (!fp)
      ErrorReturn
      (ERROR_NOFILE,(ERROR_NOFILE,
                     "MRISreadPatch(%s): could not open file", fname));

    // read number of vertices
    npts = freadInt(fp) ;
    if (npts >= 0)
    {
      if (Gdiag & DIAG_SHOW)
        fprintf
        (stdout,
         "reading patch %s with %d vertices (%2.1f%% of total)\n",
         pname, npts, 100.0f*(float)npts/(float)mris->nvertices) ;
      // set all vertices ripflag to be true
      for (k=0; k<mris->nvertices; k++)
      {
        mris->vertices[k].ripflag = TRUE;
      }

      // go through points
      for (j=0; j<npts; j++)
      {
        // read int
        i = freadInt(fp) ;
        // if negative, flip it
        if (i<0)
        {
          k = -i-1; // convert it to zero based number
          if (k < 0 || k >= mris->nvertices)
            ErrorExit
            (ERROR_BADFILE,
             "MRISreadPatch: bad vertex # (%d) found in patch file",
             k) ;
          // negative -> set the border to be true
          mris->vertices[k].border = TRUE;
        }
        // if positive
        else
        {
          k = i-1; // vertex number is zero based
          if (k < 0 || k >= mris->nvertices)
            ErrorExit
            (ERROR_BADFILE,
             "MRISreadPatch: bad vertex # (%d) found in patch file",
             k) ;
          // positive -> set the border to be false
          mris->vertices[k].border = FALSE;
        }
        // rip flag for this vertex to be false
        mris->vertices[k].ripflag = FALSE;
        // read 3 positions
        fread2(&ix,fp);
        fread2(&iy,fp);
        fread2(&iz,fp);
        // convert it to mm, i.e. change the vertex position
        mris->vertices[k].x = ix/100.0;
        mris->vertices[k].y = iy/100.0;
        mris->vertices[k].z = iz/100.0;
        // change the hi, lo values
        if (mris->vertices[k].x > mris->xhi)
        {
          mris->xhi = mris->vertices[k].x;
        }
        if (mris->vertices[k].x < mris->xlo)
        {
          mris->xlo = mris->vertices[k].x;
        }
        if (mris->vertices[k].y > mris->yhi)
        {
          mris->yhi = mris->vertices[k].y;
        }
        if (mris->vertices[k].y < mris->ylo)
        {
          mris->ylo = mris->vertices[k].y;
        }
        if (mris->vertices[k].z > mris->zhi)
        {
          mris->zhi = mris->vertices[k].z;
        }
        if (mris->vertices[k].z < mris->zlo)
        {
          mris->zlo = mris->vertices[k].z;
        }
        if (k == Gdiag_no && Gdiag & DIAG_SHOW)
          fprintf
          (stdout,
           "vertex %d read @ (%2.2f, %2.2f, %2.2f)\n",k,
           mris->vertices[k].x,
           mris->vertices[k].y,
           mris->vertices[k].z) ;
      }
    }
    else   // new surface format
    {
      // read number of vertices
      npts = freadInt(fp) ;
      if (Gdiag & DIAG_SHOW)
        fprintf
        (stdout,
         "reading patch %s with %d vertices (%2.1f%% of total)\n",
         pname, npts, 100.0f*(float)npts/(float)mris->nvertices) ;
      // set all vertices ripflag to be true
      for (k=0; k<mris->nvertices; k++)
      {
        mris->vertices[k].ripflag = TRUE;
      }

      // go through points
      for (j=0; j<npts; j++)
      {
        // read int
        i = freadInt(fp) ;
        // if negative, flip it
        if (i<0)
        {
          k = -i-1; // convert it to zero based number
          if (k < 0 || k >= mris->nvertices)
            ErrorExit
            (ERROR_BADFILE,
             "MRISreadPatch: bad vertex # (%d) found in patch file",
             k) ;
          // negative -> set the border to be true
          mris->vertices[k].border = TRUE;
        }
        // if positive
        else
        {
          k = i-1; // vertex number is zero based
          if (k < 0 || k >= mris->nvertices)
            ErrorExit
            (ERROR_BADFILE,
             "MRISreadPatch: bad vertex # (%d) found in patch file",
             k) ;
          // positive -> set the border to be false
          mris->vertices[k].border = FALSE;
        }
        // rip flag for this vertex to be false
        mris->vertices[k].ripflag = FALSE;
        // read 3 positions
        // convert it to mm, i.e. change the vertex position
        mris->vertices[k].x = freadFloat(fp) ;
        mris->vertices[k].y = freadFloat(fp) ;
        mris->vertices[k].z = freadFloat(fp) ;
        // change the hi, lo values
        if (mris->vertices[k].x > mris->xhi)
        {
          mris->xhi = mris->vertices[k].x;
        }
        if (mris->vertices[k].x < mris->xlo)
        {
          mris->xlo = mris->vertices[k].x;
        }
        if (mris->vertices[k].y > mris->yhi)
        {
          mris->yhi = mris->vertices[k].y;
        }
        if (mris->vertices[k].y < mris->ylo)
        {
          mris->ylo = mris->vertices[k].y;
        }
        if (mris->vertices[k].z > mris->zhi)
        {
          mris->zhi = mris->vertices[k].z;
        }
        if (mris->vertices[k].z < mris->zlo)
        {
          mris->zlo = mris->vertices[k].z;
        }
        if (k == Gdiag_no && Gdiag & DIAG_SHOW)
          fprintf
          (stdout,
           "vertex %d read @ (%2.2f, %2.2f, %2.2f)\n",k,
           mris->vertices[k].x,
           mris->vertices[k].y,
           mris->vertices[k].z) ;
      }
    }
  }
  if (fp)
  {
    fclose(fp);
  }
  for (k = 0 ; k < mris->nvertices ; k++)
    if (mris->vertices[k].num == 0 || mris->vertices[k].vnum == 0)
    {
      mris->vertices[k].ripflag = 1 ;
    }

  // remove ripflag set vertices
  MRISripFaces(mris);
  // set the patch flag
  mris->patch = 1 ;
  mris->status = MRIS_CUT ;
  // recalculate properties
  mrisComputeBoundaryNormals(mris);
  mrisSmoothBoundaryNormals(mris,10);
  MRISupdateSurface(mris) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadPatch(MRI_SURFACE *mris, const char *pname)
{
  int ret  ;

  // update the vertices in patch file
  ret = MRISreadPatchNoRemove(mris, pname) ;
  if (ret != NO_ERROR)
  {
    return(ret) ;
  }
  // remove ripflag set vertices
  MRISremoveRipped(mris) ;

  {
    int k ;
    for (k = 0 ; k < mris->nvertices ; k++)
      if (mris->vertices[k].num == 0 || mris->vertices[k].vnum == 0)
      {
        mris->vertices[k].ripflag = 1 ;
      }
  }

  // recalculate properties
  MRISupdateSurface(mris) ;

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISripFaces(MRI_SURFACE *mris)
{
  int n,k;
  face_type *f;

  for (k=0; k<mris->nfaces; k++)
  {
    mris->faces[k].ripflag = FALSE;
  }
  for (k=0; k<mris->nfaces; k++)
  {
    f = &mris->faces[k];
    for (n=0; n<VERTICES_PER_FACE; n++)
      if (mris->vertices[f->v[n]].ripflag)
      {
        f->ripflag = TRUE;
      }
  }

  for (k=0; k<mris->nvertices; k++)
  {
    mris->vertices[k].border = FALSE;
  }
  for (k=0; k<mris->nfaces; k++)
    if (mris->faces[k].ripflag)
    {
      f = &mris->faces[k];
      for (n=0; n<VERTICES_PER_FACE; n++)
      {
        mris->vertices[f->v[n]].border = TRUE;
      }
    }
  return(NO_ERROR) ;
}


#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisRipVertices(MRI_SURFACE *mris)
{
  int     fno, n ;
  VERTEX  *v ;
  FACE    *f ;

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    if (f->ripflag == 0)
    {
      continue ;
    }
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      v = &mris->vertices[f->v[n]] ;
      v->ripflag = 1 ;
    }
  }
  return(NO_ERROR) ;
}
#endif


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwritePatch(MRI_SURFACE *mris, const char *fname)
{
  int    k,i,npts, type ;
  float  x,y,z;
  FILE   *fp;

  type = MRISfileNameType(fname) ;
  if (type == MRIS_ASCII_TRIANGLE_FILE) // extension is ASC
  {
    return(MRISwritePatchAscii(mris, fname)) ;
  }
  else if (type == MRIS_GEO_TRIANGLE_FILE) // extension is GEO
  {
    return(MRISwriteGeo(mris, fname)) ;
  }
  else if (type == MRIS_STL_FILE)
  {
    return(MRISwriteSTL(mris, fname)) ;
  }

  // binary file write
  // count number of points
  npts = 0;
  for (k=0; k<mris->nvertices; k++)
    if (!mris->vertices[k].ripflag)
    {
      npts++;
    }
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "writing surface patch with npts=%d to %s\n",npts,fname);
  }
  // binary write
  fp = fopen(fname,"wb");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISwritePatch: can't create file %s\n",fname)) ;
  // write num points
  fwriteInt(-1, fp) ;  // "version" #
  fwriteInt(npts, fp) ;
  // go through all points
  for (k=0; k<mris->nvertices; k++)
    if (!mris->vertices[k].ripflag)
    {
      i = (mris->vertices[k].border)? (-(k+1)): (k+1);
      fwriteInt(i, fp) ;
      x = mris->vertices[k].x;
      y = mris->vertices[k].y;
      z = mris->vertices[k].z;
      fwriteFloat(x,fp);
      fwriteFloat(y,fp);
      fwriteFloat(z,fp);
      /*
        printf("k=%d, i=%d\n",k,i);
      */
    }
  fclose(fp);
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISsmoothSurfaceNormals(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  nx, ny, nz, num, len ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      nx = v->nx ;
      ny = v->ny ;
      nz = v->nz ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++] ; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        num++ ;
        nx += vn->nx ;
        ny += vn->ny ;
        nz += vn->nz ;
      }
      num++ ;   /* account for central vertex */
      v->tdx = nx / num ;
      v->tdy = ny / num ;
      v->tdz = nz / num ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      len = sqrt(v->tdx*v->tdx+v->tdy*v->tdy+v->tdz*v->tdz) ;
      if (FZERO(len))
      {
        len = 1 ;
      }
      v->nx = v->tdx/len ;
      v->ny = v->tdy/len ;
      v->nz = v->tdz/len ;
    }
  }

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisSmoothBoundaryNormals(MRI_SURFACE *mris, int niter)
{
#if 0
  int iter,k,m,n;
  vertex_type *v;
  float sumx,sumy,r;

  for (iter=0; iter<niter; iter++)
  {
    for (k=0; k<mris->nvertices; k++)
      if ((!mris->vertices[k].ripflag)&&mris->vertices[k].border)
      {
        mris->vertices[k].obnx = mris->vertices[k].bnx;
        mris->vertices[k].obny = mris->vertices[k].bny;
      }
    for (k=0; k<mris->nvertices; k++)
      if ((!mris->vertices[k].ripflag)&&mris->vertices[k].border)
      {
        v = &mris->vertices[k];
        n = 1;
        sumx = v->obnx;
        sumy = v->obny;
        for (m=0; m<v->vnum; m++)
          if ((!mris->vertices[v->v[m]].ripflag)&&
              mris->vertices[v->v[m]].border)
          {
            sumx += mris->vertices[v->v[m]].obnx;
            sumy += mris->vertices[v->v[m]].obny;
            n++;
          }
        v->bnx = (n>0)?sumx/n:0;
        v->bny = (n>0)?sumy/n:0;
      }
  }
  for (k=0; k<mris->nvertices; k++)
    if ((!mris->vertices[k].ripflag)&&mris->vertices[k].border)
    {
      r = sqrt(SQR(mris->vertices[k].bnx)+SQR(mris->vertices[k].bny));
      if (r>0)
      {
        mris->vertices[k].bnx /= r;
        mris->vertices[k].bny /= r;
      }
    }
#endif
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeBoundaryNormals(MRI_SURFACE *mris)
{
#if 0
  int      k,m,n;
  VERTEX   *v;
  float    sumx,sumy,r,nx,ny,f;

  for (k=0; k<mris->nvertices; k++)
    if ((!mris->vertices[k].ripflag)&&mris->vertices[k].border)
    {
      v = &mris->vertices[k];
      n = 0;
      sumx = 0;
      sumy = 0;
      for (m=0; m<v->vnum; m++)
        if (!mris->vertices[v->v[m]].ripflag)
        {
          sumx += v->x-mris->vertices[v->v[m]].x;
          sumy += v->y-mris->vertices[v->v[m]].y;
          n++;
        }
      v->bnx = (n>0)?sumx/n:0;
      v->bny = (n>0)?sumy/n:0;
    }
  for (k=0; k<mris->nvertices; k++)
    if ((!mris->vertices[k].ripflag)&&mris->vertices[k].border)
    {
      v = &mris->vertices[k];
      n = 0;
      sumx = 0;
      sumy = 0;
      for (m=0; m<v->vnum; m++)
        if ((!mris->vertices[v->v[m]].ripflag)&&
            mris->vertices[v->v[m]].border)
        {
          nx = -(v->y-mris->vertices[v->v[m]].y);
          ny = v->x-mris->vertices[v->v[m]].x;
          f = nx*v->bnx+ny*v->bny;
          /*
            f = (f<0)?-1.0:(f>0)?1.0:0.0;
          */
          sumx += f*nx;
          sumy += f*ny;
          n++;
        }
      v->bnx = (n>0)?sumx/n:0;
      v->bny = (n>0)?sumy/n:0;
    }
  for (k=0; k<mris->nvertices; k++)
    if ((!mris->vertices[k].ripflag)&&mris->vertices[k].border)
    {
      r = sqrt(SQR(mris->vertices[k].bnx)+SQR(mris->vertices[k].bny));
      if (r>0)
      {
        mris->vertices[k].bnx /= r;
        mris->vertices[k].bny /= r;
      }
    }
#endif
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISflattenPatchRandomly(MRI_SURFACE *mris)
{
  float   extent ;
  int     vno ;

  extent = sqrt(mris->total_area) ;
  for (vno=0; vno<mris->nvertices; vno++)
  {
    mris->vertices[vno].x = randomNumber(-extent, extent) ;
    mris->vertices[vno].y = randomNumber(-extent, extent) ;
    mris->vertices[vno].z = 0;
    if (vno == Gdiag_no && Gdiag & DIAG_SHOW)
      fprintf(stdout, "vertex %d flattened @ (%2.2f, %2.2f, %2.2f)\n",vno,
              mris->vertices[vno].x,mris->vertices[vno].y,
              mris->vertices[vno].z) ;
  }
  mris->status = MRIS_PLANE ;
  MRIScomputeMetricProperties(mris) ;
  mrisOrientPlane(mris) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISflattenPatch(MRI_SURFACE *mris)
{
  float       x,y,z,d,d1,d2;
  float       nx,ny,nz ;
  VERTEX      *v;
  int         k, an;

  if (mris->status == MRIS_PLANE)  // already flattened
  {
    for (k=0; k<mris->nvertices; k++)
      if (!mris->vertices[k].ripflag)
      {
        v = &mris->vertices[k];
        v->z = 0 ;
      }
    return(NO_ERROR) ;
  }

  x = y = z = nx = ny = nz = 0;
  an = 0;

  /* calculate average normal and vertex position */
  MRIScomputeNormals(mris) ;
  for (k=0; k<mris->nvertices; k++)
    if (!mris->vertices[k].ripflag)
    {
      v = &mris->vertices[k];
      x += v->x;
      y += v->y;
      z += v->z;
#if 0
      if (!FZERO(v->nx))
        fprintf(stdout, "vertex %d, normal = (%2.3f, %2.3f, %2.3f)\n",
                k, v->nx, v->ny, v->nz) ;
#endif
      nx += v->nx;
      ny += v->ny;
      nz += v->nz;
      an++;
    }
  x /= an;
  y /= an;
  z /= an;
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "flatten: avg p = {%2.1f, %2.1f, %2.1f}\n",x,y,z);
    fprintf(stdout, "flatten: sum n = {%2.2f, %2.2f, %2.2f}\n",nx,ny,nz);
  }
#if 0
  /* or override with direct front,back */
  if (project==POSTERIOR)
  {
    nx = nz = 0.0;
    ny = -1.0;
  }
  if (project==ANTERIOR)
  {
    nx = nz = 0.0;
    ny = 1.0;
  }
#endif

  /* make the average normal unit length */
  d = sqrt(nx*nx+ny*ny+nz*nz);
  nx /= d;
  ny /= d;
  nz /= d;
  d = sqrt(nx*nx+ny*ny);
  if (!FZERO(d))  /* not already in a plane */
  {
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    {
      fprintf(stdout, "flatten: norm n = {%2.2f, %2.2f, %2.2f}\n",nx,ny,nz);
    }
    for (k=0; k<mris->nvertices; k++)
      if (!mris->vertices[k].ripflag)
      {
        v = &mris->vertices[k];
        v->x -= x;
        v->y -= y;
        v->z -= z;
        d1 = sqrt(v->x*v->x+v->y*v->y+v->z*v->z);
        transform(&v->x,&v->y,&v->z,nx,ny,nz,d);
        d2 = sqrt(v->x*v->x+v->y*v->y+v->z*v->z);
        if (fabs(d1-d2)>0.0001)
        {
          printf("flatten: d1=%f, d2=%f\n",d1,d2);
        }
        transform(&v->nx,&v->ny,&v->nz,nx,ny,nz,d);
      }

    /* print transform matrix in tmp dir */
#if 0
    sprintf(fname,"%s/surfer.mat",dir);
    fp = fopen(fname,"w");
    if (fp==NULL)
    {
      ErrorPrintf(ERROR_NOFILE, "flatten: can't create file %s\n",fname);
    }
    else
    {
      fprintf(fp,"%13.3e %13.3e %13.3e %13.3e\n",
              nx*nz/d,  -nx,  ny/d,  0.0);
      fprintf(fp,"%13.3e %13.3e %13.3e %13.3e\n",
              d,       nz,   0.0, 0.0);
      fprintf(fp,"%13.3e %13.3e %13.3e %13.3e\n",
              -ny*nz/d,  ny,   nx/d, 0.0);
      fprintf(fp,"%13.3e %13.3e %13.3e %13.3e\n",
              0.0,      0.0,  0.0, 1.0);
      fclose(fp);
      if (Gdiag & DIAG_SHOW)
      {
        printf("flatten: file %s written\n",fname);
      }
    }
#endif

    transform(&nx,&ny,&nz,nx,ny,nz,d);
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      fprintf(stdout, "flatten: transformed n = {%2.1f, %2.1f, %2.1f}\n",
              nx,ny,nz);
  }
  for (k=0; k<mris->nvertices; k++)
  {
    mris->vertices[k].z = 0;
    if (k == Gdiag_no && Gdiag & DIAG_SHOW)
      fprintf(stdout, "vertex %d flattened @ (%2.2f, %2.2f, %2.2f)\n",k,
              mris->vertices[k].x,mris->vertices[k].y,mris->vertices[k].z) ;
  }

  mris->status = MRIS_PLANE ;
  MRIScomputeMetricProperties(mris) ;
  if (Gdiag & DIAG_SHOW && Gdiag_no >= 0)
  {
    int    n ;
    VERTEX *v, *vn ;

    v = &mris->vertices[Gdiag_no] ;
    fprintf
    (stdout,
     "%d @ (%2.1f, %2.1f, %2.1f): area %2.3f, "
     "oa %2.3f, nz=%2.3f, vnum=%d\n",
     Gdiag_no, v->x, v->y, v->z, v->area, v->origarea, v->nz, v->vnum) ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      fprintf
      (stdout,
       "%d @ (%2.1f, %2.1f, %2.1f): area %2.3f, oa %2.3f, nz=%2.3f, "
       "vnum=%d, d=%2.2f, od=%2.2f\n",
       v->v[n], vn->x, vn->y, vn->z, vn->area, v->origarea,
       vn->nz, vn->vnum, v->dist[n], v->dist_orig[n]) ;
    }
    fprintf(stdout, "\n") ;
  }


  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  2 vects ortho to summed normal
  ------------------------------------------------------*/
static int
transform(float *xptr, float *yptr, float *zptr,
          float nx, float ny, float nz, float d)
{
  float x = *xptr, y = *yptr, z = *zptr;

  *zptr = nx*x + ny*y + nz*z;
  *yptr = -ny/d*x + nx/d*y;
  *xptr = nx*nz/d*x + ny*nz/d*y - d*z;
  /*
    printf("transform {%f,%f,%f} -> {%f,%f,%f}\n",
    x,y,z,*xptr,*yptr,*zptr);
  */
  return(NO_ERROR) ;
}
static int
mrisComputeLinkTerm(MRI_SURFACE *mris, double l_link, int pial)
{
  int     vno ;
  VERTEX  *v ;
  float   dx, dy, dz, lx, ly, lz, len ;

  if (FZERO(l_link))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    lx = v->pialx-v->origx ;
    ly = v->pialy-v->origy ;
    lz = v->pialz-v->origz ;
    len = sqrt(lx*lx + ly*ly + lz*lz) ;
    if (len < .25)  /* can't accurately estimate vector
                                     connecting white and pial */
    {
      continue ;
    }
    lx /= len ;
    ly /= len ;
    lz /= len ;

    dx = l_link*(v->nx - lx) ;
    dy = l_link*(v->ny - ly) ;
    dz = l_link*(v->nz - lz) ;

    if (pial == 0)
    {
      dx *= -1 ;
      dy *= -1 ;
      dz *= -1 ;
    }

    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d link %s term: (%2.3f, %2.3f, %2.3f), "
              "Nl=(%2.1f, %2.1f, %2.1f), Ns=(%2.1f, %2.1f, %2.1f), "
              "dot=%2.3f\n",
              vno,
              pial ? "pial" : "white",
              dx, dy, dz, lx, ly, lz,
              v->nx, v->ny, v->nz, lx*v->nx+ly*v->ny+lz*v->nz) ;
  }

  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeTangentPlanes(MRI_SURFACE *mris)
{
  VECTOR  *v_n, *v_e1, *v_e2, *v ;
  int     vno ;
  VERTEX  *vertex ;

  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_e1 = VectorAlloc(3, MATRIX_REAL) ;
  v_e2 = VectorAlloc(3, MATRIX_REAL) ;
  v = VectorAlloc(3, MATRIX_REAL) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    VECTOR_LOAD(v_n, vertex->nx, vertex->ny, vertex->nz) ;
    /* now find some other non-parallel vector */
#if 0
    if (!FZERO(vertex->nx) || !FZERO(vertex->ny))
    {
      VECTOR_LOAD(v, 0.0, 0.0, 1.0) ;
    }
    else
    {
      VECTOR_LOAD(v, 0.0, 1.0, 0.0) ;
    }
#else
    VECTOR_LOAD(v, vertex->ny, vertex->nz, vertex->nx) ;
#endif
    V3_CROSS_PRODUCT(v_n, v, v_e1) ;
    if (VectorLen(v_e1) < 0.001)  /* happened to pick a parallel vector */
    {
      VECTOR_LOAD(v, vertex->ny, -vertex->nz, vertex->nx) ;
      V3_CROSS_PRODUCT(v_n, v, v_e1) ;
    }

    if ((V3_LEN_IS_ZERO(v_e1)) &&
        DIAG_VERBOSE_ON)  /* happened to pick a parallel vector */
    {
      fprintf(stderr, "vertex %d: degenerate tangent plane\n", vno) ;
    }
    V3_CROSS_PRODUCT(v_n, v_e1, v_e2) ;
    V3_NORMALIZE(v_e1, v_e1) ;
    V3_NORMALIZE(v_e2, v_e2) ;
    if (V3_LEN(v_e1) < 0.5)
    {
      DiagBreak() ;
    }
    vertex->e1x = V3_X(v_e1) ;
    vertex->e2x = V3_X(v_e2) ;
    vertex->e1y = V3_Y(v_e1) ;
    vertex->e2y = V3_Y(v_e2) ;
    vertex->e1z = V3_Z(v_e1) ;
    vertex->e2z = V3_Z(v_e2) ;
  }

  VectorFree(&v) ;
  VectorFree(&v_n) ;
  VectorFree(&v_e1) ;
  VectorFree(&v_e2) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScomputeMeanCurvature(MRI_SURFACE *mris)
{
  VECTOR  *v_n, *v_e1, *v_e2, *v_i ;
  int     vno, i, N ;
  VERTEX  *vertex, *vnb ;
  float   rsq, z, H, u, v, Hmin, Hmax ;

  mrisComputeTangentPlanes(mris) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_e1 = VectorAlloc(3, MATRIX_REAL) ;
  v_e2 = VectorAlloc(3, MATRIX_REAL) ;
  v_i = VectorAlloc(3, MATRIX_REAL) ;

  Hmin = 10000.0f ;
  Hmax = -Hmin ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    VECTOR_LOAD(v_n, vertex->nx, vertex->ny, vertex->nz) ;
    VECTOR_LOAD(v_e1, vertex->e1x, vertex->e1y, vertex->e1z) ;
    VECTOR_LOAD(v_e2, vertex->e2x, vertex->e2y, vertex->e2z) ;

    H = 0.0 ;
    N = 0 ;
    for (i = 0 ; i < vertex->vnum ; i++)  /* for each neighbor */
    {
      vnb = &mris->vertices[vertex->v[i]] ;
      if (vnb->ripflag)
      {
        continue ;
      }
      VECTOR_LOAD(v_i,
                  vnb->x-vertex->x, vnb->y-vertex->y, vnb->z-vertex->z) ;

      /* calculate projection onto tangent plane */
      u = V3_DOT(v_i, v_e1) ;
      v = V3_DOT(v_i, v_e2) ;
      rsq = u*u + v*v ;
      z = V3_DOT(v_i, v_n) ;   /* height above tangent plane */
      if (!FZERO(rsq))
      {
        H += z / rsq ;
        N++ ;
        if ((fabs(z/rsq) > 5.0) &&
            (Gdiag & DIAG_SHOW) && DIAG_VERBOSE_ON)
          fprintf
          (stdout,
           "%d --> %d: curvature = %2.1f\n", vno, vertex->v[i],
           z/rsq) ;
      }
    }
    if (N > 0)
    {
      vertex->H = 0.5f * H / (float)N ;
    }
    else
    {
      vertex->H = 0 ;
    }
    if (vertex->H > Hmax)
    {
      Hmax = vertex->H ;
    }
    if (vertex->H < Hmin)
    {
      Hmin = vertex->H ;
    }
  }

  mris->min_curv = Hmin ;
  mris->max_curv = Hmax ;

  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "mean curvature range [%2.3f --> %2.3f]\n",Hmin, Hmax) ;
  }
  VectorFree(&v_i) ;
  VectorFree(&v_n) ;
  VectorFree(&v_e1) ;
  VectorFree(&v_e2) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 1
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Fit a 1-d quadratic to the surface locally and move the
  vertex in the normal direction to improve the fit.
  ------------------------------------------------------*/
static int
mrisComputeQuadraticCurvatureTerm(MRI_SURFACE *mris, double l_curv)
{
  MATRIX   *m_R, *m_R_inv ;
  VECTOR   *v_Y, *v_A, *v_n, *v_e1, *v_e2, *v_nbr ;
  int      vno, n ;
  VERTEX   *v, *vn ;
  float    ui, vi, rsq, a, b ;

  if (FZERO(l_curv))
  {
    return(NO_ERROR) ;
  }

  mrisComputeTangentPlanes(mris) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_A = VectorAlloc(2, MATRIX_REAL) ;
  v_e1 = VectorAlloc(3, MATRIX_REAL) ;
  v_e2 = VectorAlloc(3, MATRIX_REAL) ;
  v_nbr = VectorAlloc(3, MATRIX_REAL) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v_Y = VectorAlloc(v->vtotal, MATRIX_REAL) ;    /* heights above TpS */
    m_R = MatrixAlloc(v->vtotal, 2, MATRIX_REAL) ; /* radial distances */
    VECTOR_LOAD(v_n, v->nx, v->ny, v->nz) ;
    VECTOR_LOAD(v_e1, v->e1x, v->e1y, v->e1z) ;
    VECTOR_LOAD(v_e2, v->e2x, v->e2y, v->e2z) ;
    for (n = 0 ; n < v->vtotal ; n++)  /* build data matrices */
    {
      vn = &mris->vertices[v->v[n]] ;
      VERTEX_EDGE(v_nbr, v, vn) ;
      VECTOR_ELT(v_Y, n+1) = V3_DOT(v_nbr, v_n) ;
      ui = V3_DOT(v_e1, v_nbr) ;
      vi = V3_DOT(v_e2, v_nbr) ;
      rsq = ui*ui + vi*vi ;
      *MATRIX_RELT(m_R, n+1, 1) = rsq ;
      *MATRIX_RELT(m_R, n+1, 2) = 1 ;
    }
    m_R_inv = MatrixPseudoInverse(m_R, NULL) ;
    if (!m_R_inv)
    {
      MatrixFree(&m_R) ;
      VectorFree(&v_Y) ;
      continue ;
    }
    v_A = MatrixMultiply(m_R_inv, v_Y, v_A) ;
    a = VECTOR_ELT(v_A, 1) ;
    b = VECTOR_ELT(v_A, 2) ;
    b *= l_curv ;
    v->dx += b * v->nx ;
    v->dy += b * v->ny ;
    v->dz += b * v->nz ;

    if (vno == Gdiag_no)
      fprintf(stdout, "v %d curvature term:      (%2.3f, %2.3f, %2.3f), "
              "a=%2.2f, b=%2.1f\n",
              vno, b*v->nx, b*v->ny, b*v->nz, a, b) ;
    MatrixFree(&m_R) ;
    VectorFree(&v_Y) ;
    MatrixFree(&m_R_inv) ;
  }

  VectorFree(&v_n) ;
  VectorFree(&v_e1) ;
  VectorFree(&v_e2) ;
  VectorFree(&v_nbr) ;
  VectorFree(&v_A) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Fit a 1-d quadratic to the surface locally and move the
  vertex in the normal direction to improve the fit.
  ------------------------------------------------------*/
static double
mrisComputeQuadraticCurvatureSSE(MRI_SURFACE *mris, double l_curv)
{
  MATRIX   *m_R, *m_R_inv ;
  VECTOR   *v_Y, *v_A, *v_n, *v_e1, *v_e2, *v_nbr ;
  int      vno, n ;
  VERTEX   *v, *vn ;
  float    ui, vi, rsq, a, b ;
  double   sse = 0.0 ;

  if (FZERO(l_curv))
  {
    return(0.0) ;
  }

  mrisComputeTangentPlanes(mris) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_A = VectorAlloc(2, MATRIX_REAL) ;
  v_e1 = VectorAlloc(3, MATRIX_REAL) ;
  v_e2 = VectorAlloc(3, MATRIX_REAL) ;
  v_nbr = VectorAlloc(3, MATRIX_REAL) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v_Y = VectorAlloc(v->vtotal, MATRIX_REAL) ;    /* heights above TpS */
    m_R = MatrixAlloc(v->vtotal, 2, MATRIX_REAL) ; /* radial distances */
    VECTOR_LOAD(v_n, v->nx, v->ny, v->nz) ;
    VECTOR_LOAD(v_e1, v->e1x, v->e1y, v->e1z) ;
    VECTOR_LOAD(v_e2, v->e2x, v->e2y, v->e2z) ;
    for (n = 0 ; n < v->vtotal ; n++)  /* build data matrices */
    {
      vn = &mris->vertices[v->v[n]] ;
      VERTEX_EDGE(v_nbr, v, vn) ;
      VECTOR_ELT(v_Y, n+1) = V3_DOT(v_nbr, v_n) ;
      ui = V3_DOT(v_e1, v_nbr) ;
      vi = V3_DOT(v_e2, v_nbr) ;
      rsq = ui*ui + vi*vi ;
      *MATRIX_RELT(m_R, n+1, 1) = rsq ;
      *MATRIX_RELT(m_R, n+1, 2) = 1 ;
    }
    m_R_inv = MatrixPseudoInverse(m_R, NULL) ;
    if (!m_R_inv)
    {
      MatrixFree(&m_R) ;
      VectorFree(&v_Y) ;
      continue ;
    }
    v_A = MatrixMultiply(m_R_inv, v_Y, v_A) ;
    a = VECTOR_ELT(v_A, 1) ;
    b = VECTOR_ELT(v_A, 2) ;
    sse += b*b ;
    if (vno == Gdiag_no)
    {
      printf("v %d: curvature sse %2.2f\n", vno, b*b) ;
    }
    MatrixFree(&m_R) ;
    VectorFree(&v_Y) ;
    MatrixFree(&m_R_inv) ;
  }

  VectorFree(&v_n) ;
  VectorFree(&v_e1) ;
  VectorFree(&v_e2) ;
  VectorFree(&v_nbr) ;
  VectorFree(&v_A) ;
  return(sse) ;
}
#else
/*-----------------------------------------------------
Parameters:

Returns value:

Description
Fit a quadric to the surface locally and move the
vertex in the normal direction to improve the fit.
------------------------------------------------------*/
static int
mrisComputeQuadraticCurvatureTerm(MRI_SURFACE *mris, double l_curv)
{
  MATRIX   *m_R, *m_R_inv ;
  VECTOR   *v_Y, *v_A, *v_n, *v_e1, *v_e2, *v_nbr ;
  int      vno, n ;
  VERTEX   *v, *vn ;
  float    ui, vi, a, b, c ;

  /* will set tangent plane basis to be principal directions */
  MRIScomputeSecondFundamentalForm(mris) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_A = VectorAlloc(3, MATRIX_REAL) ;
  v_e1 = VectorAlloc(3, MATRIX_REAL) ;
  v_e2 = VectorAlloc(3, MATRIX_REAL) ;
  v_nbr = VectorAlloc(3, MATRIX_REAL) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v_Y = VectorAlloc(v->vtotal, MATRIX_REAL) ;    /* heights above TpS */
    m_R = MatrixAlloc(v->vtotal, 3, MATRIX_REAL) ; /* radial distances */
    VECTOR_LOAD(v_n, v->nx, v->ny, v->nz) ;
    VECTOR_LOAD(v_e1, v->e1x, v->e1y, v->e1z) ;
    VECTOR_LOAD(v_e2, v->e2x, v->e2y, v->e2z) ;
    for (n = 0 ; n < v->vtotal ; n++)  /* build data matrices */
    {
      vn = &mris->vertices[v->v[n]] ;
      VERTEX_EDGE(v_nbr, v, vn) ;
      VECTOR_ELT(v_Y, n+1) = V3_DOT(v_nbr, v_n) ;
      ui = V3_DOT(v_e1, v_nbr) ;
      vi = V3_DOT(v_e2, v_nbr) ;
      *MATRIX_RELT(m_R, n+1, 1) = ui*ui ;
      *MATRIX_RELT(m_R, n+1, 2) = vi*vi ;
      *MATRIX_RELT(m_R, n+1, 3) = 1 ;
    }
    m_R_inv = MatrixPseudoInverse(m_R, NULL) ;
    v_A = MatrixMultiply(m_R_inv, v_Y, v_A) ;
    a = VECTOR_ELT(v_A, 1) ;
    b = VECTOR_ELT(v_A, 2) ;
    c = VECTOR_ELT(v_A, 3) ;
    c *= l_curv ;
    v->dx += c * v->nx ;
    v->dy += c * v->ny ;
    v->dz += c * v->nz ;

    MatrixFree(&m_R) ;
    VectorFree(&v_Y) ;
    MatrixFree(&m_R_inv) ;
  }

  VectorFree(&v_n) ;
  VectorFree(&v_e1) ;
  VectorFree(&v_e2) ;
  VectorFree(&v_nbr) ;
  VectorFree(&v_A) ;
  return(NO_ERROR) ;
}
#endif
#if 0
static int
mrisAverageDs(MRI_SURFACE *mris, int num_avgs)
{
  VERTEX  *v, *vn ;
  double  d, vnum ;
  int     n, vno, i, marked ;

  /* now average them */
  for (i = 0 ; i < num_avgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      marked = v->marked ;
      d = v->d ;
      for (vnum = 1.0, n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        if (vn->marked != marked)
        {
          continue ;
        }
        vnum++ ;
        d += vn->d ;
      }
      if (vnum > 0.0)
      {
        d /= vnum ;
      }
      else
      {
        d = 0.0 ;
      }
      v->tdx = d ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->d = v->tdx ;
    }
  }

  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
#define USE_TANGENTIAL_TERM  0
#define SCALE_BY_N           1
static int
mrisComputeCurvatureTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  VECTOR  *v_n, *v_delta ;
  int     vno ;
  VERTEX  *vertex ;
  double  l_curv, deltaH, Hdesired ;

  l_curv = parms->l_curv ;
  if (FZERO(l_curv))
  {
    return(NO_ERROR) ;
  }

  Hdesired = parms->Hdesired ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_delta = VectorAlloc(3, MATRIX_REAL) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    VECTOR_LOAD(v_n, vertex->nx, vertex->ny, vertex->nz) ;

    deltaH = (Hdesired - vertex->H) ;  /* sign will be reversed in MUL */
#if 1
#define TAN_SCALE 0.5
    deltaH = tanh(deltaH * TAN_SCALE) ;
#endif
    V3_SCALAR_MUL(v_n, -deltaH, v_delta) ;

    vertex->dx += l_curv * V3_X(v_delta) ;
    vertex->dy += l_curv * V3_Y(v_delta) ;
    vertex->dz += l_curv * V3_Z(v_delta) ;
    if (vno == Gdiag_no && DIAG_VERBOSE_ON)
      fprintf(stdout, "Hdes=%2.3f, dH = %2.3f, tanh= %2.3f, dx=%2.3f\n",
              Hdesired,Hdesired - vertex->H, deltaH, vertex->dx) ;
  }

  VectorFree(&v_delta) ;
  VectorFree(&v_n) ;

  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
static int
mrisComputeSethianCurvatureTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  VECTOR  *v_n, *v_delta ;
  int     vno ;
  VERTEX  *vertex ;
  double  l_curv, deltaH, Hdesired ;

  Hdesired = parms->Hdesired ;
  l_curv = parms->l_curv ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_delta = VectorAlloc(3, MATRIX_REAL) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }


    VECTOR_LOAD(v_n, vertex->nx, vertex->ny, vertex->nz) ;
    /* Osher and Sethian */
#if 1
    deltaH = (1 - parms->epsilon*tanh(Hdesired-vertex->H)*.5) ;
#else
    deltaH = (tanh(vertex->H-Hdesired)*.5) ;
#endif
    V3_SCALAR_MUL(v_n, deltaH, v_delta) ;

    vertex->dx += l_curv * V3_X(v_delta) ;
    vertex->dy += l_curv * V3_Y(v_delta) ;
    vertex->dz += l_curv * V3_Z(v_delta) ;
  }

  VectorFree(&v_delta) ;
  VectorFree(&v_n) ;

  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
static int
mrisComputeCurvatureGradientTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  VECTOR  *v_n, *v_g1, *v_g2, *v_y, *v_delta, *v_tmp, *v_n_r2, *v_u_g1,*v_v_g2;
  int     vno, i, N ;
  VERTEX  *vertex, *vnb ;
  double  r2, r3, z, u, v, l_curv, deltaH, Hdesired ;
  FILE    *fp = NULL ;

  Hdesired = parms->Hdesired ;
  l_curv = parms->l_curv ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_g1 = VectorAlloc(3, MATRIX_REAL) ;
  v_g2 = VectorAlloc(3, MATRIX_REAL) ;
  v_y = VectorAlloc(3, MATRIX_REAL) ;
  v_delta = VectorAlloc(3, MATRIX_REAL) ;
  v_tmp = VectorAlloc(3, MATRIX_REAL) ;
  v_n_r2 = VectorAlloc(3, MATRIX_REAL) ;
  v_u_g1 = VectorAlloc(3, MATRIX_REAL) ;
  v_v_g2 = VectorAlloc(3, MATRIX_REAL) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    /*
      first compute term which comes from moving the this vertex in its
      own tangent plane.
    */
#if 1
    VECTOR_LOAD(v_n, vertex->nx, vertex->ny, vertex->nz) ;
    VECTOR_LOAD(v_g1, vertex->e1x, vertex->e1y, vertex->e1z) ;
    VECTOR_LOAD(v_g2, vertex->e2x, vertex->e2y, vertex->e2z) ;
    V3_CLEAR(v_delta) ;

    if (Gdiag & DIAG_SHOW && vno == Gdiag_no && DIAG_VERBOSE_ON)
    {
      char fname[STRLEN] ;

      sprintf(fname, "v%d_%d.m", vno, parms->t) ;
      fp = fopen(fname, "w") ;
      fprintf(fp, "U%d_%d = [", vno, parms->t) ;
    }


    deltaH = (Hdesired - vertex->H) ;
    N = 0 ;
    for (i = 0 ; i < vertex->v2num ; i++)  /* for each neighbor */
    {
      vnb = &mris->vertices[vertex->v[i]] ;
      if (vnb->ripflag)
      {
        continue ;
      }
      VECTOR_LOAD(v_y,
                  vnb->x-vertex->x, vnb->y-vertex->y, vnb->z-vertex->z) ;

      /* calculate projection onto tangent plane */
      u = V3_DOT(v_y, v_g1) ;
      v = V3_DOT(v_y, v_g2) ;
      r2 = u*u + v*v ;
      r3 = r2 * sqrt(r2) ;
      if (FZERO(r3))
      {
        continue ;
      }
      z = V3_DOT(v_y, v_n) ;     /* height above tangent plane */
      if (Gdiag & DIAG_SHOW && vno == Gdiag_no && DIAG_VERBOSE_ON)
      {
        fprintf(fp, "%2.3f  %2.3f  %2.3f; ", u, v, z) ;
      }
      V3_SCALAR_MUL(v_n, -1.0/r2, v_n_r2) ;  /* -n/r^2 */
      V3_SCALAR_MUL(v_g1, u, v_u_g1) ;       /* ui g1 */
      V3_SCALAR_MUL(v_g2, v, v_v_g2) ;       /* vi g2 */
      V3_ADD(v_u_g1, v_v_g2, v_tmp) ;        /* ui g1 + vi g2 */
      V3_SCALAR_MUL(v_tmp, 4*z/r3, v_tmp) ;/*  4 z / n^3 (ui g1 + vi g2) */
#if USE_TANGENTIAL_TERM
      V3_ADD(v_tmp, v_delta, v_delta) ;      /* add it into total delta */
#endif
      V3_ADD(v_n_r2, v_delta, v_delta) ;     /* add it into total delta */
      N++ ;
    }
    if (N > 0)
#if SCALE_BY_N
      V3_SCALAR_MUL(v_delta, deltaH * 2.0/N, v_delta) ;
#else
      V3_SCALAR_MUL(v_delta, deltaH * 2.0, v_delta) ;
#endif


#endif

    if (Gdiag & DIAG_SHOW && vno == Gdiag_no)
    {
      fprintf(fp, "] ;\n") ;
      fclose(fp) ;
    }

    /*
      now add terms which come from this vertex's appearance in
      neighboring tangent planes.
    */
    for (i = 0 ; i < vertex->v2num ; i++)  /* for each neighbor */
    {
      vnb = &mris->vertices[vertex->v[i]] ;
      if (vnb->ripflag || !vnb->v2num)
      {
        continue ;
      }

      /* load coordinate system for neighbor's tangent plane */
      VECTOR_LOAD(v_n, vnb->nx, vnb->ny, vnb->nz) ;
      VECTOR_LOAD(v_g1, vnb->e1x, vnb->e1y, vnb->e1z) ;
      VECTOR_LOAD(v_g2, vnb->e2x, vnb->e2y, vnb->e2z) ;

      deltaH = (Hdesired - vnb->H) ;
      VECTOR_LOAD(v_y,
                  vertex->x-vnb->x, vertex->y-vnb->y, vertex->z-vnb->z) ;

      /* calculate projection onto tangent plane */
      u = V3_DOT(v_y, v_g1) ;
      v = V3_DOT(v_y, v_g2) ;
      r2 = u*u + v*v ;
      r3 = r2 * sqrt(r2) ;
      if (FZERO(r3))
      {
        continue ;
      }
      z = V3_DOT(v_y, v_n) ;        /* height above tangent plane */
      V3_SCALAR_MUL(v_n, 1.0/r2, v_n_r2) ;   /* n/r^2 */
      V3_SCALAR_MUL(v_g1, u, v_u_g1) ;       /* ui g1 */
      V3_SCALAR_MUL(v_g2, v, v_v_g2) ;       /* vi g2 */
      V3_ADD(v_u_g1, v_v_g2, v_tmp) ;        /* ui g1 + vi g2 */

#if USE_TANGENTIAL_TERM
      V3_SCALAR_MUL(v_tmp, -4*z/r3, v_tmp) ;  /*  -4z / n^3 (ui g1 + vi g2) */
      V3_ADD(v_n_r2, v_tmp, v_tmp) ;
#else
      V3_SCALAR_MUL(v_n_r2, 1.0, v_tmp) ;
#endif
#if SCALE_BY_N
      V3_SCALAR_MUL(v_tmp, deltaH*2/(double)vnb->v2num, v_tmp) ;
#else
      V3_SCALAR_MUL(v_tmp, deltaH*2, v_tmp) ;
#endif
      V3_ADD(v_tmp, v_delta, v_delta) ;
    }

    vertex->dx += l_curv * V3_X(v_delta) ;
    vertex->dy += l_curv * V3_Y(v_delta) ;
    vertex->dz += l_curv * V3_Z(v_delta) ;
    if (vno == Gdiag_no)
      fprintf(stdout, "moving v %d by (%2.3f, %2.3f, %2.3f)\n",
              vno, vertex->dx, vertex->dy, vertex->dz) ;
  }

  VectorFree(&v_tmp) ;
  VectorFree(&v_delta) ;
  VectorFree(&v_y) ;
  VectorFree(&v_n) ;
  VectorFree(&v_g1) ;
  VectorFree(&v_g2) ;
  VectorFree(&v_n_r2) ;
  VectorFree(&v_u_g1) ;
  VectorFree(&v_v_g2) ;

  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISupdateSurface(MRI_SURFACE *mris)
{
  MRIScomputeMetricProperties(mris) ;
  MRIScomputeSecondFundamentalForm(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScomputeEulerNumber(MRI_SURFACE *mris, int *pnvertices,
                       int *pnfaces, int *pnedges)
{
  int     eno, nfaces, nedges, nvertices, vno, fno, vnb, i ;
  VERTEX  *v1 ;

  /*  MRISripFaces(mris) ;*/
  for (nfaces = fno = 0 ; fno < mris->nfaces ; fno++)
    if (!mris->faces[fno].ripflag)
    {
      nfaces++ ;
    }

  for (nvertices = vno = 0 ; vno < mris->nvertices ; vno++)
    if (!mris->vertices[vno].ripflag)
    {
      nvertices++ ;
    }

  for (nedges = vno = 0 ; vno < mris->nvertices ; vno++)
    if (!mris->vertices[vno].ripflag)
    {
      v1 = &mris->vertices[vno] ;
      for (i = 0 ; i < v1->vnum ; i++)
      {
        vnb = v1->v[i] ;
        /* already counted */
        if ((vnb > vno) && !mris->vertices[vnb].ripflag)
        {
          nedges++ ;
        }
      }
    }

  *pnfaces = nfaces ;
  *pnvertices = nvertices ;
  *pnedges = nedges ;
  eno = nvertices - nedges + nfaces ;
  return(eno) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIStopologicalDefectIndex(MRI_SURFACE *mris)
{
  int     eno, nfaces, nedges, nvertices, vno, fno, vnb, i, dno ;
  VERTEX  *v1 ;

  for (nfaces = fno = 0 ; fno < mris->nfaces ; fno++)
    if (!mris->faces[fno].ripflag)
    {
      nfaces++ ;
    }

  for (nvertices = vno = 0 ; vno < mris->nvertices ; vno++)
    if (!mris->vertices[vno].ripflag)
    {
      nvertices++ ;
    }

  for (nedges = vno = 0 ; vno < mris->nvertices ; vno++)
    if (!mris->vertices[vno].ripflag)
    {
      v1 = &mris->vertices[vno] ;
      for (i = 0 ; i < v1->vnum ; i++)
      {
        vnb = v1->v[i] ;
        /* already counted */
        if ((vnb > vno) && !mris->vertices[vnb].ripflag)
        {
          nedges++ ;
        }
      }
    }
#if 0
  nedges += nfaces ;        /* one additional edge added for each triangle */
  nfaces *= 2 ;             /* two triangular faces per face */
#endif
  eno = nvertices - nedges + nfaces ;

  dno = abs(2-eno) + abs(2*nedges-3*nfaces) ;
  return(dno) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISremoveTopologicalDefects(MRI_SURFACE *mris,float curv_thresh)
{
  VECTOR  *v_n, *v_e1, *v_e2, *v_i ;
  int     vno, i ;
  VERTEX  *vertex, *vnb ;
  float   rsq, z, u, v ;

  mrisComputeTangentPlanes(mris) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_e1 = VectorAlloc(3, MATRIX_REAL) ;
  v_e2 = VectorAlloc(3, MATRIX_REAL) ;
  v_i = VectorAlloc(3, MATRIX_REAL) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    VECTOR_LOAD(v_n, vertex->nx, vertex->ny, vertex->nz) ;
    VECTOR_LOAD(v_e1, vertex->e1x, vertex->e1y, vertex->e1z) ;
    VECTOR_LOAD(v_e2, vertex->e2x, vertex->e2y, vertex->e2z) ;

    for (i = 0 ; i < vertex->vnum ; i++)  /* for each neighbor */
    {
      vnb = &mris->vertices[vertex->v[i]] ;
      if (vnb->ripflag)
      {
        continue ;
      }
      VECTOR_LOAD(v_i,
                  vnb->x-vertex->x, vnb->y-vertex->y, vnb->z-vertex->z) ;

      /* calculate projection onto tangent plane */
      u = V3_DOT(v_i, v_e1) ;
      v = V3_DOT(v_i, v_e2) ;
      rsq = u*u + v*v ;
      z = V3_DOT(v_i, v_n) ;   /* height above tangent plane */
      if (!FZERO(rsq))
      {
        if (fabs(z/rsq) > curv_thresh)
        {
          mrisRemoveLink(mris, vno, vertex->v[i--]) ;
        }
      }
    }
  }


  /*  MRISripFaces(mris) ;*/
  VectorFree(&v_i) ;
  VectorFree(&v_n) ;
  VectorFree(&v_e1) ;
  VectorFree(&v_e2) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisRemoveLink(MRI_SURFACE *mris, int vno1, int vno2)
{
  FACE    *face ;
  int     vno, fno, nvalid ;
  VERTEX  *v1, *v2 ;

  v1 = &mris->vertices[vno1] ;
  v2 = &mris->vertices[vno2] ;
  mrisRemoveEdge(mris, vno1, vno2) ;
  mrisRemoveEdge(mris, vno2, vno1) ;

  /* now remove all the faces which contain both edges */
  for (fno = 0 ; fno < v1->num ; fno++)
  {
    face = &mris->faces[v1->f[fno]] ;
    for (vno = 0 ; vno < VERTICES_PER_FACE ; vno++)
      if (face->v[vno] == vno2)   /* found a face with both vertices */
      {
        face->ripflag = 1 ;
      }
    if (face->ripflag)
    {
      mrisRemoveFace(mris, v1->f[fno]) ;
    }
  }

  /* make sure vno1 and vno2 are still part of at least 1 valid face */
  for (nvalid = fno = 0 ; fno < v1->num ; fno++)
    if (!mris->faces[v1->f[fno]].ripflag)
    {
      nvalid++ ;
    }
  if (nvalid <= 0)
  {
    v1->ripflag = 1 ;
  }

  for (nvalid = fno = 0 ; fno < v2->num ; fno++)
    if (!mris->faces[v2->f[fno]].ripflag)
    {
      nvalid++ ;
    }
  if (nvalid <= 0)
  {
    v2->ripflag = 1 ;
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisRemoveEdge(MRI_SURFACE *mris, int vno1, int vno2)
{
  int     i ;
  VERTEX  *v1, *v2 ;

  v1 = &mris->vertices[vno1] ;
  v2 = &mris->vertices[vno2] ;
  for (i = 0 ; i < v1->vnum ; i++)
    if (v1->v[i] == vno2)
    {
      v1->vnum-- ;
      if (i < v1->vnum)  /* not the (previous) last index */
      {
        memmove(&v1->v[i], &v1->v[i+1], (v1->vnum-i)*sizeof(v1->v[0])) ;
      }
      return(NO_ERROR) ;
    }
  return(ERROR_BADPARM) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  remove this face, as well as the link two vertices if
  they only exist through this face.
  ------------------------------------------------------*/
static int
mrisRemoveFace(MRI_SURFACE *mris, int fno)
{
  int   vno1, vno2, vno ;
  FACE  *face ;

  face = &mris->faces[fno] ;
  face->ripflag = 1 ;
  for (vno = 0 ; vno < VERTICES_PER_FACE ; vno++)
  {
    vno1 = face->v[vno] ;
    vno2 = face->v[vno < VERTICES_PER_FACE-1 ? vno+1 : 0] ;
    if (!mrisCountValidLinks(mris, vno1, vno2))
    {
      mrisRemoveEdge(mris, vno1, vno2) ;
      mrisRemoveEdge(mris, vno2, vno1) ;
    }
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Go through all the (valid) faces in vno1 and see how man
  valid links to vno2 exists.
  ------------------------------------------------------*/
static int
mrisCountValidLinks(MRI_SURFACE *mris, int vno1, int vno2)
{
  int    nvalid, fno, vno ;
  FACE   *face ;
  VERTEX *v ;

  v = &mris->vertices[vno1] ;
  for (nvalid = fno = 0 ; fno < v->num ; fno++)
  {
    face = &mris->faces[v->f[fno]] ;
    if (face->ripflag)
    {
      continue ;
    }
    for (vno = 0 ; vno < VERTICES_PER_FACE ; vno++)
      if (face->v[vno] == vno1)
      {
        if ((vno == VERTICES_PER_FACE-1) && (face->v[0] == vno2))
        {
          nvalid++ ;
        }
        else if ((vno < VERTICES_PER_FACE-1) && (face->v[vno+1] == vno2))
        {
          nvalid++ ;
        }
      }

  }
  return(nvalid) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
//#define ILL_CONDITIONED   5000.0
#define ILL_CONDITIONED   500000.0
int
MRIScomputeSecondFundamentalForm(MRI_SURFACE *mris)
{
  return(MRIScomputeSecondFundamentalFormThresholded(mris, -1)) ;
}

int
MRIScomputeSecondFundamentalFormThresholded(MRI_SURFACE *mris, double pct_thresh)
{
  double min_k1, min_k2, max_k1, max_k2, k1_scale, k2_scale, total, thresh,
         orig_rsq_thresh ;
  int    bin, zbin1, zbin2, nthresh = 0 ;
  int    vno, i, n, vmax, nbad = 0, niter ;
  VERTEX *vertex, *vnb ;
  MATRIX *m_U, *m_Ut, *m_tmp1, *m_tmp2, *m_inverse, *m_eigen, *m_Q ;
  VECTOR *v_c, *v_z, *v_n, *v_e1, *v_e2, *v_yi ;
  float  k1, k2, evalues[3], a11, a12, a21, a22, cond_no, kmax, kmin, rsq, k ;
  double ui, vi, total_area = 0.0, max_error, vmean, vsigma, rsq_thresh ;
  FILE   *fp = NULL ;
  HISTOGRAM *h_k1, *h_k2 ;

  if (mris->status == MRIS_PLANE)
  {
    return(NO_ERROR) ;
  }

  if (pct_thresh >= 0)
  {
    vmean = MRIScomputeTotalVertexSpacingStats
      (mris,&vsigma,NULL,NULL,NULL,NULL);
    rsq_thresh = MIN(vmean*.25, 1.0) ;
    rsq_thresh *= rsq_thresh ;
  }
  else
  {
    rsq_thresh = 0.0 ;
  }

  orig_rsq_thresh = rsq_thresh ;

  mrisComputeTangentPlanes(mris) ;

  v_c = VectorAlloc(3, MATRIX_REAL) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_e1 = VectorAlloc(3, MATRIX_REAL) ;
  v_e2 = VectorAlloc(3, MATRIX_REAL) ;
  v_yi = VectorAlloc(3, MATRIX_REAL) ;
  m_Q = MatrixAlloc(2, 2, MATRIX_REAL) ;   /* the quadratic form */
  m_eigen = MatrixAlloc(2, 2, MATRIX_REAL) ;

  mris->Kmin = mris->Hmin = 10000.0f ;
  mris->Kmax = mris->Hmax = -10000.0f ;
  mris->Ktotal = 0.0f ;
  vmax = -1 ;
  max_error = -1.0 ;
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    fp = fopen("curv.dat", "w") ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }

    VECTOR_LOAD(v_n, vertex->nx, vertex->ny, vertex->nz) ;
    VECTOR_LOAD(v_e1, vertex->e1x, vertex->e1y, vertex->e1z) ;
    VECTOR_LOAD(v_e2, vertex->e2x, vertex->e2y, vertex->e2z) ;

    if (vertex->vtotal <= 0)
    {
      continue ;
    }

    m_U = MatrixAlloc(vertex->vtotal, 3, MATRIX_REAL) ;
    v_z = VectorAlloc(vertex->vtotal, MATRIX_REAL) ;

    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    /* fit a quadratic form to the surface at this vertex */
    rsq_thresh = orig_rsq_thresh ;
    niter = 0 ;
    do
    {
      kmin = 10000.0f ;
      kmax = -kmin ;
      for (n = i = 0 ; i < vertex->vtotal ; i++)
      {
        vnb = &mris->vertices[vertex->v[i]] ;
        if (vnb->ripflag)
        {
          continue ;
        }
        /*
          calculate the projection of this vertex
          onto the local tangent plane
        */
        VECTOR_LOAD(v_yi,
                    vnb->x-vertex->x,
                    vnb->y-vertex->y,
                    vnb->z-vertex->z);
        ui = V3_DOT(v_yi, v_e1) ;
        vi = V3_DOT(v_yi, v_e2) ;
        *MATRIX_RELT(m_U, n+1, 1) = ui*ui ;
        *MATRIX_RELT(m_U, n+1, 2) = 2*ui*vi ;
        *MATRIX_RELT(m_U, n+1, 3) = vi*vi ;
        VECTOR_ELT(v_z, n+1) = V3_DOT(v_n, v_yi) ;  /* height above TpS */
        rsq = ui*ui + vi*vi ;
        if (!FZERO(rsq) && rsq > rsq_thresh)
        {
          k = VECTOR_ELT(v_z, n+1) / rsq ;
          if (k > kmax)
          {
            kmax = k ;
          }
          if (k < kmin)
          {
            kmin = k ;
          }
          n++ ;
        }
      }
      rsq_thresh *= 0.25 ;
      if (n < 4)
      {
        DiagBreak() ;
      }
      if (niter++ > 100)
      {
        break ;
      }
    }
    while (n < 4) ;

    m_Ut = MatrixTranspose(m_U, NULL) ;          /* Ut */
    m_tmp2 = MatrixMultiply(m_Ut, m_U, NULL) ;   /* Ut U */
    cond_no = MatrixConditionNumber(m_tmp2) ;
#if 0
    m_inverse = MatrixInverse(m_tmp2, NULL) ;    /* (Ut U)^-1 */
#else
    m_inverse = MatrixSVDInverse(m_tmp2, NULL) ;    /* (Ut U)^-1 */
#endif
    if (!m_inverse)   /* singular matrix - must be planar?? */
    {
      nbad++ ;
      evalues[0] = evalues[1] = 0.0 ;
      MatrixIdentity(m_eigen->rows, m_eigen) ;
    }
    else
    {
      m_tmp1 = MatrixMultiply(m_Ut, v_z, NULL) ;   /* Ut z */
      MatrixMultiply(m_inverse, m_tmp1, v_c) ;     /* (Ut U)^-1 Ut z */

      /* now build Hessian matrix */
      *MATRIX_RELT(m_Q,1,1) = 2*VECTOR_ELT(v_c, 1) ;
      *MATRIX_RELT(m_Q,1,2) = *MATRIX_RELT(m_Q,2,1)
                              = 2*VECTOR_ELT(v_c, 2) ;
      *MATRIX_RELT(m_Q,2,2) = 2*VECTOR_ELT(v_c, 3) ;

      if (cond_no >= ILL_CONDITIONED)
      {
#if 0
        MatrixSVDEigenValues(m_Q, evalues) ;
        vertex->k1 = k1 = evalues[0] ;
        vertex->k2 = k2 = evalues[1] ;
#else
        vertex->k1 = k1 = kmax ;
        vertex->k2 = k2 = kmin ;
#endif

#if 1
        vertex->K = k1*k2 ;
        vertex->H = (k1+k2)/2 ;
#else
        // k1 and k2 are usually very large, resulting in
        // K >> mris->Kmax and H >> mris->Hmax, which skews
        // statistics on the surface. This hardlimits the
        // K and H curvatures to not exceed the current maxima.
        if (k1*k2<0)
        {
          vertex->K = mris->Kmin ;
          vertex->H = mris->Hmin;
        }
        else
        {
          vertex->K = mris->Kmax ;
          vertex->H = mris->Hmax;
        }
#endif
        MatrixFree(&m_Ut) ;
        MatrixFree(&m_tmp2) ;
        MatrixFree(&m_U) ;
        VectorFree(&v_z) ;
        MatrixFree(&m_tmp1) ;
        MatrixFree(&m_inverse) ;
        continue ;
      }

      /* the columns of m_eigen will be the eigenvectors of m_Q */
      if (MatrixEigenSystem(m_Q, evalues, m_eigen) == NULL)
      {
        nbad++ ;
        MatrixSVDEigenValues(m_Q, evalues) ;
        vertex->k1 = k1 = evalues[0] ;
        vertex->k2 = k2 = evalues[1] ;
        vertex->K = k1*k2 ;
        vertex->H = (k1+k2)/2 ;
        MatrixFree(&m_Ut) ;
        MatrixFree(&m_tmp2) ;
        MatrixFree(&m_U) ;
        VectorFree(&v_z) ;
        MatrixFree(&m_tmp1) ;
        MatrixFree(&m_inverse) ;
        continue ;
      }

      MatrixFree(&m_tmp1) ;
      MatrixFree(&m_inverse) ;
    }
    k1 = evalues[0] ;
    k2 = evalues[1] ;
    vertex->k1 = k1 ;
    vertex->k2 = k2 ;
    vertex->K = k1 * k2 ;
    vertex->H = (k1 + k2) / 2 ;
    if (fp)
      fprintf(fp, "%d %f %f %f %f\n",
              vno, k1, k2, vertex->K, vertex->H) ;
    if (vno == Gdiag_no && (Gdiag & DIAG_SHOW))
      fprintf(stdout, "v %d: k1=%2.3f, k2=%2.3f, K=%2.3f, H=%2.3f\n",
              vno, vertex->k1, vertex->k2, vertex->K, vertex->H) ;
    if (vertex->K < mris->Kmin)
    {
      mris->Kmin = vertex->K ;
    }
    if (vertex->H < mris->Hmin)
    {
      mris->Hmin = vertex->H ;
    }
    if (vertex->K > mris->Kmax)
    {
      mris->Kmax = vertex->K ;
    }
    if (vertex->H > mris->Hmax)
    {
      mris->Hmax = vertex->H ;
    }
    mris->Ktotal += (double)k1 * (double)k2 * (double)vertex->area ;
    total_area += (double)vertex->area ;

    /* now update the basis vectors to be the principal directions */
    a11 = *MATRIX_RELT(m_eigen,1,1) ;
    a12 = *MATRIX_RELT(m_eigen,1,2) ;
    a21 = *MATRIX_RELT(m_eigen,2,1) ;
    a22 = *MATRIX_RELT(m_eigen,2,2) ;
    if (V3_LEN(v_e1) < 0.5)
    {
      DiagBreak();
    }
    vertex->e1x = V3_X(v_e1) * a11 + V3_X(v_e2) * a21 ;
    vertex->e1y = V3_Y(v_e1) * a11 + V3_Y(v_e2) * a21 ;
    vertex->e1z = V3_Z(v_e1) * a11 + V3_Z(v_e2) * a21 ;
    vertex->e2x = V3_X(v_e1) * a12 + V3_X(v_e2) * a22 ;
    vertex->e2y = V3_Y(v_e1) * a12 + V3_Y(v_e2) * a22 ;
    vertex->e2z = V3_Z(v_e1) * a12 + V3_Z(v_e2) * a22 ;
    if (SQR(vertex->e1x) + SQR(vertex->e1y) + SQR(vertex->e1z) < 0.5)
    {
      DiagBreak();
    }

    MatrixFree(&m_Ut) ;
    MatrixFree(&m_tmp2) ;
    MatrixFree(&m_U) ;
    VectorFree(&v_z) ;

  }

  if (fp)
  {
    fclose(fp) ;
  }
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "max H error=%2.3f at %d\n", max_error, vmax) ;
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "total area = %2.3f\n", total_area);
  }

  if (Gdiag & DIAG_SHOW && (nbad > 0))
  {
    fprintf(stdout, "%d ill-conditioned points\n", nbad) ;
  }
  MatrixFree(&m_eigen) ;
  VectorFree(&v_e1) ;
  VectorFree(&v_e2) ;
  VectorFree(&v_c) ;
  VectorFree(&v_n) ;
  VectorFree(&v_yi) ;
  MatrixFree(&m_Q) ;

  if (pct_thresh < 0)
  {
    return(NO_ERROR) ;
  }

  // now remove outliers
  h_k1 = HISTOalloc(1000) ;
  h_k2 = HISTOalloc(1000) ;

  min_k1 = min_k2 = 1000 ;
  max_k1 = max_k2 = -1000 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (vertex->ripflag)
    {
      continue ;
    }
    if (vertex->k1 > max_k1)
    {
      max_k1 = vertex->k1 ;
    }
    if (vertex->k2 > max_k2)
    {
      max_k2 = vertex->k2 ;
    }
    if (vertex->k1 < min_k1)
    {
      min_k1 = vertex->k1 ;
    }
    if (vertex->k2 < min_k2)
    {
      min_k2 = vertex->k2 ;
    }
  }

  k1_scale = (h_k1->nbins-1)/(max_k1 - min_k1);
  k2_scale = (h_k2->nbins-1)/(max_k2 - min_k2);
  h_k1->bin_size = 1.0/k1_scale ;
  h_k2->bin_size = 1.0/k2_scale ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (vertex->ripflag)
    {
      continue ;
    }
    bin = nint(k1_scale * (vertex->k1 - min_k1)) ;
    h_k1->counts[bin]++ ;
    bin = nint(k2_scale * (vertex->k2 - min_k2)) ;
    h_k2->counts[bin]++ ;
  }
  for (bin = 0 ; bin < h_k1->nbins ; bin++)
  {
    h_k1->bins[bin] = (bin / k1_scale) + min_k1 ;
  }
  for (bin = 0 ; bin < h_k2->nbins ; bin++)
  {
    h_k2->bins[bin] = (bin / k2_scale) + min_k2 ;
  }
  zbin1 = nint(k1_scale * (0.0-min_k1)) ;
  zbin2 = nint(k2_scale * (0.0-min_k2)) ;
  HISTOmakePDF(h_k1, h_k1) ;
  HISTOmakePDF(h_k2, h_k2) ;
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    HISTOplot(h_k1, "k1.plt") ;
    HISTOplot(h_k2, "k2.plt") ;
  }

  zbin1 = HISTOfindHighestPeakInRegion(h_k1, 0, h_k1->nbins) ;
  zbin2 = HISTOfindHighestPeakInRegion(h_k2, 0, h_k2->nbins) ;

  for (total = 0, bin = zbin1 ; bin < h_k1->nbins ; bin++)
  {
    total += h_k1->counts[bin] ;
  }
  thresh = pct_thresh*total ;
  for (total = 0, bin = zbin1 ; bin < h_k1->nbins-1 ; bin++)
  {
    total += h_k1->counts[bin] ;
    if (total > thresh)
    {
      break ;
    }
  }
  max_k1 = h_k1->bins[bin] ;

  for (total = 0, bin = zbin1 ; bin > 0 ; bin--)
  {
    total += h_k1->counts[bin] ;
  }
  thresh = pct_thresh*total ;
  for (total = 0, bin = zbin1 ; bin > 0 ; bin--)
  {
    total += h_k1->counts[bin] ;
    if (total > thresh)
    {
      break ;
    }
  }
  min_k1 = h_k1->bins[bin] ;


  for (total = 0, bin = zbin2 ; bin < h_k2->nbins ; bin++)
  {
    total += h_k2->counts[bin] ;
  }
  thresh = pct_thresh*total ;
  for (total = 0, bin = zbin2 ; bin < h_k2->nbins-1 ; bin++)
  {
    total += h_k2->counts[bin] ;
    if (total > thresh)
    {
      break ;
    }
  }
  max_k2 = h_k2->bins[bin] ;

  for (total = 0, bin = zbin2 ; bin > 0 ; bin--)
  {
    total += h_k2->counts[bin] ;
  }
  thresh = pct_thresh*total ;
  for (total = 0, bin = zbin2 ; bin > 0 ; bin--)
  {
    total += h_k2->counts[bin] ;
    if (total > thresh)
    {
      break ;
    }
  }
  min_k2 = h_k2->bins[bin] ;

  mris->Kmin = mris->Hmin = 10000.0f ;
  mris->Kmax = mris->Hmax = -10000.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (vertex->ripflag)
    {
      continue ;
    }
    if (vertex->k1 > max_k1)
    {
      vertex->k1 = max_k1 ;
      nthresh++ ;
    }
    if (vertex->k2 > max_k2)
    {
      vertex->k2 = max_k2 ;
      nthresh++ ;
    }
    if (vertex->k1 < min_k1)
    {
      vertex->k1 = min_k1 ;
      nthresh++ ;
    }
    if (vertex->k2 < min_k2)
    {
      vertex->k2 = min_k2 ;
      nthresh++ ;
    }
    vertex->K = vertex->k1 * vertex->k2 ;
    vertex->H = (vertex->k1 + vertex->k2) / 2.0 ;
    if (vertex->K < mris->Kmin)
    {
      mris->Kmin = vertex->K ;
    }
    if (vertex->H < mris->Hmin)
    {
      mris->Hmin = vertex->H ;
    }
    if (vertex->K > mris->Kmax)
    {
      mris->Kmax = vertex->K ;
    }
    if (vertex->H > mris->Hmax)
    {
      mris->Hmax = vertex->H ;
    }
  }

  HISTOfree(&h_k1) ;
  HISTOfree(&h_k2) ;
  if (nthresh > 0)
    fprintf(stderr,
            "%d vertices thresholded to be in k1 ~ "
            "[%2.2f %2.2f], k2 ~ [%2.2f %2.2f]\n",
            nthresh, min_k1, max_k1, min_k2, max_k2) ;
  return(NO_ERROR) ;
}
int
MRIScomputeSecondFundamentalFormAtVertex(MRI_SURFACE *mris, int vno,
    int *vertices, int vnum)
{
  int    i, n, nbad = 0 ;
  VERTEX *vertex, *vnb ;
  MATRIX *m_U, *m_Ut, *m_tmp1, *m_tmp2, *m_inverse ;
  VECTOR *v_z ;
  static MATRIX *m_Q, *m_eigen ;
  static VECTOR *v_c = NULL, *v_n, *v_e1, *v_e2, *v_yi ;
  float  k1, k2, evalues[3], a11, a12, a21, a22, cond_no, rsq, k, kmin, kmax ;
  double ui, vi ;

  if (mris->status == MRIS_PLANE)
  {
    return(NO_ERROR) ;
  }

  if (v_c == NULL)
  {
    v_c = VectorAlloc(3, MATRIX_REAL) ;
    v_n = VectorAlloc(3, MATRIX_REAL) ;
    v_e1 = VectorAlloc(3, MATRIX_REAL) ;
    v_e2 = VectorAlloc(3, MATRIX_REAL) ;
    v_yi = VectorAlloc(3, MATRIX_REAL) ;
    m_Q = MatrixAlloc(2, 2, MATRIX_REAL) ;   /* the quadratic form */
    m_eigen = MatrixAlloc(2, 2, MATRIX_REAL) ;
  }

  vertex = &mris->vertices[vno] ;
  if (vertex->ripflag)
  {
    return(ERROR_BADPARM) ;
  }

  if (vno == 142915)
  {
    DiagBreak() ;
  }
  VECTOR_LOAD(v_n, vertex->nx, vertex->ny, vertex->nz) ;
  VECTOR_LOAD(v_e1, vertex->e1x, vertex->e1y, vertex->e1z) ;
  VECTOR_LOAD(v_e2, vertex->e2x, vertex->e2y, vertex->e2z) ;

  if (vnum <= 0)
  {
    return(ERROR_BADPARM) ;
  }

  m_U = MatrixAlloc(vnum, 3, MATRIX_REAL) ;
  v_z = VectorAlloc(vnum, MATRIX_REAL) ;

  if (vno == Gdiag_no)
  {
    DiagBreak() ;
  }

  /* fit a quadratic form to the surface at this vertex */
  kmin = 10000.0f ;
  kmax = -kmin ;
  for (n = i = 0 ; i < vnum ; i++)
  {
    vnb = &mris->vertices[vertices[i]] ;
    if (vnb->ripflag)
    {
      continue ;
    }
    /*
      calculate the projection of this vertex onto the local tangent plane
    */
    VECTOR_LOAD(v_yi, vnb->x-vertex->x, vnb->y-vertex->y,vnb->z-vertex->z);
    ui = V3_DOT(v_yi, v_e1) ;
    vi = V3_DOT(v_yi, v_e2) ;
    *MATRIX_RELT(m_U, n+1, 1) = ui*ui ;
    *MATRIX_RELT(m_U, n+1, 2) = 2*ui*vi ;
    *MATRIX_RELT(m_U, n+1, 3) = vi*vi ;
    VECTOR_ELT(v_z, n+1) = V3_DOT(v_n, v_yi) ;  /* height above TpS */
    rsq = ui*ui + vi*vi ;
    if (!FZERO(rsq))
    {
      k = VECTOR_ELT(v_z, n+1) / rsq ;
      if (k > kmax)
      {
        kmax = k ;
      }
      if (k < kmin)
      {
        kmin = k ;
      }
    }
    n++ ;
  }

  m_Ut = MatrixTranspose(m_U, NULL) ;          /* Ut */
  m_tmp2 = MatrixMultiply(m_Ut, m_U, NULL) ;   /* Ut U */
  cond_no = MatrixConditionNumber(m_tmp2) ;
#if 0
  m_inverse = MatrixInverse(m_tmp2, NULL) ;    /* (Ut U)^-1 */
#else
  m_inverse = MatrixSVDInverse(m_tmp2, NULL) ;    /* (Ut U)^-1 */
#endif
  if (!m_inverse)   /* singular matrix - must be planar?? */
  {
    nbad++ ;
    evalues[0] = evalues[1] = 0.0 ;
  }
  else
  {
    m_tmp1 = MatrixMultiply(m_Ut, v_z, NULL) ;   /* Ut z */
    MatrixMultiply(m_inverse, m_tmp1, v_c) ;     /* (Ut U)^-1 Ut z */

    /* now build Hessian matrix */
    *MATRIX_RELT(m_Q,1,1) = 2*VECTOR_ELT(v_c, 1) ;
    *MATRIX_RELT(m_Q,1,2) = *MATRIX_RELT(m_Q,2,1) = 2*VECTOR_ELT(v_c, 2) ;
    *MATRIX_RELT(m_Q,2,2) = 2*VECTOR_ELT(v_c, 3) ;

    if (cond_no >= ILL_CONDITIONED)
    {
#if 0
      MatrixSVDEigenValues(m_Q, evalues) ;
      vertex->k1 = k1 = evalues[0] ;
      vertex->k2 = k2 = evalues[1] ;
#else
      vertex->k1 = k1 = kmax ;
      vertex->k2 = k2 = kmin ;
#endif
      //vertex->K = k1*k2 ; vertex->H = (k1+k2)/2 ;
      if (k1*k2<0)
      {
        vertex->K = mris->Kmin ;
        vertex->H = mris->Hmin;
      }
      else
      {
        vertex->K = mris->Kmax ;
        vertex->H = mris->Hmax;
      }
      MatrixFree(&m_Ut) ;
      MatrixFree(&m_tmp2) ;
      MatrixFree(&m_U) ;
      VectorFree(&v_z) ;
      MatrixFree(&m_tmp1) ;
      MatrixFree(&m_inverse) ;
      return(ERROR_BADPARM) ;
    }

    /* the columns of m_eigen will be the eigenvectors of m_Q */
    if (MatrixEigenSystem(m_Q, evalues, m_eigen) == NULL)
    {
      nbad++ ;
      MatrixSVDEigenValues(m_Q, evalues) ;
      vertex->k1 = k1 = evalues[0] ;
      vertex->k2 = k2 = evalues[1] ;
      vertex->K = k1*k2 ;
      vertex->H = (k1+k2)/2 ;
      MatrixFree(&m_Ut) ;
      MatrixFree(&m_tmp2) ;
      MatrixFree(&m_U) ;
      VectorFree(&v_z) ;
      MatrixFree(&m_tmp1) ;
      MatrixFree(&m_inverse) ;
      return(ERROR_BADPARM) ;
    }

    MatrixFree(&m_tmp1) ;
    MatrixFree(&m_inverse) ;
  }
  k1 = evalues[0] ;
  k2 = evalues[1] ;
  vertex->k1 = k1 ;
  vertex->k2 = k2 ;
  vertex->K = k1 * k2 ;
  vertex->H = (k1 + k2) / 2 ;
  if (vno == Gdiag_no && (Gdiag & DIAG_SHOW))
    fprintf(stdout, "v %d: k1=%2.3f, k2=%2.3f, K=%2.3f, H=%2.3f\n",
            vno, vertex->k1, vertex->k2, vertex->K, vertex->H) ;
  if (vertex->K < mris->Kmin)
  {
    mris->Kmin = vertex->K ;
  }
  if (vertex->H < mris->Hmin)
  {
    mris->Hmin = vertex->H ;
  }
  if (vertex->K > mris->Kmax)
  {
    mris->Kmax = vertex->K ;
  }
  if (vertex->H > mris->Hmax)
  {
    mris->Hmax = vertex->H ;
  }
  mris->Ktotal += (double)k1 * (double)k2 * (double)vertex->area ;

  /* now update the basis vectors to be the principal directions */
  a11 = *MATRIX_RELT(m_eigen,1,1) ;
  a12 = *MATRIX_RELT(m_eigen,1,2) ;
  a21 = *MATRIX_RELT(m_eigen,2,1) ;
  a22 = *MATRIX_RELT(m_eigen,2,2) ;
  if (V3_LEN(v_e1) < 0.5)
  {
    DiagBreak() ;
  }
  vertex->e1x = V3_X(v_e1) * a11 + V3_X(v_e2) * a21 ;
  vertex->e1y = V3_Y(v_e1) * a11 + V3_Y(v_e2) * a21 ;
  vertex->e1z = V3_Z(v_e1) * a11 + V3_Z(v_e2) * a21 ;
  vertex->e2x = V3_X(v_e1) * a12 + V3_X(v_e2) * a22 ;
  vertex->e2y = V3_Y(v_e1) * a12 + V3_Y(v_e2) * a22 ;
  vertex->e2z = V3_Z(v_e1) * a12 + V3_Z(v_e2) * a22 ;
  if (SQR(vertex->e1x) + SQR(vertex->e1y) + SQR(vertex->e1z) < 0.5)
  {
    DiagBreak();
  }

  MatrixFree(&m_Ut) ;
  MatrixFree(&m_tmp2) ;
  MatrixFree(&m_U) ;
  VectorFree(&v_z) ;

  if (Gdiag & DIAG_SHOW && (nbad > 0))
  {
    fprintf(stdout, "%d ill-conditioned points\n", nbad) ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISuseAreaErrors(MRI_SURFACE *mris)
{
  int    vno, fno, n ;
  float  area, orig_area ;
  FACE   *face ;
  VERTEX *vertex ;

  for (vno = 0 ; vno < mris->nvertices; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    area = orig_area = 0.0f ;

    /* use average area of all faces this vertex is part of -
       this is not really correct, but should be good enough for
       visualization purposes.
    */
    for (n = fno = 0 ; fno < vertex->num ; fno++)
    {
      face = &mris->faces[vertex->f[fno]] ;
      area += face->area ;
      orig_area += face->orig_area ;
    }
    vertex->curv = (area-orig_area) / (float)n ;
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISuseGaussianCurvature(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *vertex ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    vertex->curv = vertex->K ;
  }

  mris->min_curv = mris->Kmin ;
  mris->max_curv = mris->Kmax ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  int MRISuseMeanCurvature(MRI_SURFACE *mris)
  Set vertex->curv = vertex->H ;
  ------------------------------------------------------*/
int MRISuseMeanCurvature(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *vertex ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    vertex->curv = vertex->H ;
  }

  mris->min_curv = mris->Hmin ;
  mris->max_curv = mris->Hmax ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISusePrincipalCurvature(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *vertex ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    vertex->curv = vertex->k1 ;
  }

  mris->min_curv = mris->Hmin ;
  mris->max_curv = mris->Hmax ;
  return(NO_ERROR) ;
}

int
MRISuseK1Curvature(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *vertex ;

  float  f_min =  mris->vertices[0].curv;
  float  f_max = f_min;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    vertex->curv = vertex->k1 ;
    if (vertex->curv < f_min)
    {
      f_min = vertex->curv;
    }
    if (vertex->curv > f_max)
    {
      f_max = vertex->curv;
    }
  }

  mris->min_curv = f_min ;
  mris->max_curv = f_max;
  return(NO_ERROR) ;
}

int
MRISuseK2Curvature(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *vertex ;

  float  f_min =  mris->vertices[0].curv;
  float  f_max = f_min;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    vertex->curv = vertex->k2 ;
    if (vertex->curv < f_min)
    {
      f_min = vertex->curv;
    }
    if (vertex->curv > f_max)
    {
      f_max = vertex->curv;
    }
  }

  mris->min_curv = f_min ;
  mris->max_curv = f_max;
  return(NO_ERROR) ;
}

int
MRISusePrincipalCurvatureFunction(
  MRI_SURFACE*    pmris,
  float       (*f)(float k1, float k2))
{
  //
  // PRECONDITIONS
  //  o The principal curvatures k1 and k2 for each vertex point on the
  //    surface have been defined.
  //
  // POSTCONDITIONS
  //  o Each vertex 'curv' value is replaced with the result from the
  //    the (*f)(k1, k2) function.
  //  o Surface min and max values are set appropriately.
  //

  int     vno ;
  VERTEX* pvertex ;
  float   f_k1;
  float   f_k2;

  float   f_min           =  pmris->vertices[0].curv;
  float   f_max           = f_min;

  for (vno = 0 ; vno < pmris->nvertices ; vno++)
  {
    pvertex = &pmris->vertices[vno] ;
    if (pvertex->ripflag)
    {
      continue ;
    }
    f_k1    = pvertex->k1;
    f_k2    = pvertex->k2;
    pvertex->curv   = (*f)(f_k1, f_k2);
    if (pvertex->curv < f_min)
    {
      f_min = pvertex->curv;
    }
    if (pvertex->curv > f_max)
    {
      f_max = pvertex->curv;
    }
  }

  pmris->min_curv = f_min ;
  pmris->max_curv = f_max;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Compute the folding (FI) and intrinsic curvature (ICI)
  indices of the surface.

  Drury and Van Essen:  ICI = 56  (lh) and 54  (rh)
  FI = 500 (lh) and 520 (rh)
  ------------------------------------------------------*/
int
MRIScomputeCurvatureIndices(MRI_SURFACE *mris, double *pici, double *pfi)
{
  int    vno ;
  VERTEX *vertex ;
  double k1, k2, ici, fi, area, Kmax, Kmin ;

  ici = fi = 0.0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    k1 = (double)vertex->k1 ;
    k2 = (double)vertex->k2 ;
    area = (double)vertex->area ;
    if (vertex->K > 0)
    {
      ici += area * (double)vertex->K ;
    }
    Kmax = (double)fabs(k1) ;
    Kmin = (double)fabs(k2) ;
    fi += area * Kmax * (Kmax - Kmin) ;
  }

  *pfi = fi / (4.0*M_PI) ;
  *pici = ici / (4.0 * M_PI) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRISmaxRadius(MRI_SURFACE *mris)
{
  double  radius ;
  int    vno, n ;
  VERTEX *vertex ;
  double x, y, z, xlo, ylo, zlo, xhi, yhi, zhi, x0, y0, z0, r ;

  xhi=yhi=zhi= -10000;
  xlo=ylo=zlo= 10000;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
#if 0
    if (vertex->ripflag)
    {
      continue ;
    }
#endif
    x = (double)vertex->x ;
    y = (double)vertex->y ;
    z = (double)vertex->z ;
    if (x>xhi)
    {
      xhi=x;
    }
    if (x<xlo)
    {
      xlo=x;
    }
    if (y>yhi)
    {
      yhi=y;
    }
    if (y<ylo)
    {
      ylo=y;
    }
    if (z>zhi)
    {
      zhi=z;
    }
    if (z<zlo)
    {
      zlo=z;
    }
  }
  mris->xhi = xhi ;
  mris->xlo = xlo ;
  mris->yhi = yhi ;
  mris->ylo = ylo ;
  mris->zhi = zhi ;
  mris->zlo = zlo ;
  x0 = (xlo+xhi)/2.0f ;
  y0 = (ylo+yhi)/2.0f ;
  z0 = (zlo+zhi)/2.0f ;
  for (radius = 0.0, n = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
#if 0
    if (vertex->ripflag)
    {
      continue ;
    }
#endif
    n++ ;
    x = (double)vertex->x-x0 ;
    y = (double)vertex->y-y0 ;
    z = (double)vertex->z-z0 ;
    r = sqrt(x*x + y*y + z*z) ;
    if (r > radius)
    {
      radius = r ;
    }
  }

  return(radius) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeSurfaceDimensions(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *vertex ;
  double x, y, z, xlo, ylo, zlo, xhi, yhi, zhi ;

  xhi=yhi=zhi= -10000;
  xlo=ylo=zlo= 10000;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
#if 0
    if (vertex->ripflag)
    {
      continue ;
    }
#endif
    x = (double)vertex->x ;
    y = (double)vertex->y ;
    z = (double)vertex->z ;
    if (x>xhi)
    {
      xhi=x;
    }
    if (x<xlo)
    {
      xlo=x;
    }
    if (y>yhi)
    {
      yhi=y;
    }
    if (y<ylo)
    {
      ylo=y;
    }
    if (z>zhi)
    {
      zhi=z;
    }
    if (z<zlo)
    {
      zlo=z;
    }
  }
  mris->xlo = xlo ;
  mris->xhi = xhi ;
  mris->ylo = ylo ;
  mris->yhi = yhi ;
  mris->zlo = zlo ;
  mris->zhi = zhi ;
  mris->xctr = (xlo+xhi)/2.0f ;
  mris->yctr = (ylo+yhi)/2.0f ;
  mris->zctr = (zlo+zhi)/2.0f ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRISaverageRadius(MRI_SURFACE *mris)
{
  double  radius ;
  int    vno, n ;
  VERTEX *vertex ;
  double x, y, z, xlo, ylo, zlo, xhi, yhi, zhi, x0, y0, z0 ;

  xhi=yhi=zhi= -10000;
  xlo=ylo=zlo= 10000;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
#if 0
    if (vertex->ripflag)
    {
      continue ;
    }
#endif
    x = (double)vertex->x ;
    y = (double)vertex->y ;
    z = (double)vertex->z ;
    if (x>xhi)
    {
      xhi=x;
    }
    if (x<xlo)
    {
      xlo=x;
    }
    if (y>yhi)
    {
      yhi=y;
    }
    if (y<ylo)
    {
      ylo=y;
    }
    if (z>zhi)
    {
      zhi=z;
    }
    if (z<zlo)
    {
      zlo=z;
    }
    if (zlo < -1000)
    {
      DiagBreak() ;
    }
  }
  x0 = (xlo+xhi)/2.0f ;
  y0 = (ylo+yhi)/2.0f ;
  z0 = (zlo+zhi)/2.0f ;
  for (radius = 0.0, n = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
#if 0
    if (vertex->ripflag)
    {
      continue ;
    }
#endif
    n++ ;
    x = (double)vertex->x-x0 ;
    y = (double)vertex->y-y0 ;
    z = (double)vertex->z-z0 ;
    radius += sqrt(x*x + y*y + z*z) ;
  }

  radius /= (double)n ;
  return(radius) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Descripton
  ------------------------------------------------------*/
double
MRISaverageCanonicalRadius(MRI_SURFACE *mris)
{
  double  radius ;
  int    vno, n ;
  VERTEX *vertex ;
  double x, y, z, xlo, ylo, zlo, xhi, yhi, zhi, x0, y0, z0 ;

  xhi=yhi=zhi= -10000;
  xlo=ylo=zlo= 10000;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
#if 0
    if (vertex->ripflag)
    {
      continue ;
    }
#endif
    x = (double)vertex->cx ;
    y = (double)vertex->cy ;
    z = (double)vertex->cz ;
    if (x>xhi)
    {
      xhi=x;
    }
    if (x<xlo)
    {
      xlo=x;
    }
    if (y>yhi)
    {
      yhi=y;
    }
    if (y<ylo)
    {
      ylo=y;
    }
    if (z>zhi)
    {
      zhi=z;
    }
    if (z<zlo)
    {
      zlo=z;
    }
  }
  x0 = (xlo+xhi)/2.0f ;
  y0 = (ylo+yhi)/2.0f ;
  z0 = (zlo+zhi)/2.0f ;
  for (radius = 0.0, n = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
#if 0
    if (vertex->ripflag)
    {
      continue ;
    }
#endif
    n++ ;
    x = (double)vertex->cx-x0 ;
    y = (double)vertex->cy-y0 ;
    z = (double)vertex->cz-z0 ;
    radius += sqrt(x*x + y*y + z*z) ;
  }

  radius /= (double)n ;
  return(radius) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISinflateBrain(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int     n_averages, n, write_iterations, niterations ;
  double  delta_t = 0.0, rms_height, desired_rms_height, sse, l_dist ;

  write_iterations = parms->write_iterations ;

  if (IS_QUADRANGULAR(mris))
  {
    MRISremoveTriangleLinks(mris) ;
  }
  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    sprintf(fname, "%s.out", parms->base_name) ;
    if (!parms->start_t)
    {
      parms->fp = fopen(fname, "w") ;
    }
    else
    {
      parms->fp = fopen(fname, "a") ;
    }
    if (!parms->fp)
      ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                Progname, fname) ;
    mrisLogIntegrationParms(parms->fp, mris, parms) ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogIntegrationParms(stderr, mris, parms) ;
  }

  MRIScomputeMetricProperties(mris) ;
  niterations = parms->niterations ;
  rms_height = MRISrmsTPHeight(mris) ;
  desired_rms_height = parms->desired_rms_height ;
  //fprintf(stdout, "inflating to desired rms height = %2.3f\n",
  // desired_rms_height);

  /* write out initial surface */
  if (!parms->start_t && (parms->write_iterations > 0) && (Gdiag&DIAG_WRITE))
  {
    mrisWriteSnapshot(mris, parms, 0) ;
  }

  sse = MRIScomputeSSE(mris, parms) ;
  if (!parms->start_t)
  {
    if (Gdiag & DIAG_SHOW)
      fprintf(stdout,"%3.3d: dt: %2.4f, rms height=%2.3f, avgs=%d\n",
              0, 0.0f, (float)rms_height, parms->n_averages) ;
    else
      fprintf(stdout, "\rstep %3.3d: RMS=%2.3f (target=%2.3f)   ", 0,
              rms_height, desired_rms_height);
    if (Gdiag & DIAG_WRITE)
    {
      fprintf(parms->fp,
              "%3.3d: dt: %2.4f, rms height=%2.3f, avgs=%d\n",
              0, 0.0f, (float)rms_height, parms->n_averages) ;
      fflush(parms->fp) ;
    }

    MRISclearCurvature(mris) ;  /* curvature will be used to
                          calculate sulc */
  }

  l_dist = parms->l_dist ;
  for (n_averages = parms->n_averages ; n_averages >= 0 ; n_averages /= 2)
  {
    parms->l_dist = l_dist * sqrt(n_averages) ;
    for (n = parms->start_t ; n < parms->start_t+niterations ; n++)
    {
      MRISclearGradient(mris) ;
      mrisComputeDistanceTerm(mris, parms) ;
      mrisComputeSphereTerm(mris, parms->l_sphere, parms->a) ;
      mrisComputeExpansionTerm(mris, parms->l_expand) ;

      MRISaverageGradients(mris, n_averages) ;
      mrisComputeNormalSpringTerm(mris, parms->l_nspring) ;
      mrisComputeNonlinearSpringTerm(mris, parms->l_nlspring, parms) ;
      mrisComputeTangentialSpringTerm(mris, parms->l_tspring) ;
      mrisComputeNonlinearTangentialSpringTerm(mris,
                                               parms->l_nltspring,
                                               parms->min_dist) ;
      mrisComputeQuadraticCurvatureTerm(mris, parms->l_curv) ;
      mrisComputeSpringTerm(mris, parms->l_spring) ;
      mrisComputeLaplacianTerm(mris, parms->l_lap) ;
      mrisComputeNormalizedSpringTerm(mris, parms->l_spring_norm) ;
      switch (parms->integration_type)
      {
      case INTEGRATE_LM_SEARCH:
        delta_t = mrisLineMinimizeSearch(mris, parms) ;
        break ;
      default:
      case INTEGRATE_LINE_MINIMIZE:
        delta_t = mrisLineMinimize(mris, parms) ;
        break ;
      case INTEGRATE_MOMENTUM:
        delta_t = MRISmomentumTimeStep
                  (mris, parms->momentum, parms->dt,
                   parms->tol, 0/*parms->n_averages*/) ;
        break ;
      case INTEGRATE_ADAPTIVE:
        mrisAdaptiveTimeStep(mris, parms);
        break ;
      }
      mrisTrackTotalDistance(mris) ;  /* update sulc */
      MRIScomputeMetricProperties(mris) ;
      sse = MRIScomputeSSE(mris, parms) ;
      rms_height = MRISrmsTPHeight(mris) ;
      if (!((n+1) % 5))     /* print some diagnostics */
      {
        if (Gdiag & DIAG_SHOW)
          fprintf
          (stdout,
           "%3.3d: dt: %2.4f, "
           "rms height=%2.3f, avgs=%d, l_dist=%2.2f\n",
           n+1,(float)delta_t, (float)rms_height, n_averages,
           parms->l_dist);
        else
          fprintf(stdout, "\rstep %3.3d: RMS=%2.3f (target=%2.3f)   ",
                  n+1, rms_height, desired_rms_height) ;
        if (Gdiag & DIAG_WRITE)
        {
          fprintf(parms->fp,
                  "%3.3d: dt: %2.4f, rms height=%2.3f, "
                  "avgs=%d, l_dist=%2.2f\n",
                  n+1,(float)delta_t, (float)rms_height, n_averages,
                  parms->l_dist);
          fflush(parms->fp) ;
        }
      }

      if (parms->scale > 0)
      {
        MRIScomputeMetricProperties(mris) ;
        printf("rescaling brain to retain original "
               "surface area %2.0f (%2.2f)\n",
               mris->orig_area,
               sqrt(mris->orig_area / (mris->total_area+mris->neg_area))) ;
        MRISscaleBrainArea(mris) ;
      }
      if ((parms->write_iterations > 0) &&
          !((n+1)%write_iterations)&&(Gdiag&DIAG_WRITE))
      {
        mrisWriteSnapshot(mris, parms, n+1) ;
      }
      if (rms_height < desired_rms_height)
      {
        break ;
      }
    }

    parms->start_t = n ;
    if (!n_averages || rms_height < desired_rms_height)
    {
      break ;
    }
  }

  fprintf(stdout, "\ninflation complete.\n") ;
  if (Gdiag & DIAG_WRITE)
  {
    fclose(parms->fp) ;
    parms->fp = NULL ;
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISinflateToSphere(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int     n_averages, n, write_iterations, niterations, base_averages ;
  double  delta_t = 0.0, rms_radial_error, sse, base_dt ;
  MHT     *mht_v_current = NULL ;

  if (IS_QUADRANGULAR(mris))
  {
    MRISremoveTriangleLinks(mris) ;
  }
  write_iterations = parms->write_iterations ;
  n_averages = parms->n_averages ;

#if 1
  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    sprintf(fname, "%s.%s.out",
            mris->hemisphere == RIGHT_HEMISPHERE ? "rh" : "lh",
            parms->base_name);
    if (!parms->fp)
    {
      if (!parms->start_t)
      {
        parms->fp = fopen(fname, "w") ;
      }
      else
      {
        parms->fp = fopen(fname, "a") ;
      }

      if (!parms->fp)
        ErrorExit(ERROR_NOFILE, "MRISunfold: could not open log file %s\n",
                  fname) ;
    }
    mrisLogIntegrationParms(parms->fp, mris,parms) ;
  }
#else
  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    sprintf(fname, "%s.out", parms->base_name) ;
    if (!parms->start_t)
    {
      parms->fp = fopen(fname, "w") ;
    }
    else
    {
      parms->fp = fopen(fname, "a") ;
    }
    if (!parms->fp)
      ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                Progname, fname) ;
    mrisLogIntegrationParms(parms->fp, mris, parms) ;
  }
#endif
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogIntegrationParms(stderr, mris, parms) ;
  }

  MRIScomputeMetricProperties(mris) ;
#if 0
  MRIScomputeSecondFundamentalForm(mris) ;
#endif
  /*  parms->start_t = 0 ;*/
  niterations = parms->niterations ;
  MRISstoreMetricProperties(mris) ;
  rms_radial_error =
    sqrt(mrisComputeSphereError(mris, 1.0, parms->a)/mris->nvertices);
  fprintf(stdout, "inflating to sphere (rms error < %2.2f)\n",
          parms->tol*parms->a / 100.0f) ;

  /* write out initial surface */
  if (!parms->start_t && (parms->write_iterations > 0) && (Gdiag&DIAG_WRITE))
  {
    mrisWriteSnapshot(mris, parms, 0) ;
  }

  sse = MRIScomputeSSE(mris, parms) ;
  if (!parms->start_t)
  {
    fprintf(stdout,"%3.3d: dt: %2.4f, rms radial error=%2.3f, avgs=%d\n",
            0, 0.0f, (float)rms_radial_error, n_averages) ;
    if (Gdiag & DIAG_WRITE)
    {
      fprintf(parms->fp,
              "%3.3d: dt: %2.4f, rms radial error=%2.3f, avgs=%d\n",
              0, 0.0f, rms_radial_error, n_averages) ;
      fflush(parms->fp) ;
    }

    MRISclearCurvature(mris) ;   /* curvature will be used to
                          calculate sulc */
  }

  base_averages = parms->n_averages ;
  base_dt = parms->dt ;
  for (n_averages = base_averages ; n_averages >= 0 ; n_averages /= 4)
  {
    parms->n_averages = n_averages ;
    parms->dt = (sqrt((float)n_averages)+1)*base_dt ;
    for (n = parms->start_t ; n < parms->start_t+niterations ; n++)
    {
      if (!FZERO(parms->l_repulse_ratio))
        mht_v_current =
          MHTfillVertexTableRes(mris,mht_v_current,CURRENT_VERTICES, 3.0f);
      MRISclearGradient(mris) ;
      mrisComputeDistanceTerm(mris, parms) ;
      mrisComputeSphereTerm(mris, parms->l_sphere, parms->a) ;
      mrisComputeExpansionTerm(mris, parms->l_expand) ;
      mrisComputeRepulsiveRatioTerm(mris,parms->l_repulse_ratio,
                                    mht_v_current);
      mrisComputeConvexityTerm(mris, parms->l_convex) ;

      mrisComputeLaplacianTerm(mris, parms->l_lap) ;
      mrisComputeNonlinearSpringTerm(mris, parms->l_nlspring, parms) ;
      mrisComputeTangentialSpringTerm(mris, parms->l_tspring) ;
      mrisComputeNonlinearTangentialSpringTerm(mris,
                                               parms->l_nltspring,
                                               parms->min_dist) ;
      MRISaverageGradients(mris, n_averages) ;
      mrisComputeSpringTerm(mris, parms->l_spring) ;
      mrisComputeNormalizedSpringTerm(mris, parms->l_spring_norm) ;
      switch (parms->integration_type)
      {
      case INTEGRATE_LM_SEARCH:
        delta_t = mrisLineMinimizeSearch(mris, parms) ;
        break ;
      default:
      case INTEGRATE_LINE_MINIMIZE:
        delta_t = mrisLineMinimize(mris, parms) ;
        break ;
      case INTEGRATE_MOMENTUM:
        delta_t = MRISmomentumTimeStep
                  (mris, parms->momentum, parms->dt,
                   parms->tol, 0/*parms->n_averages*/) ;
        break ;
      case INTEGRATE_ADAPTIVE:
        mrisAdaptiveTimeStep(mris, parms);
        break ;
      }
      mrisTrackTotalDistance(mris) ;  /* update sulc */
      MRIScomputeMetricProperties(mris) ;
      sse = MRIScomputeSSE(mris, parms) ;
      rms_radial_error =
        sqrt(mrisComputeSphereError(mris, 1.0, parms->a)/mris->nvertices);
      if (!((n+1) % 5))     /* print some diagnostics */
      {
        fprintf(stdout,
                "%3.3d/%d: dt: %2.4f, rms radial error=%2.3f, avgs=%d\n",
                n+1, parms->start_t+niterations, (float)delta_t,
                (float)rms_radial_error, n_averages);
        if (Gdiag & DIAG_WRITE)
        {
          fprintf(parms->fp,
                  "%3.3d: dt: %2.4f, rms radial error=%2.3f, "
                  "avgs=%d\n",
                  n+1,(float)delta_t,
                  (float)rms_radial_error, n_averages);
          fflush(parms->fp) ;
        }
      }

      if ((parms->write_iterations > 0) &&
          !((n+1)%write_iterations)&&(Gdiag&DIAG_WRITE))
      {
        mrisWriteSnapshot(mris, parms, n+1) ;
      }
      if (100.0*rms_radial_error/parms->a < parms->tol)
      {
        break ;
      }
    }
    parms->start_t = n ;
    if (!n_averages || (100.0*rms_radial_error/parms->a < parms->tol))
    {
      break ;
    }
    printf("reducing # of averages to %d\n", n_averages/4) ;
  }

  fprintf(stdout, "\nspherical inflation complete.\n") ;
  if (Gdiag & DIAG_WRITE)
  {
    fclose(parms->fp) ;
    parms->fp = NULL ;
  }
  if (!FZERO(parms->l_repulse))
  {
    MHTfree(&mht_v_current) ;
  }

  return(NO_ERROR) ;
}

/* project onto the sphere of radius DEFAULT_RADIUS */
static void sphericalProjection(float xs, float ys , float zs,
                                float *xd,float *yd,float *zd)
{
  double dist,lambda;

  dist=sqrt(SQR(xs)+SQR(ys)+SQR(zs));
  lambda=DEFAULT_RADIUS/dist;

  /* making sure things are stable : double projection */
  *xd = xs * lambda;
  *yd = ys * lambda;
  *zd = zs * lambda;

  xs = *xd ;
  ys = *yd;
  zs = *zd;
  dist=sqrt(SQR(xs)+SQR(ys)+SQR(zs));
  lambda=DEFAULT_RADIUS/dist;

  *xd = xs * lambda;
  *yd = ys * lambda;
  *zd = zs * lambda;
}

int MRISsmoothOnSphere(MRIS *mris, int niters)
{
  int n,p;
  float x,y,z;
  VERTEX *v,*vp;

  while (niters--)
  {

    for (n =  0 ; n < mris->nvertices ; n++)
    {
      v=&mris->vertices[n];

      x=y=z=0.0f;

      for ( p = 0 ; p < v->vnum ; p++)
      {
        vp = &mris->vertices[v->v[p]];
        x += vp->x;
        y += vp->y;
        z += vp->z;
      }
      if (v->vnum == 0)
      {
        v->tx = v->x;
        v->ty = v->y;
        v->tz = v->z;
        DiagBreak() ;
      }
      else
      {
        v->tx = x/v->vnum;
        v->ty = y/v->vnum;
        v->tz = z/v->vnum;
      }
      if (!finite(v->tx))
      {
        DiagBreak() ;
      }
    }

    for (n =  0 ; n < mris->nvertices ; n++)
    {
      v=&mris->vertices[n];
      sphericalProjection(v->tx,v->ty,v->tz,&v->x,&v->y,&v->z);
      if (!finite(v->x))
      {
        DiagBreak() ;
      }
    }
  }

  return NO_ERROR;
}


static int mrisSphericalProjection(MRIS *mris)
{
  int n;
  VERTEX *v;
  //    fprintf(stderr,"spherical projection\n");
  for ( n = 0 ; n < mris->nvertices ; n++)
  {
    v=&mris->vertices[n];
    if (v->ripflag)
    {
      continue;
    }

    /*
      if(n == 88 )
      fprintf(stderr,"bf sp: vertex %d (%f,%f,%f)\n",n,v->x,v->y,v->z);
      if(n == 89 )
      fprintf(stderr,"bf sp: vertex %d (%f,%f,%f)\n",n,v->x,v->y,v->z);
      if(n == 209 )
      fprintf(stderr,"bf sp: nvertex %d (%f,%f,%f)\n",n,v->x,v->y,v->z);
    */

    sphericalProjection(v->x,v->y,v->z,&v->x,&v->y,&v->z);
    v->cx = v->x;
    v->cy = v->y ;
    v->cz = v->z;

    /*
      if(n == 88 )
      fprintf(stderr,"af sp: vertex %d (%f,%f,%f)\n",n,v->x,v->y,v->z);
      if(n == 89 )
      fprintf(stderr,"af sp: vertex %d (%f,%f,%f)\n",n,v->x,v->y,v->z);
      if(n == 209 )
      fprintf(stderr,"af sp: nvertex %d (%f,%f,%f)\n",n,v->x,v->y,v->z);

      sphericalProjection(v->x,v->y,v->z,&v->x,&v->y,&v->z);

      if(n == 88 )
      fprintf(stderr,"af 2 sp: vertex %d (%f,%f,%f)\n",n,v->x,v->y,v->z);
      if(n == 89 )
      fprintf(stderr,"af 2 sp: vertex %d (%f,%f,%f)\n",n,v->x,v->y,v->z);
      if(n == 209 )
      fprintf(stderr,"af 2 sp: nvertex %d (%f,%f,%f)\n",n,v->x,v->y,v->z);
    */

  }
  return NO_ERROR;
}


static float computeArea(MRIS *mris, int fac,int n)
{
  int n0,n1;
  face_type *f;
  float v0[3],v1[3],d1,d2,d3,dot,area;

  n0 = (n == 0)                   ? VERTICES_PER_FACE-1 : n-1;
  n1 = (n == VERTICES_PER_FACE-1) ? 0                   : n+1;

  f = &mris->faces[fac];

  v0[0] = mris->vertices[f->v[n]].x - mris->vertices[f->v[n0]].x;
  v0[1] = mris->vertices[f->v[n]].y - mris->vertices[f->v[n0]].y;
  v0[2] = mris->vertices[f->v[n]].z - mris->vertices[f->v[n0]].z;

  v1[0] = mris->vertices[f->v[n1]].x - mris->vertices[f->v[n]].x;
  v1[1] = mris->vertices[f->v[n1]].y - mris->vertices[f->v[n]].y;
  v1[2] = mris->vertices[f->v[n1]].z - mris->vertices[f->v[n]].z;

  d1 = -v1[1]*v0[2] + v0[1]*v1[2];
  d2 = v1[0]*v0[2] - v0[0]*v1[2];
  d3 = -v1[0]*v0[1] + v0[0]*v1[1];

  dot =  mris->vertices[f->v[n]].x * d1
         + mris->vertices[f->v[n]].y * d2
         + mris->vertices[f->v[n]].z * d3 ;

  if (dot < 0.0f)   /* not in same direction, area < 0 and reverse n */
  {
    area=-sqrt(d1*d1+d2*d2+d3*d3);
  }
  else
  {
    area=sqrt(d1*d1+d2*d2+d3*d3);
  }

  return area;
}


/* preserve the topology of the deformation field
   this constraint is too strong - useless!
*/
int mrisApplyGradientPositiveAreaPreserving(MRI_SURFACE *mris, double dt)
{
  int     vno, nvertices , n ;
  VERTEX  *v;
  float x,y,z,dx,dy,dz;
  float orig_area,area;

  int last_step = 5;
  float epsilon[6]= {1.0,0.8,0.6,0.4,0.2,0.0},eps;
  int step ;

  int count;
  float neg_area;

  nvertices = mris->nvertices ;
  MRISstoreCurrentPositions(mris) ;

  neg_area=0.0;
  count=0;
  for (n = 0 ; n < mris->nfaces ; n++)
  {
    orig_area = computeArea(mris,n,0);
    if (orig_area<=0)
    {
      count++;
      neg_area+=orig_area;
    }
  }

  fprintf(stderr,"before : neg = %d - area = %f \n",count,neg_area);

  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    if (!finite(v->x) || !finite(v->y) || !finite(v->z))
    {
      ErrorPrintf(ERROR_BADPARM, "vertex %d position is not finite!\n",vno) ;
    }
    if (!finite(v->dx) || !finite(v->dy) || !finite(v->dz))
    {
      ErrorPrintf(ERROR_BADPARM, "vertex %d position is not finite!\n",vno) ;
    }

    dx = dt*v->dx;
    dy = dt*v->dy;
    dz = dt*v->dz;
    x = v->x;
    y = v->y;
    z = v->z;

    step=0;
    /* preserve triangle area */
    for ( n = 0 ; n < v->num && step < last_step ; n++)
    {
      sphericalProjection(x,y,z,&v->x,&v->y,&v->z);
      orig_area = computeArea(mris,v->f[n],(int)v->n[n]);
      if (orig_area <= 0)
      {
        continue;
      }
      while (step<last_step)
      {
        eps=epsilon[step];
        sphericalProjection(x+eps*dx,y+eps*dy,z+eps*dz,&v->x,&v->y,&v->z);
        area = computeArea(mris,v->f[n],(int)v->n[n]);
        if (area > 0)
        {
          break;  /* we can stop here */
        }
        step++;
      }
    }

    eps=epsilon[step];
    sphericalProjection(x+eps*dx,y+eps*dy,z+eps*dz,&v->x,&v->y,&v->z);
  }

  neg_area=0.0;
  count=0;
  for (n = 0 ; n < mris->nfaces ; n++)
  {
    orig_area = computeArea(mris,n,0);
    if (orig_area<=0)
    {
      count++;
      neg_area+=orig_area;
    }
  }
  fprintf(stderr,"after : neg = %d - area = %f \n",count,neg_area);

  return(NO_ERROR) ;
}

/* to be implemented
   constrain the gradient triangle by triangle
   but do not ensure that the final gradient is topology preserving
*/
int mrisApplyGradientPositiveAreaMaximizing(MRI_SURFACE *mris, double dt)
{
  return mrisApplyGradientPositiveAreaPreserving(mris, dt);
}

int
MRISapplyGradient(MRI_SURFACE *mris, double dt)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  MRISstoreCurrentPositions(mris) ;
  if (mris->status == MRIS_RIGID_BODY)
  {
    MRISrotate(mris, mris, dt*mris->alpha, dt*mris->beta, dt*mris->gamma) ;
  }
  else
    for (vno = 0 ; vno < nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      if (!finite(v->x) || !finite(v->y) || !finite(v->z))
        ErrorPrintf(ERROR_BADPARM,
                    "vertex %d position is not finite!\n",vno) ;
      if (!finite(v->dx) || !finite(v->dy) || !finite(v->dz))
        ErrorPrintf(ERROR_BADPARM,
                    "vertex %d position is not finite!\n",vno) ;
      v->x += dt*v->dx ;
      v->y += dt*v->dy;
      v->z += dt*v->dz;
    }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisClearDistances(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->d = 0 ;
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISclearGradient(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->dx = 0 ;
    v->dy = 0 ;
    v->dz = 0 ;
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisClearExtraGradient(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (mris->dx2)
    {
      mris->dx2[vno] = mris->dy2[vno] = mris->dz2[vno] = 0 ;
    }
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisClearMomentum(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->odx = 0 ;
    v->ody = 0 ;
    v->odz = 0 ;
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRIStotalVariationDifference(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;
  double  var, delta ;

  nvertices = mris->nvertices ;
  for (var = 0.0, vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    delta = fabs(v->k1 - v->k2) ;
    delta *= delta ;
    var += v->area * delta ;
    if (!finite(var))
      ErrorPrintf(ERROR_BADPARM, "curvature at vertex %d is not finite!\n",
                  vno) ;
  }
  return(var) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRIStotalVariation(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;
  double  var, delta ;

  nvertices = mris->nvertices ;
  for (var = 0.0, vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    delta = v->k1 * v->k1 + v->k2 * v->k2 ;
    var += v->area * delta ;
    if (!finite(var))
      ErrorPrintf(ERROR_BADPARM, "curvature at vertex %d is not finite!\n",
                  vno) ;
  }
  return(var) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRIScurvatureError(MRI_SURFACE *mris, double Kd)
{
  int     vno, nvertices, n ;
  VERTEX  *v ;
  double  Kerror, deltaK ;

  nvertices = mris->nvertices ;
  for (Kerror = 0.0, n = vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    deltaK = (v->k1-Kd) ;
    deltaK *= deltaK ;
    Kerror += v->area * deltaK ;
    n++;
    deltaK = (v->k2-Kd) ;
    deltaK *= deltaK ;
    Kerror += v->area * deltaK ;
    n++ ;
  }
  /*  return(sqrt(Kerror/(double)n)) ;*/
  return(Kerror) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISrestoreOldPositions(MRI_SURFACE *mris)
{
#if 1
  return(MRISrestoreVertexPositions(mris, TMP_VERTICES)) ;
#else
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->x = v->ox ;
    v->y = v->oy ;
    v->z = v->oz ;
  }


  return(NO_ERROR) ;
#endif
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISstoreCurrentPositions(MRI_SURFACE *mris)
{
#if 1
  return(MRISsaveVertexPositions(mris, TMP_VERTICES)) ;
#else
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->ox = v->x ;
    v->oy = v->y ;
    v->oz = v->z ;
  }
  return(NO_ERROR) ;
#endif
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
static int
mrisStoreCurrentGradient(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->odx = v->dx ;
    v->ody = v->dy ;
    v->odz = v->dz ;
  }
  return(NO_ERROR) ;
}
#endif


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISstoreMeanCurvature(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->H = v->curv ;
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISstoreMetricProperties(MRI_SURFACE *mris)
{
  int     vno, nvertices, fno, ano, n ;
  VERTEX  *v ;
  FACE    *f ;

#if 0
  MRIScomputeNormals(mris);              /* update vertex areas */
  MRIScomputeTriangleProperties(mris) ;  /* update triangle properties */
#endif
  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->origarea = v->area ;
#if 1
    if (v->dist && v->dist_orig)
      for (n = 0 ; n < v->vtotal ; n++)
      {
        v->dist_orig[n] = v->dist[n] ;
      }
#endif
  }
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    if (f->ripflag)
    {
      continue ;
    }
    f->orig_area = f->area ;
    for (ano = 0 ; ano < ANGLES_PER_TRIANGLE ; ano++)
    {
      f->orig_angle[ano] = f->angle[ano] ;
    }
  }
  mris->orig_area = mris->total_area ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISrestoreMetricProperties(MRI_SURFACE *mris)
{
  int     vno, nvertices, fno, ano, n ;
  VERTEX  *v ;
  FACE    *f ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->area = v->origarea ;
    for (n = 0 ; n < v->vtotal ; n++)
    {
      v->dist[n] = v->dist_orig[n] ;
    }
  }
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    if (f->ripflag)
    {
      continue ;
    }
    f->area = f->orig_area ;
    for (ano = 0 ; ano < ANGLES_PER_TRIANGLE ; ano++)
    {
      f->angle[ano] = f->orig_angle[ano] ;
    }
  }
  mris->total_area = mris->orig_area ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISvalidVertices(MRI_SURFACE *mris)
{
  int vno, nvertices, nvalid ;

  nvertices = mris->nvertices ;
  for (vno = nvalid = 0 ; vno < nvertices ; vno++)
    if (!mris->vertices[vno].ripflag)
    {
      nvalid++ ;
    }

  return(nvalid) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISmarkedVertices(MRI_SURFACE *mris)
{
  int vno, nvertices, nmarked ;

  nvertices = mris->nvertices ;
  for (vno = nmarked = 0 ; vno < nvertices ; vno++)
    if (!mris->vertices[vno].ripflag && mris->vertices[vno].marked > 0)
    {
      nmarked++ ;
    }

  return(nmarked) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisValidFaces(MRI_SURFACE *mris)
{
  int fno, nfaces, nvalid ;

  nfaces = mris->nfaces ;
  for (fno = nvalid = 0 ; fno < nfaces ; fno++)
    if (!mris->faces[fno].ripflag)
    {
      nvalid++ ;
    }

  return(nvalid) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  File Format is:

  name x y z
  ------------------------------------------------------*/
int
MRISreadTetherFile(MRI_SURFACE *mris, const char *fname, float radius)
{
  int    l ;
  float  cx, cy, cz ;
  FILE   *fp ;
  char   line[STRLEN], *cp ;

  fp = fopen(fname, "r") ;
  if (!fp)
    ErrorReturn(ERROR_NOFILE, (ERROR_NOFILE,
                               "MRISreadTetherFile(%s): could not open file",
                               fname)) ;

  /* first count # of labels in file */
  mris->nlabels = 0 ;
  while ((cp = fgetl(line, 199, fp)) != NULL)
  {
    mris->nlabels++ ;
  }
  mris->labels =
    (MRIS_AREA_LABEL *)calloc(mris->nlabels, sizeof(MRIS_AREA_LABEL)) ;
  if (!mris->labels)
    ErrorExit(ERROR_NOMEMORY,
              "MRISreadTetherFile: could not allocate %d labels",
              mris->nlabels) ;

  for (l = 0 ; l < mris->nlabels ; l++)
  {
    cp = fgetl(line, 199, fp) ;
    if (!sscanf(cp, "%s %f %f %f", mris->labels[l].name,&cx, &cy, &cz) != 4)
    {
      fclose(fp) ;
      ErrorReturn(ERROR_BADFILE,
                  (ERROR_BADFILE,
                   "MRISreadTetherFile(%s): could not scan parms from %s",
                   fname, line)) ;
    }
    mris->labels[l].cx = cx;
    mris->labels[l].cy = cy;
    mris->labels[l].cz = cz;
    mrisLabelVertices(mris, cx, cy, cz, l, radius) ;
  }

  fclose(fp) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  File Format is:

  name x y z
  ------------------------------------------------------*/
static int
mrisLabelVertices(MRI_SURFACE *mris, float cx, float cy, float cz, int label,
                  float radius)
{
  VERTEX *v ;
  float  xd, yd, zd, d ;
  int    vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    xd = cx - v->x ;
    yd = cy - v->y ;
    zd = cz - v->z ;
    d = sqrt(xd*xd + yd*yd + zd*zd) ;
#if 0
    if (d <= radius)
    {
      v->label = label ;
    }
#endif
  }

  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  File Format is:

  name x y z
  ------------------------------------------------------*/
#define K_A         0.4f
static float kernel[] =
{
  K_A, 0.25f, 0.25f-K_A/2.0f
} ;
int
MRISsmoothCurvatures(MRI_SURFACE *mris, int niterations)
{
  int     vno, i, vn ;
  double  g, H, norm ;
  VERTEX  *vertex ;

  for (i = 0 ; i < niterations ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      vertex = &mris->vertices[vno] ;
      if (vertex->ripflag)
      {
        continue ;
      }
      H = kernel[0]*vertex->H ;
      g = kernel[1] ;
      for (vn = 0 ; vn < vertex->vnum ; vn++)
      {
        H += g * mris->vertices[vertex->v[vn]].H ;
      }
      g = kernel[2] ;
      for ( ; vn < vertex->v2num ; vn++)
      {
        H += g * mris->vertices[vertex->v[vn]].H ;
      }
      norm =
        kernel[0] +
        vertex->vnum*kernel[1] +
        (vertex->v2num-vertex->vnum) * kernel[2] ;
      vertex->d = H/norm ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      vertex = &mris->vertices[vno] ;
      if (vertex->ripflag)
      {
        continue ;
      }
      vertex->H = vertex->d ;
    }
  }

  return(NO_ERROR) ;
}

#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  File Format is:

  name x y z
  ------------------------------------------------------*/
static int
mrisSmoothNormals(MRI_SURFACE *mris, int niterations)
{
  int     vno, i, vn ;
  double  g ;
  VERTEX  *vertex, *vnb ;
  VECTOR  *v_n, *v_n2 ;

  v_n = VectorAlloc(3, MATRIX_REAL) ;       /* normal vector */
  v_n2 = VectorAlloc(3, MATRIX_REAL) ;       /* normal vector */

  for (i = 0 ; i < niterations ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      vertex = &mris->vertices[vno] ;
      if (vertex->ripflag)
      {
        continue ;
      }
      VECTOR_LOAD(v_n, vertex->nx, vertex->ny, vertex->nz) ;
      V3_SCALAR_MUL(v_n, kernel[0], v_n) ;
      g = kernel[1] ;
      for (vn = 0 ; vn < vertex->vnum ; vn++)
      {
        vnb = &mris->vertices[vertex->v[vn]] ;
        VECTOR_LOAD(v_n2, vnb->nx, vnb->ny, vnb->nz) ;
        V3_SCALAR_MUL(v_n2, g, v_n2) ;
        V3_ADD(v_n, v_n2, v_n) ;
      }
      g = kernel[2] ;
      for ( ; vn < vertex->v2num ; vn++)
      {
        vnb = &mris->vertices[vertex->v[vn]] ;
        VECTOR_LOAD(v_n2, vnb->nx, vnb->ny, vnb->nz) ;
        V3_SCALAR_MUL(v_n2, g, v_n2) ;
        V3_ADD(v_n, v_n2, v_n) ;
      }
      V3_NORMALIZE(v_n, v_n) ;
      vertex->tdx = V3_X(v_n) ;
      vertex->tdy = V3_Y(v_n) ;
      vertex->tdz = V3_Z(v_n) ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      vertex = &mris->vertices[vno] ;
      if (vertex->ripflag)
      {
        continue ;
      }
      vertex->nx = vertex->tdx ;
      vertex->ny = vertex->tdy ;
      vertex->nz = vertex->tdz ;
    }
  }

  VectorFree(&v_n) ;
  VectorFree(&v_n2) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisSmoothNormalOutliers(MRI_SURFACE *mris, double ndist)
{
  int     vno, n, m, smooth, nsmoothed ;
  VERTEX  *v, *vn ;
  float   sx, sy, sz, nx, ny, nz, nc, x, y, z, dist, dx, dy, dz ;


  for (nsmoothed = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    x = v->x ;
    y = v->y ;
    z = v->z ;

    sx = sy = sz = 0.0 ;
    n=0;
    /* see if we are futher than ndist from all our neighbors in
       the normal direction. If so, smooth.
    */
    for (smooth = 1, m = 0 ; smooth && m < v->vnum ; m++)
    {
      vn = &mris->vertices[v->v[m]] ;
      if (!vn->ripflag)
      {
        dx = vn->x - x;
        dy = vn->y - y;
        dz = vn->z - z;
        nc = dx*nx+dy*ny+dz*nz;   /* projection onto normal */
        dist = sqrt(nc) ;         /* distance in normal direction */
        if (dist < ndist)
        {
          smooth = 0 ;
        }
        sx += dx ;
        sy += dy ;
        sz += dz ;
        n++;
      }
    }
    if (!smooth)
    {
      continue ;
    }
    nsmoothed++ ;
    if (n>0)
    {
      sx = sx/n;
      sy = sy/n;
      sz = sz/n;
    }
#if 0
    nc = sx*nx+sy*ny+sz*nz;   /* projection onto normal */
    sx = nc*nx ;              /* move in normal direction */
    sy = nc*ny ;
    sz = nc*nz;
#endif

    v->dx += sx ;
    v->dy += sy ;
    v->dz += sz ;
  }

  fprintf(stdout, "%d smoothed (%2.2f%%)\n",
          nsmoothed, 100.0f*(float)nsmoothed / (float)mris->nvertices) ;
  return(NO_ERROR) ;
}


static int
mrisComputeAverageNormalTerm(MRI_SURFACE *mris, int navgs, double l_normal)
{
  VERTEX  *v, *vn ;
  double  nc_avg, nc, vnum, delta ;
  int     n, vno, marked ;
  float   x, y, z, dx, dy, dz, nx, ny, nz, s ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    marked = v->marked ;

    /* compute projection onto normal */
    x = v->x ;
    y = v->y ;
    z = v->z ;
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    for (vnum = nc_avg = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->marked != marked)
      {
        continue ;
      }
      vnum++ ;
      dx = vn->x - x ;
      dy = vn->y - y ;
      dz = vn->z - z ;
      nc_avg += dx*nx+dy*ny+dz*nz;   /* projection onto normal */
    }
    if (vnum > 0.0)
    {
      nc_avg /= vnum ;
    }
    else
    {
      nc_avg = 0.0 ;
    }
    v->d = nc_avg ;
  }

  mrisAverageDs(mris, navgs) ;

  /* now move each vertex in the direction of the local average */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    marked = v->marked ;

    /* compute projection onto normal */
    nc_avg = v->d ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    for (nc = vnum = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->marked != marked)
      {
        continue ;
      }
      vnum++ ;
      dx = vn->x - x ;
      dy = vn->y - y ;
      dz = vn->z - z ;
      nc += dx*nx+dy*ny+dz*nz;   /* projection onto normal */
    }
    if (vnum > 0.0)
    {
      nc /= (float)vnum ;
    }
    else
    {
      nc = 0.0 ;
    }

    s = nc_avg < 0.0 ? -1.0 : 1.0 ;
    nc_avg = sqrt(fabs(nc_avg)) * s ;
    s = nc < 0.0 ? -1.0 : 1.0 ;
    nc = sqrt(fabs(nc)) * s ;
    delta = -l_normal * (nc_avg - nc) ;
    dx = nx * delta ;
    dy = ny * delta ;
    dz = nz * delta ;
    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
  }
  return(NO_ERROR) ;
}
static int
mrisComputeCurvatureTerm(MRI_SURFACE *mris, double l_curv)
{
  int     vno, n ;
  VERTEX  *v, *vn ;
  float   nc, nx, ny, nz, x, y, z, ndx, ndy, ndz, tdx, tdy, tdz, dx, dy, dz,
          tdist, ndist, nc_avg ;
  double  curv ;

  if (FZERO(l_curv))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    x = v->x ;
    y = v->y ;
    z = v->z ;

    /* first mean tangential and normal spacing */
    nc_avg = ndx = ndy = ndz = tdist = ndist = 0.0f ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dx = vn->x - x ;
      dy = vn->y - y ;
      dz = vn->z - z ;
      nc = (dx*nx + dy*ny + dz*nz) ;
      nc_avg += nc ;
#if 0
      ndx += nc*nx ;
      ndy += nc*ny ;
      ndz += nc*nz ;
#endif
      tdx = dx-nc*nx ;
      tdy = dy-nc*ny ;
      tdz = dz-nc*nz ;
      tdist += sqrt(tdx*tdx+tdy*tdy+tdz*tdz) ;
    }
#if 0
    ndx /= (float)v->vnum ;
    ndy /= (float)v->vnum ;
    ndz /= (float)v->vnum ;
    ndist = sqrt(ndx*ndx+ndy*ndy+ndz*ndz) ;
    if (nc_avg < 0.0f)
    {
      ndist *= -1 ;  /* neighbors are predominantly below tangent plane */
    }
#else
    ndist = nc_avg ;
#endif
    tdist /= (float)v->vnum ;
    ndist /= (float)v->vnum ;
    if (FZERO(tdist))
    {
      continue ;
    }
    curv = ndist / tdist ;

    if (fabs(curv) < 0.25f)
    {
      continue ;
    }
    curv *= l_curv ;
    v->dx += curv * nx ;
    v->dy += curv * ny ;
    v->dz += curv * nz ;
    if (vno == Gdiag_no)
      fprintf(stdout,
              "vertex %d normal curvature term: (%2.3f, %2.3f, %2.3f)\n"
              , vno, curv*nx, curv*ny, curv*nz) ;
  }

  return(NO_ERROR) ;
}
#endif


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  File Format is:

  name x y z
  ------------------------------------------------------*/
static int
mrisComputeConvexityTerm(MRI_SURFACE *mris, double l_convex)
{
  int     vno, n, m ;
  VERTEX  *vertex, *vn ;
  float   sx, sy, sz, nx, ny, nz, nc, x, y, z ;

  if (FZERO(l_convex))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    nx = vertex->nx ;
    ny = vertex->ny ;
    nz = vertex->nz ;
    x = vertex->x ;
    y = vertex->y ;
    z = vertex->z ;

    sx = sy = sz = 0.0 ;
    n=0;
    for (m = 0 ; m < vertex->vnum ; m++)
    {
      vn = &mris->vertices[vertex->v[m]] ;
      if (!vn->ripflag)
      {
        sx += vn->x - x;
        sy += vn->y - y;
        sz += vn->z - z;
        n++;
      }
    }
    if (n>0)
    {
      sx = sx/n;
      sy = sy/n;
      sz = sz/n;
    }
    nc = sx*nx+sy*ny+sz*nz;   /* projection onto normal */
    if (nc < 0)
    {
      nc = 0 ;
    }
    sx = nc*nx ;              /* move in normal direction */
    sy = nc*ny ;
    sz = nc*nz;

    vertex->dx += l_convex * sx ;
    vertex->dy += l_convex * sy ;
    vertex->dz += l_convex * sz ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d convexity term: (%2.3f, %2.3f, %2.3f)\n",
              vno, l_convex*sx, l_convex*sy, l_convex*sz) ;
  }

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  File Format is:

  name x y z
  ------------------------------------------------------*/
static int
mrisComputeNormalSpringTerm(MRI_SURFACE *mris, double l_spring)
{
  int     vno, n, m ;
  VERTEX  *vertex, *vn ;
  float   sx, sy, sz, nx, ny, nz, nc, x, y, z ;

  if (FZERO(l_spring))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    nx = vertex->nx ;
    ny = vertex->ny ;
    nz = vertex->nz ;
    x = vertex->x ;
    y = vertex->y ;
    z = vertex->z ;

    sx = sy = sz = 0.0 ;
    n=0;
    for (m = 0 ; m < vertex->vnum ; m++)
    {
      vn = &mris->vertices[vertex->v[m]] ;
      if (!vn->ripflag)
      {
        sx += vn->x - x;
        sy += vn->y - y;
        sz += vn->z - z;
        n++;
      }
    }
    if (n>0)
    {
      sx = sx/n;
      sy = sy/n;
      sz = sz/n;
    }
    nc = sx*nx+sy*ny+sz*nz;   /* projection onto normal */
    sx = l_spring*nc*nx ;              /* move in normal direction */
    sy = l_spring*nc*ny ;
    sz = l_spring*nc*nz ;

    vertex->dx += sx ;
    vertex->dy += sy ;
    vertex->dz += sz ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d spring normal term:  (%2.3f, %2.3f, %2.3f)\n",
              vno, sx, sy, sz) ;
  }


  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  File Format is:

  name x y z
  ------------------------------------------------------*/
static int
mrisComputeTangentialSpringTerm(MRI_SURFACE *mris, double l_spring)
{
  int     vno, n, m ;
  VERTEX  *v, *vn ;
  float   sx, sy, sz, x, y, z, nc ;

  if (FZERO(l_spring))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    if (v->border && !v->neg)
    {
      continue ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    sx = sy = sz = 0.0 ;
    n=0;
    for (m = 0 ; m < v->vnum ; m++)
    {
      vn = &mris->vertices[v->v[m]] ;
      if (!vn->ripflag)
      {
        sx += vn->x-x;
        sy += vn->y-y;
        sz += vn->z-z;
        n++;
      }
    }
#if 0
    n = 4 ;  /* avg # of nearest neighbors */
#endif
    if (n>0)
    {
      sx = sx/n;
      sy = sy/n;
      sz = sz/n;
    }

    nc = sx*v->nx+sy*v->ny+sz*v->nz;   /* projection onto normal */
    sx = l_spring*(sx - nc*v->nx);     /* remove  normal component
                                                    and then scale */
    sy = l_spring*(sy - nc*v->ny);
    sz = l_spring*(sz - nc*v->nz);

    v->dx += sx ;
    v->dy += sy ;
    v->dz += sz ;
    if (vno == Gdiag_no)
      printf("v %d spring tangent term: (%2.3f, %2.3f, %2.3f)\n",
             vno, sx, sy, sz) ;
  }


  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  File Format is:

  name x y z
  ------------------------------------------------------*/
static int
mrisComputeNonlinearTangentialSpringTerm(MRI_SURFACE *mris,
                                         double l_spring,
                                         double min_dist)
{
  int     vno, m, n ;
  VERTEX  *v, *vn ;
  float   sx, sy, sz, x, y, z, dx, dy, dz ;
  double  d, scale ;

  if (FZERO(l_spring))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    sx = sy = sz = 0.0 ;
    for (dx = dy = dz = 0.0, n = m = 0 ; m < v->vnum ; m++)
    {
      vn = &mris->vertices[v->v[m]] ;
      if (!vn->ripflag)
      {
        sx = x-vn->x;
        sy = y-vn->y;
        sz = z-vn->z ;  // move away from nbr
        d = sqrt(sx*sx + sy*sy + sz*sz) ;
        if (d < min_dist)
        {
          scale = (min_dist-d)/min_dist ;
          d = scale*(v->e1x*sx + v->e1y*sy + v->e1z*sz) ;
          dx += v->e1x*d ;
          dy += v->e1y*d ;
          dz += v->e1z*d ;
          d = scale*(v->e2x*sx + v->e2y*sy + v->e2z*sz) ;
          dx += v->e2x*d ;
          dy += v->e2y*d ;
          dz += v->e2z*d ;
          if (vno == Gdiag_no)
          {
            DiagBreak() ;
          }
          n++ ;
        }
      }
    }
    dx *= l_spring ;
    dy *= l_spring ;
    dz *= l_spring ;
    if (vno == Gdiag_no && n > 0)
      printf("v %d nonlinear spring tangent term: (%2.3f, %2.3f, %2.3f)\n",
             vno, dx, dy, dz) ;
    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
  }


  return(NO_ERROR) ;
}

static double
mrisComputeDuraError(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  double dura_thresh = parms->dura_thresh, sse ;
  MRI *mri_dura = parms->mri_dura ;
  int     vno ;
  VERTEX  *v ;
  float   x, y, z ;
  double    val0, xw, yw, zw, delV ;

  if (FZERO(parms->l_dura))
  {
    return(0.0) ;
  }

  for (sse = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->val < 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    MRISvertexToVoxel(mris, v, mri_dura, &xw, &yw, &zw) ;
    MRIsampleVolume(mri_dura, xw, yw, zw, &val0) ;
    if (val0 < dura_thresh)
    {
      continue ;  // no effect
    }

    delV = dura_thresh - val0 ;
    sse += delV*delV ;
  }

  return(sse) ;
}


static int
mrisComputeDuraTerm(MRI_SURFACE *mris,
                    double l_dura,
                    MRI *mri_dura,
                    double dura_thresh)
{
  int     vno ;
  VERTEX  *v ;
  float   x, y, z, nx, ny, nz, dx, dy, dz ;
  double    val0, xw, yw, zw, del, delI, delV ;

  if (FZERO(l_dura))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->val < 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    MRISvertexToVoxel(mris, v, mri_dura, &xw, &yw, &zw) ;
    MRIsampleVolume(mri_dura, xw, yw, zw, &val0) ;
    if (val0 < dura_thresh)
    {
      continue ;  // no effect
    }

    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;

    delV = dura_thresh - val0 ;
    delI = 1 ;

    del = l_dura * delV * delI ;

    dx = nx * del ;
    dy = ny * del ;
    dz = nz * del ;

    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;

    if (vno == Gdiag_no)
    {
      double xwi, ywi, zwi, xwo, ywo, zwo, val_inside, val_outside ;

      x = v->x ;
      y = v->y ;
      z = v->z ;

      /* sample outward from surface */
      xw = x + nx ;
      yw = y + ny ;
      zw = z + nz ;
      MRISsurfaceRASToVoxel(mris, mri_dura, xw, yw, zw, &xwo, &ywo, &zwo);
      MRIsampleVolume(mri_dura, xw, yw, zw, &val_outside) ;

      /* sample inward from surface */
      xw = x - nx ;
      yw = y - ny ;
      zw = z - nz ;
      MRISsurfaceRASToVoxel(mris, mri_dura, xw, yw, zw, &xwi, &ywi, &zwi);
      MRIsampleVolume(mri_dura, xw, yw, zw, &val_inside) ;

      MRISsurfaceRASToVoxel(mris, mri_dura, x, y, z, &xw, &yw, &zw);
      fprintf(stdout,
              "D(%2.1f,%2.1f,%2.1f)=%2.1f, Do(%2.1f,%2.1f,%2.1f)=%2.1f, "
              "Di(%2.1f,%2.1f,%2.1f)=%2.1f\n",
              xw,yw,zw,val0, xwo, ywo,zwo,
              val_outside,xwi,ywi,zwi,val_inside);
      fprintf(stdout, "v %d dura term:      (%2.3f, %2.3f, %2.3f), "
              "delV=%2.1f, delI=%2.0f\n", vno, dx, dy, dz, delV, delI) ;
    }
  }


  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  File Format is:

  name x y z
  ------------------------------------------------------*/
#define NORMAL_MOVEMENT   0.1
#define NSAMPLES          15
#define SAMPLE_DISTANCE   0.1

static int
mrisComputeIntensityTerm(MRI_SURFACE *mris, double l_intensity, MRI *mri_brain,
                         MRI *mri_smooth, double sigma_global,
                         INTEGRATION_PARMS *parms)
{
  int     vno ;
  VERTEX  *v ;
  float   x, y, z, nx, ny, nz, dx, dy, dz ;
  double    val0, xw, yw, zw, del, val_outside, val_inside, delI, delV, k,
            ktotal_outside, xvi, yvi, zvi, interior, ktotal_inside ;
  double  sigma ;
  MRI     *mri_interior ;


  if (FZERO(l_intensity))
  {
    return(NO_ERROR) ;
  }

#if 0
  // scale intensity term down in regions that are compressed
  mrisComputeVertexDistances(mris) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    double davg ;
    int    n ;

    v = &mris->vertices[vno] ;
    if (v->ripflag || v->val < 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (davg = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      davg += v->dist[n] ;
    }
    davg /= v->vnum ;
    v->d = davg ;
  }
  mrisAverageDs(mris, 5) ;
  if (Gdiag_no >= 0)
  {
    v = &mris->vertices[Gdiag_no] ;
    printf("v %d: avg vertex distance = %2.2f\n", Gdiag_no, v->d) ;
    DiagBreak() ;
  }
#endif

  if (parms->grad_dir == 0 && 
      parms->fill_interior)  // create binary mask of interior of surface
  {
    mri_interior = MRISfillInterior(mris, 0.5, NULL) ;
    if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
    {
      MRIwrite(mri_interior, "int.mgz") ;
    }
  }
  else
  {
    mri_interior = NULL ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->val < 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    MRISvertexToVoxel(mris, v, mri_brain, &xw, &yw, &zw) ;
    MRIsampleVolume(mri_brain, xw, yw, zw, &val0) ;
    sigma = v->val2 ;
    if (FZERO(sigma))
    {
      sigma = sigma_global ;
    }
    if (FZERO(sigma))
    {
      sigma = 0.25 ;
    }

    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;

    /* compute intensity gradient using smoothed volume */
    if (parms->grad_dir == 0)
    {
      double dist, val, step_size ;
      int  n ;

      step_size = MIN(sigma/2,
                      MIN(mri_brain->xsize,
                          MIN(mri_brain->ysize, mri_brain->zsize))*0.5) ;
      ktotal_inside = ktotal_outside = 0.0 ;
      for (n = 0, val_outside = val_inside = 0.0, dist = step_size ;
           dist <= 2*sigma;
           dist += step_size, n++)
      {
        k = exp(-dist*dist/(2*sigma*sigma)) ;
        xw = x + dist*nx ;
        yw = y + dist*ny ;
        zw = z + dist*nz ;
        if (mri_interior)
        {
          MRISsurfaceRASToVoxelCached(mris,
                                      mri_interior,
                                      xw, yw, zw,
                                      &xvi,&yvi,&zvi) ;
          MRIsampleVolume(mri_interior, xvi, yvi, zvi, &interior) ;
        }

        if (mri_interior == NULL || interior < .9)
        {
          ktotal_outside += k ;
          MRISsurfaceRASToVoxelCached(mris,
                                      mri_brain,
                                      xw, yw, zw,
                                      &xw, &yw, &zw) ;
          MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
          val_outside += k*val ;
        }
        else
        {
          DiagBreak() ;
        }

        xw = x - dist*nx ;
        yw = y - dist*ny ;
        zw = z - dist*nz ;
        if (mri_interior)
        {
          MRISsurfaceRASToVoxelCached(mris,
                                      mri_interior,
                                      xw,yw,zw,
                                      &xvi,&yvi,&zvi);
          MRIsampleVolume(mri_interior, xvi, yvi, zvi, &interior) ;
        }

        if (mri_interior == NULL || interior > 0)
        {
          MRISsurfaceRASToVoxelCached(mris, mri_brain, xw, yw, zw,&xw,&yw,&zw);
          MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
          val_inside += k*val ;
          ktotal_inside += k ;
        }
        else
        {
          DiagBreak() ;
        }
      }
      if (ktotal_inside> 0)
      {
        val_inside /= (double)ktotal_inside ;
      }
      if (ktotal_outside> 0)
      {
        val_outside /= (double)ktotal_outside ;
      }
    }
    else  // don't compute gradient - assume
    {
      val_outside = parms->grad_dir ;
      val_inside = -parms->grad_dir ;
    }

    delV = v->val - val0 ;
    delI = (val_outside - val_inside) / 2.0 ;

    if (!FZERO(delI))
    {
      delI /= fabs(delI) ;
    }
    else
    {
      delI = -1 ;  /* intensities tend to increase inwards */
    }

    if (delV > 5)
    {
      delV = 5 ;
    }
    else if (delV < -5)
    {
      delV = -5 ;
    }

    del = l_intensity * delV * delI ;
#if 0
    if (v->d < .5)
    {
      del *= 0*v->d ;  // reduce weight in compressed regions
    }
#endif

    dx = nx * del ;
    dy = ny * del ;
    dz = nz * del ;

    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;


    if (vno == Gdiag_no)
    {
      double xwi, ywi, zwi, xwo, ywo, zwo ;

      x = v->x ;
      y = v->y ;
      z = v->z ;

      /* sample outward from surface */
      xw = x + nx ;
      yw = y + ny ;
      zw = z + nz ;
      MRISsurfaceRASToVoxelCached(mris,
                                  mri_smooth,
                                  xw, yw, zw,
                                  &xwo, &ywo, &zwo) ;
      /* sample inward from surface */
      xw = x - nx ;
      yw = y - ny ;
      zw = z - nz ;
      MRISsurfaceRASToVoxelCached(mris, 
                                  mri_smooth,
                                  xw, yw, zw,
                                  &xwi, &ywi, &zwi) ;
      MRISsurfaceRASToVoxelCached(mris,
                                  mri_smooth,
                                  x, y, z,
                                  &xw, &yw, &zw) ;
      fprintf(stdout,
              "I(%2.1f,%2.1f,%2.1f)=%2.1f, Io(%2.1f,%2.1f,%2.1f)=%2.1f, "
              "Ii(%2.1f,%2.1f,%2.1f)=%2.1f\n",
              xw,yw,zw,val0, xwo, ywo,zwo,
              val_outside,xwi,ywi,zwi,val_inside);
      fprintf(stdout, "v %d intensity term:      (%2.3f, %2.3f, %2.3f), "
              "delV=%2.1f, delI=%2.0f\n", vno, dx, dy, dz, delV, delI) ;
    }
  }

  if (mri_interior)
  {
    MRIfree(&mri_interior) ;
  }
  return(NO_ERROR) ;
}


static int
mrisComputeTargetLocationTerm(MRI_SURFACE *mris,
                              double l_location,
                              INTEGRATION_PARMS *parms)
{
  int     vno ;
  VERTEX  *v ;
  double    dx, dy, dz, norm ;


  if (FZERO(l_location))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
      continue ;
    if (vno == Gdiag_no)
      DiagBreak() ;

    dx = v->targx-v->x ; dy = v->targy-v->y ; dz = v->targz-v->z ;

    norm = sqrt(dx*dx + dy*dy + dz*dz) ;
#define LOCATION_MOVE_LEN  0.1
    if (norm > LOCATION_MOVE_LEN) // so things move at the same speed
    {
      dx /= norm ;
      dy /= norm ;
      dz /= norm ;
      dx *= LOCATION_MOVE_LEN ;
      dy *= LOCATION_MOVE_LEN ;
      dz *= LOCATION_MOVE_LEN ;
    }

    if (vno == Gdiag_no)
    {
      fprintf(stdout,
              "l_location: targ (%2.1f, %2.1f, %2.f), "
              "current (%2.1f, %2.1f, %2.1f), "
              "del (%2.1f, %2.1f, %2.1f), dot=%2.3f\n",
              v->targx, v->targy, v->targz,
              v->x, v->y, v->z,
              l_location*dx, l_location*dy, l_location*dz,
              dx*v->nx+dy*v->ny+dz*v->nz) ;
    }
    if (!devFinite(dx) || !devFinite(dy) || !devFinite(dz))
    {
      DiagBreak() ;
    }
    v->dx += l_location * dx ;
    v->dy += l_location * dy ;
    v->dz += l_location * dz ;

  }

  return(NO_ERROR) ;
}


static int
mrisComputeIntensityTerm_mef(MRI_SURFACE *mris, double l_intensity,
                             MRI *mri_30,
                             MRI *mri_5,
                             double sigma_global,
                             float weight30, float weight5,
                             INTEGRATION_PARMS *parms)
{
  int     vno ;
  VERTEX  *v ;
  float   x, y, z, nx, ny, nz, dx, dy, dz ;
  double    val0, xw, yw, zw, del, val_outside, val_inside, delI, delV, k,
            ktotal_outside, ktotal_inside, interior, xvi, yvi, zvi ;
  double  sigma ;
  MRI     *mri_interior ;

  if (FZERO(l_intensity))
  {
    return(NO_ERROR) ;
  }

  if (parms->grad_dir == 0 &&
      parms->fill_interior)  // create binary mask of interior of surface
  {
    mri_interior = MRISfillInterior(mris, 0.5, NULL) ;
    if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
    {
      MRIwrite(mri_interior, "int.mgz") ;
    }
  }
  else
  {
    mri_interior = NULL ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->val < 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;

    sigma = v->val2 ;
    if (FZERO(sigma))
    {
      sigma = sigma_global ;
    }
    if (!FZERO(weight30))
    {
      MRISsurfaceRASToVoxelCached(mris, mri_30, x, y, z, &xw, &yw, &zw) ;
      MRIsampleVolume(mri_30, xw, yw, zw, &val0) ;

      /* compute intensity gradient using smoothed volume */

      if (parms->grad_dir == 0)
      {
        double dist, val, step_size ;
        int  n ;

        step_size = MIN(sigma/2,
                        MIN(mri_30->xsize,
                            MIN(mri_30->ysize, mri_30->zsize))*0.5) ;
        ktotal_outside = ktotal_inside = 0.0 ;
        for (n = 0, val_outside = val_inside = 0.0, dist = step_size ;
             dist <= 2*sigma;
             dist += step_size, n++)
        {
          k = exp(-dist*dist/(2*sigma*sigma)) ;
          xw = x + dist*nx ;
          yw = y + dist*ny ;
          zw = z + dist*nz ;
          if (mri_interior)
          {
            MRISsurfaceRASToVoxelCached(mris, mri_interior,
                                        xw, yw, zw, &xvi,&yvi,&zvi) ;
            MRIsampleVolume(mri_interior, xvi, yvi, zvi, &interior) ;
          }

          if (mri_interior == NULL || interior < .9)
          {
            MRIsampleVolume(mri_30, xw, yw, zw, &val) ;
            val_outside += k*val ;
            ktotal_outside += k ;
          }
          else
          {
            DiagBreak() ;
          }

          xw = x - dist*nx ;
          yw = y - dist*ny ;
          zw = z - dist*nz ;
          if (mri_interior)
          {
            MRISsurfaceRASToVoxelCached(mris, mri_interior,
                                        xw, yw, zw, &xvi,&yvi,&zvi) ;
            MRIsampleVolume(mri_interior, xvi, yvi, zvi, &interior) ;
          }
          if (mri_interior == NULL || interior > 0)
          {
            MRIsampleVolume(mri_30, xw, yw, zw, &val) ;
            val_inside += k*val ;
            ktotal_inside += k ;
          }
          else
          {
            DiagBreak() ;
          }
        }
        if (ktotal_inside> 0)
        {
          val_inside /= (double)ktotal_inside ;
        }
        if (ktotal_outside> 0)
        {
          val_outside /= (double)ktotal_outside ;
        }
      }
      else  // don't compute gradient - assume
      {
        val_outside = parms->grad_dir ;
        val_inside = -parms->grad_dir ;
      }

      delV = v->val - val0 ;
      delI = (val_outside - val_inside) / 2.0 ;

      if (!FZERO(delI))
      {
        delI /= fabs(delI) ;
      }
      else
      {
        delI = -1;  //intensity tends to increase inwards for flash30
      }

      if (delV > 5)
      {
        delV = 5 ;
      }
      else if (delV < -5)
      {
        delV = -5 ;
      }

      del = l_intensity * delV * delI ;

      dx = nx * del*weight30 ;
      dy = ny * del*weight30 ;
      dz = nz * del*weight30;

      if (dx*nx+dy*ny+dz*nz < 0)
      {
        DiagBreak() ;
      }

      if (vno == Gdiag_no)
      {
        double xwi, ywi, zwi, xwo, ywo, zwo ;

        x = v->x ;
        y = v->y ;
        z = v->z ;

        /* sample outward from surface */
        xw = x + nx ;
        yw = y + ny ;
        zw = z + nz ;
        MRISsurfaceRASToVoxelCached(mris, mri_30,
                                    xw, yw, zw,
                                    &xwo, &ywo, &zwo) ;
        /* sample inward from surface */
        xw = x - nx ;
        yw = y - ny ;
        zw = z - nz ;
        MRISsurfaceRASToVoxelCached(mris, mri_30,
                                    xw, yw, zw,
                                    &xwi, &ywi, &zwi) ;
        fprintf(stdout,
                "I30(%2.1f,%2.1f,%2.1f)=%2.1f, Io(%2.1f,%2.1f,%2.1f)=%2.1f, "
                "Ii(%2.1f,%2.1f,%2.1f)=%2.1f\n",
                xw,yw,zw,val0, xwo, ywo,zwo,
                val_outside,xwi,ywi,zwi,val_inside);
        fprintf(stdout, "v %d I30 intensity term:  (%2.3f, %2.3f, %2.3f), "
                "targ=%2.1f, delV=%2.1f, delI=%2.0f, dot=%2.1f\n", 
                vno, dx, dy, dz, v->val,
                delV, delI,
                dx*nx+dy*ny+dz*nz) ;
      }
      v->dx += dx ;
      v->dy += dy ;
      v->dz += dz ;
    }

    //now compute flash5
    /* compute intensity gradient using smoothed volume */
    if (!FZERO(weight5))
    {
      MRISsurfaceRASToVoxelCached(mris, mri_5, x, y, z, &xw, &yw, &zw);
      MRIsampleVolume(mri_5, xw, yw, zw, &val0) ;
      if (parms->grad_dir == 0)
      {
        double dist, val, step_size ;
        int  n ;

        step_size = MIN(sigma/2,
                        MIN(mri_5->xsize,
                            MIN(mri_5->ysize, mri_5->zsize))*0.5) ;
        ktotal_inside = ktotal_outside = 0.0 ;
        for (n = 0, val_outside = val_inside = 0.0, dist = step_size ;
             dist <= 2*sigma;
             dist += step_size, n++)
        {
          k = exp(-dist*dist/(2*sigma*sigma)) ;

          xw = x + dist*nx ;
          yw = y + dist*ny ;
          zw = z + dist*nz ;
          if (mri_interior)
          {
            MRISsurfaceRASToVoxelCached(mris, mri_interior, xw, yw, zw,
                                        &xvi,&yvi,&zvi) ;
            MRIsampleVolume(mri_interior, xvi, yvi, zvi, &interior) ;
          }
          if (mri_interior == NULL || interior < .9)
          {
            MRISsurfaceRASToVoxelCached(mris, mri_5, xw, yw, zw, &xw, &yw, &zw);
            MRIsampleVolume(mri_5, xw, yw, zw, &val) ;
            val_outside += k*val ;
            ktotal_outside += k ;
          }

          xw = x - dist*nx ;
          yw = y - dist*ny ;
          zw = z - dist*nz ;
          if (mri_interior)
          {
            MRISsurfaceRASToVoxelCached(mris, mri_interior, xw, yw, zw,
                                        &xvi,&yvi,&zvi) ;
            MRIsampleVolume(mri_interior, xvi, yvi, zvi, &interior) ;
          }
          if (mri_interior == NULL || interior > 0)
          {
            MRISsurfaceRASToVoxelCached(mris, mri_5, xw, yw, zw, &xw, &yw, &zw);
            MRIsampleVolume(mri_5, xw, yw, zw, &val) ;
            val_inside += k*val ;
            ktotal_inside += k ;
          }
        }
        if (ktotal_inside> 0)
        {
          val_inside /= (double)ktotal_inside ;
        }
        if (ktotal_outside> 0)
        {
          val_outside /= (double)ktotal_outside ;
        }
      }
      else  // don't compute gradient - assume
      {
        val_outside = parms->grad_dir ;
        val_inside = -parms->grad_dir ;
      }

      delV = v->valbak - val0 ;
      delI = (val_outside - val_inside) / 2.0 ;

      if (!FZERO(delI))
      {
        delI /= fabs(delI) ;
      }
      else
      {
        delI = 0 ;
      }

      if (delV > 5)
      {
        delV = 5 ;
      }
      else if (delV < -5)
      {
        delV = -5 ;
      }

      del = l_intensity * delV * delI ;

      dx = nx * del*weight5 ;
      dy = ny * del*weight5;
      dz = nz * del*weight5;

      if (vno == Gdiag_no && !FZERO(weight5))
      {
        double xwi, ywi, zwi, xwo, ywo, zwo ;

        x = v->x ;
        y = v->y ;
        z = v->z ;

        /* sample outward from surface */
        xw = x + nx ;
        yw = y + ny ;
        zw = z + nz ;
        MRISsurfaceRASToVoxelCached(mris, mri_30,
                                    xw, yw, zw,
                                    &xwo, &ywo, &zwo) ;
        /* sample inward from surface */
        xw = x - nx ;
        yw = y - ny ;
        zw = z - nz ;
        MRISsurfaceRASToVoxelCached(mris, mri_30,
                                    xw, yw, zw,
                                    &xwi, &ywi, &zwi) ;
        MRISsurfaceRASToVoxelCached(mris, mri_30,
                                    x, y, z,
                                    &xw, &yw, &zw) ;
        fprintf(stdout,
                "I5(%2.1f,%2.1f,%2.1f)=%2.1f, Io(%2.1f,%2.1f,%2.1f)=%2.1f, "
                "Ii(%2.1f,%2.1f,%2.1f)=%2.1f\n",
                xw,yw,zw,val0, xwo, ywo,zwo,
                val_outside,xwi,ywi,zwi,val_inside);
        fprintf(stdout, "v %d I5 intensity term:   (%2.3f, %2.3f, %2.3f), "
                "delV=%2.1f, delI=%2.0f, dot=%2.1f\n",
                vno, dx, dy, dz, delV, delI,
                dx*nx + dy*ny + dz*nz) ;
      }
      v->dx += dx ;
      v->dy += dy ;
      v->dz += dz ; // add flash5 component
    }
  }


  if (mri_interior)
  {
    MRIfree(&mri_interior) ;
  }
  return(NO_ERROR) ;
}


#if 1
static int
mrisComputeIntensityGradientTerm(MRI_SURFACE*mris, double l_grad,
                                 MRI *mri_brain, MRI *mri_smooth)
{
  int     vno ;
  VERTEX  *v ;
  float   x, y, z, nx, ny, nz ;
  double    val0, mag0, xw, yw, zw, del, mag_outside, mag_inside, delI, delV,
            dx, dy, dz, val_outside, val_inside, val_dist, dn, xw1, yw1, zw1 ;

  if (FZERO(l_grad))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    /*
      sample intensity value and derivative in normal direction
      at current point.
    */
    x = v->x+v->nx ;
    y = v->y+v->ny ;
    z = v->z+v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw1, &yw1, &zw1) ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
    nx = xw1-xw ;
    ny = yw1-yw ;
    nz = zw1-zw ;
    MRIsampleVolumeGradient(mri_smooth, xw, yw, zw, &dx, &dy, &dz) ;
    MRIsampleVolume(mri_brain, xw, yw, zw, &val0) ;
    mag0 = sqrt(dx*dx+dy*dy+dz*dz) ;
    MRIsampleVolumeDerivative(mri_smooth, xw, yw, zw, nx, ny, nz, &dn) ;

    /* compute intensity gradient using smoothed volume */

    /* sample outward from surface */
    xw = x + nx ;
    yw = y + ny ;
    zw = z + nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_smooth, xw, yw, zw, &xw, &yw, &zw) ;
    MRIsampleVolumeGradient(mri_smooth, xw, yw, zw, &dx, &dy, &dz) ;
    mag_outside = sqrt(dx*dx+dy*dy+dz*dz) ;
    MRIsampleVolume(mri_smooth, xw, yw, zw, &val_outside) ;

    /* sample inward from surface */
    xw = x - nx ;
    yw = y - ny ;
    zw = z - nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_smooth, xw, yw, zw, &xw, &yw, &zw) ;
    MRIsampleVolumeGradient(mri_smooth, xw, yw, zw, &dx, &dy, &dz) ;
    mag_inside = sqrt(dx*dx+dy*dy+dz*dz) ;
    MRIsampleVolume(mri_smooth, xw, yw, zw, &val_inside) ;

    if (mag_outside > mag_inside)   /* gradients suggest edge is outwards */
    {
      val_dist = val_outside - v->val ;
    }
    else   /* gradients suggest edge is inwards */
    {
      val_dist = val_inside - v->val ;
    }

#if 0
    /* diminish the effect of gradients that are in locations whose
       intensity values are far from the target.
    */
    val_dist = 1 / (1 + val_dist*val_dist) ;
#else
    /* check to make sure that gradient is changing in right direction */
    val_dist = 1 ;
    /* is this right??? Used to be val0 > v->val, what about dn < 0?? */
    if (val0 > v->val)   /* current point is brighter than target */
    {
      /* dn > 0 implies should move in, but gradient mag points out */
      if (((mag_inside < mag_outside) && dn > 0) ||
          ((mag_inside > mag_outside) && dn < 0))
      {
        val_dist = 0 ;
      }
    }
    else                /* current point is dimmer than target */
    {
      /* dn > 0 implies should move out, but gradient mag points in */
      if (((mag_inside > mag_outside) && dn > 0) ||
          ((mag_inside < mag_outside) && dn < 0))
      {
        val_dist = 0 ;
      }
    }
#endif

    delV = 1.0f /*v->mean - mag0*/ ;
    delI = (mag_outside - mag_inside) / 2.0 ;
#if 1
    if (!FZERO(delI))
    {
      delI /= fabs(delI) ;
    }
#endif
    del = val_dist * l_grad * delV * delI ;
    dx = v->nx * del ;
    dy = v->ny * del ;
    dz = v->nz * del ;

    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
    if (vno == Gdiag_no)
      fprintf(stdout,
              "v %d intensity gradient term: (%2.3f, %2.3f, %2.3f) "
              "(mag = %2.1f, [%2.1f,%2.1f])\n",
              vno, v->dx, v->dy, v->dz, mag0, mag_inside, mag_outside) ;
  }


  return(NO_ERROR) ;
}
#else
static int
mrisComputeIntensityGradientTerm(MRI_SURFACE*mris, double l_grad,
                                 MRI *mri_brain, MRI *mri_smooth)
{
  int     vno ;
  VERTEX  *v ;
  float   x, y, z, nx, ny, nz ;
  double    xw, yw, zw, dx, dy, dz, val, mag, mag_next, scale ;

  if (FZERO(l_grad))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
    MRIsampleVolumeGradient(mri_smooth, xw, yw, zw, &dx, &dy, &dz) ;
    mag = sqrt(dx*dx + dy*dy + dz*dz) ;
    MRIsampleVolume(mri_smooth, xw, yw, zw, &val) ;

    /* sample outward from surface */
    xw = x + v->dx ;
    yw = y + v->dy ;
    zw = z + v->dz ;
    MRISsurfaceRASToVoxelCached(mris, mri_smooth, xw, yw, zw, &xw, &yw, &zw) ;
    MRIsampleVolumeGradient(mri_smooth, xw, yw, zw, &dx, &dy, &dz) ;
    mag_next = sqrt(dx*dx + dy*dy + dz*dz) ;

    /* gradient decreasing in outwards direction */
    scale = 1.0+l_grad ;
    if (fabs(mag) > fabs(mag_next))
    {
      scale /= 1.0f ;
    }

    v->dx *= scale ;
    v->dy *= scale ;
    v->dz *= scale ;
    if (vno == Gdiag_no)
      fprintf(stdout,
              "v %d intensity gradient term: (%2.3f, %2.3f, %2.3f) "
              "(mag = %2.1f, mag_next=%2.1f)\n",
              vno, v->dx, v->dy, v->dz, mag, mag_next) ;
  }


  return(NO_ERROR) ;
}
#endif


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Apply a uniform outward expansion force.
  ------------------------------------------------------*/
static int
mrisComputeSphereTerm(MRI_SURFACE *mris, double l_sphere, float radius)
{
  int     vno ;
  VERTEX  *v ;
  float   r, x, y, z, x0, y0, z0 ;

  if (FZERO(l_sphere))
  {
    return(0.0f) ;
  }

#if 1
  x0 = (mris->xlo+mris->xhi)/2.0f ;
  y0 = (mris->ylo+mris->yhi)/2.0f ;
  z0 = (mris->zlo+mris->zhi)/2.0f ;
#else
  x0 = mris->x0 ;
  y0 = mris->y0 ;
  z0 = mris->z0 ;
#endif

#if 0
  // make sure center is inside surface, otherwise move it
  {
    float dot, dx, dy, dz ;
    static int iter = 0 ;

    vno = MRISfindClosestVertex(mris, x0, y0, z0, &r) ;
    v = &mris->vertices[vno] ;
    dx = x0-v->x ;
    dy = y0-v->y ;
    dz = z0-v->z ;
    dot = v->nx*dx + v->ny*dy + v->nz*dz ;
    if (iter < 20 && dot > 0) // outside surface!
    {
      if (iter > 500)
      {
        DiagBreak() ;
      }
      printf("centroid (%2.1f, %2.1f, %2.1f) outside surface "
             "(dot = %2.1f, v %d = (%2.1f, %2.1f, %2.1f) n = "
             "(%2.1f, %2.1f, %2.1f)\n",
             x0, y0, z0, dot, vno, v->x, v->y, v->z, v->nx, v->ny, v->nz) ;
      x0 = v->x-0.5*v->nx ;
      y0 = v->y-(0.5*v->ny) ;
      z0 = v->z-(0.5*v->nz) ;
      mris->x0 = x0 ;
      mris->y0 = y0 ;
      mris->z0 = z0 ;
      print("moving centroid to (%2.1f, %2.1f, %2.1f)\n", x0, y0, z0) ;
      vno = MRISfindClosestVertex(mris, x0, y0, z0, &r) ;
      v = &mris->vertices[vno] ;
      dx = x0-v->x ;
      dy = y0-v->y ;
      dz = z0-v->z ;
      dot = v->nx*dx + v->ny*dy + v->nz*dz ;
      if (dot > 0)
      {
        printf("still outside!!!!!\n") ;
      }
    }
    iter++ ;
  }
#endif

  if (radius < 0)
  {
    radius = 0 ;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      x = v->x-x0 ;
      y = v->y-y0 ;
      z = v->z-z0 ;
      r = sqrt(x*x+y*y+z*z) ;
      if (r > radius)
      {
        radius = r ;
      }
    }
    radius++ ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x-x0 ;
    y = v->y-y0 ;
    z = v->z-z0 ;
    r = sqrt(x*x+y*y+z*z) ;
    if (FZERO(r))
    {
      continue ;
    }
    x /= r ;
    y /= r ;
    z /= r ;  /* normal direction */
    //    x = v->nx ; y = v->ny ; z = v->nz ;
    r = (radius - r) / radius ;
    if (vno == Gdiag_no &&
        (r*l_sphere * x*v->nx +
         r*l_sphere * y*v->ny +
         r*l_sphere * z*v->nz < 0))
    {
      DiagBreak() ;
    }
    v->dx += r*l_sphere * x ;
    v->dy += r*l_sphere * y ;
    v->dz += r*l_sphere * z ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d sphere   "
              " term: (%2.3f, %2.3f, %2.3f), r=%2.2f\n",
              vno, v->dx, v->dy, v->dz, r) ;
  }


  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Apply a uniform outward expansion force.
  ------------------------------------------------------*/
static int
mrisComputeExpansionTerm(MRI_SURFACE *mris, double l_expand)
{
  int     vno ;
  VERTEX  *v ;

  if (FZERO(l_expand))
  {
    return(0.0f) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    v->dx += l_expand * v->nx ;
    v->dy += l_expand * v->ny ;
    v->dz += l_expand * v->nz ;
    if (vno == Gdiag_no)
      printf("v %d expansion term: (%2.3f, %2.3f, %2.3f)\n",
             vno, l_expand*v->nx, l_expand*v->ny, l_expand*v->nz) ;
  }

  return(NO_ERROR) ;
}


static int
mrisComputeBorderTerm(MRI_SURFACE *mris, double l_border)
{
  int     vno, n, m ;
  VERTEX  *v, *vn ;
  float   sx, sy, sz, x, y, z, dist_scale ;

  if (FZERO(l_border))
  {
    return(NO_ERROR) ;
  }

  if (mris->patch)
  {
    dist_scale = 1.0 ;
  }
  else
  {
    dist_scale = sqrt(mris->orig_area / mris->total_area) ;
  }

  MRIScopyMarkedToMarked3(mris) ;
  MRISclearMarks(mris) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag == 0)
    {
      continue ;
    }
    for (m = 0 ; m < v->vtotal ; m++)
    {
      vn = &mris->vertices[v->v[m]] ;
      vn->marked = 1 ;
    }
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    if (v->border && !v->neg)
    {
      continue ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    sx = sy = sz = 0.0 ;
    n=0;
    for (m = 0 ; m < v->vnum ; m++)
    {
      vn = &mris->vertices[v->v[m]] ;
      if (vn->marked)  // move towards ripped vertices 
                       // that represent the border of this region
      {
        sx += .5*(vn->x - x) ;
        sy += .5*(vn->y - y) ;
        sz += .5*(vn->z - z) ;
        n++;
      }
    }
    if (n>0)
    {
      sx = dist_scale*sx/n;
      sy = dist_scale*sy/n;
      sz = dist_scale*sz/n;
    }

    sx *= l_border ;
    sy *= l_border ;
    sz *= l_border ;
    v->dx += sx ;
    v->dy += sy ;
    v->dz += sz ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d border term:         (%2.3f, %2.3f, %2.3f)\n",
              vno, sx, sy, sz) ;
  }

  MRIScopyMarked3ToMarked(mris) ;
  return(NO_ERROR) ;
}
static int
mrisComputeMaxSpringTerm(MRI_SURFACE *mris, double l_max_spring)
{
  int     vno, n, m, m_max ;
  VERTEX  *v, *vn ;
  float   dx, dy, dz, x, y, z, dist_scale, dist, max_dist ;

  if (FZERO(l_max_spring))
  {
    return(NO_ERROR) ;
  }

  if (mris->patch)
  {
    dist_scale = l_max_spring ;
  }
  else
  {
    dist_scale = l_max_spring*sqrt(mris->orig_area / mris->total_area) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }


    x = v->x ;
    y = v->y ;
    z = v->z ;

    n=0;
    m_max = 0 ;
    max_dist = 0 ;
    for (m = 0 ; m < v->vnum ; m++)
    {
      vn = &mris->vertices[v->v[m]] ;
      dx = (vn->x - x) ;
      dy = (vn->y - y) ;
      dz = (vn->z - z) ;
      dist = sqrt(dx*dx + dy*dy + dz*dz) ;
      if (dist >= max_dist)
      {
        m_max = m ;
        max_dist = dist ;
      }
    }

    vn = &mris->vertices[v->v[m_max]] ;
    dx = (vn->x - x) ;
    dy = (vn->y - y) ;
    dz = (vn->z - z) ;
    dx *= dist_scale ;
    dy *= dist_scale ;
    dz *= dist_scale ;

    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
    if (vno == Gdiag_no)
    {
      fprintf(stdout, "v %d spring max term:     "
              "(%2.3f, %2.3f, %2.3f)\n",
              vno, dx, dy, dz) ;
    }
  }

  MRIScopyMarked3ToMarked(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  File Format is:

  name x y z
  ------------------------------------------------------*/
static int
mrisComputeSpringTerm(MRI_SURFACE *mris, double l_spring)
{
  int     vno, n, m ;
  VERTEX  *v, *vn ;
  float   sx, sy, sz, x, y, z, dist_scale ;

  if (FZERO(l_spring))
  {
    return(NO_ERROR) ;
  }

#if METRIC_SCALE
  if (mris->patch)
  {
    dist_scale = 1.0 ;
  }
  else
  {
    dist_scale = sqrt(mris->orig_area / mris->total_area) ;
  }
#else
  dist_scale = 1.0 ;
#endif
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    if (v->border && !v->neg)
    {
      continue ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    sx = sy = sz = 0.0 ;
    n=0;
    for (m = 0 ; m < v->vnum ; m++)
    {
      vn = &mris->vertices[v->v[m]] ;
      if (!vn->ripflag)
      {
        sx += vn->x - x;
        sy += vn->y - y;
        sz += vn->z - z;
        n++;
      }
    }
#if 0
    n = 4 ;  /* avg # of nearest neighbors */
#endif
    if (n>0)
    {
      sx = dist_scale*sx/n;
      sy = dist_scale*sy/n;
      sz = dist_scale*sz/n;
    }

    sx *= l_spring ;
    sy *= l_spring ;
    sz *= l_spring ;
    v->dx += sx ;
    v->dy += sy ;
    v->dz += sz ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d spring term:         (%2.3f, %2.3f, %2.3f)\n",
              vno, sx, sy, sz) ;
  }


  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description

  Note: this function assumes that the mris surface
  has the original (i.e. after
  global rotational alignment) spherical coordinates in the TMP2_VERTICES
  ------------------------------------------------------*/
static int
mrisComputeLaplacianTerm(MRI_SURFACE *mris, double l_lap)
{
  int     vno, n, m ;
  VERTEX  *v, *vn ;
  float   x, y, z, vx, vy, vz, vnx, vny, vnz, dx, dy, dz ;

  if (FZERO(l_lap))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    if (v->border && !v->neg)
    {
      continue ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    n=0;
    vx = v->x - v->tx2 ;
    vy = v->y - v->ty2 ;
    vz = v->z - v->tz2 ;
    dx = dy = dz = 0.0f ;
    for (m = 0 ; m < v->vnum ; m++)
    {
      vn = &mris->vertices[v->v[m]] ;
      if (!vn->ripflag)
      {
        vnx = vn->x - vn->tx2 ;
        vny = vn->y - vn->ty2 ;
        vnz = vn->z - vn->tz2 ;
        dx += (vnx-vx) ;
        dy += (vny-vy) ;
        dz += (vnz-vz) ;
        if ((x == Gx && y == Gy && z == Gz) &&
            (Gdiag & DIAG_SHOW) && DIAG_VERBOSE_ON)
          printf("\tvertex %d: V=(%2.2f,%2.2f,%2.2f), "
                 "DX=(%2.2f,%2.2f,%2.2f)\n",
                 vno, vnx, vny, vnz, vnx-vx, vny-vy, vnz-vz) ;
        n++;
      }
    }
    if (n>0)
    {
      dx = dx * l_lap / n ;
      dy = dy * l_lap / n ;
      dz = dz * l_lap / n ;
    }

    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
    if (vno == Gdiag_no)
    {
      printf("l_lap: v %d: DX=(%2.2f,%2.2f,%2.2f)\n", vno, dx, dy, dz) ;
    }
  }

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Compute a spring term, and normalize it by removing the
  average normal component which typically forces the surface
  to shrink.
  ------------------------------------------------------*/
#if 0
static int
mrisComputeNormalizedSpringTerm(MRI_SURFACE *mris, double l_spring)
{
  int     vno, n, m ;
  VERTEX  *v, *vn ;
  float   sx, sy, sz, x, y, z, dist_scale, nx, ny, nz, dx, dy, dz ;
  double  dot_total, avg_len, std_len, len, num ;

  if (FZERO(l_spring))
  {
    return(NO_ERROR) ;
  }

#if METRIC_SCALE
  if (mris->patch)
  {
    dist_scale = 1.0 ;
  }
  else
  {
    dist_scale = sqrt(mris->orig_area / mris->total_area) ;
  }
#else
  dist_scale = 1.0 ;
#endif

  std_len = avg_len = dot_total = 0.0 ;
  for (num = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;

    sx = sy = sz = 0.0 ;
    n=0;
    for (m = 0 ; m < v->vnum ; m++)
    {
      vn = &mris->vertices[v->v[m]] ;
      if (!vn->ripflag)
      {
        dx = vn->x - x;
        dy = vn->y - y;
        dz = vn->z - z;
        sx += dx ;
        sy += dy ;
        sz += dz ;
        n++;
        len = sqrt(dx*dx + dy*dy + dz*dz) ;
        avg_len += len ;
        std_len += len*len ;
      }
    }
    num += n ;
    if (n>0)
    {
      sx = dist_scale*sx/n;
      sy = dist_scale*sy/n;
      sz = dist_scale*sz/n;
    }
  }
  avg_len /= num ;
  std_len = sqrt(std_len/num-avg_len*avg_len) ;

  num = (double)MRISvalidVertices(mris) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;

    sx = sy = sz = 0.0 ;
    n=0;
    for (m = 0 ; m < v->vnum ; m++)
    {
      vn = &mris->vertices[v->v[m]] ;
      if (!vn->ripflag)
      {
        dx = vn->x - x;
        dy = vn->y - y;
        dz = vn->z - z;
        len = sqrt(dx*dx + dy*dy + dz*dz) ;
        if (vno == 91951 && v->v[m] == 90994)
        {
          fprintf(stdout, "v %d-->%d: len %2.3f, "
                  "avg %2.3f (ratio=%2.3f)\n",
                  vno, v->v[m], len, avg_len, len/avg_len) ;
        }
#if 1
        dx /= len ;
        dy /= len ;
        dz /= len ;
        if (len/avg_len > 1.5)
        {
          len = avg_len * 1.0 * dist_scale ;
        }
        dx *= len ;
        dy *= len ;
        dz *= len ;
#endif
        sx += dx ;
        sy += dy ;
        sz += dz ;
        n++;
      }
    }
    if (n>0)
    {
      sx = dist_scale*sx/n;
      sy = dist_scale*sy/n;
      sz = dist_scale*sz/n;
    }

    dot_total += l_spring*(nx*sx + ny*sy + nz*sz) ;
    v->dx += l_spring * sx ;
    v->dy += l_spring * sy ;
    v->dz += l_spring * sz ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d spring nm term: (%2.3f, %2.3f, %2.3f)\n",
              vno, v->dx, v->dy, v->dz) ;
  }
  dot_total /= num ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;

    v->dx -= dot_total * nx ;
    v->dy -= dot_total * ny ;
    v->dz -= dot_total * nz ;
  }


  return(NO_ERROR) ;
}
#else
static int
mrisComputeNormalizedSpringTerm(MRI_SURFACE *mris, double l_spring)
{
  int     vno, n, m ;
  VERTEX  *v, *vn ;
  float   sx, sy, sz, x, y, z, dist_scale, nx, ny, nz, dx, dy, dz ;
  double  dot_total, num ;

  if (FZERO(l_spring))
  {
    return(NO_ERROR) ;
  }

#if METRIC_SCALE
  if (mris->patch)
  {
    dist_scale = 1.0 ;
  }
  else
  {
    dist_scale = sqrt(mris->orig_area / mris->total_area) ;
  }
#else
  dist_scale = 1.0 ;
#endif

  dot_total = 0.0 ;
  num = (double)MRISvalidVertices(mris) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;

    sx = sy = sz = 0.0 ;
    n=0;
    for (m = 0 ; m < v->vnum ; m++)
    {
      vn = &mris->vertices[v->v[m]] ;
      if (!vn->ripflag)
      {
        dx = vn->x - x;
        dy = vn->y - y;
        dz = vn->z - z;
        sx += dx ;
        sy += dy ;
        sz += dz ;
        n++;
      }
    }
    if (n>0)
    {
      sx = dist_scale*sx/n;
      sy = dist_scale*sy/n;
      sz = dist_scale*sz/n;
    }

    dot_total += l_spring*(nx*sx + ny*sy + nz*sz) ;
    v->dx += l_spring * sx ;
    v->dy += l_spring * sy ;
    v->dz += l_spring * sz ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d spring norm term: (%2.3f, %2.3f, %2.3f)\n",
              vno, l_spring*sx, l_spring*sy, l_spring*sz) ;
  }
  dot_total /= num ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;

    v->dx -= dot_total * nx ;
    v->dy -= dot_total * ny ;
    v->dz -= dot_total * nz ;
  }

  return(NO_ERROR) ;
}
#endif


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Compute the folding of the surface.
  ------------------------------------------------------*/
double
MRIScomputeFolding(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *vertex ;
  double k1, k2, folding, area ;

  folding = 0.0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    k1 = (double)vertex->k1 ;
    k2 = (double)vertex->k2 ;
    area = (double)vertex->area ;
    folding += area * (k1 - k2) * (k1 - k2) ;
  }

  return(folding) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Compute the effects of the gradient of the distance term
  ------------------------------------------------------*/
static int
mrisComputeDistanceTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  VECTOR  *v_y, *v_delta, *v_n ;
  float   l_dist, d0, dt, delta, nc, scale, norm, max_del, vsmooth = 1.0 ;
  VERTEX  *v, *vn ;
  int     vno, n, vnum, max_v, max_n ;
  int     diag_vno1, diag_vno2 ;
  char    *cp ;

  if ((cp = getenv("VDIAG1")) != NULL)
  {
    diag_vno1 = atoi(cp) ;
  }
  else
  {
    diag_vno1 = -1 ;
  }
  if ((cp = getenv("VDIAG2")) != NULL)
  {
    diag_vno2 = atoi(cp) ;
  }
  else
  {
    diag_vno2 = -1 ;
  }

  if (!FZERO(parms->l_nldist))
  {
    mrisComputeNonlinearDistanceTerm(mris, parms) ;
  }

  l_dist = parms->l_dist ;
  if (DZERO(l_dist))
  {
    return(NO_ERROR) ;
  }

  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_y = VectorAlloc(3, MATRIX_REAL) ;
  v_delta = VectorAlloc(3, MATRIX_REAL) ;
  norm = 1.0f / mris->avg_nbrs ;

#if METRIC_SCALE
  if (mris->patch)
  {
    scale = 1.0f ;
  }
  else if (mris->status == MRIS_PARAMETERIZED_SPHERE ||
           mris->status == MRIS_SPHERE)
  {
    scale = sqrt(mris->orig_area / mris->total_area) ;
  }
  else
    scale = mris->neg_area < mris->total_area ?
            sqrt(mris->orig_area / (mris->total_area-mris->neg_area)) :
            sqrt(mris->orig_area / mris->total_area) ;
#else
  scale = 1.0f ;
#endif
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "distance scale = %2.3f\n", scale) ;
  }
  max_del = 10000.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    vnum = v->vtotal ;
    if (v->ripflag || vnum <= 0)
    {
      continue ;
    }

    if (v->border)
    {
      DiagBreak() ;
    }
    V3_CLEAR(v_delta) ;
    VECTOR_LOAD(v_n, v->nx, v->ny, v->nz) ;

    if (vno == Gdiag_no && Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      fprintf(stdout,
              "computing distance term for v %d @ (%2.2f, %2.2f, %2.2f)\n",
              vno, v->x, v->y, v->z) ;

    for (n = 0 ; n < vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      d0 = v->dist_orig[n]/scale ;
      dt = v->dist[n] ;
      delta = dt - d0 ;
      if (fabs(delta) > max_del)
      {
        max_del = delta ;
        max_v = vno ;
        max_n = n ;
      }
      VECTOR_LOAD(v_y, vn->x - v->x, vn->y - v->y, vn->z - v->z) ;
      if ((V3_LEN_IS_ZERO(v_y)))
      {
        continue ;
      }
      V3_NORMALIZE(v_y, v_y) ;   /* make it a unit vector */
      V3_SCALAR_MUL(v_y, delta, v_y) ;
      V3_ADD(v_y, v_delta, v_delta) ;
      if (vno == Gdiag_no && Gdiag & DIAG_SHOW & 0)// deverbosified by dng
        fprintf(stdout,
                "nbr %d (%6.6d) @ (%2.2f, %2.2f, %2.2f), "
                "d0 %2.2f, dt %2.2f, "
                "delta %2.3f\n\tdx=%2.3f, %2.3f, %2.3f)\n",
                n, v->v[n], vn->x, vn->y, vn->z, d0, dt,
                delta, V3_X(v_y), V3_Y(v_y), V3_Z(v_y)) ;
      if ((vno == diag_vno1 && v->v[n] == diag_vno2) ||
          (vno == diag_vno2 && v->v[n] == diag_vno1))
        printf("nbr %d (%6.6d) @ (%2.2f, %2.2f, %2.2f), "
               "d0 %2.2f, dt %2.2f, "
               "delta %2.3f\n\ty=%2.3f, %2.3f, %2.3f)\n",
               n, v->v[n], vn->x, vn->y, vn->z, d0, dt,
               delta, V3_X(v_y), V3_Y(v_y), V3_Z(v_y)) ;
    }

    V3_SCALAR_MUL(v_delta, norm, v_delta) ;

    if ((vno == Gdiag_no || vno == diag_vno1 || vno == diag_vno1)
        && Gdiag & DIAG_SHOW)
      fprintf(stdout,
              "total delta=(%2.3f, %2.3f, %2.3f)\n",
              V3_X(v_delta), V3_Y(v_delta), V3_Z(v_delta)) ;
    /* take out normal component */
    nc = V3_DOT(v_n, v_delta) ;
    V3_SCALAR_MUL(v_n, -nc, v_n) ;
    V3_ADD(v_delta, v_n, v_delta) ;

    if (parms->vsmoothness)
    {
      vsmooth = (1.0 - parms->vsmoothness[vno]) ;
    }

    v->dx += l_dist * V3_X(v_delta) ;
    v->dy += l_dist * V3_Y(v_delta) ;
    v->dz += l_dist * V3_Z(v_delta) ;
    if (vno == Gdiag_no || vno == diag_vno1 || vno == diag_vno1)
      fprintf(stdout, "v %d, distance term: (%2.3f, %2.3f, %2.3f)\n",
              vno, v->dx, v->dy, v->dz) ;
    if (Gdiag_no == vno)
    {
      FILE *fp ;
      char fname[STRLEN] ;
      VERTEX *v ;
      int    i ;
      static int iter = 0 ;

      sprintf(fname, "v%d_dist_%04d.log", Gdiag_no, iter++) ;
      fp = fopen(fname, "w") ;
      v = &mris->vertices[Gdiag_no] ;
      for (i = 0 ; i < v->vtotal ; i++)
        fprintf(fp, "%03d: %05d, %f   %f   %f\n",
                i, v->v[i], v->dist_orig[i], v->dist[i],
                v->dist[i]-v->dist_orig[i]/scale);
      fclose(fp) ;
    }
  }

  VectorFree(&v_n) ;
  VectorFree(&v_y) ;
  VectorFree(&v_delta) ;

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Compute the effects of the gradient of the distance term
  ------------------------------------------------------*/
static int
mrisComputeNonlinearDistanceTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  VECTOR  *v_y, *v_delta, *v_n ;
  float   l_dist, d0, dt, delta, nc, scale, norm, ratio ;
  VERTEX  *v, *vn ;
  int     vno, n, vnum ;

  l_dist = parms->l_nldist ;
  if (FZERO(l_dist))
  {
    return(NO_ERROR) ;
  }

  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_y = VectorAlloc(3, MATRIX_REAL) ;
  v_delta = VectorAlloc(3, MATRIX_REAL) ;
  norm = 1.0f / mris->avg_nbrs ;

#if METRIC_SCALE
  if (mris->patch)
  {
    scale = 1.0f ;
  }
  else if (mris->status == MRIS_PARAMETERIZED_SPHERE)
  {
    scale = sqrt(mris->orig_area / mris->total_area) ;
  }
  else
    scale = mris->neg_area < mris->total_area ?
            sqrt(mris->orig_area / (mris->total_area-mris->neg_area)) :
            sqrt(mris->orig_area / mris->total_area) ;
#else
  scale = 1.0f ;
#endif
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "distance scale = %2.3f\n", scale) ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    vnum = v->vtotal ;
    if (v->ripflag || vnum <= 0)
    {
      continue ;
    }

    if (v->border)
    {
      DiagBreak() ;
    }
    V3_CLEAR(v_delta) ;
    VECTOR_LOAD(v_n, v->nx, v->ny, v->nz) ;

    if (vno == Gdiag_no && Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      fprintf(stdout,
              "computing distance term for v %d @ (%2.2f, %2.2f, %2.2f)\n",
              vno, v->x, v->y, v->z) ;

    for (n = 0 ; n < vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      d0 = v->dist_orig[n] ;
      dt = scale * v->dist[n] ;
      delta = dt - d0 ;
      VECTOR_LOAD(v_y, vn->x - v->x, vn->y - v->y, vn->z - v->z) ;
      if ((V3_LEN_IS_ZERO(v_y)))
      {
        continue ;
      }
      V3_NORMALIZE(v_y, v_y) ;   /* make it a unit vector */
      if (!FZERO(d0))
      {
        ratio = dt / d0 ;
        delta *= 1 / (1 + exp(-1*ratio)) ;
      }
      V3_SCALAR_MUL(v_y, delta, v_y) ;
      V3_ADD(v_y, v_delta, v_delta) ;
      if (vno == Gdiag_no && Gdiag & DIAG_SHOW)
        fprintf(stdout,
                "nbr %d (%6.6d) @ (%2.2f, %2.2f, %2.2f), "
                "d0 %2.2f, dt %2.2f, "
                "delta %2.3f\n\ty=%2.3f, %2.3f, %2.3f)\n",
                n, v->v[n], vn->x, vn->y, vn->z, d0, dt,
                delta, V3_X(v_y), V3_Y(v_y), V3_Z(v_y)) ;
    }

    V3_SCALAR_MUL(v_delta, norm, v_delta) ;

    if (vno == Gdiag_no && Gdiag & DIAG_SHOW)
      fprintf(stdout,
              "total delta=(%2.3f, %2.3f, %2.3f)\n",
              V3_X(v_delta), V3_Y(v_delta), V3_Z(v_delta)) ;
    /* take out normal component */
    nc = V3_DOT(v_n, v_delta) ;
    V3_SCALAR_MUL(v_n, -nc, v_n) ;
    V3_ADD(v_delta, v_n, v_delta) ;

    v->dx += l_dist * V3_X(v_delta) ;
    v->dy += l_dist * V3_Y(v_delta) ;
    v->dz += l_dist * V3_Z(v_delta) ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d, distance term: (%2.3f, %2.3f, %2.3f)\n",
              vno, v->dx, v->dy, v->dz) ;
  }

  VectorFree(&v_n) ;
  VectorFree(&v_y) ;
  VectorFree(&v_delta) ;

  return(NO_ERROR) ;
}


/*-----------------------------------------------------*/
int
mrisLogIntegrationParms(FILE *fp, MRI_SURFACE *mris,INTEGRATION_PARMS *parms)
{
  char  *cp, host_name[STRLEN] ;
  static int first = 1 ;

  if (!fp)
  {
    return(NO_ERROR) ;
  }

  cp = getenv("HOST") ;
  if (cp)
  {
    strcpy(host_name, cp) ;
  }
  else
  {
    strcpy(host_name, "unknown") ;
  }

  fprintf(fp, "tol=%2.1e, sigma=%2.1f, host=%5.5s, nav=%d, nbrs=%d",
          (float)parms->tol, parms->sigma, host_name, 
          parms->n_averages, mris->nsize) ;
  if (!FZERO(parms->l_area))
  {
    fprintf(fp, ", l_area=%2.3f", parms->l_area) ;
  }
  if (!FZERO(parms->l_map))
  {
    fprintf(fp, ", l_map=%2.3f", parms->l_map) ;
  }
  if (!FZERO(parms->l_map2d))
  {
    fprintf(fp, ", l_map2d=%2.3f", parms->l_map2d) ;
  }
  if (!FZERO(parms->l_dura))
  {
    fprintf(fp, ", l_dura=%2.3f", parms->l_dura) ;
  }
  if (!FZERO(parms->l_expandwrap))
  {
    fprintf(fp, ", l_expandwrap=%2.3f", parms->l_expandwrap) ;
  }
  if (!FZERO(parms->l_shrinkwrap))
  {
    fprintf(fp, ", l_shrinkwrap=%2.3f", parms->l_shrinkwrap) ;
  }
  if (!FZERO(parms->l_external))
  {
    fprintf(fp, ", l_extern=%2.3f", parms->l_external) ;
  }
  if (!FZERO(parms->l_parea))
  {
    fprintf(fp, ", l_parea=%2.3f", parms->l_parea) ;
  }
  if (!FZERO(parms->l_nlarea))
  {
    fprintf(fp, ", l_nlarea=%2.3f", parms->l_nlarea) ;
  }
  if (!FZERO(parms->l_nldist))
  {
    fprintf(fp, ", l_nldist=%2.3f", parms->l_nldist) ;
  }
  if (!FZERO(parms->l_angle))
  {
    fprintf(fp, ", l_angle=%2.3f", parms->l_angle) ;
  }
  if (!FZERO(parms->l_repulse))
  {
    fprintf(fp, ", l_repulse=%2.3f", parms->l_repulse) ;
  }
  if (!FZERO(parms->l_repulse_ratio))
  {
    fprintf(fp, ", l_repulse_ratio=%2.3f", parms->l_repulse_ratio) ;
  }
  if (!FZERO(parms->l_surf_repulse))
  {
    fprintf(fp, ", l_surf_repulse=%2.3f", parms->l_surf_repulse) ;
  }
  if (!FZERO(parms->l_corr))
  {
    fprintf(fp, ", l_corr=%2.3f", parms->l_corr) ;
  }
  if (!FZERO(parms->l_spring))
  {
    fprintf(fp, ", l_spring=%2.3f", parms->l_spring) ;
  }
  if (!FZERO(parms->l_spring_norm))
  {
    fprintf(fp, ", l_spring_norm=%2.3f", parms->l_spring_norm) ;
  }
  if (!FZERO(parms->l_tspring))
  {
    fprintf(fp, ", l_tspring=%2.3f", parms->l_tspring) ;
  }
  if (!FZERO(parms->l_nltspring))
  {
    fprintf(fp, ", l_nltspring=%2.3f", parms->l_nltspring) ;
  }
  if (!FZERO(parms->l_histo))
  {
    fprintf(fp, ", l_histo=%2.3f", parms->l_histo) ;
  }
  if (!FZERO(parms->l_nlspring))
  {
    fprintf(fp, ", l_nlspring=%2.3f", parms->l_nlspring) ;
  }
  if (!FZERO(parms->l_nspring))
  {
    fprintf(fp, ", l_nspring=%2.3f", parms->l_nspring) ;
  }
  if (!FZERO(parms->l_dist))
  {
    fprintf(fp, ", l_dist=%2.3f", parms->l_dist) ;
  }
  if (!FZERO(parms->l_intensity))
  {
    fprintf(fp, ", l_intensity=%2.3f", parms->l_intensity) ;
  }
  if (!FZERO(parms->l_location))
  {
    fprintf(fp, ", l_location=%2.3f", parms->l_location) ;
  }
  if (!FZERO(parms->l_grad))
  {
    fprintf(fp, ", l_grad=%2.3f", parms->l_grad) ;
  }
  if (!FZERO(parms->l_sphere))
  {
    fprintf(fp, ", l_sphere=%2.3f", parms->l_sphere) ;
  }
  if (!FZERO(parms->l_expand))
  {
    fprintf(fp, ", l_expand=%2.3f", parms->l_expand) ;
  }
  if (!FZERO(parms->l_curv))
  {
    fprintf(fp, ", l_curv=%2.3f", parms->l_curv) ;
  }
  if (!FZERO(parms->l_convex))
  {
    fprintf(fp, ", l_convex=%2.3f", parms->l_convex) ;
  }
  if (!FZERO(parms->l_boundary))
  {
    fprintf(fp, ", l_boundary=%2.3f", parms->l_boundary) ;
  }
  if (!FZERO(parms->l_neg))
  {
    fprintf(fp, ", l_neg=%2.3f", parms->l_neg) ;
  }
  if (!FZERO(parms->l_tsmooth))
  {
    fprintf(fp, ", l_tsmooth=%2.3f", parms->l_tsmooth) ;
  }
  if (!FZERO(parms->l_thick_min))
  {
    fprintf(fp, ", l_thick_min=%2.3f", parms->l_thick_min) ;
  }
  if (!FZERO(parms->l_thick_parallel))
  {
    fprintf(fp, ", l_thick_parallel=%2.3f", parms->l_thick_parallel) ;
  }
  if (!FZERO(parms->l_ashburner_triangle))
  {
    fprintf(fp, ", l_ashburner_triangle=%2.3f", parms->l_ashburner_triangle) ;
  }
  if (!FZERO(parms->l_thick_normal))
  {
    fprintf(fp, ", l_thick_normal=%2.3f", parms->l_thick_normal) ;
  }
  if (!FZERO(parms->l_thick_spring))
  {
    fprintf(fp, ", l_thick_spring=%2.3f", parms->l_thick_spring) ;
  }
  fprintf(fp, "\n") ;
  switch (parms->integration_type)
  {
  case INTEGRATE_LM_SEARCH:
    fprintf(fp, "using binary search line minimization\n") ;
    break ;
  case INTEGRATE_LINE_MINIMIZE:
    fprintf(fp, "using quadratic fit line minimization\n") ;
    break ;
  case INTEGRATE_ADAPTIVE:
    fprintf(fp,
            "mom=%2.2f, dt=%2.2f, base_dt=%2.3f, dt_inc=%2.2f, "
            "dt_dec=%2.2f, err_rat=%2.2f\n",
            (float)parms->momentum, (float)parms->dt,
            (float)parms->base_dt, (float)parms->dt_increase,
            (float)parms->dt_decrease, (float)parms->error_ratio) ;
    break ;
  default:
  case INTEGRATE_MOMENTUM:
    fprintf(fp,
            "mom=%2.2f, dt=%2.2f\n",
            (float)parms->momentum, (float)parms->dt);
    break ;
  }
#if 0
  fprintf(fp, "nbhd_size=%d, max_nbrs=%d ", parms->nbhd_size,parms->max_nbrs);
#endif
  if (parms->desired_rms_height > 0.0)
  {
    fprintf(fp, "desired rms height=%2.3f", parms->desired_rms_height) ;
  }
  if (first)
  {
    fprintf(fp,"complete_dist_mat %d\n",parms->complete_dist_mat);
    fprintf(fp,"rms %g\n",parms->rms);
    fprintf(fp,"smooth_averages %d\n",parms->smooth_averages);
    fprintf(fp,"remove_neg %d\n",parms->remove_neg);
    fprintf(fp,"ico_order %d\n",parms->ico_order);
    fprintf(fp,"which_surface %d\n",parms->which_surface);
    fprintf(fp,"target_radius %f\n",parms->target_radius);
    fprintf(fp,"nfields %d\n",parms->nfields);
    fprintf(fp,"scale %lf\n",parms->scale);
    fprintf(fp,"desired_rms_height %lf\n",parms->desired_rms_height);
    fprintf(fp,"momentum %lf\n",parms->momentum);
    fprintf(fp,"nbhd_size %d\n",parms->nbhd_size);
    fprintf(fp,"max_nbrs %d\n",parms->max_nbrs);
    fprintf(fp,"niterations %d\n",parms->niterations);
    fprintf(fp,"nsurfaces %d\n",parms->nsurfaces);
    fprintf(fp,"SURFACES %d\n",(int)(SURFACES));
    fprintf(fp,"flags %d (%x)\n",parms->flags,parms->flags);
    fprintf(fp,"use curv %d\n",(parms->flags & IP_USE_CURVATURE));
    fprintf(fp,"no sulc %d\n",(parms->flags & IP_NO_SULC));
    fprintf(fp,"no rigid align %d\n",(parms->flags & IP_NO_RIGID_ALIGN));
    fprintf(fp,"mris->nsize %d\n",mris->nsize);
    fprintf(fp,"mris->hemisphere %d\n",mris->hemisphere);
    fprintf(fp,"randomSeed %ld\n",getRandomSeed());
    fprintf(fp, "\n") ;
    first = 0 ;
  }
  fflush(fp) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisWriteSnapshots(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, int t)
{
  char base_name[STRLEN] ;

  MRISsaveVertexPositions(mris, TMP_VERTICES) ;

  strcpy(base_name, parms->base_name) ;

  MRISrestoreVertexPositions(mris, PIAL_VERTICES) ;
  sprintf(parms->base_name, "%s_pial", base_name) ;
  mrisWriteSnapshot(mris, parms, t) ;

  MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
  sprintf(parms->base_name, "%s_white", base_name) ;
  mrisWriteSnapshot(mris, parms, t) ;

  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;

  strcpy(parms->base_name, base_name) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisWriteSnapshot(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, int t)
{
  char fname[STRLEN], path[STRLEN], base_name[STRLEN], *cp, *hemi ;

  switch (mris->hemisphere)
  {
  case LEFT_HEMISPHERE:
    hemi = "lh" ;
    break ;
  case BOTH_HEMISPHERES:
    hemi = "both" ;
    break ;
  case RIGHT_HEMISPHERE:
    hemi = "rh" ;
    break ;
  default:
    hemi = "unknown" ;
    break ;
  }
  FileNamePath(mris->fname, path) ;
  sprintf(base_name, "%s/%s.%s", path, hemi, parms->base_name);
  if ((cp = strstr(base_name, ".geo")) != NULL)
  {
    *cp = 0;
    sprintf(fname, "%s%4.4d.geo", base_name, t) ;
    *cp = '.' ;
  }
  else
  {
    sprintf(fname, "%s%4.4d", base_name, t) ;
  }
#if 1
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "writing %s...", fname) ;
  }
  if (mris->patch)
  {
    MRISwritePatch(mris, fname) ;
  }
  else
  {
    MRISwrite(mris, fname) ;
  }

  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "done.\n") ;
    fflush(stderr) ;
  }
#endif

  if (mris->status == MRIS_PARAMETERIZED_SPHERE && DIAG_VERBOSE_ON)
  {
    MRI_SP *mrisp = (MRI_SP *)mris->vp ;

    sprintf(fname, "%s%4.4d.hipl", parms->base_name, t) ;
    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, "writing %s\n", fname) ;
    }
    MRIStoParameterization(mris, mrisp, 1, 0) ;
    MRISPwrite(mrisp, fname) ;
  }
  if (!FZERO(parms->l_area) && DIAG_VERBOSE_ON)
  {
    sprintf(fname, "%s%4.4d.area_error", base_name, t) ;
    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, " %s...", fname) ;
    }
    MRISwriteAreaError(mris, fname) ;
  }

  if (!FZERO(parms->l_corr) && DIAG_VERBOSE_ON)
  {
    sprintf(fname, "%s%4.4d.angle_error", base_name, t) ;
    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, " %s...", fname) ;
    }
    MRISwriteAngleError(mris, fname) ;
  }

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeDistanceError(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  VERTEX  *v, *vn ;
  int     vno, n, nvertices, max_v, max_n, err_cnt, max_errs, vn_vno ;
  double  dist_scale, sse_dist, delta, v_sse, max_del ;
  static int first = 1 ;

#if METRIC_SCALE
  if (mris->patch)
  {
    dist_scale = 1.0 ;
  }
  else if (mris->status == MRIS_PARAMETERIZED_SPHERE)
  {
    dist_scale = sqrt(mris->orig_area / mris->total_area) ;
  }
  else
    dist_scale = mris->neg_area < mris->total_area ?
                 sqrt(mris->orig_area / (mris->total_area-mris->neg_area)) :
                 sqrt(mris->orig_area / mris->total_area) ;
#else
  dist_scale = 1.0 ;
#endif
  max_del = -1.0 ;
  max_v = max_n = -1 ;

  err_cnt=0;
  max_errs=1000;

  for (sse_dist = 0.0, nvertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

#if NO_NEG_DISTANCE_TERM
    if (v->neg)
    {
      continue ;
    }
#endif

    nvertices++ ;
    for (v_sse = 0.0, n = 0 ; n < v->vtotal ; n++)
    {
      vn_vno = v->v[n] ;
      vn = &mris->vertices[vn_vno] ;
      if (vn->ripflag)
      {
        continue ;
      }
#if NO_NEG_DISTANCE_TERM
      if (mris->vertices[v->v[n]].neg)
      {
        continue ;
      }
#endif
      if (v->dist_orig[n] >= UNFOUND_DIST)
      {
        continue ;
      }
      if (DZERO(v->dist_orig[n]) && first)
      {
        first = 0 ;
        fprintf(stderr, "v[%d]->dist_orig[%d] = %f!!!!\n",
                vno, n, v->dist_orig[n]) ;
        fflush(stderr);
        DiagBreak() ;
        if (++err_cnt > max_errs)
        {
          ErrorExit
          (ERROR_BADLOOP,
           "mrisComputeDistanceError: Too many errors!\n") ;
        }
      }
      delta = dist_scale*v->dist[n] - v->dist_orig[n] ;

      if (fabs(delta) > fabs(max_del))
      {
        max_del = delta ;
        max_v = vno ;
        max_n = n ;
      }
      if (parms->vsmoothness)
      {
        v_sse += (1.0-parms->vsmoothness[vno])*(delta*delta) ;
      }
      else
      {
        v_sse += delta*delta ;
      }
      if (!finite(delta) || !finite(v_sse))
      {
        DiagBreak() ;
      }
    }
    if (v_sse > 10000)
    {
      DiagBreak() ;
    }
    if (parms->dist_error)
    {
      parms->dist_error[vno] = v_sse ;
    }
    sse_dist += v_sse ;
    if (!finite(sse_dist) || !finite(v_sse))
    {
      DiagBreak() ;
    }
  }

#ifdef FS_CUDA
  /* investigate some of the flags. Neither being true would help
     tremendously with the GPU implementation as it removes the need
     to have or produce the information involved with these flags
  */
  fprintf(stdout,"mrisComputeDistanceError: parms->dist_error=%d, "
          "parms->vsmoothness=%d, sse_dist=%lg\n",
          (parms->dist_error!=NULL),(parms->vsmoothness!=NULL),sse_dist);
#endif /* FS_CUDA */

  /*fprintf(stdout, "max_del = %f at v %d, n %d\n", max_del, max_v, max_n) ;*/
  return(sse_dist) ;
}

#ifdef FS_CUDA
static float
mrisComputeDistanceErrorCUDA(MRI_SURFACE *mris,
                             MRI_CUDA_SURFACE *mrisc,
                             INTEGRATION_PARMS *parms)
{
  double  dist_scale, sse_dist;

#if METRIC_SCALE
  if (mris->patch)
  {
    dist_scale = 1.0 ;
  }
  else if (mris->status == MRIS_PARAMETERIZED_SPHERE)
  {
    dist_scale = sqrt(mris->orig_area / mris->total_area) ;
  }
  else
    dist_scale = mris->neg_area < mris->total_area ?
                 sqrt(mris->orig_area / (mris->total_area-mris->neg_area)) :
                 sqrt(mris->orig_area / mris->total_area) ;
#else
  dist_scale = 1.0 ;
#endif

  /*
  if(dist_scale != 1.0) {
    fprintf(stdout,"FYFYF: dist_scale = %lg\n",dist_scale);
  }
  */

  if(parms->vsmoothness == NULL && parms->dist_error == NULL)
  {
    sse_dist = (double)(MRISCcomputeDistanceError(mrisc,dist_scale));
  }
  else
  {
    sse_dist = mrisComputeDistanceError(mris,parms);
  }

  /*
    fprintf(stdout,"mrisComputeDistanceErrorCUDA: **************************************** sse_dist=%lg\n",sse_dist);
  */
  return(sse_dist) ;
}

#endif /* FS_CUDA */


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeNonlinearDistanceSSE(MRI_SURFACE *mris)
{
  VERTEX  *v ;
  int     vno, n, nvertices, max_v, max_n ;
  double  dist_scale, sse_dist, delta, v_sse, max_del, ratio ;

#if METRIC_SCALE
  if (mris->patch)
  {
    dist_scale = 1.0 ;
  }
  else if (mris->status == MRIS_PARAMETERIZED_SPHERE)
  {
    dist_scale = sqrt(mris->orig_area / mris->total_area) ;
  }
  else
    dist_scale = mris->neg_area < mris->total_area ?
                 sqrt(mris->orig_area / (mris->total_area-mris->neg_area)) :
                 sqrt(mris->orig_area / mris->total_area) ;
#else
  dist_scale = 1.0 ;
#endif
  max_del = -1.0 ;
  max_v = max_n = -1 ;
  for (sse_dist = 0.0, nvertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    nvertices++ ;
    for (v_sse = 0.0, n = 0 ; n < v->vtotal ; n++)
    {
#if 0
      delta = dist_scale*v->dist[n] - v->dist_orig[n] ;
      delta *= delta ;
#endif
      if (FZERO(v->dist_orig[n]))
      {
        continue ;
      }
      ratio = dist_scale*v->dist[n] / v->dist_orig[n] ;
      delta = log(1+exp(ratio)) ;
      v_sse += delta ;
      if (!finite(delta) || !finite(v_sse))
      {
        DiagBreak() ;
      }
    }
    sse_dist += v_sse ;
    if (!finite(sse_dist) || !finite(v_sse))
    {
      DiagBreak() ;
    }
  }

  return(sse_dist) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeThicknessSmoothnessEnergy(MRI_SURFACE *mris, double l_tsmooth)
{
  int     vno, n ;
  double  sse_tsmooth, v_sse, dn, dx, dy, dz, x, y, z, d0 ;
  VERTEX  *v, *vn ;

  if (FZERO(l_tsmooth))
  {
    return(0.0) ;
  }

  for (sse_tsmooth = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;
    d0 = SQR(x-v->origx)+SQR(y-v->origy)+SQR(z-v->origz) ;
    for (v_sse = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (!vn->ripflag)
      {
        dx = vn->x-vn->origx ;
        dy = vn->y-vn->origy ;
        dz = vn->z-vn->origz ;
        dn = (dx*dx+dy*dy+dz*dz) ;
        v_sse += (dn - d0) * (dn - d0) ;
      }
    }
    sse_tsmooth += v_sse ;
  }
  return(sse_tsmooth) ;
}
static float
mrisSampleMinimizationEnergy(MRI_SURFACE *mris,
                             VERTEX *v,
                             INTEGRATION_PARMS *parms, 
                             float cx, float cy, float cz)
{
  float   xw, yw, zw, dx, dy, dz, thick_sq, xp, yp, zp ;

  project_point_onto_sphere(cx, cy, cz, mris->radius, &cx, &cy, &cz) ;
  MRISvertexCoord2XYZ_float(v, WHITE_VERTICES, &xw, &yw, &zw) ;
  MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,
                                cx, cy, cz, PIAL_VERTICES, &xp, &yp, &zp);

  dx = xp-xw ;
  dy = yp - yw ;
  dz = zp - zw ;
  thick_sq = dx*dx + dy*dy + dz*dz ;

  return(thick_sq) ;
}
static int
project_point_onto_sphere(float cx, float cy, float cz, float radius, float *pcx, float *pcy, float *pcz)
{
  float x2, y2, z2, d, dist, dx, dy, dz ;

  x2 = cx*cx ;
  y2 = cy*cy ;
  z2 = cz*cz ;
  dist = sqrt(x2+y2+z2) ;
  if (FZERO(dist))
  {
    d = 0 ;
  }
  else
  {
    d = 1 - radius / dist ;
  }
  dx = d*cx ;
  dy = d*cy;
  dz = d*cz;
  *pcx = cx-dx ;
  *pcy = cy-dy;
  *pcz = cz-dz;
  return(NO_ERROR) ;
}

static float
mrisSampleParallelEnergyAtVertex(MRI_SURFACE *mris,
                                 VERTEX *v,
                                 INTEGRATION_PARMS *parms)
{
  float   xw, yw, zw, xp, yp, zp, dx, dy, dz, dxn, dyn, dzn,
    len, dxn_total, dyn_total, dzn_total ;
  int     n, num ;
  double  sse ;
  VERTEX  *vn ;

  MRISvertexCoord2XYZ_float(v, WHITE_VERTICES, &xw, &yw, &zw) ;
  MRISsampleFaceCoords(mris, v->fno, v->x, v->y, v->z, 
                       PIAL_VERTICES, CANONICAL_VERTICES, &xp, &yp, &zp);
#if 0
  {
    double  fdist ;
    int     fno ;
    FACE    *face ;
    float   xp2, yp2, zp2 ;

    MHTfindClosestFaceGeneric((MHT *)(parms->mht), mris, 
                              v->x, v->y, v->z, 4, 4, 1, &face, &fno, &fdist) ;
    if (fno != v->fno)
    {
      DiagBreak() ;
    }
    MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,
                                  v->x,v->y,v->z, PIAL_VERTICES, 
                                  &xp2, &yp2, &zp2);
    if (!FEQUAL(xp, xp2) || !FEQUAL(yp, yp2) || !FEQUAL(zp, zp2))
    {
      DiagBreak() ;
    }
    xp = xp2 ;
    yp = yp2 ;
    zp = zp2 ;
  }
#endif

  dx = xp-xw ;
  dy = yp - yw ;
  dz = zp - zw ;
  len = sqrt(dx*dx + dy*dy + dz*dz) ;
  if (FZERO(len))
  {
    return(0.0) ;
  }
  dx /= len ;
  dy /= len ;
  dz /= len ;

  dxn_total = dyn_total = dzn_total = 0.0 ;
  for (num = 0, sse = 0.0, n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]];
    if (vn->ripflag)
    {
      continue ;
    }
    MRISvertexCoord2XYZ_float(vn, WHITE_VERTICES, &xw, &yw, &zw) ;
    if (vn->fno >= 0)
    {
      MRISsampleFaceCoords(mris, vn->fno, vn->x, vn->y, vn->z, 
                           PIAL_VERTICES, CANONICAL_VERTICES, &xp, &yp, &zp);
    }
    else
    {
      MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,
                                    vn->x, vn->y, vn->z, 
                                    PIAL_VERTICES, &xp, &yp, &zp);
    }

    dxn = xp-xw ;
    dyn = yp - yw ;
    dzn = zp - zw ;
    len = sqrt(dxn*dxn + dyn*dyn + dzn*dzn) ;
    if (FZERO(len))
    {
      continue ;
    }
    dxn /= len ;
    dyn /= len ;
    dzn /= len ;

#if 1

    dxn_total += dxn ;
    dyn_total += dyn ;
    dzn_total += dzn ;
#else
#if 1
    sse += SQR(dxn-dx) + SQR(dyn-dy) + SQR(dzn-dz) ;
#else
    len = dx*dxn + dy*dyn + dz*dzn;  // dot product
    len = 1 - len;
    sse += sqrt(len*len);
#endif
#endif
    num++ ;
  }

  len = sqrt(dxn_total*dxn_total + dyn_total*dyn_total + dzn_total*dzn_total) ;
  if (len > 0)
  {
    dxn_total /= len ;
    dyn_total /= len ;
    dzn_total /= len ;
    sse = SQR(dxn_total-dx) + SQR(dyn_total-dy) + SQR(dzn_total-dz) ;
    //    sse /= num ;
  }

  return(sse) ;
}
static float
mrisSampleParallelEnergy(MRI_SURFACE *mris,
                         VERTEX *v,
                         INTEGRATION_PARMS *parms,
                         float cx, float cy, float cz)
{
  int     n, fno, old_fno, num ;
  double  sse, fdist ;
  FACE    *face ;
  float   x, y, z ;
  MHT     *mht = (MHT *)(parms->mht) ;
  VERTEX  *vn ;

  project_point_onto_sphere(cx, cy, cz, mris->radius, &cx, &cy, &cz) ;
  x = v->x ;
  y = v->y ;
  z = v->z ;     // store old coordinates
  old_fno = v->fno ;                   // store old face
  MHTfindClosestFaceGeneric(mht, mris, cx, cy, cz, 4, 4, 1, &face, &fno, &fdist) ;
  if (fno < 0)
  {
    MHTfindClosestFaceGeneric(mht, mris, cx, cy, cz, 
                              1000, -1, -1, &face, &fno, &fdist) ;
  }
  v->fno = fno ;

  v->x = cx ;
  v->y = cy ;
  v->z = cz ;  // change coords to here and compute effects on sse
  sse = mrisSampleParallelEnergyAtVertex(mris, v, parms) ;
  for (num = 1, n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;
    if (vn->ripflag)
    {
      continue ;
    }
    sse += mrisSampleParallelEnergyAtVertex(mris, vn, parms) ;
    num++ ;
  }

  v->x = x ;
  v->y = y ;
  v->z = z ;     // restore old coordinates
  v->fno = old_fno ;                   // restore old face
  sse /= (num) ;
  return(sse) ;
}

static float
mrisSampleNormalEnergy(MRI_SURFACE *mris,
                       VERTEX *v,
                       INTEGRATION_PARMS *parms,
                       float cx, float cy, float cz)
{
  float   dx, dy, dz, len, xw, yw, zw, xp, yp, zp ;
  double  sse ;

  if (v-mris->vertices == Gdiag_no)
  {
    DiagBreak();
  }
  project_point_onto_sphere(cx, cy, cz, mris->radius, &cx, &cy, &cz) ;
  MRISvertexCoord2XYZ_float(v, WHITE_VERTICES, &xw, &yw, &zw) ;
  MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris, 
                                cx, cy, cz, PIAL_VERTICES, &xp, &yp, &zp);

  dx = xp-xw ;
  dy = yp-yw ;
  dz = zp-zw ;
  len = sqrt(dx*dx + dy*dy + dz*dz) ;
  if (FZERO(len))
  {
    return(0.0) ;
  }
  dx /= len ;
  dy /= len ;
  dz /= len ;
  len = dx*v->wnx + dy*v->wny + dz*v->wnz;  // dot product
  len = 1 - len;
  sse = sqrt(len*len);
  sse = SQR(dx-v->wnx) + SQR(dy-v->wny) + SQR(dz-v->wnz) ;

  if (!devFinite(sse))
  {
    DiagBreak() ;
  }
  return(sse) ;
}

static float
mrisSampleSpringEnergy(MRI_SURFACE *mris,
                       VERTEX *v,
                       INTEGRATION_PARMS *parms,
                       float cx, float cy, float cz)
{
  int     n, fno, old_fno, num ;
  double  sse, fdist ;
  FACE    *face ;
  float   x, y, z ;
  MHT     *mht = (MHT *)(parms->mht) ;
  VERTEX  *vn ;

  project_point_onto_sphere(cx, cy, cz, mris->radius, &cx, &cy, &cz) ;
  x = v->x ;
  y = v->y ;
  z = v->z ;     // store old coordinates
  old_fno = v->fno ;                   // store old face
  MHTfindClosestFaceGeneric(mht, mris, cx, cy, cz, 
                            4, 4, 1, &face, &fno, &fdist) ;
  if (fno < 0)
  {
    MHTfindClosestFaceGeneric(mht, mris, cx, cy, cz, 
                              1000, -1, -1, &face, &fno, &fdist) ;
  }
  v->fno = fno ;

  v->x = cx ;
  v->y = cy ;
  v->z = cz ;  // change coords to here and compute effects on sse
  sse = mrisSampleSpringEnergyAtVertex(mris, v, parms) ;
  for (num = 1, n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;
    if (vn->ripflag)
    {
      continue ;
    }
    sse += mrisSampleSpringEnergyAtVertex(mris, vn, parms) ;
    num++ ;
  }

  v->x = x ;
  v->y = y ;
  v->z = z ;     // restore old coordinates
  v->fno = old_fno ;                   // restore old face
  sse /= (num) ;
  return(sse) ;
}
static float
mrisSampleSpringEnergyAtVertex(MRI_SURFACE *mris,
                               VERTEX *v,
                               INTEGRATION_PARMS *parms)
{
  float   xn, yn, zn, xp, yp, zp, xc, yc, zc ;
  double  sse ;
  int     n ;
  VERTEX  *vn ;

  if (v-mris->vertices == Gdiag_no)
  {
    DiagBreak();
  }
  MRISsampleFaceCoords(mris, v->fno, v->x, v->y, v->z, 
                       PIAL_VERTICES, CANONICAL_VERTICES, &xp, &yp, &zp);

  xc = yc = zc = 0 ;
  for (n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;
    MRISsampleFaceCoords(mris, vn->fno, vn->x, vn->y, vn->z, 
                         PIAL_VERTICES, CANONICAL_VERTICES,&xn,&yn,&zn);
    xc += xn ;
    yc += yn ;
    zc += zn ;
  }
  if (v->vnum > 0)
  {
    xc /= v->vnum ;
    yc /= v->vnum ;
    zc /= v->vnum ;
  }

  sse = SQR(xc-xp) + SQR(yc-yp) + SQR(zc-zp) ;

  if (!devFinite(sse))
  {
    DiagBreak() ;
  }
  return(sse) ;
}

static double
ashburnerTriangleEnergy(MRI_SURFACE *mris, int fno, double lambda)
{
  static MATRIX *m_x, *m_x_inv, *m_y, *m_J, *m_U, *m_V, *m_m, 
    *m_evectors = NULL ;
  FACE   *f ;
  VERTEX *v1, *v2, *v3 ;
  float  e1x, e1y, e1z, e2x, e2y, e2z , x11, x12, x13, x21, x22, x23, 
    y11, y12, y13, y21, y22, y23, evalues[2], det, s11, s22 ;
  double energy /*, a, b, c, d*/ ;

  if (m_x == NULL)
  {
    m_x = MatrixAlloc(3,3,MATRIX_REAL) ;
    m_m = MatrixAlloc(3,3,MATRIX_REAL) ;
    m_x_inv = MatrixAlloc(3,3,MATRIX_REAL) ;
    m_y = MatrixAlloc(3,3,MATRIX_REAL) ;
    m_J = MatrixAlloc(2,2,MATRIX_REAL) ;
    m_U = MatrixAlloc(2,2,MATRIX_REAL) ;
    m_V = MatrixAlloc(2,2,MATRIX_REAL) ;
  }

  f = &mris->faces[fno] ;
  if (fno == Gdiag_no || f->area < 0)
  {
    DiagBreak();
  }
  get_face_axes(mris, f, &e1x, &e1y, &e1z, &e2x, &e2y, &e2z) ;
  // first index refers to coord # and second to which vertex
  v1 = &mris->vertices[f->v[0]] ;
  v2 = &mris->vertices[f->v[1]] ;
  v3 = &mris->vertices[f->v[2]] ;

  // original coords in tangent plane
  x11 = v1->cx * e1x + v1->cy * e1y + v1->cz * e1z ;
  x21 = v1->cx * e2x + v1->cy * e2y + v1->cz * e2z ;
  x12 = v2->cx * e1x + v2->cy * e1y + v2->cz * e1z ;
  x22 = v2->cx * e2x + v2->cy * e2y + v2->cz * e2z ;
  x13 = v3->cx * e1x + v3->cy * e1y + v3->cz * e1z ;
  x23 = v3->cx * e2x + v3->cy * e2y + v3->cz * e2z ;

  // mapped coords in tangent plane
  y11 = v1->x * e1x + v1->y * e1y + v1->z * e1z ;
  y21 = v1->x * e2x + v1->y * e2y + v1->z * e2z ;
  y12 = v2->x * e1x + v2->y * e1y + v2->z * e1z ;
  y22 = v2->x * e2x + v2->y * e2y + v2->z * e2z ;
  y13 = v3->x * e1x + v3->y * e1y + v3->z * e1z ;
  y23 = v3->x * e2x + v3->y * e2y + v3->z * e2z ;


  *MATRIX_RELT(m_x, 1, 1) = x11 ;
  *MATRIX_RELT(m_x, 1, 2) = x12 ;
  *MATRIX_RELT(m_x, 1, 3) = x13 ;
  *MATRIX_RELT(m_x, 2, 1) = x21 ;
  *MATRIX_RELT(m_x, 2, 2) = x22 ;
  *MATRIX_RELT(m_x, 2, 3) = x23 ;
  *MATRIX_RELT(m_x, 3, 1) = 1.0 ;
  *MATRIX_RELT(m_x, 3, 2) = 1.0 ;
  *MATRIX_RELT(m_x, 3, 3) = 1.0 ;

  *MATRIX_RELT(m_y, 1, 1) = y11 ;
  *MATRIX_RELT(m_y, 1, 2) = y12 ;
  *MATRIX_RELT(m_y, 1, 3) = y13 ;
  *MATRIX_RELT(m_y, 2, 1) = y21 ;
  *MATRIX_RELT(m_y, 2, 2) = y22 ;
  *MATRIX_RELT(m_y, 2, 3) = y23 ;
  *MATRIX_RELT(m_y, 3, 1) = 1.0 ;
  *MATRIX_RELT(m_y, 3, 2) = 1.0 ;
  *MATRIX_RELT(m_y, 3, 3) = 1.0 ;

#define SMALL 1e-8
  if (MatrixInverse(m_x, m_x_inv) == NULL)
  {
    return(log(SMALL)*log(SMALL)) ;
  }
  MatrixMultiply(m_y, m_x_inv, m_m) ;
  MatrixCopyRegion(m_m, m_J, 1, 1, 2, 2, 1,1) ;
  //  MatrixSVDEigenValues(m_J, evalues) ;
  det = MatrixDeterminant(m_J) ;
  if (det < 0)
  {
    return(log(SMALL)*log(SMALL)) ;
  }
  m_evectors = MatrixEigenSystem(m_J, evalues, m_evectors) ;
  s11 = evalues[0] ;
  s22 = evalues[1] ;

#if 0
  a = *MATRIX_RELT(m_m, 1, 1) ;
  b = *MATRIX_RELT(m_m, 1, 2) ;
  c = *MATRIX_RELT(m_m, 2, 1) ;
  d = *MATRIX_RELT(m_m, 2, 2) ;
  det = a*d - b*c ;
  s11 = ((a+d)/2) + sqrt((4*b*c + (a-d)*(a-d)) / 2);
  s22 = ((a+d)/2) - sqrt((4*b*c + (a-d)*(a-d)) / 2);
#endif
  if (!finite(s11))
  {
    return(log(SMALL)*log(SMALL)) ;
  }
  if (!finite(s22))
  {
    return(log(SMALL)*log(SMALL)) ;
  }
  if (s11 <= 0)
  {
    s11 = SMALL ;
  }
  s11 = log(s11) ;
  s11 *= s11 ;

  if (s22 <= 0)
  {
    s22 = SMALL ;
  }
  s22 = log(s22) ;
  s22 *= s22 ;

  energy = lambda * (1 + det) * (s11 + s22) ;  // log and square of snn already taken

  if (!finite(energy))
  {
    DiagBreak() ;
  }
  return(energy/2) ;
}
static float
mrisSampleAshburnerTriangleEnergy(MRI_SURFACE *mris, VERTEX *v, INTEGRATION_PARMS *parms, float cx, float cy, float cz)
{
  double  sse, ox, oy, oz, sse_total ;
  int     n ;

  if (v-mris->vertices == Gdiag_no)
  {
    DiagBreak();
  }
  project_point_onto_sphere(cx, cy, cz, mris->radius, &cx, &cy, &cz) ;
  ox = v->x ;
  oy = v->y ;
  oz = v->z ;   //  save current location
  v->x = cx ;
  v->y = cy ;
  v->z = cz ;   // change location to compute energy
  for (sse_total = 0.0, n = 0 ; n < v->num ; n++)
  {
    sse = ashburnerTriangleEnergy(mris, v->f[n], parms->l_ashburner_lambda) ;
    if (sse < 0 || !finite(sse))
    {
      DiagBreak() ;
    }
    sse_total += sse ;
  }
  v->x = ox ;
  v->y = oy ;
  v->z = oz ;  // restore original location of vertex
  sse_total /= v->num ;
  return(sse_total) ;
}
#if 0
static int
mrisSamplePialCoordsInTangentPlane(MRI_SURFACE *mris, VERTEX *v, float x, float y, float z, float *pxp, float *pyp, float *pzp)
{
  double  d, xi, yi, zi, u0, v0, u1, v1, wt, wt_total ;
  int     n ;
  VERTEX  *vn ;

  u0 = v->pe1x * x + v->pe1y*y + v->pe1z * z ;  // project point onto tangent plane
  v0 = v->pe2x * x + v->pe2y*y + v->pe2z * z ;
  for (wt_total = 0.0, n = -1 ; n < v->vnum ; n++)
  {
    if (n < 0)
    {
      vn = v ;
    }
    else
    {
      vn = &mris->vertices[v->v[n]] ;
    }
    u1 = v->pe1x * vn->pialx + v->pe1y*vn->pialy + v->pe1z * vn->pialz ;  // project nbr onto tangent plane
    v1 = v->pe2x * vn->pialx + v->pe2y*vn->pialy + v->pe2z * vn->pialz ;
    d = sqrt(SQR(u1-u0) + SQR(v1-v0)) ;
#define WT_VAR (0.1*0.1)
    wt = exp(-d*d/(2*WT_VAR)) ;
    wt_total += wt ;
  }
  xi = yi = zi = 0 ;
  for (n = -1 ; n < v->vnum ; n++)
  {
    if (n < 0)
    {
      vn = v ;
    }
    else
    {
      vn = &mris->vertices[v->v[n]] ;
    }
    u1 = v->pe1x * vn->pialx + v->pe1y*vn->pialy + v->pe1z * vn->pialz ;  // project nbr onto tangent plane
    v1 = v->pe2x * vn->pialx + v->pe2y*vn->pialy + v->pe2z * vn->pialz ;
    d = sqrt(SQR(u1-u0) + SQR(v1-v0));
    wt = exp(-d*d/(2*WT_VAR)) ;
    xi += wt * vn->pialx ;
    yi += wt * vn->pialy ;
    zi += wt * vn->pialz ;
  }
  *pxp = xi/wt_total  ;
  *pyp = yi/wt_total ;
  *pzp = zi/wt_total ;
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeThicknessMinimizationEnergy(MRI_SURFACE *mris, double l_thick_min, INTEGRATION_PARMS *parms)
{
  int     vno, max_vno ;
  float   thick_sq ;
  double  sse_tmin, max_sse ;
  VERTEX  *v ;
  static  int cno = 0 ;
  static double last_sse[200000] ;

  if (FZERO(l_thick_min))
  {
    return(0.0) ;
  }

  if (cno == 0)
  {
    memset(last_sse, 0, sizeof(last_sse)) ;
  }
  cno++ ;

  max_sse = 0.0 ;
  max_vno = -1 ;
  for (sse_tmin = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    thick_sq = mrisSampleMinimizationEnergy(mris, v, parms, v->x, v->y, v->z) ;

    // diagnostics
    if (thick_sq-last_sse[vno] > max_sse)
    {
      max_sse = thick_sq-last_sse[vno] ;
      max_vno = vno ;
    }
    if (thick_sq > last_sse[vno] && cno > 1 && vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (thick_sq > last_sse[vno] && cno > 1)
    {
      DiagBreak() ;
    }
    last_sse[vno] = thick_sq ;
    // diagnostics end

    v->curv = sqrt(thick_sq) ;
    sse_tmin += thick_sq ;
    if (Gdiag_no == vno)
    {
      printf("E_thick_min:  v %d @ (%2.2f, %2.2f, %2.2f): thick = %2.5f\n", vno, v->x, v->y, v->z, v->curv) ;
    }
  }
  sse_tmin /= 2 ;
  if (max_sse > 0 && DIAG_VERBOSE_ON)
    printf("max sse increase @ vno = %d, delta sse = %2.2f (now %2.2f, was %2.2f)\n",
           max_vno, max_sse, last_sse[vno], last_sse[vno]-max_sse) ;
  return(sse_tmin) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double big_sse = 10.0 ;
static double
mrisComputeThicknessNormalEnergy(MRI_SURFACE *mris, double l_thick_normal, INTEGRATION_PARMS *parms)
{
  int     vno, max_vno ;
  double  sse_tnormal, sse, max_sse ;
  VERTEX  *v ;
  static  int cno = 0 ;
  static double last_sse[200000] ;


  if (FZERO(l_thick_normal))
  {
    return(0.0) ;
  }

  if (cno == 0)
  {
    memset(last_sse, 0, sizeof(last_sse)) ;
  }
  cno++ ;

  max_sse = 0.0 ;
  for (sse_tnormal = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    sse = mrisSampleNormalEnergy(mris, v, parms, v->x, v->y, v->z);
    if (sse > big_sse)
    {
      DiagBreak() ;
    }

    if (sse-last_sse[vno] > max_sse)
    {
      max_sse = sse-last_sse[vno] ;
      max_vno = vno ;
    }
    if (sse > last_sse[vno] && cno > 1 && vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (sse > last_sse[vno] && cno > 1)
    {
      DiagBreak() ;
    }
    sse_tnormal += sse ;
    last_sse[vno] = sse ;
    if (Gdiag_no == vno)
    {
      float  E ;
      float   dx, dy, dz, len, xw, yw, zw, xp, yp, zp, cx,cy, cz ;

      cx = v->x ;
      cy = v->y ;
      cz = v->z ;
      E = mrisSampleNormalEnergy(mris, v, parms, v->x, v->y,  v->z) ;
      MRISvertexCoord2XYZ_float(v, WHITE_VERTICES, &xw, &yw, &zw) ;
      MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,cx,cy,cz, PIAL_VERTICES, &xp, &yp, &zp);
      dx = xp-xw ;
      dy = yp-yw ;
      dz = zp-zw ;
      len = sqrt(dx*dx + dy*dy + dz*dz) ;
      if (FZERO(len) == 0)
      {
        dx /= len ;
        dy /= len ;
        dz /= len ;
      }
      printf("E_thick_normal: vno %d, E=%f, N = (%2.2f, %2.2f, %2.2f), D = (%2.2f, %2.2f, %2.2f), dot= %f\n",
             vno, E, v->wnx, v->wny, v->wnz, dx, dy, dz,
             v->wnx*dx + v->wny*dy + v->wnz*dz);

    }
  }
  sse_tnormal /= 2 ;
  return(sse_tnormal) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeThicknessSpringEnergy(MRI_SURFACE *mris, double l_thick_spring, INTEGRATION_PARMS *parms)
{
  int     vno ;
  double  sse_spring, sse ;
  VERTEX  *v ;

  if (FZERO(l_thick_spring))
  {
    return(0.0) ;
  }

  for (sse_spring = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    sse = mrisSampleSpringEnergy(mris, v, parms, v->x, v->y, v->z);

    sse_spring += sse ;
    if (Gdiag_no == vno)
    {
      float  E ;
      float   dx, dy, dz, len, xw, yw, zw, xp, yp, zp, cx,cy, cz ;

      cx = v->x ;
      cy = v->y ;
      cz = v->z ;
      E = mrisSampleSpringEnergy(mris, v, parms, v->x, v->y,  v->z) ;
      MRISvertexCoord2XYZ_float(v, WHITE_VERTICES, &xw, &yw, &zw) ;
      MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,cx,cy,cz, PIAL_VERTICES, &xp, &yp, &zp);
      dx = xp-xw ;
      dy = yp-yw ;
      dz = zp-zw ;
      len = sqrt(dx*dx + dy*dy + dz*dz) ;
      if (FZERO(len) == 0)
      {
        dx /= len ;
        dy /= len ;
        dz /= len ;
      }
      printf("E_thick_spring: vno %d, E=%f, N = (%2.2f, %2.2f, %2.2f), D = (%2.2f, %2.2f, %2.2f), dot= %f\n",
             vno, E, v->wnx, v->wny, v->wnz, dx, dy, dz,
             v->wnx*dx + v->wny*dy + v->wnz*dz);

    }
  }
  sse_spring /= 2 ;
  return(sse_spring) ;
}
static int
mrisAssignFaces(MRI_SURFACE *mris, MHT *mht, int which_vertices)
{
  int     vno, fno ;
  VERTEX *v ;
  double fdist ;
  FACE   *face ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    project_point_onto_sphere(v->x, v->y, v->z, mris->radius, &v->x, &v->y, &v->z) ;
    MHTfindClosestFaceGeneric(mht, mris, v->x, v->y, v->z, 8, 8, 1, &face, &fno, &fdist) ;
    if (fno < 0)
    {
      MHTfindClosestFaceGeneric(mht, mris, v->x, v->y, v->z, 1000, -1, -1, &face, &fno, &fdist) ;
    }
    v->fno = fno ;
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeThicknessParallelEnergy(MRI_SURFACE *mris, double l_thick_parallel, INTEGRATION_PARMS *parms)
{
  int     vno, max_vno ;
  double  sse_tparallel, sse, max_sse ;
  VERTEX  *v ;
  static  int cno = 0 ;
  static double last_sse[200000] ;

  if (FZERO(l_thick_parallel))
  {
    return(0.0) ;
  }
  if (cno == 0)
  {
    memset(last_sse, 0, sizeof(last_sse)) ;
  }
  cno++ ;

  mrisAssignFaces(mris, (MHT *)(parms->mht), CANONICAL_VERTICES) ;  // don't look it up every time
  max_sse = 0.0 ;
  for (sse_tparallel = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    sse = mrisSampleParallelEnergy(mris, v, parms, v->x, v->y, v->z);
    if (sse > big_sse)
    {
      DiagBreak() ;
    }
    if (sse > max_sse)
    {
      max_sse = sse ;
      max_vno = vno ;
    }
    if (sse > last_sse[vno] && cno > 1 && vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (sse > last_sse[vno] && cno > 1)
    {
      DiagBreak() ;
    }
    last_sse[vno] = sse ;
    sse_tparallel += sse ;
    if (vno == Gdiag_no)
    {
      printf("E_parallel: vno = %d, E = %f\n", vno, sse) ;
    }
  }
  sse_tparallel /= 2 ;
  return(sse_tparallel) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeAshburnerTriangleEnergy(MRI_SURFACE *mris, double l_ashburner_triangle, INTEGRATION_PARMS *parms)
{
  int     vno, max_vno = -1 ;
  double  sse_ashburner, sse, max_sse = 0.0 ;
  VERTEX  *v ;

  if (FZERO(l_ashburner_triangle))
  {
    return(0.0) ;
  }

  mrisAssignFaces(mris, (MHT *)(parms->mht), CANONICAL_VERTICES) ;  // don't look it up every time
  for (sse_ashburner = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    sse = mrisSampleAshburnerTriangleEnergy(mris, v, parms, v->x, v->y, v->z);
    if (sse < 0)
    {
      DiagBreak() ;
    }
    if (sse > max_sse)
    {
      max_sse = sse ;
      max_vno = vno ;
    }
    sse_ashburner += sse ;
    if (vno == Gdiag_no)
    {
      printf("E_ash_triangle: vno = %d, E = %f\n", vno, sse) ;
    }
  }
  sse_ashburner /= 2 ;
  return(sse_ashburner) ;
}
#if 1
// debugged and working, but not needed at the moment
static int
get_face_axes(MRI_SURFACE *mris, FACE *face, float *pe1x, float *pe1y, float *pe1z,
              float *pe2x, float *pe2y, float *pe2z)
{
  double V0[3], V1[3], V2[3], e1[3], e2[3], tmp[3], norm, dot ;

  V0[0] = mris->vertices[face->v[0]].x ;
  V0[1] = mris->vertices[face->v[0]].y ;
  V0[2] = mris->vertices[face->v[0]].z ;
  V1[0] = mris->vertices[face->v[1]].x ;
  V1[1] = mris->vertices[face->v[1]].y ;
  V1[2] = mris->vertices[face->v[1]].z ;
  V2[0] = mris->vertices[face->v[2]].x ;
  V2[1] = mris->vertices[face->v[2]].y ;
  V2[2] = mris->vertices[face->v[2]].z ;

  // first basis vector
  SUB(e1, V1, V0) ;
  norm = VLEN(e1) ;
  if (FZERO(norm))  // degenerate case - not much to do
  {
    VERTEX *v = &mris->vertices[face->v[0]] ;
    *pe1x = v->e1x ;
    *pe1y = v->e1y ;
    *pe1z = v->e1z ;
    *pe2x = v->e2x ;
    *pe2y = v->e2y ;
    *pe2z = v->e2z ;
    return(NO_ERROR) ;
  }
  SCALAR_MUL(e1, 1.0/norm, e1) ;

  // project 1st basis vector out of 2nd to orthonormalize it
  SUB(e2, V2, V0) ;
  norm = VLEN(e2) ;
  if (FZERO(norm))  // degenerate case - not much to do
  {
    VERTEX *v = &mris->vertices[face->v[0]] ;
    *pe1x = v->e1x ;
    *pe1y = v->e1y ;
    *pe1z = v->e1z ;
    *pe2x = v->e2x ;
    *pe2y = v->e2y ;
    *pe2z = v->e2z ;
    return(NO_ERROR) ;
  }
  SCALAR_MUL(e2, 1.0/norm, e2) ;
  dot = DOT(e1, e2) ;
  SCALAR_MUL(tmp, dot, e1) ;
  SUB(e2, e2, tmp) ;
  norm = VLEN(e2) ;
  if (FZERO(norm))  // degenerate case - not much to do
  {
    VERTEX *v = &mris->vertices[face->v[0]] ;
    *pe1x = v->e1x ;
    *pe1y = v->e1y ;
    *pe1z = v->e1z ;
    *pe2x = v->e2x ;
    *pe2y = v->e2y ;
    *pe2z = v->e2z ;
    return(NO_ERROR) ;
  }
  SCALAR_MUL(e2, 1.0/norm, e2) ;

  *pe1x = e1[0] ;
  *pe1y = e1[1] ;
  *pe1z = e1[2] ;
  *pe2x = e2[0] ;
  *pe2y = e2[1] ;
  *pe2z = e2[2] ;
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeThicknessMinimizationTerm(MRI_SURFACE *mris, double l_thick_min, INTEGRATION_PARMS *parms)
{
  int     vno, max_vno ;
  float   dE_de1, dE_de2, e1p, e1m, e2p, e2m  ;
  float   e1x, e1y, e1z, e2x, e2y, e2z, max_DE, norm, dx, dy, dz, E0, E1 ;
  VERTEX  *v ;
  double  d_dist = D_DIST ;

  if (FZERO(l_thick_min))
  {
    return(0.0) ;
  }

  max_DE = 0 ;
  max_vno = 0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    e1x = v->e1x ;
    e1y = v->e1y ;
    e1z = v->e1z ;
    e2x = v->e2x ;
    e2y = v->e2y ;
    e2z = v->e2z ;
#if 0
    MHTfindClosestFaceGeneric((MHT *)(parms->mht), mris, v->x, v->y, v->z, 4, 4, 1, &face, &fno, &fdist) ;
    if (face == NULL)
    {
      MHTfindClosestFaceGeneric((MHT *)(mris->mht), mris, v->x,v->y,v->z, 1000, -1, -1, &face, &fno, &fdist);
    }
    if (face == NULL)
    {
      continue ;  // shouldn't happen
    }
#endif

    /*
      sample the coordinate functions along the tangent plane axes and
      compute the derivates using them.
    */
    e1p = mrisSampleMinimizationEnergy(mris, v, parms, v->x+d_dist*e1x,  v->y+d_dist*e1y,  v->z+d_dist*e1z) ;
    e1m = mrisSampleMinimizationEnergy(mris, v, parms, v->x-d_dist*e1x,  v->y-d_dist*e1y,  v->z-d_dist*e1z) ;
    e2p = mrisSampleMinimizationEnergy(mris, v, parms, v->x+d_dist*e2x,  v->y+d_dist*e2y,  v->z+d_dist*e2z) ;
    e2m = mrisSampleMinimizationEnergy(mris, v, parms, v->x-d_dist*e2x,  v->y-d_dist*e2y,  v->z-d_dist*e2z) ;
    dE_de1 = (e1p - e1m) / (2 * d_dist) ;
    dE_de2 = (e2p - e2m) / (2 * d_dist) ;

    norm = sqrt(dE_de1*dE_de1 + dE_de2*dE_de2) ;
    if (norm > max_DE)
    {
      max_vno = vno ;
      max_DE = norm ;
    }
    if (norm > 1)
    {
      dE_de1 /= norm ;
      dE_de2 /= norm ;
    }

    dx = -l_thick_min * (dE_de1 * e1x + dE_de2 * e2x) ;
    dy = -l_thick_min * (dE_de1 * e1y + dE_de2 * e2y) ;
    dz = -l_thick_min * (dE_de1 * e1z + dE_de2 * e2z) ;
    E0 = mrisSampleMinimizationEnergy(mris, v, parms, v->x,  v->y,  v->z) ;
    E1 = mrisSampleMinimizationEnergy(mris, v, parms, v->x+parms->dt*dx, v->y+parms->dt*dy, v->z+parms->dt*dz);

    if (E1 > E0)
    {
      double E2 ;

      DiagBreak() ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      E2 = mrisSampleMinimizationEnergy(mris, v, parms, v->x-parms->dt*dx, v->y-parms->dt*dy, v->z-parms->dt*dz);
      if (E2 < E0)
      {
        dx *= -1 ;
        dy *= -1 ;
        dz *= -1 ;
      }
      else
      {
        dx = dy = dz = 0 ;
      }
    }
    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
    if (Gdiag_no == vno)
    {
      printf("l_thick_min: v %d: E0 %2.3f, E1 %2.3f, dE = (%2.2f, %2.2f), e1 = (%2.1f, %2.1f, %2.1f), e2 = (%2.1f, %2.1f, %2.1f), DX = (%2.2f, %2.2f, %2.2f)\n",

             vno, sqrt(E0), sqrt(E1), dE_de1, dE_de2, e1x, e1y, e1z, e2x, e2y, e2z,
             l_thick_min * (dE_de1 * e1x + dE_de2 * e2x),
             l_thick_min * (dE_de1 * e1y + dE_de2 * e2y),
             l_thick_min * (dE_de1 * e1z + dE_de2 * e2z)) ;

    }
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    printf("Thick Min: max dE = %2.2f at vno %d\n", max_DE, max_vno) ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeThicknessParallelTerm(MRI_SURFACE *mris, double l_thick_parallel, INTEGRATION_PARMS *parms)
{
  int     vno, max_vno ;
  float   dE_de1, dE_de2, e1p, e1m, e2p, e2m, dx, dy, dz  ;
  float   e1x, e1y, e1z, e2x, e2y, e2z, max_DE, norm, E0, E1 ;
  VERTEX  *v ;

  if (FZERO(l_thick_parallel))
  {
    return(0.0) ;
  }

  mrisAssignFaces(mris, (MHT *)(parms->mht), CANONICAL_VERTICES) ;  // don't look it up every time
  max_DE = 0 ;
  max_vno = 0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    e1x = v->e1x ;
    e1y = v->e1y ;
    e1z = v->e1z ;
    e2x = v->e2x ;
    e2y = v->e2y ;
    e2z = v->e2z ;
    /*
      sample the coordinate functions along the tangent plane axes and
      compute the derivates using them.
    */
    e1p = mrisSampleParallelEnergy(mris, v, parms, v->x+D_DIST*e1x,  v->y+D_DIST*e1y,  v->z+D_DIST*e1z) ;
    e1m = mrisSampleParallelEnergy(mris, v, parms, v->x-D_DIST*e1x,  v->y-D_DIST*e1y,  v->z-D_DIST*e1z) ;
    e2p = mrisSampleParallelEnergy(mris, v, parms, v->x+D_DIST*e2x,  v->y+D_DIST*e2y,  v->z+D_DIST*e2z) ;
    e2m = mrisSampleParallelEnergy(mris, v, parms, v->x-D_DIST*e2x,  v->y-D_DIST*e2y,  v->z-D_DIST*e2z) ;
    dE_de1 = (e1p - e1m) / (2 * D_DIST) ;
    dE_de2 = (e2p - e2m) / (2 * D_DIST) ;
    norm = sqrt(dE_de1*dE_de1 + dE_de2*dE_de2) ;
    if (norm > max_DE)
    {
      max_vno = vno ;
      max_DE = norm ;
    }
    if (norm > 1)
    {
      dE_de1 /= norm ;
      dE_de2 /= norm ;
    }

    dx = -l_thick_parallel * (dE_de1 * e1x + dE_de2 * e2x) ;
    dy = -l_thick_parallel * (dE_de1 * e1y + dE_de2 * e2y) ;
    dz = -l_thick_parallel * (dE_de1 * e1z + dE_de2 * e2z) ;
    E0 = mrisSampleParallelEnergy(mris, v, parms, v->x,  v->y,  v->z) ;
    E1 = mrisSampleParallelEnergy(mris, v, parms, v->x+parms->dt*dx,  v->y+parms->dt*dy,  v->z+parms->dt*dz) ;
    if (E1 > E0)
    {
      double E2 ;
      DiagBreak() ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      E2 = mrisSampleParallelEnergy(mris, v, parms, v->x-parms->dt*dx, v->y-parms->dt*dy, v->z-parms->dt*dz);
      if (E2 < E0)
      {
        dx *= -1 ;
        dy *= -1 ;
        dz *= -1 ;
      }
      else
      {
        dx = dy = dz = 0 ;
      }
    }
    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
    if (Gdiag_no == vno)
    {
      printf("l_thick_parallel: v %d: E0=%f, E1=%f, dE = (%2.3f, %2.3f), e1 = (%2.1f, %2.1f, %2.1f), e2 = (%2.1f, %2.1f, %2.1f), DX = (%2.3f, %2.3f, %2.3f)\n",

             vno, E0, E1, dE_de1, dE_de2, e1x, e1y, e1z, e2x, e2y, e2z, parms->dt*dx, parms->dt*dy, parms->dt*dz) ;

    }
  }
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    printf("Parallel: max dE = %2.3f at vno %d\n", max_DE, max_vno) ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#define MAX_NORM 0.1
#if 0
static int
mrisComputeThicknessNormalTerm(MRI_SURFACE *mris, double l_thick_normal, INTEGRATION_PARMS *parms)
{
  int     vno, fno ;
  FACE    *face ;
  double  dxc, dyc, dzc, fdist ;
  float   dx, dy, dz, xw, yw, zw, dxn, dyn, dzn ;
  float   dxp_dxc, dyp_dxc, dzp_dxc,
          dxp_dyc, dyp_dyc, dzp_dyc,
          dxp_dzc, dyp_dzc, dzp_dzc ;
  float   e1x, e1y, e1z, e2x, e2y, e2z, norm, e1dot, e2dot ;
  float   xp, yp, zp, xpP, xpM, ypP, ypM, zpP, zpM ;
  VERTEX  *v ;

  if (FZERO(l_thick_normal))
  {
    return(0.0) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    MRISvertexCoord2XYZ_float(v, WHITE_VERTICES, &xw, &yw, &zw) ;
    MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,v->x,v->y,v->z, PIAL_VERTICES, &xp, &yp, &zp);
    dxn = xp-xw ;
    dyn = yp-yw ;
    dzn = zp-zw ;
    norm = sqrt(dxn*dxn + dyn*dyn + dzn*dzn) ;
    if (!FZERO(norm))
    {
      dxn /= norm ;
      dyn /= norm ;
      dzn /= norm ;
    }
    dx = dxn-v->wnx ;
    dy = dyn-v->wny ;
    dz = dzn-v->wnz ;
    dx *= -1 ;
    dy *= -1 ;
    dz *= -1 ; // move in -gradient direction

    e1x = v->e1x ;
    e1y = v->e1y ;
    e1z = v->e1z ;
    e2x = v->e2x ;
    e2y = v->e2y ;
    e2z = v->e2z ;

#define NSAMPLE_DIST   .1
    // d / dxc
    MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,
                                  v->x+NSAMPLE_DIST,v->y,v->z, PIAL_VERTICES, &xpP, &ypP, &zpP);
    MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,
                                  v->x-NSAMPLE_DIST,v->y,v->z, PIAL_VERTICES, &xpM, &ypM, &zpM);
    MHTfindClosestFaceGeneric((MHT *)(parms->mht), mris, v->x,v->y,v->z, 1000, -1, 1, &face, &fno, &fdist) ;
    MRISsampleFaceCoords(mris, fno,
                         v->x+NSAMPLE_DIST,v->y,v->z, WHITE_VERTICES, &xpP, &ypP, &zpP);
    MRISsampleFaceCoords(mris, fno,
                         v->x-NSAMPLE_DIST,v->y,v->z, WHITE_VERTICES, &xpM, &ypM, &zpM);
    dxp_dxc = (xpP - xpM) / (2*NSAMPLE_DIST) ;
    dyp_dxc = (ypP - ypM) / (2*NSAMPLE_DIST) ;
    dzp_dxc = (zpP - zpM) / (2*NSAMPLE_DIST) ;


    // d / dyc
    MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,
                                  v->x,v->y+NSAMPLE_DIST,v->z, PIAL_VERTICES, &xpP, &ypP, &zpP);
    MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,
                                  v->x,v->y-NSAMPLE_DIST,v->z, PIAL_VERTICES, &xpM, &ypM, &zpM);
    MRISsampleFaceCoords(mris, fno,
                         v->x,v->y+NSAMPLE_DIST,v->z, WHITE_VERTICES, &xpP, &ypP, &zpP);
    MRISsampleFaceCoords(mris, fno,
                         v->x,v->y-NSAMPLE_DIST,v->z, WHITE_VERTICES, &xpM, &ypM, &zpM);
    dxp_dyc = (xpP - xpM) / (2*NSAMPLE_DIST) ;
    dyp_dyc = (ypP - ypM) / (2*NSAMPLE_DIST) ;
    dzp_dyc = (zpP - zpM) / (2*NSAMPLE_DIST) ;

    // d / dzc
    MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,
                                  v->x,v->y,v->z+NSAMPLE_DIST, PIAL_VERTICES, &xpP, &ypP, &zpP);
    MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,
                                  v->x,v->y,v->z-NSAMPLE_DIST, PIAL_VERTICES, &xpM, &ypM, &zpM);
    MRISsampleFaceCoords(mris, fno,
                         v->x,v->y,v->z+NSAMPLE_DIST, WHITE_VERTICES, &xpP, &ypP, &zpP);
    MRISsampleFaceCoords(mris, fno,
                         v->x,v->y,v->z-NSAMPLE_DIST, WHITE_VERTICES, &xpM, &ypM, &zpM);
    dxp_dzc = (xpP - xpM) / (2*NSAMPLE_DIST) ;
    dyp_dzc = (ypP - ypM) / (2*NSAMPLE_DIST) ;
    dzp_dzc = (zpP - zpM) / (2*NSAMPLE_DIST) ;

    dxc = l_thick_normal * ((dx * dxp_dxc) + (dy * dyp_dxc) + (dz * dzp_dxc)) ;
    dyc = l_thick_normal * ((dx * dxp_dyc) + (dy * dyp_dyc) + (dz * dzp_dyc)) ;
    dzc = l_thick_normal * ((dx * dxp_dzc) + (dy * dyp_dzc) + (dz * dzp_dzc)) ;
    norm = sqrt(dxc*dxc + dyc*dyc + dzc*dzc) ;
    if (norm > MAX_NORM)
    {
      dxc = MAX_NORM * dxc / norm ;
      dyc = MAX_NORM * dyc / norm ;
      dzc = MAX_NORM * dzc / norm ;
    }
    // project onto tangent direction
    e1dot = e1x*dxc + e1y*dyc + e1z*e1z ;
    e2dot = e2x*dxc + e2y*dyc + e2z*e2z ;
    //    dxc = e1x*e1dot + e2x*e2dot ; dyc = e1y*e1dot + e2y*e2dot ; dzc = e1z*e1dot + e2z*e2dot ;
    v->dx += dxc ;
    v->dy += dyc ;
    v->dz += dzc ;
    if (Gdiag_no == vno)
    {
      double d=NSAMPLE_DIST ;

      MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,
                                    v->x+d*v->dx,v->y+d*v->dy,v->z+d*v->dz, PIAL_VERTICES,
                                    &xpP,&ypP,&zpP);
      MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,
                                    v->x-d*v->dx,v->y-d*v->dy,v->z-d*v->dz, PIAL_VERTICES,
                                    &xpM,&ypM,&zpM);

      if (((xpP-xpM) * dx < 0) ||
          ((ypP-ypM) * dy < 0) ||
          ((zpP-zpM) * dz < 0))
      {
        DiagBreak() ;
      }
      printf("l_thick_normal: v %d: fno = %d, DX = (%2.2f, %2.2f, %2.2f)\n", vno, fno, dxc, dyc, dzc) ;
      printf("    N = (%2.2f, %2.2f, %2.2f), D = (%2.2f, %2.2f, %2.2f), dot= %f\n",
             v->wnx, v->wny, v->wnz, dxn, dyn, dzn,
             v->wnx*dxn + v->wny*dyn + v->wnz*dzn);
      DiagBreak() ;
    }
  }
  return(NO_ERROR) ;
}
#else
static int
mrisComputeThicknessNormalTerm(MRI_SURFACE *mris, double l_thick_normal, INTEGRATION_PARMS *parms)
{
  int     vno, max_vno ;
  float   dE_de1, dE_de2, e1p, e1m, e2p, e2m, cx, cy, cz  ;
  float   E0, E1, dx, dy, dz ;
  float   e1x, e1y, e1z, e2x, e2y, e2z, max_DE, norm ;
  VERTEX  *v ;
  //  int     missed = 0 ;


  if (FZERO(l_thick_normal))
  {
    return(0.0) ;
  }

  max_DE = 0 ;
  max_vno = 0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }

#if 0
    MHTfindClosestFaceGeneric((MHT *)(parms->mht), mris, v->x, v->y, v->z, 1000, -1, 1, &face, &fno, &fdist) ;
    if (face_barycentric_coords(mris, fno, CANONICAL_VERTICES, v->x, v->y, v->z, NULL,NULL,NULL) <0)
    {
      missed++ ;
      continue ;
    }
#endif

    e1x = v->e1x ;
    e1y = v->e1y ;
    e1z = v->e1z ;
    e2x = v->e2x ;
    e2y = v->e2y ;
    e2z = v->e2z ;
    /*
      sample the coordinate functions along the tangent plane axes and
      compute the derivates using them.
    */
    e1p = mrisSampleNormalEnergy(mris, v, parms, v->x+D_DIST*e1x,  v->y+D_DIST*e1y,  v->z+D_DIST*e1z) ;
    e1m = mrisSampleNormalEnergy(mris, v, parms, v->x-D_DIST*e1x,  v->y-D_DIST*e1y,  v->z-D_DIST*e1z) ;
    e2p = mrisSampleNormalEnergy(mris, v, parms, v->x+D_DIST*e2x,  v->y+D_DIST*e2y,  v->z+D_DIST*e2z) ;
    e2m = mrisSampleNormalEnergy(mris, v, parms, v->x-D_DIST*e2x,  v->y-D_DIST*e2y,  v->z-D_DIST*e2z) ;
    dE_de1 = (e1p - e1m) / (2 * D_DIST) ;
    dE_de2 = (e2p - e2m) / (2 * D_DIST) ;
    norm = sqrt(dE_de1*dE_de1 + dE_de2*dE_de2) ;
    if (norm > max_DE)
    {
      max_vno = vno ;
      max_DE = norm ;
    }
    if (norm > MAX_NORM)
    {
      dE_de1 = MAX_NORM * dE_de1 / norm ;
      dE_de2 = MAX_NORM * dE_de2 / norm ;
    }

    dx = -l_thick_normal * (dE_de1 * e1x + dE_de2 * e2x) ;
    dy = -l_thick_normal * (dE_de1 * e1y + dE_de2 * e2y) ;
    dz = -l_thick_normal * (dE_de1 * e1z + dE_de2 * e2z) ;
    cx = v->x+parms->dt*dx ;
    cy = v->y+parms->dt*dy ;
    cz = v->z+parms->dt*dz ;
    E0 = mrisSampleNormalEnergy(mris, v, parms, v->x, v->y,  v->z) ;
    E1 = mrisSampleNormalEnergy(mris, v, parms, cx, cy,  cz) ;
    if (E1 > E0)
    {
      double E2 ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      DiagBreak() ;
      E2 = mrisSampleNormalEnergy(mris, v, parms, v->x-parms->dt*dx, v->y-parms->dt*dy, v->z-parms->dt*dz);
      if (E2 < E0)
      {
        dx *= -1 ;
        dy *= -1 ;
        dz *= -1 ;
      }
      else
      {
        dx = dy = dz = 0 ;
      }
    }
    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
    if (Gdiag_no == vno)
    {
      float   len, xw, yw, zw, xp, yp, zp ;

      MRISvertexCoord2XYZ_float(v, WHITE_VERTICES, &xw, &yw, &zw) ;
      MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,cx,cy,cz, PIAL_VERTICES, &xp, &yp, &zp);
      dx = xp-xw ;
      dy = yp-yw ;
      dz = zp-zw ;
      len = sqrt(dx*dx + dy*dy + dz*dz) ;
      if (FZERO(len) == 0)
      {
        dx /= len ;
        dy /= len ;
        dz /= len ;
      }

      printf("l_thick_normal: v %d: E=%f-->%f (%f), dE = (%2.2f, %2.2f), e1 = (%2.1f, %2.1f, %2.1f), e2 = (%2.1f, %2.1f, %2.1f), DX = (%2.2f, %2.2f, %2.2f)\n",

             vno, E0, E1, E0-E1, dE_de1, dE_de2, e1x, e1y, e1z, e2x, e2y, e2z,
             l_thick_normal * (dE_de1 * e1x + dE_de2 * e2x),
             l_thick_normal * (dE_de1 * e1y + dE_de2 * e2y),
             l_thick_normal * (dE_de1 * e1z + dE_de2 * e2z)) ;
      printf("    N = (%2.2f, %2.2f, %2.2f), D = (%2.2f, %2.2f, %2.2f), dot= %f\n",
             v->wnx, v->wny, v->wnz, dx, dy, dz,
             v->wnx*dx + v->wny*dy + v->wnz*dz);

    }

  }
  //  printf("%d faces missed (%2.2f%%)\n", missed, 100.0*missed/mris->nvertices) ;
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    printf("Parallel: max dE = %2.2f at vno %d\n", max_DE, max_vno) ;
  }
  return(NO_ERROR) ;
}
static int
mrisComputeThicknessSpringTerm(MRI_SURFACE *mris, double l_thick_spring, INTEGRATION_PARMS *parms)
{
  int     vno, max_vno ;
  float   dE_de1, dE_de2, e1p, e1m, e2p, e2m, cx, cy, cz  ;
  float   E0, E1, dx, dy, dz ;
  float   e1x, e1y, e1z, e2x, e2y, e2z, max_DE, norm ;
  VERTEX  *v ;
  //  int     missed = 0 ;


  if (FZERO(l_thick_spring))
  {
    return(0.0) ;
  }

  max_DE = 0 ;
  max_vno = 0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }

    e1x = v->e1x ;
    e1y = v->e1y ;
    e1z = v->e1z ;
    e2x = v->e2x ;
    e2y = v->e2y ;
    e2z = v->e2z ;
    /*
      sample the coordinate functions along the tangent plane axes and
      compute the derivates using them.
    */
    e1p = mrisSampleSpringEnergy(mris, v, parms, v->x+D_DIST*e1x,  v->y+D_DIST*e1y,  v->z+D_DIST*e1z) ;
    e1m = mrisSampleSpringEnergy(mris, v, parms, v->x-D_DIST*e1x,  v->y-D_DIST*e1y,  v->z-D_DIST*e1z) ;
    e2p = mrisSampleSpringEnergy(mris, v, parms, v->x+D_DIST*e2x,  v->y+D_DIST*e2y,  v->z+D_DIST*e2z) ;
    e2m = mrisSampleSpringEnergy(mris, v, parms, v->x-D_DIST*e2x,  v->y-D_DIST*e2y,  v->z-D_DIST*e2z) ;
    dE_de1 = (e1p - e1m) / (2 * D_DIST) ;
    dE_de2 = (e2p - e2m) / (2 * D_DIST) ;
    norm = sqrt(dE_de1*dE_de1 + dE_de2*dE_de2) ;
    if (norm > max_DE)
    {
      max_vno = vno ;
      max_DE = norm ;
    }
    if (norm > MAX_NORM)
    {
      dE_de1 = MAX_NORM * dE_de1 / norm ;
      dE_de2 = MAX_NORM * dE_de2 / norm ;
    }

    dx = -l_thick_spring * (dE_de1 * e1x + dE_de2 * e2x) ;
    dy = -l_thick_spring * (dE_de1 * e1y + dE_de2 * e2y) ;
    dz = -l_thick_spring * (dE_de1 * e1z + dE_de2 * e2z) ;
    cx = v->x+parms->dt*dx ;
    cy = v->y+parms->dt*dy ;
    cz = v->z+parms->dt*dz ;
    E0 = mrisSampleSpringEnergy(mris, v, parms, v->x, v->y,  v->z) ;
    E1 = mrisSampleSpringEnergy(mris, v, parms, cx, cy,  cz) ;
    if (E1 > E0)
    {
      double E2 ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      DiagBreak() ;
      E2 = mrisSampleSpringEnergy(mris, v, parms, v->x-parms->dt*dx, v->y-parms->dt*dy, v->z-parms->dt*dz);
      if (E2 < E0)
      {
        dx *= -1 ;
        dy *= -1 ;
        dz *= -1 ;
      }
      else
      {
        dx = dy = dz = 0 ;
      }
    }
    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
    if (Gdiag_no == vno)
    {
      float   len, xw, yw, zw, xp, yp, zp ;

      MRISvertexCoord2XYZ_float(v, WHITE_VERTICES, &xw, &yw, &zw) ;
      MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris,cx,cy,cz, PIAL_VERTICES, &xp, &yp, &zp);
      dx = xp-xw ;
      dy = yp-yw ;
      dz = zp-zw ;
      len = sqrt(dx*dx + dy*dy + dz*dz) ;
      if (FZERO(len) == 0)
      {
        dx /= len ;
        dy /= len ;
        dz /= len ;
      }

      printf("l_thick_spring: v %d: E=%f-->%f (%f), dE = (%2.2f, %2.2f), e1 = (%2.1f, %2.1f, %2.1f), e2 = (%2.1f, %2.1f, %2.1f), DX = (%2.2f, %2.2f, %2.2f)\n",

             vno, E0, E1, E0-E1, dE_de1, dE_de2, e1x, e1y, e1z, e2x, e2y, e2z,
             l_thick_spring * (dE_de1 * e1x + dE_de2 * e2x),
             l_thick_spring * (dE_de1 * e1y + dE_de2 * e2y),
             l_thick_spring * (dE_de1 * e1z + dE_de2 * e2z)) ;
      printf("    N = (%2.2f, %2.2f, %2.2f), D = (%2.2f, %2.2f, %2.2f), dot= %f\n",
             v->wnx, v->wny, v->wnz, dx, dy, dz,
             v->wnx*dx + v->wny*dy + v->wnz*dz);

    }

  }
  return(NO_ERROR) ;
}
#endif
static int
mrisComputeAshburnerTriangleTerm(MRI_SURFACE *mris, double l_ashburner_triangle, INTEGRATION_PARMS *parms)
{
  int     vno, max_vno ;
  float   dE_de1, dE_de2, e1p, e1m, e2p, e2m, cx, cy, cz  ;
  float   E0, E1, dx, dy, dz ;
  float   e1x, e1y, e1z, e2x, e2y, e2z, max_DE, norm ;
  VERTEX  *v ;
  //  int     missed = 0 ;


  if (FZERO(l_ashburner_triangle))
  {
    return(0.0) ;
  }

  max_DE = 0 ;
  max_vno = 0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }

    e1x = v->e1x ;
    e1y = v->e1y ;
    e1z = v->e1z ;
    e2x = v->e2x ;
    e2y = v->e2y ;
    e2z = v->e2z ;
    /*
      sample the coordinate functions along the tangent plane axes and
      compute the derivates using them.
    */
    e1p = mrisSampleAshburnerTriangleEnergy(mris, v, parms, v->x+D_DIST*e1x,  v->y+D_DIST*e1y,  v->z+D_DIST*e1z) ;
    e1m = mrisSampleAshburnerTriangleEnergy(mris, v, parms, v->x-D_DIST*e1x,  v->y-D_DIST*e1y,  v->z-D_DIST*e1z) ;
    e2p = mrisSampleAshburnerTriangleEnergy(mris, v, parms, v->x+D_DIST*e2x,  v->y+D_DIST*e2y,  v->z+D_DIST*e2z) ;
    e2m = mrisSampleAshburnerTriangleEnergy(mris, v, parms, v->x-D_DIST*e2x,  v->y-D_DIST*e2y,  v->z-D_DIST*e2z) ;
    dE_de1 = (e1p - e1m) / (2 * D_DIST) ;
    dE_de2 = (e2p - e2m) / (2 * D_DIST) ;
    norm = sqrt(dE_de1*dE_de1 + dE_de2*dE_de2) ;
    if (norm > max_DE)
    {
      max_vno = vno ;
      max_DE = norm ;
    }
    if (norm > MAX_NORM)
    {
      dE_de1 = MAX_NORM * dE_de1 / norm ;
      dE_de2 = MAX_NORM * dE_de2 / norm ;
    }

    dx = -l_ashburner_triangle * (dE_de1 * e1x + dE_de2 * e2x) ;
    dy = -l_ashburner_triangle * (dE_de1 * e1y + dE_de2 * e2y) ;
    dz = -l_ashburner_triangle * (dE_de1 * e1z + dE_de2 * e2z) ;
    cx = v->x+parms->dt*dx ;
    cy = v->y+parms->dt*dy ;
    cz = v->z+parms->dt*dz ;
    E0 = mrisSampleAshburnerTriangleEnergy(mris, v, parms, v->x, v->y,  v->z) ;
    E1 = mrisSampleAshburnerTriangleEnergy(mris, v, parms, cx, cy,  cz) ;
    if (E1 > E0)
    {
      double E2 ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      DiagBreak() ;
      E2 = mrisSampleAshburnerTriangleEnergy(mris, v, parms, v->x-parms->dt*dx, v->y-parms->dt*dy, v->z-parms->dt*dz);
      if (E2 < E0)
      {
        dx *= -1 ;
        dy *= -1 ;
        dz *= -1 ;
      }
      else
      {
        dx = dy = dz = 0 ;
      }
    }
    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
    if (Gdiag_no == vno)
    {
      printf("l_ashburner_triangle: v %d: E=%f-->%f (%f), dE = (%2.2f, %2.2f), e1 = (%2.1f, %2.1f, %2.1f), e2 = (%2.1f, %2.1f, %2.1f), DX = (%2.2f, %2.2f, %2.2f)\n",

             vno, E0, E1, E0-E1, dE_de1, dE_de2, e1x, e1y, e1z, e2x, e2y, e2z,
             l_ashburner_triangle * (dE_de1 * e1x + dE_de2 * e2x),
             l_ashburner_triangle * (dE_de1 * e1y + dE_de2 * e2y),
             l_ashburner_triangle * (dE_de1 * e1z + dE_de2 * e2z)) ;
    }

  }
  //  printf("%d faces missed (%2.2f%%)\n", missed, 100.0*missed/mris->nvertices) ;
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    printf("Parallel: max dE = %2.2f at vno %d\n", max_DE, max_vno) ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
static double
mrisComputeRepulsiveEnergy(MRI_SURFACE *mris, double l_repulse)
{
  int     vno, n ;
  double  sse_repulse, v_sse, dist, dx, dy, dz, x, y, z ;
  VERTEX  *v, *vn ;

  if (FZERO(l_repulse))
  {
    return(0.0) ;
  }

  for (sse_repulse = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;
    for (v_sse = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (!vn->ripflag)
      {
        dx = x - vn->x ;
        dy = y - vn->y ;
        dz = z - vn->z ;
        dist = sqrt(dx*dx+dy*dy+dz*dz) + REPULSE_E ;
        v_sse += REPULSE_K / (dist*dist*dist*dist) ;
      }
    }
    sse_repulse += v_sse ;
  }
  return(l_repulse * sse_repulse) ;
}
#else
static double
mrisComputeRepulsiveEnergy(MRI_SURFACE *mris, double l_repulse, MHT *mht,
                           MHT *mht_faces)
{
  int     vno, num, min_vno, i, n ;
  float   dist, dx, dy, dz, x, y, z, min_d ;
  double  sse_repulse, v_sse ;
  VERTEX  *v, *vn ;
  MHBT    *bucket ;
  MHB     *bin ;
#if 0
  int     in_face ;
  float   fx, fy, fz ;
  FACE    *f ;
#endif

  if (FZERO(l_repulse))
  {
    return(NO_ERROR) ;
  }

  min_d = 1000.0 ;
  min_vno = 0 ;
  for (sse_repulse = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;
    bucket = MHTgetBucket(mht, x, y, z) ;
    if (!bucket)
    {
      continue ;
    }
    for (v_sse = 0.0, bin = bucket->bins, num = i = 0 ;
         i < bucket->nused ;
         i++, bin++)
    {
      if (bin->fno == vno)
      {
        continue ;  /* don't be repelled by myself */
      }
      for (n = 0 ; n < v->vtotal ; n++)
        if (v->v[n] == bin->fno)
        {
          break ;
        }
      if (n < v->vtotal)   /* don't be repelled by a neighbor */
      {
        continue ;
      }
      vn = &mris->vertices[bin->fno] ;
      if (!vn->ripflag)
      {
        dx = vn->x - x ;
        dy = vn->y - y ;
        dz = vn->z - z ;
        dist = sqrt(dx*dx+dy*dy+dz*dz) + REPULSE_E ;
        if (vno == Gdiag_no)
        {
          if (dist-REPULSE_E < min_d)
          {
            min_vno = bin->fno ;
            min_d = dist-REPULSE_E ;
          }
        }
        dist = dist*dist*dist ;
        dist *= dist ; /* dist^6 */
        v_sse += REPULSE_K / dist ;
      }
    }
    sse_repulse += v_sse ;

    if (vno == Gdiag_no && !FZERO(v_sse))
    {
      printf("v %d: repulse sse:    min_dist=%2.4f, v_sse %2.4f\n", vno,
             min_d, v_sse) ;
    }
  }

#if 0
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;
    bucket = MHTgetBucket(mht_faces, x, y, z) ;
    if (!bucket)
    {
      continue ;
    }
    for (v_sse = 0.0, bin = bucket->bins, num = i = 0 ;
         i < bucket->nused ;
         i++, bin++)
    {
      f = &mris->faces[bin->fno] ;
      fx = fy = fz = 0 ;
      for (in_face = n = 0 ; n < VERTICES_PER_FACE ; n++)
      {
        fx += mris->vertices[f->v[n]].x ;
        fy += mris->vertices[f->v[n]].y ;
        fz += mris->vertices[f->v[n]].z ;
        if (f->v[n] == vno)
        {
          in_face = 1 ;
        }
      }
      if (in_face)
      {
        continue ;  /* don't be repelled by myself */
      }
      fx /= VERTICES_PER_FACE ;
      fy /= VERTICES_PER_FACE ;
      fz /= VERTICES_PER_FACE ;
      for (n = 0 ; n < v->vtotal ; n++)
        if (v->f[n] == bin->fno)
        {
          break ;
        }
      if (n < v->vtotal)   /* don't be repelled by a neighbor */
      {
        continue ;
      }
      if (!f->ripflag)
      {
        dx = fx - x ;
        dy = fy - y ;
        dz = fz - z ;
        dist = sqrt(dx*dx+dy*dy+dz*dz) + REPULSE_E ;
        if (vno == Gdiag_no)
        {
          if (dist-REPULSE_E < min_d)
          {
            min_vno = bin->fno ;
            min_d = dist-REPULSE_E ;
          }
        }
        dist = dist*dist*dist ;
        dist *= dist ; /* dist^6 */
        v_sse += REPULSE_K / dist ;
      }
    }
    sse_repulse += v_sse ;

    if (vno == Gdiag_no && !FZERO(v_sse))
    {
      printf("v %d: repulse sse:    min_dist=%2.4f, v_sse %2.4f\n", vno,
             min_d, v_sse) ;
    }
  }
#endif

  return(l_repulse * sse_repulse) ;
}
#endif


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/

static double
mrisComputeRepulsiveRatioEnergy(MRI_SURFACE *mris, double l_repulse)
{
  int     vno, n ;
  double  sse_repulse, v_sse, dist, dx, dy, dz, x, y, z, canon_dist,
          cdx, cdy, cdz ;
  VERTEX  *v, *vn ;

  if (FZERO(l_repulse))
  {
    return(0.0) ;
  }

  for (sse_repulse = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;
    for (v_sse = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (!vn->ripflag)
      {
        dx = x - vn->x ;
        dy = y - vn->y ;
        dz = z - vn->z ;
        dist = sqrt(dx*dx+dy*dy+dz*dz) ;
        cdx = vn->cx - v->cx ;
        cdy = vn->cy - v->cy ;
        cdz = vn->cz - v->cz ;
        canon_dist = sqrt(cdx*cdx+cdy*cdy+cdz*cdz) + REPULSE_E ;
        dist /= canon_dist ;
        dist += REPULSE_E ;
#if 0
        v_sse += REPULSE_K / (dist*dist*dist*dist) ;
#else
        v_sse += REPULSE_K / (dist*dist) ;
#endif
      }
    }
    sse_repulse += v_sse ;
  }
  return(l_repulse * sse_repulse) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeThicknessSmoothnessTerm(MRI_SURFACE *mris, double l_tsmooth)
{
  int     vno, n, num ;
  float   dx, dy, dz, x, y, z, dn, d0, vx, vy, vz, delta ;
  VERTEX  *v, *vn ;

  if (FZERO(l_tsmooth))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;
    vx = v->x - v->origx ;
    vy = v->y - v->origy ;
    vz = v->z - v->origz ;
    d0 = vx*vx + vy*vy + vz*vz ;
    dx = dy = dz = 0.0 ;
    for (num = n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (!vn->ripflag)
      {
        dn = SQR(vn->x-vn->origx)+
             SQR(vn->origy-vn->y)+
             SQR(vn->origz-vn->z) ;
        delta = d0 - dn ;
        dx -= delta * vx ;
        dy -= delta * vy ;
        dz -= delta * vz ;
        num++ ;
      }
    }
    if (num)
    {
      dx /= num ;
      dy /= num ;
      dz /= num ;
    }
    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
    if (vno == Gdiag_no)
    {
      fprintf(stdout, "v %d tsmooth term:        (%2.3f, %2.3f, %2.3f)\n",
              vno, dx, dy, dz) ;
    }
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeRepulsiveTerm(MRI_SURFACE *mris, double l_repulse, MHT *mht,
                         MHT *mht_faces)
{
  int     vno, num, min_vno, i, n ;
  float   dist, dx, dy, dz, x, y, z, sx, sy, sz, min_d, min_scale, norm ;
  double  scale ;
  VERTEX  *v, *vn ;
  MHBT    *bucket ;
  MHB     *bin ;
#if 0
  double  fx, fy, fz ;
  int     in_face ;
  FACE    *f ;
#endif

  if (FZERO(l_repulse))
  {
    return(NO_ERROR) ;
  }

  min_d = 100000.0 ;
  min_scale = 1.0 ;
  min_vno = 0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;
    bucket = MHTgetBucket(mht, x, y, z) ;
    if (!bucket)
    {
      continue ;
    }
    sx = sy = sz = 0.0 ;
    for (bin = bucket->bins, num = i = 0 ; i < bucket->nused ; i++, bin++)
    {
      if (bin->fno == vno)
      {
        continue ;  /* don't be repelled by myself */
      }
      for (n = 0 ; n < v->vtotal ; n++)
        if (v->v[n] == bin->fno)
        {
          break ;
        }
      if (n < v->vtotal)   /* don't be repelled by a neighbor */
      {
        continue ;
      }
      vn = &mris->vertices[bin->fno] ;
      if (!vn->ripflag)
      {
        dx = x - vn->x ;
        dy = y - vn->y ;
        dz = z - vn->z ;
        dist = sqrt(dx*dx+dy*dy+dz*dz) + REPULSE_E ;
        scale = 4*REPULSE_K / (dist*dist*dist*dist*dist*dist*dist) ;
        /* ^-7 */
        if (vno == Gdiag_no)
        {
          if (dist-REPULSE_E < 0.75)
          {
            DiagBreak() ;
          }
          if (dist-REPULSE_E < min_d)
          {
            min_vno = bin->fno ;
            min_d = dist-REPULSE_E ;
            min_scale = scale ;
          }
        }
        norm = sqrt(dx*dx+dy*dy+dz*dz) ;
        if (FZERO(norm))
        {
          norm = 1.0 ;
        }
        dx /= norm ;
        dy /= norm ;
        dz /= norm ;
        if (!finite(dx) || !finite(dy) || !finite(dz))
        {
          DiagBreak() ;
        }
        sx += scale * dx ;
        sy += scale * dy ;
        sz += scale * dz ;
        num++ ;
      }
    }
    if (num)
    {
      scale = l_repulse / (double)num ;
      sx *= scale ;
      sy *= scale ;
      sz *= scale ;
    }
    v->dx += sx ;
    v->dy += sy ;
    v->dz += sz ;
    if ((vno == Gdiag_no) && min_d < 1)
    {
      vn = &mris->vertices[min_vno] ;
      dx = vn->x - x ;
      dy = vn->y - y ;
      dz = vn->z - z;

      fprintf(stdout, "v %d self repulse term:   (%2.3f, %2.3f, %2.3f)\n",
              vno, sx, sy, sz) ;
      fprintf(stdout, "min_dist @ %d = %2.2f, scale = %2.1f\n",
              min_vno, min_d, min_scale) ;
    }
  }

#if 0
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;
    bucket = MHTgetBucket(mht_faces, x, y, z) ;
    if (!bucket)
    {
      continue ;
    }
    sx = sy = sz = 0.0 ;
    for (bin = bucket->bins, num = i = 0 ;
         i < bucket->nused ;
         i++, bin++)
    {
      f = &mris->faces[bin->fno] ;
      fx = fy = fz = 0 ;
      for (in_face = n = 0 ; n < VERTICES_PER_FACE ; n++)
      {
        fx += mris->vertices[f->v[n]].x ;
        fy += mris->vertices[f->v[n]].y ;
        fz += mris->vertices[f->v[n]].z ;
        if (f->v[n] == vno)
        {
          in_face = 1 ;
        }
      }
      if (in_face)
      {
        continue ;  /* don't be repelled by myself */
      }
      fx /= VERTICES_PER_FACE ;
      fy /= VERTICES_PER_FACE ;
      fz /= VERTICES_PER_FACE ;
      for (n = 0 ; n < v->vtotal ; n++)
        if (v->f[n] == bin->fno)
        {
          break ;
        }
      if (n < v->vtotal)   /* don't be repelled by a neighbor */
      {
        continue ;
      }
      if (!f->ripflag)
      {
        dx = fx - x ;
        dy = fy - y ;
        dz = fz - z ;
        dist = sqrt(dx*dx+dy*dy+dz*dz) + REPULSE_E ;
        scale = 4*REPULSE_K / (dist*dist*dist*dist*dist*dist*dist) ;
        /* ^-7 */
        if (vno == Gdiag_no)
        {
          if (dist-REPULSE_E < 0.75)
          {
            DiagBreak() ;
          }
          if (dist-REPULSE_E < min_d)
          {
            min_vno = bin->fno ;
            min_d = dist-REPULSE_E ;
            min_scale = scale ;
          }
        }
        norm = sqrt(dx*dx+dy*dy+dz*dz) ;
        if (FZERO(norm))
        {
          norm = 1.0 ;
        }
        dx /= norm ;
        dy /= norm ;
        dz /= norm ;
        sx += scale * dx ;
        sy += scale * dy ;
        sz += scale * dz ;
        num++ ;
      }
    }

    if (vno == Gdiag_no && min_d < .75)
    {
      f = &mris->faces[min_vno] ;
      dx = x - fx ;
      dy = y - fy ;
      dz = z - fz ;

      fprintf(stdout, "v %d self repulse term:   (%2.3f, %2.3f, %2.3f)\n",
              vno, sx, sy, sz) ;
      fprintf(stdout, "min_dist @ %d = %2.2f, scale = %2.1f\n",
              min_vno, min_d, min_scale) ;
    }
  }
#endif

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeRepulsiveRatioTerm(MRI_SURFACE *mris, double l_repulse, MHT *mht)
{
  int     vno, num, min_vno, i ;
  float   dist, dx, dy, dz, x, y, z, sx, sy, sz, min_d, min_scale, canon_dist,
          cdx, cdy, cdz ;
  double  scale ;
  VERTEX  *v, *vn ;
  MHBT    *bucket ;
  MHB     *bin ;

  if (FZERO(l_repulse))
  {
    return(NO_ERROR) ;
  }

  min_d = 1000.0 ;
  min_scale = 1.0 ;
  min_vno = 0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;
    bucket = MHTgetBucket(mht, x, y, z) ;
    if (!bucket)
    {
      continue ;
    }
    sx = sy = sz = 0.0 ;
    for (bin = bucket->bins, num = i = 0 ; i < bucket->nused ; i++, bin++)
    {
      if (bin->fno == vno)
      {
        continue ;  /* don't be repelled by myself */
      }
      vn = &mris->vertices[bin->fno] ;
      if (!vn->ripflag)
      {
        dx = vn->x - x ;
        dy = vn->y - y ;
        dz = vn->z - z ;
        dist = sqrt(dx*dx+dy*dy+dz*dz) ;
        cdx = vn->cx - v->cx ;
        cdy = vn->cy - v->cy ;
        cdz = vn->cz - v->cz ;
        canon_dist = sqrt(cdx*cdx+cdy*cdy+cdz*cdz) + REPULSE_E ;
        dist /= canon_dist ;
        dist += REPULSE_E ;
#if 0
        scale = -4*REPULSE_K / (dist*dist*dist*dist*dist) ;
#else
        scale = -4*REPULSE_K / (dist*dist*dist) ;
#endif
        if (vno == Gdiag_no)
        {
          if (dist-REPULSE_E < min_d)
          {
            min_vno = bin->fno ;
            min_d = dist-REPULSE_E ;
            min_scale = scale ;
          }
        }
        sx += scale * dx ;
        sy += scale * dy ;
        sz += scale*dz ;
        num++ ;
      }
    }
    if (num)
    {
      scale = l_repulse / (double)num ;
      sx *= scale ;
      sy *= scale ;
      sz *= scale ;
    }
    v->dx += sx ;
    v->dy += sy ;
    v->dz += sz ;
    if (vno == Gdiag_no)
    {
      vn = &mris->vertices[min_vno] ;
      dx = x - vn->x ;
      dy = y - vn->y ;
      dz = z - vn->z ;

      fprintf(stdout, "v %d repulse term:        (%2.3f, %2.3f, %2.3f)\n",
              vno, sx, sy, sz) ;
      fprintf(stdout, "min_dist @ %d = %2.2f, scale = %2.1f\n",
              min_vno, min_d, min_scale) ;
    }
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeSpringEnergy(MRI_SURFACE *mris)
{
  int     vno, n ;
  double  area_scale, sse_spring, v_sse ;
  VERTEX  *v ;

#if METRIC_SCALE
  if (mris->patch)
  {
    area_scale = 1.0 ;
  }
  else
  {
    area_scale = mris->orig_area / mris->total_area ;
  }
#else
  area_scale = 1.0 ;
#endif

  for (sse_spring = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    for (v_sse = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      v_sse += (v->dist[n]*v->dist[n]) ;
    }
    sse_spring += area_scale * v_sse ;
  }
  return(sse_spring) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description


  Note: this function assumes that the mris surface has the original
  (i.e. after global rotational alignment)
  spherical coordinates in the TMP2_VERTICES
  ------------------------------------------------------*/
static double
mrisComputeLaplacianEnergy(MRI_SURFACE *mris)
{
  int     vno, n ;
  double  area_scale, sse_lap, v_sse,
          dx, dy, dz, vx, vy, vz, vnx, vny, vnz, error ;
  VERTEX  *v, *vn ;

#if METRIC_SCALE
  if (mris->patch)
  {
    area_scale = 1.0 ;
  }
  else
  {
    area_scale = mris->orig_area / mris->total_area ;
  }
#else
  area_scale = 1.0 ;
#endif

  for (sse_lap = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    vx = v->x - v->tx2 ;
    vy = v->y - v->ty2 ;
    vz = v->z - v->tz2 ;
    for (v_sse = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      vnx = vn->x - vn->tx2 ;
      vny = vn->y - vn->ty2 ;
      vnz = vn->z - vn->tz2 ;
      dx = vnx-vx ;
      dy = vny-vy ;
      dz = vnz - vz ;
      error = dx*dx + dy*dy + dz*dz ;
      v_sse += error ;
    }
    sse_lap += area_scale * v_sse ;
  }
  return(sse_lap) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeTangentialSpringEnergy(MRI_SURFACE *mris)
{
  int     vno, n ;
  double  area_scale, sse_spring, v_sse ;
  VERTEX  *v, *vn ;
  float   dx, dy, dz, x, y, z, nc, dist_sq ;

#if METRIC_SCALE
  if (mris->patch)
  {
    area_scale = 1.0 ;
  }
  else
  {
    area_scale = FZERO(mris->total_area) ? 1.0 : mris->orig_area / mris->total_area ;
  }
#else
  area_scale = 1.0 ;
#endif

  for (sse_spring = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    for (v_sse = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dx = vn->x - x ;
      dy = vn->y - y ;
      dz = vn->z - z ;
      nc = dx * v->nx + dy*v->ny + dz*v->nz ;
      dx -= nc*v->nx ;
      dy -= nc*v->ny ;
      dz -= nc*v->nz ;
      dist_sq = dx*dx+dy*dy+dz*dz ;
      v_sse += dist_sq ;
    }
    sse_spring += area_scale * v_sse ;
  }
  return(sse_spring) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
    compute nonlinear spring energy (stolen from BET, thanks Steve)
------------------------------------------------------*/
#define RMIN 1
#define RMAX 5

static int
mrisComputeNonlinearSpringTerm(MRI_SURFACE *mris,double l_nlspring, INTEGRATION_PARMS *parms)
{
  int     vno, n ;
  double  area_scale, sse_spring, E, F, f, rmin, rmax ;
  VERTEX  *v, *vn ;
  float   dx, dy, dz, nc, r, lsq, mean_vdist ;

  if (FZERO(parms->l_nlspring))
  {
    return(NO_ERROR) ;
  }

#if METRIC_SCALE
  if (mris->patch)
  {
    area_scale = 1.0 ;
  }
  else
  {
    area_scale = mris->orig_area / mris->total_area ;
  }
#else
  area_scale = 1.0 ;
#endif

  mean_vdist = MRIScomputeVertexSpacingStats(mris, NULL, NULL, NULL, NULL,NULL,CURRENT_VERTICES);
  lsq = mean_vdist * mean_vdist ;

  rmax = parms->rmax ;
  rmin = parms->rmin ;
  if (FZERO(rmin) || FZERO(rmax))
    ErrorReturn(ERROR_BADPARM,
                (ERROR_BADPARM,
                 "mrisComputeNonlinearSpringTerm: rmin or rmax = 0!"));

  F = 6.0 / (1.0/rmin - 1.0/rmax) ;
  E = (1.0/rmin + 1.0/rmax)/2 ;
  for (sse_spring = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dx = vn->x - v->x ;
      dy = vn->y - v->y ;
      dz = vn->z - v->z ;
      //      lsq = dx*dx + dy*dy + dz*dz ;
      nc = dx * v->nx + dy*v->ny + dz*v->nz ;
      dx = nc * v->nx ;
      dy = nc*v->ny ;
      dz = nc*v->nz ; // sn
      r = lsq / fabs(2.0*nc) ;
      if (r < rmin)
      {
        DiagBreak() ;
      }
      f = nc*(1 + tanh(F*(1.0/r - E)))/2.0 ;
      if (vno == Gdiag_no)
        printf("l_nlspring: f = %2.3f (r = %2.2f), dx = (%2.2f, %2.2f, %2.2f)\n", f, r,
               v->nx*f*l_nlspring, v->ny*f*l_nlspring, v->nz*f*l_nlspring) ;
      v->dx += v->nx*f*l_nlspring ;
      v->dy += v->ny*f*l_nlspring ;
      v->dz += v->nz*f*l_nlspring ;
    }
  }
  return(NO_ERROR) ;
}

static double
mrisComputeNonlinearSpringEnergy(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int     vno, n ;
  double  area_scale, sse_spring, E, F, f, rmin, rmax, ftotal ;
  VERTEX  *v, *vn ;
  float   dx, dy, dz, nc, r, lsq, mean_vdist ;

  mean_vdist = MRIScomputeVertexSpacingStats(mris, NULL, NULL,NULL,NULL,NULL,CURRENT_VERTICES) ;
  lsq = mean_vdist * mean_vdist ;
#if METRIC_SCALE
  if (mris->patch)
  {
    area_scale = 1.0 ;
  }
  else
  {
    area_scale = mris->orig_area / mris->total_area ;
  }
#else
  area_scale = 1.0 ;
#endif

  rmin = parms->rmin ;
  rmax = parms->rmax ;
  if (FZERO(rmin) || FZERO(rmax))
    ErrorReturn(ERROR_BADPARM,
                (ERROR_BADPARM,
                 "mrisComputeNonlinearSpringTerm: rmin or rmax = 0!"));

  F = 6.0 / (1.0/rmin - 1.0/rmax) ;
  E = (1.0/rmin + 1.0/rmax)/2 ;
  for (sse_spring = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    for (ftotal = r = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dx = vn->x - v->x ;
      dy = vn->y - v->y ;
      dz = vn->z - v->z ;
      //      lsq = dx*dx + dy*dy + dz*dz ;
      nc = dx * v->nx + dy*v->ny + dz*v->nz ;
      dx = nc * v->nx ;
      dy = nc*v->ny ;
      dz = nc*v->nz ; // sn
      r = lsq / fabs(2.0*nc) ;
      f = (1 + tanh(F*(1.0/r - E)));
      ftotal += f*f ;
    }
    if (vno == Gdiag_no)
    {
      printf("E_nlspring: f = %2.3f\n", ftotal/v->vnum) ;
    }
    sse_spring += area_scale * ftotal/v->vnum ;
  }
  return(sse_spring) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  each face has 2 triangles defined by it:

  V0       d      V3
  o--------------o
  |              |
  | A0           |
  a |              | c
  |              |
  |           A1 |
  o--------------o
  V1      b        V2

  a = V1 - V0
  d = V3 - V0
  A0 = 0.5 (a x d) . n

  b = V1 - V2
  c = V3 - V2
  A1 = 0.5 (c x b) . n

  each face has 1 triangle defined by it:

  V0    b     V2
  o----------o
  |         /
  | A0    /
  a |     /
  |   /
  | /
  o
  V1

  a = V1 - V0
  b = V2 - V0
  A0 = 0.5 (a x b) . n

  ------------------------------------------------------*/
static int
mrisComputeAngleAreaTerms(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int     fno, ano ;
  VERTEX  *v0, *v1, *v2, *va, *vb, *vo ;
  VECTOR  *v_a, *v_b, *v_a_x_n, *v_b_x_n, *v_n, *v_tmp, *v_sum ;
  FACE    *face ;
  float   orig_area, area, l_parea, l_area, l_angle, delta, len, area_scale ;

#if METRIC_SCALE
  if (mris->patch ||
      (mris->status != MRIS_SPHERE &&
       mris->status != MRIS_PARAMETERIZED_SPHERE))
  {
    area_scale = 1.0f ;
  }
  else
  {
    area_scale = mris->orig_area / mris->total_area ;
  }
#else
  area_scale = 1.0f ;
#endif

  l_angle = parms->l_angle ;
  l_area = parms->l_area ;
  l_parea = parms->l_parea ;
  if (!FZERO(parms->l_nlarea))
  {
    mrisComputeNonlinearAreaTerm(mris, parms) ;
  }

  if (FZERO(l_area) && FZERO(l_angle) && FZERO(l_parea))
  {
    return(NO_ERROR) ;
  }

  v_a = VectorAlloc(3, MATRIX_REAL) ;
  v_b = VectorAlloc(3, MATRIX_REAL) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;

  v_tmp = VectorAlloc(3, MATRIX_REAL) ;
  v_sum = VectorAlloc(3, MATRIX_REAL) ;
  v_a_x_n = VectorAlloc(3, MATRIX_REAL) ;
  v_b_x_n = VectorAlloc(3, MATRIX_REAL) ;

  /* calculcate movement of each vertex caused by each triangle */
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
    if (fno == Gdiag_no2)
    {
      DiagBreak() ;
    }
    VECTOR_LOAD(v_n, face->nx, face->ny, face->nz) ;
    v0 = &mris->vertices[face->v[0]] ;
    v1 = &mris->vertices[face->v[1]] ;
    v2 = &mris->vertices[face->v[2]] ;
    VERTEX_EDGE(v_a, v0, v1) ;
    VERTEX_EDGE(v_b, v0, v2) ;
    orig_area = face->orig_area ;
    area = area_scale * face->area ;
    delta = 0.0 ;
    if (!FZERO(l_parea))
    {
      delta += l_parea * (area - orig_area) ;
    }

    if (!FZERO(l_area))
    {
      if (area <= 0.0f)
      {
        delta += l_area * (area - orig_area) ;
      }
    }

    if (face->v[0] == Gdiag_no ||
        face->v[1] == Gdiag_no ||
        face->v[2] == Gdiag_no)
    {
      printf("face %d, orig area %2.2f, area, %2.2f, delta = %2.2f\n", fno, orig_area, area, delta) ;
      DiagBreak() ;
    }

    V3_CROSS_PRODUCT(v_a, v_n, v_a_x_n) ;
    V3_CROSS_PRODUCT(v_b, v_n, v_b_x_n) ;

    /* calculate movement of vertices in order, 0-3 */

    /* v0 */
    V3_SCALAR_MUL(v_a_x_n, -1.0f, v_sum) ;
    V3_ADD(v_sum, v_b_x_n, v_sum) ;
    V3_SCALAR_MUL(v_sum, delta, v_sum) ;
    v0->dx += V3_X(v_sum) ;
    v0->dy += V3_Y(v_sum) ;
    v0->dz += V3_Z(v_sum) ;
    if (face->v[0] == Gdiag_no)
    {
      printf("\tv %d, area/angle term = (%2.3f %2.3f, %2.3f)\n", face->v[0], V3_X(v_sum), V3_Y(v_sum), V3_Z(v_sum)) ;
    }

    /* v1 */
    V3_SCALAR_MUL(v_b_x_n, -delta, v_sum) ;
    v1->dx += V3_X(v_sum) ;
    v1->dy += V3_Y(v_sum) ;
    v1->dz += V3_Z(v_sum) ;
    if (face->v[1] == Gdiag_no)
    {
      printf("\tv %d, area/angle term = (%2.3f %2.3f, %2.3f)\n", face->v[1], V3_X(v_sum), V3_Y(v_sum), V3_Z(v_sum)) ;
    }

    /* v2 */
    V3_SCALAR_MUL(v_a_x_n, delta, v_sum) ;
    v2->dx += V3_X(v_sum) ;
    v2->dy += V3_Y(v_sum) ;
    v2->dz += V3_Z(v_sum) ;
    if (face->v[2] == Gdiag_no)
    {
      printf("\tv %d, area/angle term = (%2.3f %2.3f, %2.3f)\n", face->v[2], V3_X(v_sum), V3_Y(v_sum), V3_Z(v_sum)) ;
    }

    /* now calculate the angle contributions */
    if (!FZERO(l_angle))
    {
      for (ano = 0 ; ano < ANGLES_PER_TRIANGLE ; ano++)
      {
        switch (ano)
        {
        default:
        case 0:
          vo = v0 ;
          va = v2 ;
          vb = v1 ;
          break ;
        case 1:
          vo = v1 ;
          va = v0 ;
          vb = v2 ;
          break ;
        case 2:
          vo = v2 ;
          va = v1 ;
          vb = v0 ;
          break ;
        }
        delta = deltaAngle(face->angle[ano],face->orig_angle[ano]);
#if ONLY_NEG_AREA_TERM
        if (face->angle[ano] >= 0.0f)
        {
          delta = 0.0f ;
        }
#endif
        delta *= parms->l_angle ;
        VERTEX_EDGE(v_a, vo, va) ;
        VERTEX_EDGE(v_b, vo, vb) ;

        /* this angle's contribution to va */
        V3_CROSS_PRODUCT(v_a, v_n, v_tmp) ;
        len = V3_DOT(v_a,v_a) ;
        if (!FZERO(len))
        {
          V3_SCALAR_MUL(v_tmp, delta/len, v_tmp) ;
        }
        else
        {
          V3_SCALAR_MUL(v_tmp, 0.0f, v_tmp) ;
        }
        va->dx += V3_X(v_tmp) ;
        va->dy += V3_Y(v_tmp);
        va->dz += V3_Z(v_tmp);
        if (va-mris->vertices == Gdiag_no)
        {
          printf("\tv %d, area/angle term = (%2.3f %2.3f, %2.3f)\n", Gdiag_no, V3_X(v_sum), V3_Y(v_sum), V3_Z(v_sum)) ;
        }

        /* this angle's contribution to vb */
        V3_CROSS_PRODUCT(v_n, v_b, v_sum) ;
        len = V3_DOT(v_b,v_b) ;
        if (!FZERO(len))
        {
          V3_SCALAR_MUL(v_sum, delta/len, v_sum) ;
        }
        else
        {
          V3_SCALAR_MUL(v_sum, 0.0f, v_sum) ;
        }
        vb->dx += V3_X(v_sum) ;
        vb->dy += V3_Y(v_sum);
        vb->dz += V3_Z(v_sum);
        if (vb-mris->vertices == Gdiag_no)
        {
          printf("\tv %d, area/angle term = (%2.3f %2.3f, %2.3f)\n", Gdiag_no, V3_X(v_sum), V3_Y(v_sum), V3_Z(v_sum)) ;
        }

        /* this angle's contribution to vo */
        V3_ADD(v_tmp, v_sum, v_sum) ;
        vo->dx -= V3_X(v_sum);
        vo->dy -= V3_Y(v_sum);
        vo->dz -= V3_Z(v_sum) ;
        if (vo-mris->vertices == Gdiag_no)
        {
          printf("\tv %d, area/angle term = (%2.3f %2.3f, %2.3f)\n", Gdiag_no, V3_X(v_sum), V3_Y(v_sum), V3_Z(v_sum)) ;
        }
      }
    }
  }    /* done with all faces */

  VectorFree(&v_a) ;
  VectorFree(&v_b) ;
  VectorFree(&v_tmp) ;
  VectorFree(&v_sum) ;
  VectorFree(&v_n) ;

  VectorFree(&v_a_x_n) ;
  VectorFree(&v_b_x_n) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeNonlinearAreaTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int     fno ;
  VERTEX  *v0, *v1, *v2 ;
  VECTOR  *v_a, *v_b, *v_a_x_n, *v_b_x_n, *v_n, *v_tmp, *v_sum ;
  FACE    *face ;
  double  orig_area, area, delta, area_scale, scale, l_nlarea, ratio, nlscale ;

#if METRIC_SCALE
  if (mris->patch ||
      (mris->status != MRIS_SPHERE &&
       mris->status != MRIS_PARAMETERIZED_SPHERE))
  {
    area_scale = 1.0f ;
  }
  else
  {
    area_scale = mris->orig_area / mris->total_area ;
  }
#else
  area_scale = 1.0f ;
#endif

  l_nlarea = parms->l_nlarea ;

  if (FZERO(l_nlarea))
  {
    return(NO_ERROR) ;
  }

  v_a = VectorAlloc(3, MATRIX_REAL) ;
  v_b = VectorAlloc(3, MATRIX_REAL) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;

  v_tmp = VectorAlloc(3, MATRIX_REAL) ;
  v_sum = VectorAlloc(3, MATRIX_REAL) ;
  v_a_x_n = VectorAlloc(3, MATRIX_REAL) ;
  v_b_x_n = VectorAlloc(3, MATRIX_REAL) ;

  /* calculcate movement of each vertex caused by each triangle */
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
    if (face->area < 0)
    {
      DiagBreak() ;
    }
    if (face->v[0] == Gdiag_no ||
        face->v[1] == Gdiag_no ||
        face->v[2] == Gdiag_no)
    {
      DiagBreak() ;
    }
    VECTOR_LOAD(v_n, face->nx, face->ny, face->nz) ;
    v0 = &mris->vertices[face->v[0]] ;
    v1 = &mris->vertices[face->v[1]] ;
    v2 = &mris->vertices[face->v[2]] ;
    VERTEX_EDGE(v_a, v0, v1) ;
    VERTEX_EDGE(v_b, v0, v2) ;
    orig_area = face->orig_area ;
    area = area_scale * face->area ;
#if SCALE_NONLINEAR_AREA
    if (!FZERO(orig_area))
    {
      ratio = area / orig_area ;
    }
    else
    {
      ratio = 0.0f ;
    }
#else
    ratio = area ;
#endif

    if (ratio > MAX_NEG_RATIO)
    {
      ratio = MAX_NEG_RATIO ;
    }
    else if (ratio < -MAX_NEG_RATIO)
    {
      ratio = -MAX_NEG_RATIO ;
    }
#if 0
    scale = l_nlarea * (1 - (1/(1.0+exp(-NEG_AREA_K*ratio)))) ;
#else
    scale = l_nlarea / (1.0+exp(NEG_AREA_K*ratio)) ;
#endif
    delta = scale * (area - orig_area) ;
    nlscale = (mris->total_area / mris->nfaces) / ((area < 0 ? 0 : area) + 0.001) ;
    nlscale = 1;
    delta *= (nlscale*nlscale) ;

    if (face->v[0] == Gdiag_no ||
        face->v[1] == Gdiag_no ||
        face->v[2] == Gdiag_no)
    {
      printf("face %d, orig area %2.2f, area, %2.2f, delta = %2.2f\n", fno, orig_area, area, scale) ;
      DiagBreak() ;
    }

    V3_CROSS_PRODUCT(v_a, v_n, v_a_x_n) ;
    V3_CROSS_PRODUCT(v_b, v_n, v_b_x_n) ;

    /* calculate movement of vertices in order, 0-3 */

    /* v0 */
    V3_SCALAR_MUL(v_a_x_n, -1.0f, v_sum) ;
    V3_ADD(v_sum, v_b_x_n, v_sum) ;
    V3_SCALAR_MUL(v_sum, delta, v_sum) ;
    v0->dx += V3_X(v_sum) ;
    v0->dy += V3_Y(v_sum) ;
    v0->dz += V3_Z(v_sum) ;
    if (face->v[0] == Gdiag_no)
    {
      printf("\tv %d, area/angle term = (%2.3f %2.3f, %2.3f)\n", face->v[0], V3_X(v_sum), V3_Y(v_sum), V3_Z(v_sum)) ;
    }

    /* v1 */
    V3_SCALAR_MUL(v_b_x_n, -delta, v_sum) ;
    v1->dx += V3_X(v_sum) ;
    v1->dy += V3_Y(v_sum) ;
    v1->dz += V3_Z(v_sum) ;
    if (face->v[1] == Gdiag_no)
    {
      printf("\tv %d, area/angle term = (%2.3f %2.3f, %2.3f)\n", face->v[1], V3_X(v_sum), V3_Y(v_sum), V3_Z(v_sum)) ;
    }

    /* v2 */
    V3_SCALAR_MUL(v_a_x_n, delta, v_sum) ;
    v2->dx += V3_X(v_sum) ;
    v2->dy += V3_Y(v_sum) ;
    v2->dz += V3_Z(v_sum) ;
    if (face->v[2] == Gdiag_no)
    {
      printf("\tv %d, area/angle term = (%2.3f %2.3f, %2.3f)\n", face->v[2], V3_X(v_sum), V3_Y(v_sum), V3_Z(v_sum)) ;
    }
  }    /* done with all faces */

  VectorFree(&v_a) ;
  VectorFree(&v_b) ;
  VectorFree(&v_tmp) ;
  VectorFree(&v_sum) ;
  VectorFree(&v_n) ;

  VectorFree(&v_a_x_n) ;
  VectorFree(&v_b_x_n) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeSurfaceRepulsionTerm(MRI_SURFACE *mris, double l_repulse, MHT *mht)
{
  int     vno, max_vno, i ;
  float   dx, dy, dz, x, y, z, sx, sy, sz,norm[3],dot;
  float   max_scale, max_dot ;
  double  scale ;
  VERTEX  *v, *vn ;
  MHBT    *bucket ;
  MHB     *bin ;

  if (FZERO(l_repulse))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;
    bucket = MHTgetBucket(mht, x, y, z) ;
    if (!bucket)
    {
      continue ;
    }
    bin = bucket->bins ;
    sx = sy = sz = 0.0 ;
    max_dot = max_scale = 0.0 ;
    max_vno = 0 ;
    for (i = 0 ; i < bucket->nused ; i++, bin++)
    {
      vn = &mris->vertices[bin->fno] ;
      if (bin->fno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (vn->ripflag)
      {
        continue ;
      }
      dx = x - vn->origx ;
      dy = y - vn->origy ;
      dz = z - vn->origz ;
      mrisComputeOrigNormal(mris, bin->fno, norm) ;
      dot = dx*norm[0] + dy*norm[1] + dz*norm[2] ;
      if (dot > 1)
      {
        continue ;
      }
      if (dot < 0 && vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (dot > MAX_NEG_RATIO)
      {
        dot = MAX_NEG_RATIO ;
      }
      else if (dot < -MAX_NEG_RATIO)
      {
        dot = -MAX_NEG_RATIO ;
      }
#if 0
      scale = l_repulse / (1.0+exp(NEG_AREA_K*dot)) ;
#else
      scale = l_repulse*pow(1.0-(double)dot,4.0) ;
#endif
      if (scale > max_scale)
      {
        max_scale = scale ;
        max_vno = bin->fno ;
        max_dot = dot ;
      }
      sx += (scale*v->nx) ;
      sy += (scale*v->ny) ;
      sz += (scale*v->nz) ;
    }

    v->dx += sx ;
    v->dy += sy ;
    v->dz += sz ;
    if (vno == Gdiag_no)
    {
      vn = &mris->vertices[max_vno] ;
      dx = x - vn->x ;
      dy = y - vn->y ;
      dz = z - vn->z ;

      fprintf(stdout, "v %d inside repulse term:  (%2.3f, %2.3f, %2.3f)\n",
              vno, sx, sy, sz) ;
      fprintf(stdout, "max_scale @ %d = %2.2f, max dot = %2.2f\n",
              max_vno, max_scale, max_dot) ;
    }
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeWhichSurfaceRepulsionTerm(MRI_SURFACE *mris,
                                     double l_repulse,
                                     MHT *mht,
                                     int which,
                                     float dot_thresh)
{
  int     vno, max_vno, i ;
  float   dx, dy, dz, x, y, z, sx, sy, sz,norm[3],dot;
  float   max_scale, max_dot ;
  double  scale, sgn ;
  VERTEX  *v, *vn ;
  MHBT    *bucket ;
  MHB     *bin ;

  if (FZERO(l_repulse))
  {
    return(NO_ERROR) ;
  }

  if (l_repulse < 0)
  {
    sgn = -1 ;
  }
  else
  {
    sgn = 1 ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;
    bucket = MHTgetBucket(mht, x, y, z) ;
    if (!bucket)
    {
      continue ;
    }
    bin = bucket->bins ;
    sx = sy = sz = 0.0 ;
    max_dot = max_scale = 0.0 ;
    max_vno = 0 ;
    for (i = 0 ; i < bucket->nused ; i++, bin++)
    {
      vn = &mris->vertices[bin->fno] ;
      if (bin->fno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (vn->ripflag)
      {
        continue ;
      }
      switch (which)
      {
      default:
      case ORIGINAL_VERTICES:
        mrisComputeOrigNormal(mris, bin->fno, norm) ;
        dx = x - vn->origx ;
        dy = y - vn->origy ;
        dz = z - vn->origz ;
        break ;
      case WHITE_VERTICES:
        mrisComputeWhiteNormal(mris, bin->fno, norm) ;
        dx = x - vn->whitex ;
        dy = y - vn->whitey ;
        dz = z - vn->whitez ;
        break ;
      case PIAL_VERTICES:
        mrisComputePialNormal(mris, bin->fno, norm) ;
        dx = x - vn->pialx ;
        dy = y - vn->pialy ;
        dz = z - vn->pialz ;
        break ;
      }
      dot = dx*norm[0] + dy*norm[1] + dz*norm[2] ;
      if (sgn*dot > dot_thresh)
      {
        continue ;
      }
      if (dot < 0 && vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (dot > MAX_NEG_RATIO)
      {
        dot = MAX_NEG_RATIO ;
      }
      else if (dot < -MAX_NEG_RATIO)
      {
        dot = -MAX_NEG_RATIO ;
      }
#if 0
      scale = l_repulse / (1.0+exp(NEG_AREA_K*dot)) ;
#else
      scale = l_repulse*pow(1.0-(double)dot,15.0) ;
#endif
      if (scale > max_scale)
      {
        max_scale = scale ;
        max_vno = bin->fno ;
        max_dot = dot ;
      }
      sx += (scale*v->nx) ;
      sy += (scale*v->ny) ;
      sz += (scale*v->nz) ;
    }

    v->dx += sgn*sx ;
    v->dy += sgn*sy ;
    v->dz += sgn*sz ;
    if (vno == Gdiag_no)
    {
      vn = &mris->vertices[max_vno] ;
      dx = x - vn->x ;
      dy = y - vn->y ;
      dz = z - vn->z ;

      fprintf(stdout, "v %d inside repulse term:  (%2.3f, %2.3f, %2.3f)\n",
              vno, sx, sy, sz) ;
      fprintf(stdout, "max_scale @ %d = %2.2f, max dot = %2.2f\n",
              max_vno, max_scale, max_dot) ;
    }
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
static double
mrisComputeAverageHeight(MRI_SURFACE *mris)
{
  int    vno, n, nv ;
  VERTEX *vertex, *vn ;
  double height ;
  float  dx, dy, dz, nx, ny, nz, x, y, z ;

  for (height = 0.0, nv = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    x = vertex->x ;
    y = vertex->y ;
    z = vertex->z ;
    nx = vertex->nx ;
    ny = vertex->ny ;
    nz = vertex->nz ;
    if (vertex->ripflag)
    {
      continue ;
    }
    nv += vertex->vtotal ;
    for (n = 0 ; n < vertex->vtotal ; n++)
    {
      vn = &mris->vertices[vertex->v[n]] ;
      dx = x - vn->x ;
      dy = y - vn->y ;
      dz = z - vn->z ;
      height += fabs(dx * nx + dy * ny + dz * nz) ;
    }
  }

  return(sqrt(height/(double)nv)) ;
}
#endif


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisProjectSurface(MRI_SURFACE *mris)
{

  /*  MRISupdateSurface(mris) ;*/
  switch (mris->status)
  {
  case MRIS_PLANE:
    MRISflattenPatch(mris) ;
    break ;
  case MRIS_SPHERICAL_PATCH:
    mrisSphericalProjection(mris);
    break;
  case MRIS_PARAMETERIZED_SPHERE:
    MRISprojectOntoSphere(mris, mris, mris->radius) ;
    break ;
  case MRIS_SPHERE:
    MRISprojectOntoSphere(mris, mris, mris->radius) ;
    break ;
  case MRIS_ELLIPSOID:
    MRISprojectOntoEllipsoid(mris, mris, 0.0f, 0.0f, 0.0f);
    break ;
    //        case PROJECT_PLANE:
    /*    mrisOrientPlane(mris) ;*/
    //                break ;
  case MRIS_RIGID_BODY:
    /*    MRISprojectOntoSphere(mris, mris, mris->radius) ;*/
    mris->status = MRIS_RIGID_BODY ;
    break ;
  case MRIS_PIAL_SURFACE:
    mrisProjectOntoSurface(mris, PIAL_VERTICES) ;
    break ;
  default:
    break ;
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisOrientSurface(MRI_SURFACE *mris)
{
  switch (mris->status)
  {
  case MRIS_RIGID_BODY:
  case MRIS_PARAMETERIZED_SPHERE:
  case MRIS_SPHERE:
  case MRIS_ELLIPSOID:
  case MRIS_SPHERICAL_PATCH:
    MRISupdateEllipsoidSurface(mris) ;
    break ;
  case MRIS_PLANE:
    mrisOrientPlane(mris) ;
    break ;
  default:
    /*    MRISupdateSurface(mris) ;*/
    break ;
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisLogStatus(MRI_SURFACE *mris,INTEGRATION_PARMS *parms,FILE *fp, float dt, float old_sse)
{
  float  area_rms, angle_rms, curv_rms, sse, dist_rms, corr_rms ;
  int    n,negative ;
  float nv;
  int fyi;

  if (!(Gdiag & DIAG_SHOW))
  {
    return(NO_ERROR) ;
  }

  negative = MRIScountNegativeTriangles(mris) ;

  fyi=0;
  if (parms->flags & IP_USE_MULTIFRAMES)
  {
    if (FZERO(parms->l_corr))
    {
      /* just for your information */
      /* check if we can load curvature information */
      for (n=0; n<parms->nfields; n++)
        if (parms->fields[n].field==CURVATURE_CORR_FRAME)
        {
          parms->frame_no=parms->fields[n].frame*IMAGES_PER_SURFACE;
          fyi=1;
          parms->l_corr=1.0f;
          break;
        }
    }
  }

  if (parms->l_thick_min || parms->l_thick_parallel || parms->l_thick_normal || parms->l_ashburner_triangle || parms->l_tspring || parms->l_thick_spring)
  {
    float pct_change  ;
    sse = MRIScomputeSSE(mris, parms) ;
    if (old_sse > 0)
    {
      pct_change = 100 * (old_sse - sse) / (old_sse) ;
    }
    else
    {
      pct_change = 0.0 ;
    }
    fprintf(fp, "%3.3d: dt: %2.4f, sse: %2.1f  "
            "neg: %d (%%%2.3f:%%%2.2f), avgs: %d, %2.2f%%\n",
            parms->t, dt, sse,
            negative, 100.0*mris->neg_area/(mris->neg_area+mris->total_area),
            100.0*mris->neg_orig_area/(mris->orig_area),
            parms->n_averages, pct_change);
  }
  else
  {
    sse  = mrisComputeError(mris, parms,&area_rms,&angle_rms,&curv_rms,&dist_rms,
                            &corr_rms);

    if (fyi)
    {
      parms->l_corr=0.0f;
    }

#if 0
    sse = MRIScomputeSSE(mris, parms) ;
#endif
#if 0
    sse /= (float)MRISvalidVertices(mris) ;
    sse = sqrt(sse) ;
#endif

    if (mris->status==MRIS_SPHERICAL_PATCH)
    {
      return NO_ERROR;
    }

    if (FZERO(parms->l_corr) &&
        FZERO(parms->l_pcorr) &&
        ((parms->flags & IP_USE_MULTIFRAMES) == 0 ))
    {
      fprintf(fp, "%3.3d: dt: %2.2f, sse: %2.1f (%2.3f, %2.1f, %2.3f), "
              "neg: %d (%%%2.3f:%%%2.2f), avgs: %d\n",
              parms->t, dt, sse, area_rms, (float)DEGREES(angle_rms), dist_rms,
              negative, 100.0*mris->neg_area/(mris->neg_area+mris->total_area),
              100.0*mris->neg_orig_area/(mris->orig_area),
              parms->n_averages);
      if (dist_rms > 20)
      {
        DiagBreak() ;
      }
    }
    else
    {
      if (parms->flags & IP_USE_MULTIFRAMES)
      {
        nv = (float) MRISvalidVertices(mris) ;

        fprintf(fp, "%3.3d: dt: %2.3f, sse: %2.1f (%2.3f, %2.1f, %2.3f, %2.3f), "
                "neg: %d (%%%2.2f:%%%2.2f), avgs: %d\n",
                parms->t, dt, sse, area_rms, (float)DEGREES(angle_rms), dist_rms,
                corr_rms, negative,
                100.0*mris->neg_area/(mris->neg_area+mris->total_area),
                100.0*mris->neg_orig_area/(mris->orig_area),
                parms->n_averages);
        for ( n = 0 ; n < parms->nfields ; n++ )
        {
          if (FZERO(parms->fields[n].l_corr+parms->fields[n].l_pcorr))
          {
            continue;
          }
          fprintf(stdout,"  (%d: %2.3f : %2.3f)",
                  n,parms->fields[n].sse,sqrt(parms->fields[n].sse/nv));
        }
        fprintf(stdout,"\n");
      }
      else
        fprintf(fp, "%3.3d: dt: %2.3f, sse: %2.1f (%2.3f, %2.1f, %2.3f, %2.3f), "
                "neg: %d (%%%2.2f:%%%2.2f), avgs: %d\n",
                parms->t, dt, sse, area_rms, (float)DEGREES(angle_rms), dist_rms,
                corr_rms, negative,
                100.0*mris->neg_area/(mris->neg_area+mris->total_area),
                100.0*mris->neg_orig_area/(mris->orig_area),
                parms->n_averages);
    }
  }
  fflush(fp) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISreadVertexPositions(MRI_SURFACE *mris, const char *name)
{
  char    fname[STRLEN] ;
  int     vno, nvertices, nfaces, magic, version, tmp, ix, iy, iz, n, type ;
  VERTEX  *vertex ;
  FILE    *fp ;

  type = MRISfileNameType(name) ;
  MRISbuildFileName(mris, name, fname) ;
  if (type == MRIS_GEO_TRIANGLE_FILE)
  {
    return(mrisReadGeoFilePositions(mris, fname)) ;
  }
  else if (type == MRIS_ICO_FILE)
  {
    return(ICOreadVertexPositions(mris, fname, CURRENT_VERTICES)) ;
  }
  fp = fopen(fname, "rb") ;
  if (!fp)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISreadVertexPosition(%s): could not open file %s",
                 name, fname));

  fread3(&magic, fp) ;
  if (magic == QUAD_FILE_MAGIC_NUMBER)
  {
    version = -1;
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    {
      fprintf(stdout, "new surface file format\n");
    }
  }
  else if (magic == NEW_QUAD_FILE_MAGIC_NUMBER)
  {
    version = -2 ;
  }
  else if (magic == TRIANGLE_FILE_MAGIC_NUMBER)
  {
    fclose(fp) ;
    if (mrisReadTriangleFilePositions(mris,fname)  != NO_ERROR)
    {
      ErrorReturn(Gerror, (Gerror, "mrisReadTriangleFile failed.\n")) ;
    }
    version = -3 ;
  }
  else
  {
    rewind(fp);
    version = 0;
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    {
      printf("surfer: old surface file format\n");
    }
  }

  if (version >= -2)
  {
    fread3(&nvertices, fp);
    fread3(&nfaces, fp);
    nfaces *= 2 ;

    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      fprintf(stdout, "reading %d vertices and %d faces.\n",
              nvertices,nfaces);

    if (nvertices != mris->nvertices || nfaces != mris->nfaces)
    {
      fclose(fp) ;
      ErrorReturn
      (ERROR_BADFILE,
       (ERROR_BADFILE,
        "\nERROR: \n      MRISreadVertexPositions(%s): surfaces differ. "
        "Main: %d verts %d faces, %s: %d verts %d faces\n"
        "Surfaces may be out-of-date\n\n",
        fname, mris->nvertices, mris->nfaces,
        name, nvertices, nfaces)) ;
    }

    for (vno = 0 ; vno < nvertices ; vno++)
    {
      vertex = &mris->vertices[vno] ;
      if (version == -1)
      {
        fread2(&ix,fp);
        fread2(&iy,fp);
        fread2(&iz,fp);
        vertex->x = ix/100.0;
        vertex->y = iy/100.0;
        vertex->z = iz/100.0;
      }
      else  /* version == -2 */
      {
        vertex->x = freadFloat(fp) ;
        vertex->y = freadFloat(fp) ;
        vertex->z = freadFloat(fp) ;
      }
      if (version == 0)  /* old surface format */
      {
        fread1(&tmp, fp);
        for (n=0; n<vertex->num; n++)
        {
          fread3(&tmp,fp);
        }
      }
    }

    fclose(fp);
  }

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScomputeMetricProperties(MRI_SURFACE *mris)
{
  MRIScomputeNormals(mris);
  mrisComputeVertexDistances(mris);
  mrisComputeSurfaceDimensions(mris);
  MRIScomputeTriangleProperties(mris);  /* compute areas and normals */
  mris->avg_vertex_area = mris->total_area/mris->nvertices;
  mris->avg_vertex_dist = MRISavgInterVertexDist(mris, &mris->std_vertex_dist);
  mrisOrientSurface(mris);
  // See also MRISrescaleMetricProperties()
  if (mris->status == MRIS_PARAMETERIZED_SPHERE ||
      mris->status == MRIS_RIGID_BODY ||
      mris->status == MRIS_SPHERE)
  {
    double old_area ;
    old_area = mris->total_area ;
    mris->total_area = M_PI * mris->radius * mris->radius * 4.0 ;
  }
  return(NO_ERROR) ;
}

#ifdef FS_CUDA
/* this is a fork of mrisComputeMetricProperties,
   but ultimately shouldn't be
*/
int
mrisComputeMetricPropertiesCUDA(MRI_CUDA_SURFACE *mrics,MRI_SURFACE *mris)
{
#ifdef FS_CUDA_TIMINGS
  struct timeval tv1,tv2,result;
#endif // FS_CUDA_TIMINGS

  if(mris->status == MRIS_SPHERE ||
      mris->status == MRIS_PARAMETERIZED_SPHERE)
  {
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    MRIScomputeNormals(mris);
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("MRIScomputeMetricProperties->MRIScomputeNormals: %ld ms\n",
           result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);
#endif // FS_CUDA_TIMINGS

    /* UPLOAD the vertices here */
    MRISCuploadVertices(mrics,mris);

#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    //mrisComputeVertexDistances(mris);
    MRISCcomputeVertexDistances(mrics,mris);
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("CUDA MRIScomputeMetricProperties->mrisComputeVertexDistances: "
           "%ld ms\n",result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);
#endif // FS_CUDA_TIMINGS

    /* DOWNLOAD distances */
    MRISCdownloadDistances(mrics,mris);
  }
  else
  {
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
    int rval = MRIScomputeMetricProperties(mris);
#ifdef FS_CUDA_TIMINGS
    gettimeofday(&tv2,NULL);
    timeval_subtract(&result,&tv2,&tv1);
    printf("CPU MRIScomputeMetricProperties->mrisComputeVertexDistances: "
           "%ld ms\n",result.tv_sec*1000+result.tv_usec/1000);
    fflush(stdout);
#endif // FS_CUDA_TIMINGS
    return rval;
  }

#ifdef FS_CUDA_TIMINGS
  gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
  mrisComputeSurfaceDimensions(mris);
#ifdef FS_CUDA_TIMINGS
  gettimeofday(&tv2,NULL);
  timeval_subtract(&result,&tv2,&tv1);
  printf("MRIScomputeMetricProperties->mrisComputeSurfaceDimensions: "
         "%ld ms\n",result.tv_sec*1000+result.tv_usec/1000);
  fflush(stdout);

  gettimeofday(&tv1,NULL);
#endif // FS_CUDA_TIMINGS
  MRIScomputeTriangleProperties(mris);  /* compute areas and normals */
#ifdef FS_CUDA_TIMINGS
  gettimeofday(&tv2,NULL);
  timeval_subtract(&result,&tv2,&tv1);
  printf("MRIScomputeMetricProperties->MRIScomputeTriangleProperties: "
         "%ld ms\n",result.tv_sec*1000+result.tv_usec/1000);
  fflush(stdout);
#endif // FS_CUDA_TIMINGS

  mris->avg_vertex_area = mris->total_area/mris->nvertices;
  // this would obviously require the distances

  mris->avg_vertex_dist = MRISavgInterVertexDist(mris, &mris->std_vertex_dist);
  mrisOrientSurface(mris);
  // See also MRISrescaleMetricProperties()
  if (mris->status == MRIS_PARAMETERIZED_SPHERE ||
      mris->status == MRIS_RIGID_BODY ||
      mris->status == MRIS_SPHERE)
  {
    double old_area ;
    old_area = mris->total_area ;
    mris->total_area = M_PI * mris->radius * mris->radius * 4.0 ;
  }
  return(NO_ERROR) ;
}
#endif /* FS_CUDA */

/* --------------------------------------------------------------------
   MRISrescaleMetricProperties() - rescale metric properties (area,
   dist) of group surfaces so that they match that of the average of
   the input set. Does not change the actual vertex xyz. Requires that
   MRISrescaleMetricProperties() have been run. Returns the distance
   scaling factor. Has no effect if surface is not a group surface.
   -------------------------------------------------------------------- */
double MRISrescaleMetricProperties(MRIS *surf)
{
  int VtxNo, nthNNbr, nNNbrs, NbrVtxNo;
  VERTEX *vtx1,*vtx2;
  double scale;

  if (surf->group_avg_surface_area == 0)
  {
    return(0.0);  // not a group surface
  }

  scale = sqrt((double)surf->group_avg_surface_area/surf->total_area);
  printf("scale = %lf\n",scale);

  for (VtxNo = 0; VtxNo < surf->nvertices; VtxNo++)
  {
    vtx1 = &surf->vertices[VtxNo] ;
    if (vtx1->ripflag)
    {
      continue;
    }
    vtx1->area *= (scale*scale);
    nNNbrs = surf->vertices[VtxNo].vnum;
    for (nthNNbr = 0; nthNNbr < nNNbrs; nthNNbr++)
    {
      NbrVtxNo = surf->vertices[VtxNo].v[nthNNbr];
      vtx2 = &surf->vertices[NbrVtxNo] ;
      if (vtx2->ripflag)
      {
        continue;
      }
      vtx1->dist[nthNNbr] *= scale;
    }
  }
  surf->total_area *= (scale*scale);
  surf->avg_vertex_dist  *= scale;
  surf->std_vertex_dist  *= scale;
  surf->avg_vertex_area *= (scale*scale);
  return(scale);
}


/*------------------------------------------------------
  ------------------------------------------------------*/
static int mrisCountTotalNeighbors(MRI_SURFACE *mris)
{
  int     vno, total ;
  VERTEX  *v ;

  for (total = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    total += v->vtotal+1 ;  /* include this vertex in count */
  }
  return(total) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
static int
mrisComputeBoundaryTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
#if 0
  int    vno ;
  VERTEX *v ;
  double l_boundary ;

  l_boundary = parms->l_boundary ;

  if ((mris->status != MRIS_PLANE) || FZERO(l_boundary))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || !v->border)
    {
      continue ;
    }
    if (v->neg)
    {
#if 0
      v->dx -= l_boundary * v->bnx ;
      v->dy -= l_boundary * v->bny ;
#endif
    }
    else
    {
#if 1
      v->dx += l_boundary * v->bnx ;
      v->dy += l_boundary * v->bny ;
#endif
    }
  }

#endif
  return(NO_ERROR) ;
}
#endif


#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeNegTerm(MRI_SURFACE *mris,INTEGRATION_PARMS *parms)
{
  int    vno, n, neg ;
  VERTEX *v, *vn ;
  double l_neg, dx, dy, dz, len ;

  l_neg = parms->l_neg ;

  if (FZERO(l_neg))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (v->neg)
    {
      neg = 1 ;
    }
    else
    {
      neg = 0 ;
    }
    dx = dy = dz = 0.0 ;
    for (n = 0 ; n < v->vtotal ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->neg)
      {
        neg++ ;
        continue ;
      }
      dx += vn->x - v->x ;
      dy += vn->y - v->y ;
      dz += vn->z - v->z ;
    }
    len = sqrt(dx*dx + dy*dy + dz*dz) ;
    if (!FZERO(len) && neg > 0)
    {
      dx /= len ;
      dy /= len ;
      dz /= len ;
      v->dx += l_neg*dx ;
      v->dy += l_neg*dy ;
      v->dz += l_neg*dz ;
    }
  }

  return(NO_ERROR) ;
}
#endif


static int
mrisFlipPatch(MRI_SURFACE *mris)
{
  int     vno ;
  VERTEX  *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->x = -v->x ;
  }

  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  read in vertex positions from the original file,
  and compute the metric properties of that surface.
  Note we must change the status of the mris as the
  original surface has no externally defined orientation.
  ------------------------------------------------------*/
int
MRISreadOriginalProperties(MRI_SURFACE *mris, const char *sname)
{
  int  old_status ;

  if (!sname)
  {
    sname = "smoothwm" ;
  }

  MRISsaveVertexPositions(mris, TMP_VERTICES) ;

  old_status = mris->status ;
  mris->status = MRIS_PATCH ;  /* so no orientating will be done */
  if (MRISreadVertexPositions(mris, sname) != NO_ERROR)
    ErrorReturn(ERROR_BADFILE,
                (ERROR_BADFILE,
                 "MRISreadOriginalProperties: could not read surface file %s",
                 sname)) ;

  MRISsaveVertexPositions(mris, ORIGINAL_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;
  MRIScomputeTriangleProperties(mris) ;
  MRISstoreMetricProperties(mris) ;
  mris->status = old_status ;
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;
  MRIScomputeTriangleProperties(mris) ;
  mrisOrientSurface(mris) ;
  mris->orig_area = mris->total_area ;

  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISsaveVertexPositions(MRI_SURFACE *mris, int which)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
#if 0
    if (v->ripflag)
    {
      continue ;
    }
#endif
    switch (which)
    {
    case LAYERIV_VERTICES:
      v->l4x = v->x ;
      v->l4y = v->y ;
      v->l4z = v->z ;
      break ;
    case TARGET_VERTICES:
      v->targx = v->x ;
      v->targy = v->y ;
      v->targz = v->z ;
      break ;
    case WHITE_VERTICES:
      v->whitex = v->x ;
      v->whitey = v->y ;
      v->whitez = v->z ;
      break ;
    case PIAL_VERTICES:
      v->pialx = v->x ;
      v->pialy = v->y ;
      v->pialz = v->z ;
      break ;
    case INFLATED_VERTICES:
      v->infx = v->x ;
      v->infy = v->y ;
      v->infz = v->z ;
      break ;
    case FLATTENED_VERTICES:
      v->fx = v->x ;
      v->fy = v->y ;
      v->fz = v->z ;
      break ;
    case CANONICAL_VERTICES:
      v->cx = v->x ;
      v->cy = v->y ;
      v->cz = v->z ;
      break ;
    case ORIGINAL_VERTICES:
      v->origx = v->x ;
      v->origy = v->y ;
      v->origz = v->z ;
      break ;
    case TMP2_VERTICES:
      v->tx2 = v->x ;
      v->ty2 = v->y ;
      v->tz2 = v->z ;
      break ;
    default:
    case TMP_VERTICES:
      v->tx = v->x ;
      v->ty = v->y ;
      v->tz = v->z ;
      break ;
    }
  }
  if (which == CANONICAL_VERTICES)
  {
    MRIScomputeCanonicalCoordinates(mris) ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISsaveNormals(MRI_SURFACE *mris, int which)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    switch (which)
    {
    case TMP_VERTICES:
      v->tx = v->nx ;
      v->ty = v->ny ;
      v->tz = v->nz ;
      break ;
    case TMP2_VERTICES:
      v->tx2 = v->nx ;
      v->ty2 = v->ny ;
      v->tz2 = v->nz ;
      break ;
    case PIAL_VERTICES:
      v->pnx = v->nx ;
      v->pny = v->ny ;
      v->pnz = v->nz ;
      break ;
    case WHITE_VERTICES:
      v->wnx = v->nx ;
      v->wny = v->ny ;
      v->wnz = v->nz ;
      break ;
    case INFLATED_VERTICES:
    case FLATTENED_VERTICES:
    case CANONICAL_VERTICES:
    case ORIGINAL_VERTICES:
    default:
      ErrorExit(ERROR_BADPARM, "MRISsaveNormals: unsupported which %d", which);
      break ;
    }
  }
  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISrestoreNormals(MRI_SURFACE *mris, int which)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    switch (which)
    {
    case TMP_VERTICES:
      v->nx = v->tx ;
      v->ny = v->ty ;
      v->nz = v->tz ;
      break ;
    case TMP2_VERTICES:
      v->nx = v->tx2 ;
      v->ny = v->ty2 ;
      v->nz = v->tz2 ;
      break ;
    case PIAL_VERTICES:
      v->nx = v->pnx ;
      v->ny = v->pny ;
      v->nz = v->pnz ;
      break ;
    case WHITE_VERTICES:
    case INFLATED_VERTICES:
    case FLATTENED_VERTICES:
    case CANONICAL_VERTICES:
    case ORIGINAL_VERTICES:
    default:
      ErrorExit(ERROR_BADPARM, "MRISsaveNormals: unsupported which %d", which);
      break ;
    }
  }
  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScomputeCanonicalCoordinates(MRI_SURFACE *mris)
{
  float   theta, phi, r, d, x, y, z ;
  VERTEX  *v ;
  int     vno ;

  r = mris->radius = MRISaverageCanonicalRadius(mris) ;
  r = mris->radius = (float)nint(mris->radius) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    x = v->cx ;
    y = v->cy ;
    z = v->cz ;
    theta = atan2(y/r, x/r) ;
    if (theta < 0.0f)
    {
      theta = 2 * M_PI + theta ;  /* make it 0 --> 2*PI */
    }
    d = r*r-z*z ;
    if (d < 0.0)
    {
      d = 0.0 ;
    }
    phi = atan2(sqrt(d), z) ;
    v->theta = theta ;
    v->phi = phi ;
  }
  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISrestoreVertexPositions(MRI_SURFACE *mris, int which)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
#if 0
    if (v->ripflag)
    {
      continue ;
    }
#endif
    switch (which)
    {
    case TARGET_VERTICES:
      v->x = v->targx ;
      v->y = v->targy ;
      v->z = v->targz ;
      break ;
    case WHITE_VERTICES:
      v->x = v->whitex ;
      v->y = v->whitey ;
      v->z = v->whitez ;
      break ;
    case LAYERIV_VERTICES:
      v->x = v->l4x ;
      v->y = v->l4y ;
      v->z = v->l4z ;
      break ;
    case PIAL_VERTICES:
      v->x = v->pialx ;
      v->y = v->pialy ;
      v->z = v->pialz ;
      break ;
    case INFLATED_VERTICES:
      v->x = v->infx ;
      v->y = v->infy ;
      v->z = v->infz ;
      break ;
    case FLATTENED_VERTICES:
      v->x = v->fx ;
      v->y = v->fy ;
      v->z = v->fz ;
      break ;
    case CANONICAL_VERTICES:
      v->x = v->cx ;
      v->y = v->cy ;
      v->z = v->cz ;
      break ;
    case ORIGINAL_VERTICES:
      v->x = v->origx ;
      v->y = v->origy ;
      v->z = v->origz ;
      break ;
    case TMP2_VERTICES:
      v->x = v->tx2 ;
      v->y = v->ty2 ;
      v->z = v->tz2 ;
      break ;
    default:
    case TMP_VERTICES:
      v->x = v->tx ;
      v->y = v->ty ;
      v->z = v->tz ;
      break ;
    }
  }
  if (mris->status == MRIS_SPHERICAL_PATCH)
  {
    for (vno = 0 ; vno < nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      switch (which)
      {
      case WHITE_VERTICES:
        v->cx = v->whitex ;
        v->cy = v->whitey ;
        v->cz = v->whitez ;
        break ;
      case PIAL_VERTICES:
        v->cx = v->pialx ;
        v->cy = v->pialy ;
        v->cz = v->pialz ;
        break ;
      case INFLATED_VERTICES:
        v->cx = v->infx ;
        v->cy = v->infy ;
        v->cz = v->infz ;
        break ;
      case FLATTENED_VERTICES:
        v->cx = v->fx ;
        v->cy = v->fy ;
        v->cz = v->fz ;
        break ;
      case CANONICAL_VERTICES:
        v->cx = v->cx ;
        v->cy = v->cy ;
        v->cz = v->cz ;
        break ;
      case ORIGINAL_VERTICES:
        v->cx = v->origx ;
        v->cy = v->origy ;
        v->cz = v->origz ;
        break ;
      case TMP2_VERTICES:
        v->cx = v->tx2 ;
        v->cy = v->ty2 ;
        v->cz = v->tz2 ;
        break ;
      default:
      case TMP_VERTICES:
        v->cx = v->tx ;
        v->cy = v->ty ;
        v->cz = v->tz ;
        break ;
      }

    }
  }
  mrisComputeSurfaceDimensions(mris) ;
  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRISpercentDistanceError(MRI_SURFACE *mris)
{
  VERTEX  *v ;
  int     vno, n, nvertices ;
  double  dist_scale, pct, dist, odist, mean, mean_error ;

  if (mris->patch)
  {
    dist_scale = 1.0 ;
  }
  else
  {
    dist_scale = sqrt(mris->orig_area / mris->total_area) ;
  }

  mean = 0.0 ;
  for (pct = 0.0, nvertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    for (n = 0 ; n < v->vtotal ; n++)
    {
      nvertices++ ;
      dist = dist_scale*v->dist[n] ;
      odist = v->dist_orig[n] ;
      if (!FZERO(odist))
      {
        pct += fabs(dist - odist) / odist ;
      }
      mean += odist ;
    }
  }

  for (mean_error = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    for (n = 0 ; n < v->vtotal ; n++)

    {
      dist = dist_scale*v->dist[n] ;
      odist = v->dist_orig[n] ;
      mean_error += fabs(dist-odist) ;
      if (fabs(dist-odist) > 50)
      {
        DiagBreak() ;
      }
    }
  }
  mean /= (double)nvertices ;
  mean_error /= (double)nvertices ;
#if 0
  pct /= (double)nvertices ;
#else
  if (!FZERO(mean))
  {
    pct = mean_error / mean ;
  }
  else
  {
    pct = 1000.0 ;  /* should never happen */
  }
#endif
  return(100.0*pct) ;
}



/*-----------------------------------------------------
  int MRISfileNameType()

  Parameters: char *fname

  Returns value: int

  Description: return filetype using the extension
  default is MRIS_BINARY_QUADRANGLE_FILE
  ------------------------------------------------------*/
int
MRISfileNameType(const char *fname)
{
  int   type ;
  char  *dot, ext[STRLEN], str[STRLEN], *idext ;

  // First check whether it is a volume format
  idext = IDextensionFromName(fname);
  if(idext != NULL)
  {
    free(idext);
    return(MRIS_VOLUME_FILE);
  }

  FileNameOnly(fname, str) ;/* remove path */

  ext[0] = 0 ;
  dot = strrchr(str, '@') ;   /* forces the type of the file */
  if (dot)
  {
    *dot = 0 ;   /* remove it from file name so that fopen will work */
    strcpy(ext, dot+1) ;
  }
  else     /* no explicit type - check extension */
  {
    dot = strrchr(str, '.') ;
    if (dot)
    {
      strcpy(ext, dot+1) ;
    }
  }
  StrUpper(ext) ;
  if (!strcmp(ext, "ASC"))
  {
    type = MRIS_ASCII_TRIANGLE_FILE ;
  }
  else if (!strcmp(ext, "GEO"))
  {
    type = MRIS_GEO_TRIANGLE_FILE ;
  }
  else if (!strcmp(ext, "TRI") || !strcmp(ext, "ICO"))
  {
    type = MRIS_ICO_FILE ;
  }
  else if (!strcmp(ext, "VTK"))
  {
    type = MRIS_VTK_FILE ;
  }
  else if (!strcmp(ext, "STL"))
  {
    type = MRIS_STL_FILE ;
  }
  else if (!strcmp(ext, "GII"))
  {
    type = MRIS_GIFTI_FILE ;
  }
  else if (!strcmp(ext, "MGH"))
  {
    type = MRI_MGH_FILE ;  // surface-encoded volume
  }
  else if (!strcmp(ext, "ANNOT"))
  {
    type = MRIS_ANNOT_FILE ;
  }
  else
  {
    type = MRIS_BINARY_QUADRANGLE_FILE ;
  }

  return(type) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteAscii(MRI_SURFACE *mris, const char *fname)
{
  int     vno, fno, n ;
  VERTEX  *v ;
  FACE    *face ;
  FILE    *fp ;

  fp = fopen(fname, "w") ;
  if (!fp)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISwriteAscii: could not open file %s",fname));

  fprintf(fp, "#!ascii version of %s\n", mris->fname) ;
  fprintf(fp, "%d %d\n", mris->nvertices, mris->nfaces) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    fprintf(fp, "%f  %f  %f  %d\n", v->x, v->y, v->z, v->ripflag) ;
  }
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      fprintf(fp, "%d ", face->v[n]) ;
    }
    fprintf(fp, "%d\n", face->ripflag) ;
  }

  fclose(fp) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Description: Same as MRISwriteAscii, but write surface
  normals instead of
  ------------------------------------------------------*/
int
MRISwriteNormalsAscii(MRI_SURFACE *mris, const char *fname)
{
  int     vno, fno, n ;
  VERTEX  *v ;
  FACE    *face ;
  FILE    *fp ;

  fp = fopen(fname, "w") ;
  if (!fp)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISwriteNormalsAscii: could not open file %s",fname));

  fprintf(fp, "#!ascii version of %s (vertices are surface normals)\n",
          mris->fname) ;
  fprintf(fp, "%d %d\n", mris->nvertices, mris->nfaces) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    fprintf(fp, "%f  %f  %f  %d\n", v->nx, v->ny, v->nz, v->ripflag) ;
  }
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      fprintf(fp, "%d ", face->v[n]) ;
    }
    fprintf(fp, "%d\n", face->ripflag) ;
  }

  fclose(fp) ;
  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Description: Same write the surface normals into a .mgz volume
  ------------------------------------------------------*/
int
MRISwriteNormals(MRI_SURFACE *mris, const char *fname)
{
  int     vno ;
  VERTEX  *v ;
  MRI     *mri ;

  mri = MRIallocSequence(mris->nvertices, 1, 1, MRI_FLOAT, 3) ;
  if (mri == NULL)
  {
    ErrorReturn(ERROR_NOFILE, (ERROR_NOFILE, "MRISwriteNormals(%s): could not allocate volume", fname)) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    MRIsetVoxVal(mri, vno, 0, 0, 0, v->nx) ;
    MRIsetVoxVal(mri, vno, 0, 0, 1, v->ny) ;
    MRIsetVoxVal(mri, vno, 0, 0, 2, v->nz) ;
  }
  MRIwrite(mri, fname) ;
  MRIfree(&mri) ;
  return(NO_ERROR) ;
}
int
MRISreadNormals(MRI_SURFACE *mris, const char *fname)
{
  int     vno ;
  VERTEX  *v ;
  MRI     *mri ;

  mri = MRIread(fname) ;
  if (mri == NULL)
  {
    ErrorReturn(ERROR_NOFILE, (ERROR_NOFILE, "MRISreadNormals(%s): could not open volume", fname)) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->nx = MRIgetVoxVal(mri, vno, 0, 0, 0) ;
    v->ny = MRIgetVoxVal(mri, vno, 0, 0, 1) ;
    v->nz = MRIgetVoxVal(mri, vno, 0, 0, 2) ;
  }
  MRIfree(&mri) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Description: Same write the white matter surface normals into a .mgz volume
  ------------------------------------------------------*/
int
MRISwriteWhiteNormals(MRI_SURFACE *mris, const char *fname)
{
  int     vno ;
  VERTEX  *v ;
  MRI     *mri ;

  mri = MRIallocSequence(mris->nvertices, 1, 1, MRI_FLOAT, 3) ;
  if (mri == NULL)
  {
    ErrorReturn(ERROR_NOFILE, (ERROR_NOFILE, "MRISwriteWhiteNormals(%s): could not allocate volume", fname)) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    MRIsetVoxVal(mri, vno, 0, 0, 0, v->wnx) ;
    MRIsetVoxVal(mri, vno, 0, 0, 1, v->wny) ;
    MRIsetVoxVal(mri, vno, 0, 0, 2, v->wnz) ;
  }
  MRIwrite(mri, fname) ;
  MRIfree(&mri) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Description: write the principal curvature directions
  ------------------------------------------------------*/
int
MRISwritePrincipalDirection(MRI_SURFACE *mris, int dir_index, const char *fname)
{
  int     vno ;
  VERTEX  *v ;
  MRI     *mri ;

  mri = MRIallocSequence(mris->nvertices, 1, 1, MRI_FLOAT, 3) ;
  if (mri == NULL)
  {
    ErrorReturn(ERROR_NOFILE, (ERROR_NOFILE, "MRISwritePrincipalDirections(%s): could not allocate volume", fname)) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;

    if ( dir_index == 1 )
    {
      MRIsetVoxVal(mri, vno, 0, 0, 0, v->e1x) ;
      MRIsetVoxVal(mri, vno, 0, 0, 1, v->e1y) ;
      MRIsetVoxVal(mri, vno, 0, 0, 2, v->e1z) ;
    }
    else
    {
      MRIsetVoxVal(mri, vno, 0, 0, 0, v->e2x) ;
      MRIsetVoxVal(mri, vno, 0, 0, 1, v->e2y) ;
      MRIsetVoxVal(mri, vno, 0, 0, 2, v->e2z) ;
    }
  }
  MRIwrite(mri, fname) ;
  MRIfree(&mri) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteVTK(MRI_SURFACE *mris, const char *fname)
{
  int     vno, fno, n ;
  VERTEX  *v ;
  FACE    *face ;
  FILE    *fp ;

  fp = fopen(fname, "w") ;
  if (!fp)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISwriteVTK: could not open file %s",fname));

  fprintf(fp, "# vtk DataFile Version 1.0\n") ;
  fprintf(fp, "vtk output\nASCII\nDATASET POLYDATA\nPOINTS %d float\n",
          mris->nvertices) ;
  /*  fprintf(fp, "%d %d\n", mris->nvertices, mris->nfaces) ;*/

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    fprintf(fp, "%.9f  %.9f  %.9f\n", v->x, v->y, v->z) ;
  }
  fprintf(fp, "POLYGONS %d %d\n", mris->nfaces, mris->nfaces*4) ;
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    fprintf(fp,"%d ", VERTICES_PER_FACE) ;
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      fprintf(fp, "%d ", face->v[n]) ;
    }
    fprintf(fp, "\n") ;
  }

  fclose(fp) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description: Append the curv data to 'fname', which
  is assumed to have been written with point and face
  data via the MRISwriteVTK routine.
  ------------------------------------------------------*/
int
MRISwriteCurvVTK(MRI_SURFACE *mris, const char *fname)
{
  FILE *fp = fopen(fname, "a") ;
  if (!fp)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "MRISwriteScalarVTK: could not open file %s",fname));

  fprintf(fp, "POINT_DATA %d\n", mris->nvertices) ;
  fprintf(fp, "FIELD FieldData 1\n") ;
  fprintf(fp, "curv 1 %d double\n", mris->nvertices) ;

  int vno ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    VERTEX *v = &mris->vertices[vno] ;
    fprintf(fp, "%.9f\n", v->curv) ;
  }

  fclose(fp) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI_SURFACE *MRISreadVTK(MRI_SURFACE *mris, const char *fname)
{
  char line[STRLEN], *cp = NULL;

  FILE *fp = fopen(fname, "r") ;
  if (!fp)
  {
    ErrorReturn(NULL,
                (ERROR_NOFILE,
                 "MRISreadVTK: could not open file %s\n",fname));
  }

  /* a valid file must have these three lines (see MRISwriteVTK):
  vtk output
  ASCII
  DATASET POLYDATA
  */
  int checks=0;
  while ((cp = fgetl(line, STRLEN, fp)))
  {
    // handle both upper and lower case
    if (strncmp(cp,"VTK OUTPUT",10)==0)
    {
      checks++;
    }
    if (strncmp(cp,"vtk output",10)==0)
    {
      checks++;
    }
    if (strncmp(cp,"ASCII",5)==0)
    {
      checks++;
    }
    if (strncmp(cp,"ascii",5)==0)
    {
      checks++;
    }
    if (strncmp(cp,"DATASET POLYDATA",16)==0)
    {
      checks++;
    }
    if (strncmp(cp,"dataset polydata",16)==0)
    {
      checks++;
    }
    //printf("%s\n",cp);
    if (checks == 3)
    {
      break;
    }
  }
  if (!cp || (checks != 3))
  {
    fclose(fp);
    ErrorReturn
    (NULL,
     (ERROR_NOFILE,
      "MRISreadVTK: error reading file %s\n",fname));
  }

  /* now the next line should look like this (get the number of vertices):
  POINTS 142921 float
  */
  int nvertices = 0;
  cp = fgetl(line, STRLEN, fp) ;
  if (!cp)
  {
    fclose(fp);
    ErrorReturn
    (NULL,
     (ERROR_NOFILE,
      "MRISreadVTK: error parsing POINTS from file %s\n",fname));
  }
  if ((sscanf(cp, "POINTS %d float\n", &nvertices)) ||
      (sscanf(cp, "points %d float\n", &nvertices)))
  {
    if (nvertices <= 0)
    {
      fclose(fp);
      ErrorReturn
      (NULL,
       (ERROR_NOFILE,
        "MRISreadVTK: error reading file %s, invalid nvertices=%d\n",
        fname,nvertices));
    }
  }
  else
  {
    fclose(fp);
    ErrorReturn
    (NULL,
     (ERROR_NOFILE,
      "MRISreadVTK: error reading file %s, no POINTS field\n",fname));
  }

  /* if needed, alloc MRIS structure (we'll handle faces later in the file) */
  int newMris=0;// flag to indicate vertices and face data are empty
  if (NULL == mris)
  {
    mris = MRISalloc(nvertices, 0) ;  // note: nfaces=0 for now...
    mris->type = MRIS_TRIANGULAR_SURFACE ;
    newMris = 1; // flag indicating need to fill-in vertex and face data
  }
  else
  {
    // confirm that the mris structure we've been passed has the same
    // number of vertices
    if (mris->nvertices != nvertices)
    {
      fclose(fp);
      ErrorReturn
      (NULL,
       (ERROR_NOFILE,
        "MRISreadVTK: error reading file %s, mismatched nvertices=%d/%d\n",
        fname,mris->nvertices,nvertices));
    }
  }

  /* read vertices... */
  int vno;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    VERTEX v;
    fscanf(fp, "%f %f %f", &v.x, &v.y, &v.z) ;
    if (newMris) // if passed an mris struct, dont overwrite x,y,z
    {
      mris->vertices[vno].x = v.x;
      mris->vertices[vno].y = v.y;
      mris->vertices[vno].z = v.z;
    }
  }

  /* now, if we're lucky, we've read all the vertices, and the next line
     should be something like this:
  POLYGONS 285838 1143352
  */
  cp = fgetl(line, STRLEN, fp) ;
  if (!cp)
  {
    fclose(fp);
    ErrorReturn
    (NULL,
     (ERROR_NOFILE,
      "MRISreadVTK: error parsing POLYGONS in file %s",fname));
  }
  int nfaces = 0;
  int somenum = 0; // should be nfaces * 4
  if ((sscanf(cp, "POLYGONS %d %d\n", &nfaces, &somenum)) ||
      (sscanf(cp, "polygons %d %d\n", &nfaces, &somenum)))
  {
    if (nfaces <= 0)
    {
      fclose(fp);
      ErrorReturn
      (NULL,
       (ERROR_NOFILE,
        "MRISreadVTK: error reading file %s, invalid nfaces=%d\n",
        fname,nfaces));
    }
    if (somenum != (nfaces*4)) // check for 3-vertex face data
    {
      fclose(fp);
      ErrorReturn
      (NULL,
       (ERROR_NOFILE,
        "MRISreadVTK: error reading file %s, invalid POLYGON data\n",fname));
    }
  }
  else
  {
    fclose(fp);
    ErrorReturn
    (NULL,
     (ERROR_NOFILE,
      "MRISreadVTK: error parsing POLYGONS in file %s",fname));
  }
  // POLYGONS field looks valid....

  /* now we can book some face space (if we have a new mris structure) */
  if (newMris)
  {
    mris->nfaces = nfaces ;
    mris->faces = (FACE *)calloc(nfaces, sizeof(FACE)) ;
    if (!mris->faces)
    {
      fclose(fp);
      ErrorExit(ERROR_NO_MEMORY,
                "MRISreadVTK(%d, %d): could not allocate faces",
                nfaces, sizeof(FACE));
    }
    else
    {
      memset(mris->faces,0,nfaces*sizeof(FACE));
    }
  }
  else
  {
    // confirm that the mris structure passed to us has the expected num faces
    if (mris->nfaces != nfaces)
    {
      fclose(fp);
      ErrorReturn
      (NULL,
       (ERROR_NOFILE,
        "MRISreadVTK: error reading file %s, mismatched nfaces=%d/%d\n",
        fname,mris->nfaces,nfaces));
    }
  }

  /* finally, read the face data...*/
  int fno, facepoints=0;
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    FACE *face = &mris->faces[fno] ;
    fscanf(fp, "%d ", &facepoints);
    if (facepoints != 3)
    {
      fclose(fp);
      ErrorReturn
      (NULL,
       (ERROR_NOFILE,
        "MRISreadVTK: error reading file %s, facepoints != 3\n",fname));
    }
    int n;
    for (n = 0 ; n < 3 ; n++)
    {
      vno = -1;
      fscanf(fp, "%d", &vno) ;
      if ((vno < 0) || (vno >= nvertices))
      {
        fclose(fp);
        ErrorReturn
        (NULL,
         (ERROR_NOFILE,
          "MRISreadVTK: invalid vertex num in %s, vno = %d\n",fname,vno));
      }
      if (newMris) // dont overwrite face data if passed an mris struct
      {
        // fill-in the face data to our new mris struct
        face->v[n] = vno;
        mris->vertices[vno].num++;
      }
      else
      {
        // confirm that the mris structure passed to us has the same face num
        if (face->v[n] != vno)
        {
          fclose(fp);
          ErrorReturn
          (NULL,
           (ERROR_NOFILE,
            "MRISreadVTK: error reading file %s, mismatched faces=%d/%d\n",
            fname,face->v[n],vno));
        }
      }
    }
  }
  if (fno != mris->nfaces)
  {
    fclose(fp);
    ErrorReturn
    (NULL,
     (ERROR_NOFILE,
      "MRISreadVTK: failure reading %s, fno=%d != nfaces\n",
      fname,fno,mris->nfaces));
  }

  /* at this point in the file, we're at the end, or there is possibly
     curv or scalar data fields to read */
  cp = fgetl(line, STRLEN, fp) ;
  //printf("%s\n",cp);
  int nvertices_data=0;
  if (cp) // it appears we have another line...
  {
    if ((sscanf(cp, "POINT_DATA %d\n", &nvertices_data)) ||
        (sscanf(cp, "point_data %d\n", &nvertices_data)))
    {
      if (nvertices != nvertices_data)
      {
        fclose(fp);
        ErrorReturn
        (NULL,
         (ERROR_NOFILE,
          "MRISreadVTK: error reading file %s, invalid nvertices=%d "
          "in POINT_DATA field, expected %d vertices\n",
          fname,nvertices_data,nvertices));
      }
      int nfields=0;
      cp = fgetl(line, STRLEN, fp) ;
      //printf("%s\n",cp);
      if ((sscanf(cp, "FIELD %*s %d\n", &nfields)) ||
          (sscanf(cp, "field %*s %d\n", &nfields)))
      {
        int num_fields;
        for (num_fields=0; num_fields < nfields; num_fields++)
        {
          // parse each data field
          char fieldName[STRLEN];
          int fieldNum=0;
          cp = fgetl(line, STRLEN, fp) ;
          //printf("%s\n",cp);
          if (sscanf(cp, "%s %d %d %*s\n",
                     fieldName,&fieldNum,&nvertices_data))
          {
            if (nvertices != nvertices_data)
            {
              fclose(fp);
              ErrorReturn
              (NULL,
               (ERROR_NOFILE,
                "MRISreadVTK: error reading file %s, invalid nvertices=%d "
                "in %s field, expected %d vertices\n",
                fname,nvertices_data,fieldName,nvertices));
            }
            // read either scalar or curv data
            int isCurvData=0;
            if (strncmp(fieldName,"curv",4)==0)
            {
              isCurvData = 1;
            }
            if (strncmp(fieldName,"CURV",4)==0)
            {
              isCurvData = 1;
            }
            float curvmin = 10000.0f ;
            float curvmax = -10000.0f ;  /* for compiler warnings */
            for (vno = 0 ; vno < mris->nvertices ; vno++)
            {
              VERTEX *v = &mris->vertices[vno] ;
              float f = 0.0;
              if (fscanf(fp, "%f", &f))
              {
                v->curv = f; // fill-in both curvature and scalar data fields
                v->val = f;
                if (isCurvData)
                {
                  //printf("%f\n",v->curv);
                  if (vno==0)
                  {
                    curvmin=curvmax=v->curv;
                  }
                  if (v->curv > curvmax)
                  {
                    curvmax=v->curv;
                  }
                  if (v->curv < curvmin)
                  {
                    curvmin=v->curv;
                  }
                }
              }
              else
              {
                fclose(fp);
                ErrorReturn
                (NULL,
                 (ERROR_NOFILE,
                  "MRISreadVTK: error parsing %s FIELD in file %s",
                  fieldName,fname));
              }
            }
            if (isCurvData)
            {
              mris->max_curv = curvmax ;
              mris->min_curv = curvmin ;
              //printf("maxcurv=%f, mincurv=%f\n",curvmax, curvmin);
            }
          }
          else
          {
            fclose(fp);
            ErrorReturn
            (NULL,
             (ERROR_NOFILE,
              "MRISreadVTK: error parsing FIELDs in file %s",fname));
          }
        }
      }
    }
  }

  fclose(fp) ;
  return(mris) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteGeo(MRI_SURFACE *mris, const char *fname)
{
  int     vno, fno, n, actual_vno, toggle, nfaces, nvertices, vnos[300000] ;
  VERTEX  *v ;
  FACE    *face ;
  FILE    *fp ;

  nfaces = mrisValidFaces(mris) ;
  nvertices = MRISvalidVertices(mris) ;
  fp = fopen(fname, "w") ;
  if (!fp)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISwriteGeo: could not open file %s",fname));

  fprintf(fp, "    1 %d %d %d\n", nvertices,
          nfaces, VERTICES_PER_FACE*nfaces) ;
  fprintf(fp, "    1 %d\n", nfaces) ;
  for (actual_vno = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    vnos[vno] = actual_vno++ ;
  }

  for (toggle = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    fprintf(fp, "%12.5e %12.5e %12.5e", v->x, v->y, v->z) ;
    if (toggle)
    {
      toggle = 0 ;
      fprintf(fp, "\n") ;
    }
    else
    {
      toggle = 1 ;
      fprintf(fp, " ") ;
    }
  }
  if (toggle)
  {
    fprintf(fp, "\n") ;
  }

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
    for (n = 0 ; n < VERTICES_PER_FACE-2 ; n++)
    {
      fprintf(fp, "%d ", vnos[face->v[n]]+1);  /* 1-based */
    }

    /* swap order on output to conform to movie.byu convention */
    fprintf(fp, "%d ",vnos[face->v[VERTICES_PER_FACE-1]]+1) ;
    fprintf(fp, "-%d\n",vnos[face->v[VERTICES_PER_FACE-2]]+1);
  }

  fclose(fp) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters: MRI_SURFACE *mris, char *fname

  Returns value: int

  Description: write ascii icosahedron data (vertices and face vertices info)
  ------------------------------------------------------*/
/* note that .tri or .ico file.  numbering is 1-based output.*/
int
MRISwriteICO(MRI_SURFACE *mris, const char *fname)
{
  int     vno, fno, nfaces, nvertices;
  int     actual_fno, actual_vno;
  VERTEX  *v ;
  FACE    *face ;
  FILE    *fp ;
  // get the valid faces and vertices numbers
  nfaces = mrisValidFaces(mris) ;
  nvertices = MRISvalidVertices(mris) ;

  fp = fopen(fname, "w") ;
  if (!fp)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISwriteICO: could not open file %s",fname));

  // write number of vertices
  fprintf(fp, "%8d\n", nvertices);
  // go over all vertices and ignoring bad ones
  actual_vno = 1; // count from 1 (1-based output)
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    fprintf(fp, "%8d %8.4f %8.4f %8.4f\n", actual_vno, v->x, v->y, v->z) ;
    actual_vno++;
  }
  // write number of faces
  fprintf(fp, "%8d\n", nfaces);
  // go over all faces and ignoring bad ones
  actual_fno = 1; // count from 1 (1-based)
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
    // make the vertex number 1 based
    // the vertex ordering flipped to clockwise (see icosahedron.c)
    fprintf(fp, "%8d %8d %8d %8d\n",
            actual_fno,face->v[0]+1,face->v[2]+1,face->v[1]+1);
    actual_fno++;
  }
  fclose(fp) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwritePatchAscii(MRI_SURFACE *mris, const char *fname)
{
  FILE    *fp ;
  int     vno, fno, n, nvertices, nfaces, type ;
  VERTEX  *v ;
  FACE    *face ;
  int     i;

  type = MRISfileNameType(fname) ;
#if 0
  if (type == MRIS_ASCII_TRIANGLE_FILE)
  {
    return(MRISwriteAscii(mris, fname)) ;
  }
#endif

  fp = fopen(fname, "w") ;
  if (!fp)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISwritePatchAscii: could not open file %s",
                 fname));

  for (nvertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    nvertices++ ;
  }
  for (nfaces = fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
    nfaces++ ;
  }
  fprintf(fp, "#!ascii version of patch %s. "
          "The 1st index is not a vertex number\n", mris->fname) ;
  fprintf(fp, "%d %d\n", nvertices, nfaces) ;
  fprintf(stdout, "nvertices=%d (valid=%d) nfaces=%d\n", nvertices,
          MRISvalidVertices(mris), nfaces) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (!v->ripflag)
    {
      // patch file uses border to change vertex index written to a file
      i = (v->border) ? (-(vno+1)) : (vno+1);
      fprintf(fp, "%d vno=%d\n", i, vno) ;
      fprintf(fp, "%f  %f  %f\n", v->x, v->y, v->z) ;
    }
  }
  // face vertex info
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (!face->ripflag)
    {
      fprintf(fp, "%d\n", fno) ;
      for (n = 0 ; n < VERTICES_PER_FACE ; n++)
      {
        fprintf(fp, "%d ", face->v[n]) ;
      }
      fprintf(fp, "\n") ;
    }
  }
  fclose(fp) ;
  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters: MRI_SURFACE *mris, char *fname

  Returns value: int

  Description: write ascii STL (stereolithography) format
  ------------------------------------------------------*/
int MRISwriteSTL(MRI_SURFACE *mris, const char *fname)
{
  int     vno, fno;
  VERTEX  *v ;
  FACE    *face ;
  FILE    *fp ;

  fp = fopen(fname, "w") ;
  if (!fp)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISwriteSTL: could not open file %s",fname));

  fprintf(fp, "solid %s\n", fname);

  // go over all faces, ignoring bad ones
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }

    fprintf(fp, "facet normal %f %f %f\n", face->nx, face->ny, face->nz);
    fprintf(fp, "  outer loop\n");

    for (vno = 0 ; vno < VERTICES_PER_FACE ; vno++)
    {
      v = &mris->vertices[face->v[vno]];
      fprintf(fp, "    vertex %f %f %f\n", v->x, v->y, v->z);
    }

    fprintf(fp, "  endloop\n");
    fprintf(fp, "endfacet\n");
  }

  fprintf(fp, "endsolid %s\n", fname);

  fclose(fp) ;

  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static MRI_SURFACE *
mrisReadAsciiFile(const char *fname)
{
  MRI_SURFACE   *mris ;
  char    line[STRLEN], *cp ;
  int     vno, fno, n, nvertices, nfaces, patch, rip ;
  VERTEX  *v ;
  FACE    *face ;
  FILE    *fp ;

  fp = fopen(fname, "r") ;
  if (!fp)
    ErrorReturn(NULL,
                (ERROR_NOFILE,
                 "MRISreadAsciiFile: could not open file %s",fname));

  patch = 0 ;
  cp = fgetl(line, STRLEN, fp) ;
  sscanf(cp, "%d %d\n", &nvertices, &nfaces) ;
  mris = MRISalloc(nvertices, nfaces) ;
#if 0
  mris->type = MRIS_ASCII_TRIANGLE_FILE ;
#else
  mris->type = MRIS_TRIANGULAR_SURFACE ;
#endif
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    fscanf(fp, "%f  %f  %f  %d\n", &v->x, &v->y, &v->z, &rip) ;
    v->ripflag = rip ;
    if (v->ripflag)
    {
      patch = 1 ;
    }
  }
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      fscanf(fp, "%d ", &face->v[n]) ;
      mris->vertices[face->v[n]].num++;
    }
    fscanf(fp, "%d\n", &rip) ;
    face->ripflag = rip ;
  }

  mris->patch = patch ;
  if (patch)
  {
    mris->status = MRIS_PLANE ;
  }
  fclose(fp) ;
  return(mris) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static MRI_SURFACE *
mrisReadGeoFile(const char *fname)
{
  MRI_SURFACE   *mris ;
  char    line[202], *cp ;
  int     vno, fno, n, nvertices, nfaces, patch, vertices_per_face, nedges ;
  VERTEX  *v ;
  FACE    *face ;
  FILE    *fp ;

  fp = fopen(fname, "r") ;
  if (!fp)
    ErrorReturn(NULL,
                (ERROR_NOFILE,
                 "mrisReadGeoFile: could not open file %s",fname));

  patch = 0 ;
  cp = fgetl(line, 100, fp) ;
  if (sscanf(cp, "%*d %d %d %d\n", &nvertices, &nfaces, &nedges) != 3)
  {
    fclose(fp) ;
    ErrorReturn(NULL, (ERROR_BADFILE, "mrisReadGeoFile(%s): could not scan "
                       "dimensions from '%s'", fname, cp)) ;
  }
  vertices_per_face = nedges / nfaces ;
  if (vertices_per_face != VERTICES_PER_FACE)
  {
    fclose(fp) ;
    ErrorReturn(NULL, (ERROR_BADFILE,
                       "mrisReadGeoFile(%s): unsupported vertices/face %d.",
                       fname, vertices_per_face)) ;
  }

  cp = fgetl(line, 200, fp) ;   /* nfaces again */
  mris = MRISalloc(nvertices, nfaces) ;
  mris->type = MRIS_GEO_TRIANGLE_FILE ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    fscanf(fp, "%e %e %e", &v->x, &v->y, &v->z) ;
    if (ISODD(vno))
    {
      fscanf(fp, "\n") ;
    }
  }
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    int tmp ;
    face = &mris->faces[fno] ;
    for (n = 0 ; n < VERTICES_PER_FACE-1 ; n++)
    {
      fscanf(fp, "%d ", &face->v[n]) ;
      face->v[n]-- ;   /* make it 0-based */
      if (face->v[n] < 0)
      {
        DiagBreak() ;
      }
      mris->vertices[face->v[n]].num++;
    }
    n = VERTICES_PER_FACE-1 ;   /* already true - but make it explicit */
    fscanf(fp, "-%d\n", &face->v[n]) ;
    face->v[n]-- ;   /* make it 0-based */
    mris->vertices[face->v[n]].num++;

    /* swap positions so normal (via cross-product) will point outwards */
    tmp = face->v[1] ;
    face->v[1] = face->v[2] ;
    face->v[2] = tmp ;
  }

  fclose(fp) ;
  return(mris) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisReadGeoFilePositions(MRI_SURFACE *mris, const char *fname)
{
  char    line[202], *cp ;
  int     vno, nvertices, nfaces, patch, vertices_per_face, nedges ;
  VERTEX  *v ;
  FILE    *fp ;

  fp = fopen(fname, "r") ;
  if (!fp)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE,
                 "mrisReadGeoFile: could not open file %s",fname));

  patch = 0 ;
  cp = fgetl(line, 100, fp) ;
  if (sscanf(cp, "%*d %d %d %d\n", &nvertices, &nfaces, &nedges) != 3)
  {
    fclose(fp) ;
    ErrorReturn(ERROR_BADFILE,
                (ERROR_BADFILE, "mrisReadGeoFile(%s): could not scan "
                 "dimensions from '%s'", fname, cp)) ;
  }
  vertices_per_face = nedges / nfaces ;
  if (vertices_per_face != VERTICES_PER_FACE)
  {
    fclose(fp) ;
    ErrorReturn(ERROR_BADFILE,
                (ERROR_BADFILE,
                 "mrisReadGeoFile(%s): unsupported vertices/face %d.",
                 fname, vertices_per_face)) ;
  }

  cp = fgetl(line, 200, fp) ;   /* nfaces again */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    fscanf(fp, "%e %e %e", &v->x, &v->y, &v->z) ;
    if (ISODD(vno))
    {
      fscanf(fp, "\n") ;
    }
  }

  fclose(fp) ;
  return(NO_ERROR) ;
}


#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static MRI_SURFACE *
mrisReadAsciiPatchFile(char *fname)
{
  MRI_SURFACE   *mris ;
  char    line[STRLEN], *cp ;
  int     vno, fno, n, nvertices, nfaces ;
  VERTEX  *v ;
  FACE    *face ;
  FILE    *fp ;

  fp = fopen(fname, "r") ;
  if (!fp)
    ErrorReturn(NULL,
                (ERROR_NOFILE,
                 "MRISreadAsciiFile: could not open file %s",fname));

  cp = fgetl(line, 100, fp) ;
  sscanf(cp, "%d %d\n", &nvertices, &nfaces) ;
  mris = MRISalloc(nvertices, nfaces) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    fscanf(fp, "%f  %f  %f\n", &v->x, &v->y, &v->z) ;
  }
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      fscanf(fp, "%d ", &face->v[n]) ;
      mris->vertices[face->v[n]].num++;
    }
    fscanf(fp, "\n") ;
  }

  fclose(fp) ;
  return(mris) ;
}
#endif


/*-----------------------------------------------------
  Parameters:    input file name of STL file

  Returns value: freesurfer surface structure

  Description:   reads an ascii stereolithography (STL)
                 formatted file, putting vertices, faces,
                 and face normals into an MRIS_SURFACE
                 structure.
  ------------------------------------------------------*/
static MRI_SURFACE * mrisReadSTLfile(const char *fname)
{
  MRI_SURFACE   *mris;
  char    line[STRLEN], *cp ;
  int     nfaces, fno, vno, fvno, n2;
  VERTEX  *v ;
  FACE    *face = NULL;
  FILE    *fp ;

  fp = fopen(fname, "r") ;
  if (!fp)
    ErrorReturn(NULL,
                (ERROR_NOFILE,
                 "MRISreadSTLfile: could not open file %s",fname));

  // confirm that this is an STL file.
  // the first word on the first line should be 'solid'
  cp = fgetl(line, STRLEN, fp);
  if (!cp)
    ErrorReturn
    (NULL,
     (ERROR_NOFILE,
      "MRISreadSTLfile: error reading file %s",fname));
  if (strncmp(cp,"solid",5))
    ErrorReturn
    (NULL,
     (ERROR_NOFILE,
      "MRISreadSTLfile: file %s does not appear to be an STL file",fname));

  // now count the number of faces in the file, so that we can alloc
  nfaces=0;
  while ((cp = fgetl(line, STRLEN, fp)))
  {
    if (strncmp(cp,"endfacet",8)==0)
    {
      nfaces++;
    }
    if (strncmp(cp,"endsolid",8)==0)
    {
      break;
    }
  }
  if (!cp)
  {
    ErrorReturn
    (NULL,
     (ERROR_NOFILE,
      "MRISreadSTLfile: error reading file %s",fname));
  }

  // start from the beginning of the file...
  fclose(fp) ;
  fp = fopen(fname, "r") ;
  if (!fp)
    ErrorReturn(NULL,
                (ERROR_NOFILE,
                 "MRISreadSTLfile: could not open file %s",fname));

  // the STL file format does not account for vertices shared by faces,
  // so we must alloc the max number of vertices
  mris = MRISalloc(nfaces*3, nfaces) ;
  if (mris==NULL)
  {
    ErrorReturn(NULL,
                (ERROR_NOMEMORY,
                 "MRISreadSTLfile: could not alloc memory for mris"));
  }
  else
  {
    mris->type = MRIS_TRIANGULAR_SURFACE ;
  }

  fno=0;
  vno=0;
  fvno=0;
  while ((cp = fgetl(line, STRLEN, fp)))
  {
    // start of file indicator
    if (strncmp(cp,"solid",5)==0)
    {
      continue;
    }

    if (strncmp(cp,"facet ",6)==0)
    {
      face = &mris->faces[fno];
      sscanf(cp, "facet normal %f %f %f", &face->nx, &face->ny, &face->nz);
    }

    if (strncmp(cp,"outer loop",10)==0)
    {
      continue;
    }

    if (strncmp(cp,"vertex ",7)==0)
    {
      v = &mris->vertices[vno];
      sscanf(cp, "vertex %f %f %f", &v->x, &v->y, &v->z);
      face->v[fvno]=vno;
      vno++;
      if (++fvno>=3)
      {
        fvno=0;
      }
    }

    if (strncmp(cp,"endloop",7)==0)
    {
      continue;
    }

    if (strncmp(cp,"endfacet",8)==0)
    {
      fno++;
    }

    // end of file indicator
    if (strncmp(cp,"endsolid",8)==0)
    {
      break;
    }
  }
  if (!cp)
  {
    ErrorReturn
    (NULL,
     (ERROR_NOFILE,
      "MRISreadSTLfile: error reading file %s",fname));
  }
  else
  {
    printf("Found %d faces and %d vertices in STL file\n",fno,vno);
  }

  mris->nvertices=vno;
  mris->nfaces=fno;
  nfaces=fno;

#if 1  // code checking for duplicate vertices takes forever to execute!
  {
    MRI_SURFACE *mris_new;
    int     nduplicates, nvertices, n;
    VERTEX  *v2 ;
    int     *vnums,*vnums2;
    FACE    *face_new;

    // check for duplicate vertices.
    // the STL format does not account for these.
    vnums = (int *)calloc(mris->nvertices, sizeof(int)) ;

    // assume no duplicates:
    for (n=0; n < mris->nvertices; n++)
    {
      vnums[n] = n;
    }

    // make note of duplicates in vnums array...
    nduplicates = 0;
    for (n=0; n < mris->nvertices - 1; n++)
    {
      printf ("Checking vertex %d (found %d duplicates)\r",n,nduplicates);
      v = &mris->vertices[n];
      for (n2 = n+1; n2 < mris->nvertices; n2++)
      {
        if (vnums[n2] == vnums[n])
        {
          continue;  // already caught this one
        }
        v2 = &mris->vertices[n2];
        if ((fabs(v->x - v2->x)==0) &&
            (fabs(v->y - v2->y)==0) &&
            (fabs(v->z - v2->z)==0))
        {
          // its a duplicate, so save the existing vertex number
          vnums[n2] = n;
          nduplicates++;
        }
      }
    }

    // create old to new mapping table
    vnums2 = (int *)calloc(mris->nvertices, sizeof(int)) ;
    nduplicates=0;
    for (n=0; n < mris->nvertices; n++)
    {
      if (vnums[n] != n)
      {
        nduplicates++;
        vnums2[n] = -1;
      }
      else
      {
        vnums2[n] = n - nduplicates;
      }
    }

    // count unique vertices
    nvertices = 0;
    for (n=0; n < mris->nvertices; n++)
    {
      if (vnums[n] == n)
      {
        nvertices++;
      }
    }
    printf("\nFound %d unique vertices\n",nvertices);

    // now create new data structure, absent the duplicates
    mris_new = MRISalloc(nvertices, nfaces) ;
    if (mris_new==NULL)
    {
      ErrorReturn(NULL,
                  (ERROR_NOMEMORY,
                   "MRISreadSTLfile: could not alloc memory for mris_new"));
    }
    mris_new->type = MRIS_TRIANGULAR_SURFACE ;
    mris_new->nvertices = nvertices;
    mris_new->nfaces = nfaces;
    for (n=0, n2=0; n < mris->nvertices; n++)
    {
      if (vnums[n] == n)
      {
        v = &mris->vertices[n];
        v2 = &mris_new->vertices[n2];
        v2->x = v->x;
        v2->y = v->y;
        v2->z = v->z;
        n2++;
      }
    }
    if (n2 != nvertices) // sanity check
    {
      ErrorReturn(NULL,
                  (ERROR_BADPARM,
                   "MRISreadSTLfile: nvertices != n2"));
    }

    for (fno = 0 ; fno < mris->nfaces ; fno++)
    {
      face = &mris->faces[fno] ;
      face_new = &mris_new->faces[fno] ;
      for (fvno = 0 ; fvno < VERTICES_PER_FACE ; fvno++)
      {
        face_new->v[fvno] = vnums2[vnums[face->v[fvno]]];
      }
    }
    mris = mris_new;
  }
#endif // end of duplicate checking code

#if 1
  {
    int fvno2, vn;

    /* count # of faces each vertex is part of */
    for (fno = 0 ; fno < mris->nfaces ; fno++)
    {
      face = &mris->faces[fno] ;
      for (fvno = 0 ; fvno < VERTICES_PER_FACE ; fvno++)
      {
        v = &mris->vertices[face->v[fvno]] ;
        v->num++ ;
        v->vnum += 2 ;
      }
    }

    // alloc mem for neighbor list for each vertex
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      v->v = (int *)calloc(v->vnum, sizeof(int)) ;
      if (!v->v)
        ErrorExit(ERROR_NOMEMORY,
                  "MRISreadSTLfile: could not allocate %dth vertex list.",
                  vno) ;
      v->vnum = 0 ;
    }

    /* now build list of neighbors */
    for (fno = 0 ; fno < mris->nfaces ; fno++)
    {
      face = &mris->faces[fno] ;
      for (fvno = 0 ; fvno < VERTICES_PER_FACE ; fvno++)
      {
        v = &mris->vertices[face->v[fvno]] ;

        /* now add an edge to other 2 vertices if not already in list */
        for (fvno2 = 0 ; fvno2 < VERTICES_PER_FACE ; fvno2++)
        {
          if (fvno2 == fvno)   /* don't connect vertex to itself */
          {
            continue ;
          }

          vn = mris->faces[fno].v[fvno2] ;

          /* now check to make sure it's not a duplicate */
          for (n2 = 0 ; n2 < v->vnum ; n2++)
          {
            if (v->v[n2] == vn)
            {
              vn = -1 ; /* mark it as a duplicate */
              break ;
            }
          }
          if (vn >= 0)
          {
            v->v[v->vnum++] = vn ;
          }
        }
      }
    }

    /* now allocate face arrays in vertices */
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      v->f = (int *)calloc(v->num, sizeof(int)) ;
      if (!v->f)
        ErrorExit(ERROR_NO_MEMORY,
                  "MRISreadSTLfileICOread: could not allocate %d faces",
                  v->num);
      v->n = (unsigned char *)calloc(v->num,sizeof(unsigned char));
      if (!v->n)
        ErrorExit(ERROR_NO_MEMORY,
                  "MRISreadSTLfile: could not allocate %d nbrs", v->n);
      v->num = 0 ;   /* for use as counter in next section */
      v->dist = (float *)calloc(v->vnum, sizeof(float)) ;
      if (!v->dist)
        ErrorExit(ERROR_NOMEMORY,
                  "MRISreadSTLfile: could not allocate list of %d "
                  "dists at v=%d", v->vnum, vno) ;
      v->dist_orig = (float *)calloc(v->vnum, sizeof(float)) ;
      if (!v->dist_orig)
        ErrorExit(ERROR_NOMEMORY,
                  "MRISreadSTLfile: could not allocate list of %d "
                  "dists at v=%d", v->vnum, vno) ;
      v->vtotal = v->vnum ;
    }

    /* fill in face indices in vertex structures */
    for (fno = 0 ; fno < mris->nfaces ; fno++)
    {
      face = &mris->faces[fno] ;
      for (fvno = 0 ; fvno < VERTICES_PER_FACE ; fvno++)
      {
        v = &mris->vertices[face->v[fvno]] ;
        v->n[v->num] = fvno ;
        v->f[v->num++] = fno ;
      }
    }
  }
#endif

  fclose(fp) ;

  return(mris) ;
}


double
MRIScomputeCorrelationError(MRI_SURFACE *mris,MRI_SP *mrisp_template,int fno)
{
  INTEGRATION_PARMS  parms ;
  float              error ;

  if (!mrisp_template)
  {
    return(0.0) ;
  }

  memset(&parms, 0, sizeof(parms)) ;
  parms.mrisp_template = mrisp_template ;
  parms.l_corr = 1.0f ;
  parms.frame_no = fno ;
  error = mrisComputeCorrelationError(mris, &parms, 1) ;
  return(sqrt(error / (double)MRISvalidVertices(mris))) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
mrisComputeCorrelationError(MRI_SURFACE *mris, INTEGRATION_PARMS *parms,
                            int use_stds)
{
  double   src, target, sse, delta, std ;
  VERTEX   *v ;
  int      vno, max_vno ;
  float    x, y, z, l_corr, max_delta ;

  l_corr = parms->l_corr + parms->l_pcorr ;  /* only one will be nonzero */
  if (FZERO(l_corr))
  {
    return(0.0) ;
  }

  max_delta = 0.0 ;
  max_vno = -1 ;
  for (sse = 0.0f, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;
#if 0
    src = MRISPfunctionVal(parms->mrisp, mris, x, y, z, 0) ;
#else
    src = v->curv ;
#endif
    target = MRISPfunctionVal(parms->mrisp_template, mris, x, y, z,
                              parms->frame_no) ;
#define DEFAULT_STD  4.0f
#define DISABLE_STDS  0
#if DISABLE_STDS
    std = 1.0f ;
#else
    std = MRISPfunctionVal(parms->mrisp_template,mris,x,y,z,parms->frame_no+1);
    std = sqrt(std) ;
    if (FZERO(std))
    {
      std = DEFAULT_STD /*FSMALL*/ ;
    }
    if (!use_stds)
    {
      std = 1.0f ;
    }
#endif
    delta = (src - target) / std ;
    if (fabs(delta) > max_delta)
    {
      max_delta = fabs(delta) ;
      max_vno = vno ;
    }
    if (!finite(target) || !finite(delta))
    {
      DiagBreak() ;
    }
    if (parms->geometry_error)
    {
      parms->geometry_error[vno] = (delta*delta) ;
    }
    if (parms->abs_norm)
    {
      sse += fabs(delta) ;
    }
    else
    {
      sse += delta * delta ;
    }
  }
  return(sse) ;
}

static double
mrisComputeVectorCorrelationError(MRI_SURFACE *mris,
                                  INTEGRATION_PARMS *parms,
                                  int use_stds)
{
  double   src, target, sse, delta, std ;
  VERTEX   *v ;
  int      n,vno ,fno ;
  float    x, y, z, l_corr ;

  double *vals,*corrs,*sses;
  int nframes,*frames,*ind;

  for ( nframes = n = 0 ; n < parms->nfields ; n++ )
  {
    l_corr = parms->fields[n].l_corr+parms->fields[n].l_pcorr ;
    if (FZERO(l_corr))
    {
      continue;
    }
    nframes++;
  }
  if (!nframes)
  {
    return 0.0;
  }

  corrs=(double*)malloc(nframes*sizeof(double));
  sses=(double*)malloc(nframes*sizeof(double));
  ind =(int*)malloc(nframes*sizeof(int));

  vals=(double*)malloc(2*nframes*sizeof(double)); /* include the variances */
  frames=(int*)malloc(2*nframes*sizeof(int));
  for ( nframes = n = 0 ; n < parms->nfields ; n++ )
  {
    l_corr = parms->fields[n].l_corr+parms->fields[n].l_pcorr ;
    if (FZERO(l_corr))
    {
      continue;
    }
    fno = parms->fields[n].frame * IMAGES_PER_SURFACE;
    frames[2*nframes]= fno;
    frames[2*nframes+1]= fno+1;
    ind[nframes]=n;
    corrs[nframes]= l_corr;
    nframes++;
  }

  memset(sses,0,nframes*sizeof(double)); /* set the vals to zero */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;
    /* get the template values (variance included) */
    MRISPfunctionVectorVals(parms->mrisp_template,
                            mris, x, y, z, frames, 2*nframes ,vals) ;
#define DEFAULT_STD  4.0f
#if DISABLE_STDS
    for (n = 0 ; n < nframes ; n++)
    {
      src = ((VALS_VP*)v->vp)->vals[ind[n]] ;
      target = vals[2*n];
      std = 1.0f;
      delta = (src - target) / std ;
      sses[n] += delta*delta;
    }
#else
    for (n = 0 ; n < nframes ; n++)
    {
      src = ((VALS_VP*)v->vp)->vals[ind[n]] ;
      target = vals[2*n];
      std = sqrt(vals[2*n+1]);
      if (FZERO(std))
      {
        std = DEFAULT_STD /*FSMALL*/ ;  /* to be checked */
      }
      if (!use_stds)
      {
        std = 1.0f ;
      }

      if (parms->fields[ind[n]].type)
      {
        std=MAX(0.01,std);
      }

      delta = (src - target) / std ;

      //if(vno==0) fprintf(stderr,"[%d : %f , %f , %f ]",n, src,target,std);

      sses[n] += delta*delta;
    }
#endif
  }
  sse=0.0f;
  for (n = 0 ; n < nframes ; n++)
  {
    //fprintf(stderr,"(%d,%f,%f -> %f)\n",n,corrs[n],sses[n],corrs[n]*sses[n]);
    parms->fields[ind[n]].sse = sses[n];
    sse +=      corrs[n] * sses[n];
  }

  free(corrs);
  free(sses);
  free(ind);
  free(frames);
  free(vals);

  return (sse);

#if 0
  sse=0.0f; /* compiler warnings */
  for (n=0 ; n < parms->nfields ; n++)
  {

    l_corr = parms->fields[n].l_corr+parms->fields[n].l_pcorr ;

    if (FZERO(l_corr))
    {
      continue;
    }

    fno = parms->fields[n].frame * IMAGES_PER_SURFACE;

    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }

      x = v->x ;
      y = v->y ;
      z = v->z ;
#if 0
      src = MRISPfunctionVal(parms->mrisp, mris, x, y, z, 0) ;
#else
      src = ((VALS_VP*)v->vp)->vals[n] ;
#endif
      target = MRISPfunctionVal(parms->mrisp_template, mris, x, y, z, fno) ;
#define DEFAULT_STD  4.0f
#define DISABLE_STDS  0
#if DISABLE_STDS
      std = 1.0f ;
#else
      std = MRISPfunctionVal(parms->mrisp_template,mris,x,y,z,fno+1);
      std = sqrt(std) ;
      if (FZERO(std))
      {
        std = DEFAULT_STD /*FSMALL*/ ;
      }
      if (!use_stds)
      {
        std = 1.0f ;
      }
#endif
      delta = (src - target) / std ;
      if (!finite(target) || !finite(delta))
      {
        DiagBreak() ;
      }
      sse += l_corr * delta * delta ;
    }
  }
  return(sse) ;
#endif
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/

static int
mrisComputeCorrelationTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  double   du, dv, up1, um1, vp1, vm1, delta, src, target, mag, max_mag,l_corr;
  VERTEX   *v ;
  int      vno, fno ;
  float    x, y, z, e1x, e1y, e1z, e2x, e2y, e2z, ux, uy, uz, vx, vy, vz,
           std, coef, vsmooth = 1.0 ;

  l_corr = parms->l_corr ;
  if (FZERO(l_corr))
  {
    return(NO_ERROR) ;
  }
  fno = parms->frame_no ;
  mrisComputeTangentPlanes(mris) ;
  max_mag = 0.0f ;
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    MRISPwrite(parms->mrisp_template, "temp.hipl") ;
    MRISPwrite(parms->mrisp, "srf.hipl") ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    e1x = v->e1x ;
    e1y = v->e1y ;
    e1z = v->e1z ;
    e2x = v->e2x ;
    e2y = v->e2y ;
    e2z = v->e2z ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
#if 0
    src = MRISPfunctionVal(parms->mrisp, mris, x, y, z, 0) ;
#else
    src = v->curv ;
#endif
    target = MRISPfunctionVal(parms->mrisp_template,mris,x,y,z,
                              parms->frame_no);
    std = MRISPfunctionVal(parms->mrisp_template,mris,x,y,z,parms->frame_no+1);
    std = sqrt(std) ;
    if (FZERO(std))
    {
      std = DEFAULT_STD /*FSMALL*/ ;
    }
#if DISABLE_STDS
    std = 1.0f ;
#endif
    delta = (target-src) ;
    if (parms->vsmoothness)
    {
      vsmooth = 1.0 + parms->vsmoothness[vno] ;
    }
    coef = vsmooth * delta * l_corr / std ;

    /* now compute gradient of template w.r.t. a change in vertex position */

    /*
      sample the curvature functions along the tangent plane axes and
      compute the derivates using them.
    */
    ux = e1x*D_DIST ;
    uy = e1y*D_DIST ;
    uz = e1z*D_DIST ;
    vx = e2x*D_DIST ;
    vy = e2y*D_DIST ;
    vz = e2z*D_DIST ;

#if 0
    /* compute src term */
    up1 = MRISPfunctionVal(parms->mrisp, mris, x+ux, y+uy, z+uz, fno) ;
    um1 = MRISPfunctionVal(parms->mrisp, mris, x-ux, y-uy, z-uz, fno) ;
    vp1 = MRISPfunctionVal(parms->mrisp, mris, x+vx, y+vy, z+vz, fno) ;
    vm1 = MRISPfunctionVal(parms->mrisp, mris, x-vx, y-vy, z-vz, fno) ;
    du = (up1 - um1) / (2 * D_DIST) ;
    dv = (vp1 - vm1) / (2 * D_DIST) ;
    v->dx += coef * (du*e1x + dv*e2x) ;  /* in negative of grad. direction */
    v->dy += coef * (du*e1y + dv*e2y) ;
    v->dz += coef * (du*e1z + dv*e2z) ;
#endif

    /* compute target term */
    up1 = MRISPfunctionVal(parms->mrisp_template, mris, x+ux, y+uy, z+uz, fno);
    um1 = MRISPfunctionVal(parms->mrisp_template, mris, x-ux, y-uy, z-uz, fno);
    vp1 = MRISPfunctionVal(parms->mrisp_template, mris, x+vx, y+vy, z+vz, fno);
    vm1 = MRISPfunctionVal(parms->mrisp_template, mris, x-vx, y-vy, z-vz, fno);
    du = (up1 - um1) / (2 * D_DIST) ;
    dv = (vp1 - vm1) / (2 * D_DIST) ;
    v->dx -= coef * (du*e1x + dv*e2x) ;
    v->dy -= coef * (du*e1y + dv*e2y) ;
    v->dz -= coef * (du*e1z + dv*e2z) ;

    mag = sqrt(v->dx*v->dx + v->dy*v->dy + v->dz*v->dz) ;
    if (mag > max_mag)
    {
      max_mag = mag ;
    }
    if (!finite(v->dx) || !finite(v->dy) || !finite(v->dz))
    {
      DiagBreak() ;
      ErrorExit(ERROR_BADPARM,
                "mrisComputeCorrelationTerm: delta is not finite at vno %d",
                vno) ;
    }
    if (vno == Gdiag_no)
      printf("l_corr(%d): dx = (%2.2f, %2.2f, %2.2f), vsmooth = %2.3f\n",
             vno, coef * (du*e1x + dv*e2x),  coef * (du*e1y + dv*e2y), coef * (du*e1z + dv*e2z), vsmooth);
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "max gradient magnitude = %2.5f\n", max_mag) ;
  }

  return(NO_ERROR) ;
}

static int mrisComputeVectorCorrelationTerm(MRI_SURFACE *mris,
    INTEGRATION_PARMS *parms)
{
  double   du, dv, up1, um1, vp1, vm1, delta, src, target, mag, max_mag,l_corr;
  VERTEX   *v ;
  int      vno, fno ,n ;
  float    x, y, z, e1x, e1y, e1z, e2x, e2y, e2z, ux, uy, uz, vx, vy, vz, std;
  double *vals,*upvals,*umvals,*vpvals,*vmvals,*corrs;
  int nframes,*frames,*wv_frames,*ind;

  for ( nframes = n = 0 ; n < parms->nfields ; n++ )
  {
    l_corr = parms->fields[n].l_corr ;
    if (FZERO(l_corr))
    {
      continue;
    }
    nframes++;
  }
  if (!nframes)
  {
    return NO_ERROR;  /* no frames */
  }

  corrs=(double*)malloc(nframes*sizeof(double)); /* correlation coefficients */
  ind =(int*)malloc(nframes*sizeof(int));

  vals=(double*)malloc(2*nframes*sizeof(double));   /* include the variances */
  frames=(int*)malloc(2*nframes*sizeof(int));       /* include the variances */
  upvals=(double*)malloc(nframes*sizeof(double));   /* without the variances */
  umvals=(double*)malloc(nframes*sizeof(double));
  vpvals=(double*)malloc(nframes*sizeof(double));
  vmvals=(double*)malloc(nframes*sizeof(double));
  wv_frames=(int*)malloc(nframes*sizeof(int));

  for ( nframes = n = 0 ; n < parms->nfields ; n++ )
  {
    l_corr = parms->fields[n].l_corr ;
    if (FZERO(l_corr))
    {
      continue;
    }
    fno = parms->fields[n].frame * IMAGES_PER_SURFACE;
    frames[2*nframes]= fno;     /* mean field */
    frames[2*nframes+1]= fno+1; /* variance field */
    wv_frames[nframes] = fno;
    ind[nframes]=n;
    corrs[nframes]= l_corr;
    nframes++;
  }

  mrisComputeTangentPlanes(mris) ;
  max_mag = 0.0f ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    e1x = v->e1x ;
    e1y = v->e1y ;
    e1z = v->e1z ;
    e2x = v->e2x ;
    e2y = v->e2y ;
    e2z = v->e2z ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
    target = MRISPfunctionVectorVals(parms->mrisp_template,mris,x,y,z,frames,2*nframes,vals);
    /* now compute gradient of template w.r.t. a change in vertex position */
    /*
      sample the fields along the tangent plane axes and
      compute the derivates using them.
    */
    ux = e1x*D_DIST ;
    uy = e1y*D_DIST ;
    uz = e1z*D_DIST ;
    vx = e2x*D_DIST ;
    vy = e2y*D_DIST ;
    vz = e2z*D_DIST ;
    /* compute target terms */
    up1 = MRISPfunctionVectorVals(parms->mrisp_template, mris,
                                  x+ux, y+uy, z+uz, wv_frames,nframes,upvals);
    um1 = MRISPfunctionVectorVals(parms->mrisp_template, mris,
                                  x-ux, y-uy, z-uz, wv_frames,nframes,umvals);
    vp1 = MRISPfunctionVectorVals(parms->mrisp_template, mris,
                                  x+vx, y+vy, z+vz, wv_frames,nframes,vpvals);
    vm1 = MRISPfunctionVectorVals(parms->mrisp_template, mris,
                                  x-vx, y-vy, z-vz, wv_frames,nframes,vmvals);

#if DISABLE_STDS
    for (n = 0 ; n < nframes ; n++)
    {
      src = ((VALS_VP*)v->vp)->vals[ind[n]] ;
      target = vals[2*n];
      std = 1.0f;
      delta = corrs[n] * (target - src) / std ;

      du = (upvals[n] - umvals[n]) / (2 * D_DIST) ;
      dv = (vpvals[n] - vmvals[n]) / (2 * D_DIST) ;

      v->dx -= delta * (du*e1x + dv*e2x) ;
      v->dy -= delta * (du*e1y + dv*e2y) ;
      v->dz -= delta * (du*e1z + dv*e2z) ;
    }
#else
    for (n = 0 ; n < nframes ; n++)
    {
      src = ((VALS_VP*)v->vp)->vals[ind[n]] ;
      target = vals[2*n];
      std = sqrt(vals[2*n+1]);
      if (FZERO(std))
      {
        std = DEFAULT_STD /*FSMALL*/ ;  /* to be checked */
      }
      delta = corrs[n] * (target - src) / std ;

      du = (upvals[n] - umvals[n]) / (2 * D_DIST) ;
      dv = (vpvals[n] - vmvals[n]) / (2 * D_DIST) ;

      v->dx -= delta * (du*e1x + dv*e2x) ;
      v->dy -= delta * (du*e1y + dv*e2y) ;
      v->dz -= delta * (du*e1z + dv*e2z) ;
    }
#endif
    mag = sqrt(v->dx*v->dx + v->dy*v->dy + v->dz*v->dz) ;
    if (mag > max_mag)
    {
      max_mag = mag ;
    }
    if (!finite(v->dx) || !finite(v->dy) || !finite(v->dz))
    {
      DiagBreak() ;
      ErrorExit
      (ERROR_BADPARM,
       "mrisComputeVectorCorrelationTerm: delta is not finite at vno %d",
       vno) ;
    }
  }
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "max gradient magnitude = %2.5f\n", max_mag) ;
  }

  free(corrs);
  free(ind);
  free(vals);
  free(upvals);
  free(umvals);
  free(vpvals);
  free(vmvals);
  free(frames);
  free(wv_frames);

#if 0
  mrisComputeTangentPlanes(mris) ;
  max_mag = 0.0f ;
  for (n=0 ; n < parms->nfields ; n++)
  {

    l_corr = parms->fields[n].l_corr ;

    if (FZERO(l_corr))
    {
      continue;
    }

    fno = parms->fields[n].frame * IMAGES_PER_SURFACE;

    max_mag = 0.0f ;

    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }

      e1x = v->e1x ;
      e1y = v->e1y ;
      e1z = v->e1z ;
      e2x = v->e2x ;
      e2y = v->e2y ;
      e2z = v->e2z ;
      x = v->x ;
      y = v->y ;
      z = v->z ;
#if 0
      src = MRISPfunctionVal(parms->mrisp, mris, x, y, z, 0) ;
#else
      src = ((VALS_VP*)v->vp)->vals[n] ;
#endif
      target = MRISPfunctionVal(parms->mrisp_template,mris,x,y,z,fno);
      std = MRISPfunctionVal(parms->mrisp_template,mris,x,y,z,fno+1);
      std = sqrt(std) ;
      if (FZERO(std))
      {
        std = DEFAULT_STD /*FSMALL*/ ;
      }
#if DISABLE_STDS
      std = 1.0f ;
#endif
      delta = (target-src) ;
      coef = delta * l_corr / std ;

      /* now compute gradient of template w.r.t. a change in vertex position */

      /*
        sample the curvature functions along the tangent plane axes and
        compute the derivates using them.
      */
      ux = e1x*D_DIST ;
      uy = e1y*D_DIST ;
      uz = e1z*D_DIST ;
      vx = e2x*D_DIST ;
      vy = e2y*D_DIST ;
      vz = e2z*D_DIST ;

#if 0
      /* compute src term */
      up1 = MRISPfunctionVal(parms->mrisp, mris, x+ux, y+uy, z+uz, fno) ;
      um1 = MRISPfunctionVal(parms->mrisp, mris, x-ux, y-uy, z-uz, fno) ;
      vp1 = MRISPfunctionVal(parms->mrisp, mris, x+vx, y+vy, z+vz, fno) ;
      vm1 = MRISPfunctionVal(parms->mrisp, mris, x-vx, y-vy, z-vz, fno) ;
      du = (up1 - um1) / (2 * D_DIST) ;
      dv = (vp1 - vm1) / (2 * D_DIST) ;
      v->dx += coef * (du*e1x + dv*e2x) ;  /* in negative of grad. direction */
      v->dy += coef * (du*e1y + dv*e2y) ;
      v->dz += coef * (du*e1z + dv*e2z) ;
#endif

      /* compute target term */
      up1 =
        MRISPfunctionVal(parms->mrisp_template, mris, x+ux, y+uy, z+uz, fno);
      um1 =
        MRISPfunctionVal(parms->mrisp_template, mris, x-ux, y-uy, z-uz, fno);
      vp1 =
        MRISPfunctionVal(parms->mrisp_template, mris, x+vx, y+vy, z+vz, fno);
      vm1 =
        MRISPfunctionVal(parms->mrisp_template, mris, x-vx, y-vy, z-vz, fno);
      du = (up1 - um1) / (2 * D_DIST) ;
      dv = (vp1 - vm1) / (2 * D_DIST) ;
      v->dx -= coef * (du*e1x + dv*e2x) ;
      v->dy -= coef * (du*e1y + dv*e2y) ;
      v->dz -= coef * (du*e1z + dv*e2z) ;

      mag = sqrt(v->dx*v->dx + v->dy*v->dy + v->dz*v->dz) ;
      if (mag > max_mag)
      {
        max_mag = mag ;
      }
      if (!finite(v->dx) || !finite(v->dy) || !finite(v->dz))
      {
        DiagBreak() ;
        ErrorExit
        (ERROR_BADPARM,
         "mrisComputeVectorCorrelationTerm: delta is not finite at vno %d",
         vno) ;
      }
    }
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "max gradient magnitude = %2.5f\n", max_mag) ;
  }
#endif

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#define D_ANGLE  RADIANS(0.25)

static int
mrisComputePolarCorrelationTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  double   ap1, am1, da, bp1, bm1, db, gp1, gm1, dg, delta, src, target, mag,
           max_mag ;
  VERTEX   *v ;
  int      vno, fno ;
  float    x, y, z, std, coef, dx, dy, dz, nv, r ;

  if (FZERO(parms->l_pcorr))
  {
    return(NO_ERROR) ;
  }
  fno = parms->frame_no ;
  max_mag = 0.0f ;
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    MRISPwrite(parms->mrisp_template, "temp.hipl") ;
    /*    MRISPwrite(parms->mrisp, "srf.hipl") ;*/
  }
  mris->gamma = mris->beta = mris->alpha = 0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;
#if 0
    src = MRISPfunctionVal(parms->mrisp, mris, x, y, z, 0) ;
#else
    src = v->curv ;
#endif
    target = MRISPfunctionVal(parms->mrisp_template,mris,x,y,z,
                              parms->frame_no);
    std =
      MRISPfunctionVal(parms->mrisp_template,mris,x,y,z,parms->frame_no+1);
    std = sqrt(std) ;
    if (FZERO(std))
    {
      std = DEFAULT_STD /*FSMALL*/ ;
    }
#if DISABLE_STDS
    std = 1.0f ;
#endif
    delta = (target-src) ;
    coef = delta / std ;

    /* now compute gradient of template w.r.t. a change in vertex position */

    /*
      compute the gradient by using differential rotations in the 3
      rotational directions using the associated skew-symmetric
      differential rotation matrices
    */
    /* compute alpha term - differential rotation around z axis */
    dx = y*D_ANGLE ;
    dy = -x*D_ANGLE ;
    dz = 0 ;
    am1 =
      MRISPfunctionVal(parms->mrisp_template, mris, x-dx, y-dy, z-dz, 0) ;
    ap1 =
      MRISPfunctionVal(parms->mrisp_template, mris, x+dx, y+dy, z+dz, 0) ;
    da = (ap1 - am1) / (2*D_ANGLE);

    /* compute beta term - differential rotation around y axis */
    dx = -z*D_ANGLE ;
    dy = 0 ;
    dz = x*D_ANGLE ;
    bm1 =
      MRISPfunctionVal(parms->mrisp_template, mris, x-dx, y-dy, z-dz, 0) ;
    bp1 =
      MRISPfunctionVal(parms->mrisp_template, mris, x+dx, y+dy, z+dz, 0) ;
    db = (bp1 - bm1) / (2*D_ANGLE);

    /* compute gamma term - differential rotation around x axis */
    dx = 0 ;
    dy = -z*D_ANGLE ;
    dz = y*D_ANGLE ;
    gm1 =
      MRISPfunctionVal(parms->mrisp_template, mris, x-dx, y-dy, z-dz, 0) ;
    gp1 =
      MRISPfunctionVal(parms->mrisp_template, mris, x+dx, y+dy, z+dz, 0) ;
    dg = (gp1 - gm1) / (2*D_ANGLE);

    mris->gamma -= coef * dg ;   /* around x-axis */
    mris->beta  -= coef * db ;   /* around y-axis */
    mris->alpha -= coef * da ;   /* around z-axis */

    mag = sqrt(v->dx*v->dx + v->dy*v->dy + v->dz*v->dz) ;
    if (mag > max_mag)
    {
      max_mag = mag ;
    }
    if (!finite(v->dx) || !finite(v->dy) || !finite(v->dz))
    {
      DiagBreak() ;
      ErrorExit
      (ERROR_BADPARM,
       "mrisComputePolarCorrelationTerm: delta is not finite at vno %d",
       vno) ;
    }
  }

  nv = MRISvalidVertices(mris) ;
  r = mris->radius ;
  mris->alpha /= nv ;
  mris->beta /= nv ;
  mris->gamma /= nv ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->dx = r*mris->alpha ;
    v->dy = r*mris->beta ;
    v->dz = r*mris->gamma ;
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "max gradient magnitude = %2.5f\n", max_mag) ;
  }

  return(NO_ERROR) ;
}

static int
mrisComputePolarVectorCorrelationTerm
(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  double    da, db, dg, delta, src, target, l_pcorr ;
  VERTEX   *v ;
  int      vno, fno ,n ;
  float    x, y, z, std,  dx, dy, dz, nv, r ;

  double *vals,*dalpha,*dbeta,*dgamma,*apvals,*amvals,
         *bpvals,*bmvals,*gpvals,*gmvals,*corrs;
  int nframes,*frames,*wv_frames,*ind;

  for ( nframes = n = 0 ; n < parms->nfields ; n++ )
  {
    l_pcorr = parms->fields[n].l_pcorr ;
    if (FZERO(l_pcorr))
    {
      continue;
    }
    nframes++;
  }
  if (!nframes)
  {
    return NO_ERROR;  /* no frames */
  }

  corrs=(double*)malloc(nframes*sizeof(double)); /* correlation coefficients */
  dalpha=(double*)malloc(nframes*sizeof(double)); /* gradient coefficients */
  dbeta=(double*)malloc(nframes*sizeof(double)); /* gradient coefficients */
  dgamma=(double*)malloc(nframes*sizeof(double)); /* gradient coefficients */
  ind =(int*)malloc(nframes*sizeof(int));

  vals=(double*)malloc(2*nframes*sizeof(double));   /* include the variances */
  frames=(int*)malloc(2*nframes*sizeof(int));       /* include the variances */
  apvals=(double*)malloc(nframes*sizeof(double));   /* without the variances */
  amvals=(double*)malloc(nframes*sizeof(double));
  bpvals=(double*)malloc(nframes*sizeof(double));
  bmvals=(double*)malloc(nframes*sizeof(double));
  gpvals=(double*)malloc(nframes*sizeof(double));
  gmvals=(double*)malloc(nframes*sizeof(double));
  wv_frames=(int*)malloc(nframes*sizeof(int));

  for ( nframes = n = 0 ; n < parms->nfields ; n++ )
  {
    l_pcorr = parms->fields[n].l_pcorr ;
    if (FZERO(l_pcorr))
    {
      continue;
    }
    fno = parms->fields[n].frame * IMAGES_PER_SURFACE;
    frames[2*nframes]= fno;     /* mean field */
    frames[2*nframes+1]= fno+1; /* variance field */
    wv_frames[nframes]=fno;
    ind[nframes]=n;
    corrs[nframes]= l_pcorr;
    nframes++;
  }

  memset(dalpha,0,nframes*sizeof(double));
  memset(dbeta,0,nframes*sizeof(double));
  memset(dgamma,0,nframes*sizeof(double));
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    target = MRISPfunctionVectorVals
             (parms->mrisp_template,mris,x,y,z,frames,2*nframes,vals);
    /*
      compute the gradient by using differential rotations in the 3
      rotational directions using the associated skew-symmetric
      differential rotation matrices
    */
    /* compute alpha term - differential rotation around z axis */
    dx = y*D_ANGLE ;
    dy = -x*D_ANGLE ;
    dz = 0 ;
    MRISPfunctionVectorVals
    (parms->mrisp_template, mris,
     x-dx, y-dy, z-dz,wv_frames,nframes, amvals) ;
    MRISPfunctionVectorVals
    (parms->mrisp_template, mris,
     x+dx, y+dy, z+dz, wv_frames,nframes,apvals) ;

    /* compute beta term - differential rotation around y axis */
    dx = -z*D_ANGLE ;
    dy = 0 ;
    dz = x*D_ANGLE ;
    MRISPfunctionVectorVals
    (parms->mrisp_template, mris,
     x-dx, y-dy, z-dz, wv_frames,nframes,bmvals) ;
    MRISPfunctionVectorVals
    (parms->mrisp_template, mris,
     x+dx, y+dy, z+dz, wv_frames,nframes,bpvals) ;


    /* compute gamma term - differential rotation around x axis */
    dx = 0 ;
    dy = -z*D_ANGLE ;
    dz = y*D_ANGLE ;
    MRISPfunctionVectorVals
    (parms->mrisp_template, mris,
     x-dx, y-dy, z-dz, wv_frames,nframes,gmvals) ;
    MRISPfunctionVectorVals
    (parms->mrisp_template, mris,
     x+dx, y+dy, z+dz, wv_frames,nframes,gpvals) ;

#if DISABLE_STDS
    for (n = 0 ; n < nframes ; n++)
    {
      src = ((VALS_VP*)v->vp)->vals[ind[n]] ;
      target = vals[2*n];
      std = 1.0f;
      delta = (target - src) / std ;

      da = (apvals[n] - amvals[n]) / (2*D_ANGLE);
      dalpha[n] += delta * da;

      db = (bpvals[n] - bmvals[n]) / (2*D_ANGLE);
      dbeta[n] += delta * db;

      dg = (gpvals[n] - gmvals[n]) / (2*D_ANGLE);
      dgamma[n] += delta * dg;
    }
#else
    for (n = 0 ; n < nframes ; n++)
    {
      src = ((VALS_VP*)v->vp)->vals[ind[n]] ;
      target = vals[2*n];
      std = sqrt(vals[2*n+1]);
      if (FZERO(std))
      {
        std = DEFAULT_STD /*FSMALL*/ ;  /* to be checked */
      }
      delta = (target - src) / std ;

      da = (apvals[n] - amvals[n]) / (2*D_ANGLE);
      dalpha[n] += delta * da;

      db = (bpvals[n] - bmvals[n]) / (2*D_ANGLE);
      dbeta[n] += delta * db;

      dg = (gpvals[n] - gmvals[n]) / (2*D_ANGLE);
      dgamma[n] += delta * dg;
    }
#endif
  }

  mris->gamma = mris->beta = mris->alpha = 0 ;
  for ( n = 0 ; n < nframes ; n++)
  {
    mris->gamma -= corrs[n] * dgamma[n] ;   /* around x-axis */
    mris->beta  -= corrs[n] * dbeta[n] ;   /* around y-axis */
    mris->alpha -= corrs[n] * dalpha[n] ;   /* around z-axis */
  }

  nv = MRISvalidVertices(mris) ;
  r = mris->radius ;
  mris->alpha /= nv ;
  mris->beta /= nv ;
  mris->gamma /= nv ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->dx = r*mris->alpha ;
    v->dy = r*mris->beta ;
    v->dz = r*mris->gamma ;
  }

  free(corrs);
  free(dalpha);
  free(dbeta);
  free(dgamma);
  free(ind);
  free(vals);
  free(frames);
  free(apvals);
  free(amvals);
  free(bpvals);
  free(bmvals);
  free(gpvals);
  free(gmvals);
  free(wv_frames);


#if 0

  for (n=0 ; n < parms->nfields ; n++)
  {

    l_pcorr = parms->fields[n].l_pcorr ;
    if (FZERO(l_pcorr))
    {
      continue;
    }

    fno = parms->fields[n].frame * IMAGES_PER_SURFACE ;

    mris->gamma = mris->beta = mris->alpha = 0 ;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }

      x = v->x ;
      y = v->y ;
      z = v->z ;
#if 0
      src = MRISPfunctionVal(parms->mrisp, mris, x, y, z, 0) ;
#else
      src = ((VALS_VP*)v->vp)->vals[n] ;
#endif
      target = MRISPfunctionVal(parms->mrisp_template,mris,x,y,z,fno);
      std = MRISPfunctionVal(parms->mrisp_template,mris,x,y,z,fno+1);
      std = sqrt(std) ;
      if (FZERO(std))
      {
        std = DEFAULT_STD /*FSMALL*/ ;
      }
#if DISABLE_STDS
      std = 1.0f ;
#endif
      delta = (target-src) ;
      coef = delta * l_pcorr / std ;

      /* now compute gradient of template w.r.t. a change in vertex position */

      /*
        compute the gradient by using differential rotations in the 3
        rotational directions using the associated skew-symmetric
        differential rotation matrices
      */
      /* compute alpha term - differential rotation around z axis */
      dx = y*D_ANGLE ;
      dy = -x*D_ANGLE ;
      dz = 0 ;
      am1 =
        MRISPfunctionVal(parms->mrisp_template, mris, x-dx, y-dy, z-dz, 0) ;
      ap1 =
        MRISPfunctionVal(parms->mrisp_template, mris, x+dx, y+dy, z+dz, 0) ;
      da = (ap1 - am1) / (2*D_ANGLE);

      /* compute beta term - differential rotation around y axis */
      dx = -z*D_ANGLE ;
      dy = 0 ;
      dz = x*D_ANGLE ;
      bm1 =
        MRISPfunctionVal(parms->mrisp_template, mris, x-dx, y-dy, z-dz, 0) ;
      bp1 =
        MRISPfunctionVal(parms->mrisp_template, mris, x+dx, y+dy, z+dz, 0) ;
      db = (bp1 - bm1) / (2*D_ANGLE);

      /* compute gamma term - differential rotation around x axis */
      dx = 0 ;
      dy = -z*D_ANGLE ;
      dz = y*D_ANGLE ;
      gm1 =
        MRISPfunctionVal(parms->mrisp_template, mris, x-dx, y-dy, z-dz, 0) ;
      gp1 =
        MRISPfunctionVal(parms->mrisp_template, mris, x+dx, y+dy, z+dz, 0) ;
      dg = (gp1 - gm1) / (2*D_ANGLE);

      mris->gamma -= coef * dg ;   /* around x-axis */
      mris->beta  -= coef * db ;   /* around y-axis */
      mris->alpha -= coef * da ;   /* around z-axis */

    }
  }
  nv = MRISvalidVertices(mris) ;
  r = mris->radius ;
  mris->alpha /= nv ;
  mris->beta /= nv ;
  mris->gamma /= nv ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->dx = r*mris->alpha ;
    v->dy = r*mris->beta ;
    v->dz = r*mris->gamma ;
  }
#endif

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISzeroMeanCurvature(MRI_SURFACE *mris)
{
  double    mean ;
  int       vno, vtotal ;
  VERTEX    *v ;

  for (mean = 0.0f, vtotal = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    mean += v->curv ;
    vtotal++ ;
  }

  mean /= (double)vtotal ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "curvature mean = %2.3f\n", mean) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv -= mean ;
  }

  mrisComputeCurvatureMinMax(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
int MRISnormalizeCurvature(MRI_SURFACE *mris, int which_norm)
Normalize the curvatures so they have unit standard deviation.
which_norm can be NORM_MEDIAN or NORM_MEAN. NORM_MEAN results
in the usual stddev computation. NORM_MEDIAN uses the median
instead of the mean for the stddev computation.
  ------------------------------------------------------*/
int MRISnormalizeCurvature(MRI_SURFACE *mris, int which_norm)
{
  double    mean, var, std, median ;
  int       vno, vtotal ;
  VERTEX    *v ;

  if (which_norm == NORM_NONE)
  {
    return(NO_ERROR) ;
  }

  if (which_norm == NORM_MEDIAN)
  {
    float *curvs ;
    curvs = (float *)calloc(mris->nvertices, sizeof(float)) ;
    if (curvs == NULL)
    {
      ErrorExit(ERROR_NOMEMORY, "MRISnormalize(MEDIAN): couldn't alloc array");
    }

    MRISextractCurvatureVector(mris, curvs) ;
    qsort(curvs, mris->nvertices, sizeof(curvs[0]), compare_sort_vals) ;
    median = curvs[mris->nvertices/2] ;
    free(curvs) ;
    for (var = 0.0f, vtotal = vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      std = (v->curv - median) ;
      vtotal++ ;
      var += std * std ;
    }

    var /= (double)vtotal ;
    std = sqrt(var) ;

    //    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    fprintf(stdout, "curvature median = %2.3f, std = %2.3f\n", median, std) ;

    // now normalize the curvatures so they have unit standard deviation
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->curv = (v->curv - median) / std ;
    }
  }
  else  // normalize mean
  {
    for (mean = 0.0f, vtotal = vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      mean += v->curv ;
      vtotal++ ;
    }

    mean /= (double)vtotal ;

    for (var = 0.0f, vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      std = v->curv - mean ;
      var += std * std ;
    }

    var /= (double)vtotal ;
    std = sqrt(var) ;

    //    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    fprintf(stdout, "curvature mean = %2.3f, std = %2.3f\n", mean, std) ;

    /* now normalize the curvatures so they have unit standard deviation, but
       leave the mean alone */
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->curv = (v->curv - mean) / std /* + mean*/ ;
    }
  }
  mrisComputeCurvatureMinMax(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISnormalizeCurvatureVariance(MRI_SURFACE *mris)
{
  double    mean, var, std ;
  int       vno, vtotal ;
  VERTEX    *v ;

  for (mean = 0.0f, vtotal = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    mean += v->curv ;
    vtotal++ ;
  }

  mean /= (double)vtotal ;

  for (var = 0.0f, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    std = v->curv - mean ;
    var += std * std ;
  }

  var /= (double)vtotal ;
  std = sqrt(var) ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "curvature mean = %2.3f, std = %2.3f\n", mean, std) ;
  }

  /* now normalize the curvatures so they have unit standard deviation, but
     leave the mean alone */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = (v->curv - mean) / std  + mean ;
  }

  mrisComputeCurvatureMinMax(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISscaleDistances(MRI_SURFACE *mris, float scale)
{
  int       vno, n ;
  VERTEX    *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    for (n = 0 ; n < v->vtotal ; n++)
    {
      v->dist[n] *= scale ;
    }
  }
  return(NO_ERROR) ;
}
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisCheck(MRI_SURFACE *mris)
{
  int       vno ;
  VERTEX    *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (fabs(v->curv) > 10000.0)
    {
      DiagBreak() ;
      return(ERROR_BADPARM) ;
    }
  }
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISminFilterCurvatures(MRI_SURFACE *mris, int niter)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  curv ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < niter ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      curv = v->curv ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        if (vn->curv < curv)
        {
          curv = vn->curv ;
        }
      }
      v->tdx = curv ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->curv = v->tdx ;
    }
  }
  mrisComputeCurvatureMinMax(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISmaxFilterCurvatures(MRI_SURFACE *mris, int niter)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  curv ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < niter ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      curv = v->curv ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        if (vn->curv > curv)
        {
          curv = vn->curv ;
        }
      }
      v->tdx = curv ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->curv = v->tdx ;
    }
  }
  mrisComputeCurvatureMinMax(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
int MRISaverageCurvatures(MRI_SURFACE *mris, int navgs)
Performs navgs steps of iterative spatial smoothing on curv.
------------------------------------------------------*/
int MRISaverageCurvatures(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  curv, num ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      curv = v->curv ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        num++ ;
        curv += vn->curv ;
      }
      num++ ;  /*  account for central vertex */
      v->tdx = curv / num ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->curv = v->tdx ;
    }
  }
  mrisComputeCurvatureMinMax(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISaverageMarkedCurvatures(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  curv, num ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || !v->marked)
      {
        continue ;
      }
      curv = v->curv ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        num++ ;
        curv += vn->curv ;
      }
      num++ ;  /*  account for central vertex */
      v->tdx = curv / num ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 0)
      {
        continue ;
      }
      v->curv = v->tdx ;
    }
  }
  mrisComputeCurvatureMinMax(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISaverageMarkedVals(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  val, num ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 0)
      {
        continue ;
      }
      val = v->val ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag || vn->marked == 0)
        {
          continue ;
        }
        num++ ;
        val += vn->val ;
      }
      num++ ;  /*  account for central vertex */
      v->tdx = val / num ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 0)
      {
        continue ;
      }
      v->val = v->tdx ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISaverageVals(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  val, num ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      val = v->val ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        num++ ;
        val += vn->val ;
      }
      num++ ;  /*  account for central vertex */
      v->tdx = val / num ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->val = v->tdx ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  spatially average the v->d field
  ------------------------------------------------------*/
int
MRISaverageD(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  val, num ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      val = v->d ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        num++ ;
        val += vn->d ;
      }
      num++ ;  /*  account for central vertex */
      v->tdx = val / num ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->d = v->tdx ;
    }
  }
  return(NO_ERROR) ;
}
static int
compare_sort_vals(const void *pc1, const void *pc2)
{
  register float c1, c2 ;

  c1 = *(float *)pc1 ;
  c2 = *(float *)pc2 ;

  /*  return(c1 > c2 ? 1 : c1 == c2 ? 0 : -1) ;*/
  if (c1 > c2)
  {
    return(1) ;
  }
  else if (c1 < c2)
  {
    return(-1) ;
  }

  return(0) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISmedianFilterVals(MRI_SURFACE *mris, int nmedians)
{
  int    i, vno, vnb, *pnb, vnum, num ;
  float  val_list[MAX_NEIGHBORS] ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < nmedians ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      pnb = v->v ;
      //      vnum = v->vtotal ;   BRF - used to be vnum
      vnum = v->vnum ;
      val_list[0] = v->val ;
      for (num = 1, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }

        val_list[num++] = vn->val ;
      }
      qsort(val_list, num, sizeof(val_list[0]), compare_sort_vals) ;
      if (ISODD(num))
      {
        v->tdx = val_list[(num-1)/2] ;
      }
      else
      {
        v->tdx = (val_list[num/2] + val_list[num/2-1])/2 ;
      }
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->val = v->tdx ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISmedianFilterVerexPositions(MRI_SURFACE *mris, int nmedians)
{
  int    i, vno, vnb, *pnb, vnum, num ;
  float  val_list[MAX_NEIGHBORS] ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < nmedians ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      pnb = v->v ;
      vnum = v->vnum ;
      val_list[0] = v->x ;
      for (num = 1, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }

        val_list[num++] = vn->x ;
      }
      qsort(val_list, num, sizeof(val_list[0]), compare_sort_vals) ;
      if (ISODD(num))
      {
        v->tdx = val_list[(num-1)/2] ;
      }
      else
      {
        v->tdx = (val_list[num/2] + val_list[num/2-1])/2 ;
      }

      pnb = v->v ;
      vnum = v->vnum ;
      val_list[0] = v->y ;
      for (num = 1, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }

        val_list[num++] = vn->y ;
      }
      qsort(val_list, num, sizeof(val_list[0]), compare_sort_vals) ;
      if (ISODD(num))
      {
        v->tdy = val_list[(num-1)/2] ;
      }
      else
      {
        v->tdy = (val_list[num/2] + val_list[num/2-1])/2 ;
      }

      pnb = v->v ;
      vnum = v->vnum ;
      val_list[0] = v->z ;
      for (num = 1, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }

        val_list[num++] = vn->z ;
      }
      qsort(val_list, num, sizeof(val_list[0]), compare_sort_vals) ;
      if (ISODD(num))
      {
        v->tdz = val_list[(num-1)/2] ;
      }
      else
      {
        v->tdz = (val_list[num/2] + val_list[num/2-1])/2 ;
      }
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->x = v->tdx ;
      v->y = v->tdy ;
      v->z = v->tdz ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISgaussianFilterD(MRI_SURFACE *mris, double wt)
{
  int    vno, vnb, *pnb, vnum ;
  double nbr_wt, val, norm ;
  VERTEX *v, *vn ;

  nbr_wt = 1-wt ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    pnb = v->v ;
    vnum = v->vnum ;

    val = wt * v->d ;

    for ( norm = wt, vnb = 0 ; vnb < vnum ; vnb++)
    {
      vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
      if (vn->ripflag)
      {
        continue ;
      }

      val += nbr_wt*vn->d ;
      norm += nbr_wt ;
    }
    v->tdx = val/norm ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->d = v->tdx ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISmedianFilterD(MRI_SURFACE *mris, int nmedians, int vtotal)
{
  int    i, vno, vnb, *pnb, vnum, num ;
  float  val_list[MAX_NEIGHBORS] ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < nmedians ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      pnb = v->v ;
      if (vtotal)
      {
        vnum = v->vtotal ;
      }
      else
      {
        vnum = v->vnum ;
      }
      val_list[0] = v->d ;
      for (num = 1, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }

        val_list[num++] = vn->d ;
      }
      qsort(val_list, num, sizeof(val_list[0]), compare_sort_vals) ;
      if (ISODD(num))
      {
        v->tdx = val_list[(num-1)/2] ;
      }
      else
      {
        v->tdx = (val_list[num/2] + val_list[num/2-1])/2 ;
      }
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->d = v->tdx ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISmedianFilterCurvature(MRI_SURFACE *mris, int nmedians)
{
  int    i, vno, vnb, *pnb, vnum, num ;
  float  val_list[MAX_NEIGHBORS] ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < nmedians ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      pnb = v->v ;
      vnum = v->vnum ;
      val_list[0] = v->curv ;
      for (num = 1, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }

        val_list[num++] = vn->curv ;
      }
      qsort(val_list, num, sizeof(val_list[0]), compare_sort_vals) ;
      if (ISODD(num))
      {
        v->tdx = val_list[(num-1)/2] ;
      }
      else
      {
        v->tdx = (val_list[num/2] + val_list[num/2-1])/2 ;
      }
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->curv = v->tdx ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISmedianFilterVal2s(MRI_SURFACE *mris, int nmedians)
{
  int    i, vno, vnb, *pnb, vnum, num ;
  float  val_list[MAX_NEIGHBORS] ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < nmedians ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      pnb = v->v ;
      vnum = v->vnum ;
      val_list[0] = v->val2 ;
      for (num = 1, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }

        val_list[num++] = vn->val2 ;
      }
      qsort(val_list, num, sizeof(val_list[0]), compare_sort_vals) ;
      if (ISODD(num))
      {
        v->tdx = val_list[(num-1)/2] ;
      }
      else
      {
        v->tdx = (val_list[num/2] + val_list[num/2-1])/2 ;
      }
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->val2 = v->tdx ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISmedianFilterVal2baks(MRI_SURFACE *mris, int nmedians)
{
  int    i, vno, vnb, *pnb, vnum, num ;
  float  val_list[MAX_NEIGHBORS] ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < nmedians ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      pnb = v->v ;
      vnum = v->vnum ;
      val_list[0] = v->val2bak ;
      for (num = 1, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }

        val_list[num++] = vn->val2bak ;
      }
      qsort(val_list, num, sizeof(val_list[0]), compare_sort_vals) ;
      if (ISODD(num))
      {
        v->tdx = val_list[(num-1)/2] ;
      }
      else
      {
        v->tdx = (val_list[num/2] + val_list[num/2-1])/2 ;
      }
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->val2bak = v->tdx ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISaverageVal2s(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  val, num ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      val = v->val2 ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        num++ ;
        val += vn->val2 ;
      }
      num++ ;  /*  account for central vertex */
      v->tdx = val / num ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->val2 = v->tdx ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISaverageVal2baks(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  val, num ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      val = v->val2bak ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        num++ ;
        val += vn->val2bak ;
      }
      num++ ;  /*  account for central vertex */
      v->tdx = val / num ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->val2bak = v->tdx ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISscaleCurvatures(MRI_SURFACE *mris, float min_curv, float max_curv)
{
  double    old_min_curv, old_max_curv, mean, scale ;
  int       vno, vtotal ;
  VERTEX    *v ;

  old_min_curv = 100000.0 ;
  old_max_curv = -100000.0 ;
  for (mean = 0.0, vtotal = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    vtotal++ ;
    mean += v->curv ;
    if (v->curv > old_max_curv)
    {
      old_max_curv = v->curv ;
    }
    if (v->curv < old_min_curv)
    {
      old_min_curv = v->curv ;
    }
  }

  mean /= (double)vtotal ;
  scale = (max_curv - min_curv) / (old_max_curv - old_min_curv) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = (v->curv - mean) * scale + mean ;
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISnonmaxSuppress(MRI_SURFACE *mris)
{
  double   du, dv, up1, um1, vp1, vm1, src, dx, dy, dz, fp1, fm1, mag ;
  VERTEX   *v ;
  int      vno ;
  float    x, y, z, e1x, e1y, e1z, e2x, e2y, e2z, ux, uy, uz, vx, vy, vz ;
  MRI_SP   *mrisp, *mrisp_blur ;

  mrisp = MRIStoParameterization(mris, NULL, 1, 0) ;
  mrisp_blur = MRISPblur(mrisp, NULL, 20.0, 0) ;
  mrisComputeTangentPlanes(mris) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    e1x = v->e1x ;
    e1y = v->e1y ;
    e1z = v->e1z ;
    e2x = v->e2x ;
    e2y = v->e2y ;
    e2z = v->e2z ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
#if 0
    src = v->curv ;
#else
    src = MRISPfunctionVal(mrisp, mris, x, y, z, 0) ;
#endif


    /* now compute gradient of template w.r.t. a change in vertex position */

    /*
      sample the curvature functions along the tangent plane axes and
      compute the derivates using them.
    */
    ux = 10*e1x ;
    uy = 10*e1y ;
    uz = 10*e1z ;
    vx = 10*e2x ;
    vy = 10*e2y ;
    vz = 10*e2z ;
    ux = e1x*D_DIST ;
    uy = e1y*D_DIST ;
    uz = e1z*D_DIST ;
    vx = e2x*D_DIST ;
    vy = e2y*D_DIST ;
    vz = e2z*D_DIST ;

    /* compute gradient usnig blurred image */
    up1 = MRISPfunctionVal(mrisp_blur, mris, x+ux, y+uy, z+uz, 0) ;
    um1 = MRISPfunctionVal(mrisp_blur, mris, x-ux, y-uy, z-uz, 0) ;
    vp1 = MRISPfunctionVal(mrisp_blur, mris, x+vx, y+vy, z+vz, 0) ;
    vm1 = MRISPfunctionVal(mrisp_blur, mris, x-vx, y-vy, z-vz, 0) ;
    du = (up1 - um1) / (2 * D_DIST) ;
    dv = (vp1 - vm1) / (2 * D_DIST) ;

    /* calculate curvature gradient */
    dx = (du*e1x + dv*e2x) ;
    dy = (du*e1y + dv*e2y) ;
    dz = (du*e1z + dv*e2z) ;
    mag = sqrt(dx*dx + dy*dy + dz*dz) ;
    if (FZERO(mag))   /* zero gradient */
    {
      v->curv = 0 ;
    }
    else
    {
      mag *= .1 ;
      dx = dx / mag ;
      dy = dy / mag ;
      dz = dz / mag ;
    }
    fp1 = MRISPfunctionVal(mrisp, mris, x+dx, y+dy, z+dz, 0) ;
    fm1 = MRISPfunctionVal(mrisp, mris, x-dx, y-dy, z-dz, 0) ;

    if ((src >= fp1) && (src >= fm1))       /* local max */
    {
      v->curv = 1 ;
    }
    else if ((src <= fp1) && (src <= fm1))  /* local min */
    {
      v->curv = -1 ;
    }
    else
    {
      v->curv = 0 ;
    }
    v->curv = src ;
  }
  MRISPfree(&mrisp) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  same as  below, but tracks odx,ody,odz fields
  ------------------------------------------------------*/
static int
mrisTrackTotalDistanceNew(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;
  float  nc ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    nc = v->odx*v->nx + v->ody*v->ny + v->odz*v->nz ;
    v->curv += nc ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisTrackTotalDistance(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;
  float  nc ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    nc = v->dx*v->nx + v->dy*v->ny + v->dz*v->nz ;
    v->curv += nc ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISclearCurvature(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = 0 ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISrigidBodyAlignLocal(MRI_SURFACE *mris, INTEGRATION_PARMS *old_parms)
{
  int                old_status, steps ;
  INTEGRATION_PARMS  parms ;

  /* dx,dy,dz interpreted as rotations in applyGradient when status is rigid */
  old_status = mris->status ;   /* okay, okay, this is a hack too... */
  mris->status = MRIS_RIGID_BODY ;
  memset(&parms, 0, sizeof(parms)) ;
  parms.integration_type = INTEGRATE_LM_SEARCH ;
  parms.integration_type = INTEGRATE_LINE_MINIMIZE ;

  parms.mrisp_template = old_parms->mrisp_template ;
  parms.fp = old_parms->fp ;
  parms.niterations =  25 ;
  parms.frame_no = old_parms->frame_no ;
  parms.mrisp = old_parms->mrisp ;
  parms.tol = old_parms->tol ;
  parms.l_pcorr = 1.0f ;
  parms.dt = old_parms->dt ;
  /*  parms.integration_type = old_parms->integration_type ;*/
  parms.momentum = old_parms->momentum ;
  parms.write_iterations = old_parms->write_iterations ;
  parms.start_t = old_parms->start_t ;
  strcpy(parms.base_name, old_parms->base_name) ;

  steps = MRISintegrate(mris, &parms, 0) ;
  old_parms->start_t += steps ;
  mris->status = old_status ;
  if (Gdiag & DIAG_WRITE)
    fprintf(old_parms->fp, "rigid alignment complete, sse = %2.3f\n",
            MRIScomputeSSE(mris, old_parms)) ;
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    float area_rms, angle_rms, curv_rms, dist_rms, corr_rms, rms ;

    rms =
      mrisComputeError(mris, &parms,&area_rms,&angle_rms,&curv_rms,&dist_rms,
                       &corr_rms);
    fprintf(stdout, "rms = %2.3f, corr_rms = %2.3f ", rms, corr_rms) ;
    rms =
      mrisComputeError(mris, old_parms,&area_rms,&angle_rms,&curv_rms,
                       &dist_rms, &corr_rms);
    fprintf(stdout, "(%2.3f, %2.3f)\n", rms, corr_rms) ;
  }
  return(NO_ERROR) ;
}

int
MRISrigidBodyAlignVectorLocal(MRI_SURFACE *mris, INTEGRATION_PARMS *old_parms)
{
  int                n,old_status, steps ;
  INTEGRATION_PARMS  parms ;

  /* dx,dy,dz interpreted as rotations in applyGradient when status is rigid */
  old_status = mris->status ;   /* okay, okay, this is a hack too... */
  mris->status = MRIS_RIGID_BODY ;
  memset(&parms, 0, sizeof(parms)) ;
  parms.integration_type = INTEGRATE_LM_SEARCH ;
  parms.integration_type = INTEGRATE_LINE_MINIMIZE ;

  parms.mrisp_template = old_parms->mrisp_template ;
  parms.fp = old_parms->fp ;
  parms.niterations =  25 ;
  parms.frame_no = old_parms->frame_no ;
  parms.mrisp = old_parms->mrisp ;
  parms.tol = old_parms->tol ;

  parms.nfields = old_parms->nfields;
  parms.flags &= IP_USE_MULTIFRAMES;
  for (n=0; n < MNOFIV ; n++)
  {
    memmove(&parms.fields[n],&old_parms->fields[n],sizeof(FIELD_LABEL));
  }

  parms.l_pcorr = parms.l_corr = 0.0f ;
  parms.dt = old_parms->dt ;
  /*  parms.integration_type = old_parms->integration_type ;*/
  parms.momentum = old_parms->momentum ;
  parms.write_iterations = old_parms->write_iterations ;
  parms.start_t = old_parms->start_t ;
  strcpy(parms.base_name, old_parms->base_name) ;

  steps = MRISintegrate(mris, &parms, 0) ;
  old_parms->start_t += steps ;
  mris->status = old_status ;
  if (Gdiag & DIAG_WRITE)
    fprintf(old_parms->fp, "rigid alignment complete, sse = %2.3f\n",
            MRIScomputeSSE(mris, old_parms)) ;
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    float area_rms, angle_rms, curv_rms, dist_rms, corr_rms, rms ;

    rms =
      mrisComputeError(mris, &parms,&area_rms,&angle_rms,&curv_rms,&dist_rms,
                       &corr_rms);
    fprintf(stdout, "rms = %2.3f, corr_rms = %2.3f ", rms, corr_rms) ;
    rms =
      mrisComputeError(mris, old_parms,&area_rms,&angle_rms,&curv_rms,
                       &dist_rms, &corr_rms);
    fprintf(stdout, "(%2.3f, %2.3f)\n", rms, corr_rms) ;
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#define STARTING_ANGLE   RADIANS(16.0f)
#define ENDING_ANGLE     RADIANS(4.0f)
#define NANGLES          8

int
MRISrigidBodyAlignGlobal(MRI_SURFACE *mris, INTEGRATION_PARMS *parms,
                         float min_degrees, float max_degrees, int nangles)
{
  double   alpha, beta, gamma, degrees, delta, mina, minb, ming,
           sse, min_sse, ext_sse ;
  int      old_status = mris->status, old_norm, msec;
  struct timeb  mytimer;

  printf("Starting MRISrigidBodyAlignGlobal()\n");
  TimerStart(&mytimer) ;

  old_norm = parms->abs_norm ;
  parms->abs_norm = 1 ;
  min_degrees = RADIANS(min_degrees) ;
  max_degrees = RADIANS(max_degrees) ;
  mrisOrientSurface(mris) ;
  mris->status = MRIS_RIGID_BODY ;

  if (!parms->start_t)
  {
    mrisLogStatus(mris, parms, stdout, 0.0f, -1) ;
    if (Gdiag & DIAG_WRITE)
    {
      mrisLogStatus(mris, parms, parms->fp, 0.0f, -1) ;
      if (parms->write_iterations > 0)
      {
        mrisWriteSnapshot(mris, parms, 0) ;
      }
    }
  }

  for (degrees = max_degrees ; degrees >= min_degrees ; degrees /= 2.0f)
  {
    mina = minb = ming = 0.0 ;
    min_sse = mrisComputeCorrelationError(mris, parms, 1) ;  /* was 0 !!!! */

    if (gMRISexternalSSE)
    {
      ext_sse = (*gMRISexternalSSE)(mris, parms) ;
      min_sse += ext_sse ;
    }

    delta = 2*degrees / (float)nangles ;

    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, "scanning %2.2f degree nbhd, min sse = %2.2f\n",
              (float)DEGREES(degrees), (float)min_sse) ;
    }

    for (alpha = -degrees ; alpha <= degrees ; alpha += delta)
    {
      for (beta = -degrees ; beta <= degrees ; beta += delta)
      {
        if (Gdiag & DIAG_SHOW)
        {
          fprintf(stdout, "\r(%+2.2f, %+2.2f, %+2.2f), "
                  "min @ (%2.2f, %2.2f, %2.2f) = %2.1f   ",
                  (float)DEGREES(alpha), (float)DEGREES(beta), (float)
                  DEGREES(-degrees), (float)DEGREES(mina),
                  (float)DEGREES(minb), (float)DEGREES(ming),(float)min_sse);
        }

        for (gamma = -degrees ; gamma <= degrees ; gamma += delta)
        {
          MRISsaveVertexPositions(mris, TMP_VERTICES) ;
          MRISrotate(mris, mris, alpha, beta, gamma) ;
          sse = mrisComputeCorrelationError(mris, parms, 1) ;  /* was 0 !!!! */
          if (gMRISexternalSSE)
          {
            ext_sse = (*gMRISexternalSSE)(mris, parms) ;
            sse += ext_sse ;
          }
          MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
          if (sse < min_sse)
          {
            mina = alpha ;
            minb = beta ;
            ming = gamma ;
            min_sse = sse ;
          }
#if 0
          if (Gdiag & DIAG_SHOW)
            fprintf(stdout, "\r(%+2.2f, %+2.2f, %+2.2f), "
                    "min @ (%2.2f, %2.2f, %2.2f) = %2.1f   ",
                    (float)DEGREES(alpha), (float)DEGREES(beta), (float)
                    DEGREES(gamma), (float)DEGREES(mina),
                    (float)DEGREES(minb), (float)DEGREES(ming),(float)min_sse);
#endif
        } // gamma
      } // beta
    } // alpha

    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, "\n") ;
    }

    if (!FZERO(mina) || !FZERO(minb) || !FZERO(ming) )
    {
      // Apply the rotation to get to the minimum. This sets up for the next
      // degree iteration over a smaller area.
      MRISrotate(mris, mris, mina, minb, ming) ;
      sse = mrisComputeCorrelationError(mris, parms, 1) ;  /* was 0 !!!! */
      if (gMRISexternalSSE)
      {
        sse += (*gMRISexternalSSE)(mris, parms) ;
      }
      msec = TimerStop(&mytimer) ;
      printf("  d=%4.2f min @ (%2.2f, %2.2f, %2.2f) sse = %2.1f, tmin=%6.4f\n",
             (float)DEGREES(degrees),(float)DEGREES(mina),(float)DEGREES(minb),
             (float)DEGREES(ming),(float)min_sse,msec/(1000*60.0));
      fflush(stdout);
      if (Gdiag & DIAG_SHOW)
      {
        fprintf(stdout, "min sse = %2.2f at (%2.2f, %2.2f, %2.2f)\n",
                sse, (float)DEGREES(mina), (float)DEGREES(minb),
                (float)DEGREES(ming)) ;
      }

      if (Gdiag & DIAG_WRITE)
      {
        fprintf(parms->fp,
                "rotating brain by (%2.2f, %2.2f, %2.2f), sse: %2.2f\n",
                (float)DEGREES(mina), (float)DEGREES(minb),
                (float)DEGREES(ming), (float)sse) ;
      }

      parms->start_t += 1.0f ;
      parms->t += 1.0f ;

      if (Gdiag & DIAG_WRITE && parms->write_iterations > 0)
      {
        mrisWriteSnapshot(mris, parms, parms->start_t) ;
      }
      if (Gdiag & DIAG_WRITE)
      {
        mrisLogStatus(mris, parms, parms->fp, 0.0f, -1) ;
      }
      if (Gdiag & DIAG_SHOW)
      {
        mrisLogStatus(mris, parms, stdout, 0.0f, -1) ;
      }
    }
  } // degrees

  mris->status = old_status ;
  parms->abs_norm = old_norm ;

  msec = TimerStop(&mytimer) ;
  printf("MRISrigidBodyAlignGlobal() done %6.2f min\n",msec/(1000*60.0));

  return(NO_ERROR) ;
}

int
MRISrigidBodyAlignVectorGlobal
(MRI_SURFACE *mris, INTEGRATION_PARMS *parms,
 float min_degrees, float max_degrees, int nangles)
{
  double   alpha, beta, gamma, degrees, delta, mina, minb, ming,
           sse, min_sse ;
  int      old_status = mris->status ;

  min_degrees = RADIANS(min_degrees) ;
  max_degrees = RADIANS(max_degrees) ;
  mrisOrientSurface(mris) ;
  mris->status = MRIS_RIGID_BODY ;
  if (!parms->start_t)
  {
    mrisLogStatus(mris, parms, stdout, 0.0f, -1) ;
    if (Gdiag & DIAG_WRITE)
    {
      mrisLogStatus(mris, parms, parms->fp, 0.0f, -1) ;
      if (parms->write_iterations > 0)
      {
        mrisWriteSnapshot(mris, parms, 0) ;
      }
    }
  }
  for (degrees = max_degrees ; degrees >= min_degrees ; degrees /= 2.0f)
  {
    mina = minb = ming = 0.0 ;
    min_sse =
      mrisComputeVectorCorrelationError(mris, parms, 1) ;  /* was 0 !!!! */
    /*                if (gMRISexternalSSE) */
    /*                        min_sse += (*gMRISexternalSSE)(mris, parms) ; */
    delta = 2*degrees / (float)nangles ;
    if (Gdiag & DIAG_SHOW)
      fprintf(stdout, "scanning %2.2f degree nbhd, min sse = %2.2f\n",
              (float)DEGREES(degrees), (float)min_sse) ;
    for (alpha = -degrees ; alpha <= degrees ; alpha += delta)
    {
      for (beta = -degrees ; beta <= degrees ; beta += delta)
      {
        if (Gdiag & DIAG_SHOW)
          fprintf(stdout, "\r(%+2.2f, %+2.2f, %+2.2f), "
                  "min @ (%2.2f, %2.2f, %2.2f) = %2.1f   ",
                  (float)DEGREES(alpha), (float)DEGREES(beta), (float)
                  DEGREES(-degrees), (float)DEGREES(mina),
                  (float)DEGREES(minb), (float)DEGREES(ming),(float)min_sse);

        for (gamma = -degrees ; gamma <= degrees ; gamma += delta)
        {
          MRISsaveVertexPositions(mris, TMP_VERTICES) ;
          MRISrotate(mris, mris, alpha, beta, gamma) ;
          sse =
            mrisComputeVectorCorrelationError(mris, parms, 1); /* was 0 !!!! */
          /* if (gMRISexternalSSE) */
          /*   sse += (*gMRISexternalSSE)(mris, parms) ; */
          MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
          if (sse < min_sse)
          {
            mina = alpha ;
            minb = beta ;
            ming = gamma ;
            min_sse = sse ;
          }
#if 0
          if (Gdiag & DIAG_SHOW)
            fprintf(stdout, "\r(%+2.2f, %+2.2f, %+2.2f), "
                    "min @ (%2.2f, %2.2f, %2.2f) = %2.1f   ",
                    (float)DEGREES(alpha), (float)DEGREES(beta), (float)
                    DEGREES(gamma), (float)DEGREES(mina),
                    (float)DEGREES(minb), (float)DEGREES(ming),(float)min_sse);
#endif
        }
      }
    }
    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, "\n") ;
    }
    if (!FZERO(mina) || !FZERO(minb) || !FZERO(ming))
    {
      MRISrotate(mris, mris, mina, minb, ming) ;
      sse =
        mrisComputeVectorCorrelationError(mris, parms, 1) ;  /* was 0 !!!! */
      /* if (gMRISexternalSSE) */
      /*   sse += (*gMRISexternalSSE)(mris, parms) ; */
      if (Gdiag & DIAG_SHOW)
        fprintf(stdout, "min sse = %2.2f at (%2.2f, %2.2f, %2.2f)\n",
                sse, (float)DEGREES(mina), (float)DEGREES(minb),
                (float)DEGREES(ming)) ;
      if (Gdiag & DIAG_WRITE)
        fprintf(parms->fp,
                "rotating brain by (%2.2f, %2.2f, %2.2f), sse: %2.2f\n",
                (float)DEGREES(mina), (float)DEGREES(minb),
                (float)DEGREES(ming), (float)sse) ;
      parms->start_t += 1.0f ;
      parms->t += 1.0f ;
      if (Gdiag & DIAG_WRITE && parms->write_iterations > 0)
      {
        mrisWriteSnapshot(mris, parms, parms->start_t) ;
      }
      if (Gdiag & DIAG_WRITE)
      {
        mrisLogStatus(mris, parms, parms->fp, 0.0f, -1) ;
      }
      if (Gdiag & DIAG_SHOW)
      {
        mrisLogStatus(mris, parms, stdout, 0.0f, -1) ;
      }
    }
  }

  mris->status = old_status ;
  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRISrmsTPHeight(MRI_SURFACE *mris)
{
  int    vno, i, total_nbrs ;
  VERTEX *vertex, *vnb ;
  double avg_height, dot, nx, ny, nz, x, y, z, d ;

  if (mris->status == MRIS_PLANE)
  {
    return(NO_ERROR) ;
  }

  avg_height = 0.0 ;
  total_nbrs = 0 ;
  mrisComputeTangentPlanes(mris) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }

    if (vertex->vtotal <= 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    nx = vertex->nx ;
    ny = vertex->ny ;
    nz = vertex->nz ;

    for (i = 0 ; i < vertex->vtotal ; i++)
    {
      vnb = &mris->vertices[vertex->v[i]] ;
      if (vnb->ripflag)
      {
        continue ;
      }
      x = vnb->x-vertex->x ;
      y = vnb->y-vertex->y ;
      z = vnb->z-vertex->z ;
      d = (x*x+y*y+z*z) ;
      if (FZERO(d))
      {
        continue ;
      }
      /*
        calculate the projection of this vertex onto the surface normal
      */
      dot = nx*x + ny*y + nz*z ;  /* height above TpS */
      avg_height += dot*dot / d ;
      total_nbrs++ ;
    }
  }

  return(sqrt(avg_height / (double)total_nbrs)) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISzeroNegativeAreas(MRI_SURFACE *mris)
{
  int     vno, fno ;
  VERTEX  *v ;
  FACE    *face ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (v->area < 0)
    {
      v->area = 0 ;
    }
  }
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->ripflag)
    {
      continue ;
    }
    if (face->area < 0.0f)
    {
      face->area = 0.0f ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISfindClosestVertex(MRI_SURFACE *mris,
                      float x, float y, float z,
                      float *dmin)
{
  int    vno, min_v = -1 ;
  VERTEX *v ;
  float  d, min_d, dx, dy, dz ;

  min_d = 10000.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    dx = v->x - x ;
    dy = v->y - y ;
    dz = v->z - z ;
    d = sqrt(dx*dx + dy*dy + dz*dz) ;
    if (d < min_d)
    {
      min_d = d ;
      min_v = vno ;
    }
  }
  if (dmin != NULL)
  {
    *dmin = min_d;
  }
  return(min_v) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISfindClosestOriginalVertex(MRI_SURFACE *mris, float x, float y, float z)
{
  int    vno, min_v = -1 ;
  VERTEX *v ;
  float  d, min_d, dx, dy, dz ;

  min_d = 10000.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    if (vno == 91007 || vno == 91814)
    {
      DiagBreak() ;
    }
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    dx = v->origx - x ;
    dy = v->origy - y ;
    dz = v->origz - z ;
    d = sqrt(dx*dx + dy*dy + dz*dz) ;
    if (d < min_d)
    {
      min_d = d ;
      min_v = vno ;
    }
  }

  return(min_v) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISfindClosestCanonicalVertex(MRI_SURFACE *mris, float x, float y, float z)
{
  int    vno, min_v = -1 ;
  VERTEX *v ;
  float  d, min_d, dx, dy, dz ;

  min_d = 10000.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    dx = v->cx - x ;
    dy = v->cy - y ;
    dz = v->cz - z ;
    d = sqrt(dx*dx + dy*dy + dz*dz) ;
    if (d < min_d)
    {
      min_d = d ;
      min_v = vno ;
    }
  }

  return(min_v) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISfindClosestWhiteVertex(MRI_SURFACE *mris, float x, float y, float z)
{
  int    vno, min_v = -1 ;
  VERTEX *v ;
  float  d, min_d, dx, dy, dz ;

  min_d = 10000.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    dx = v->whitex - x ;
    dy = v->whitey - y ;
    dz = v->whitez - z ;
    d = sqrt(dx*dx + dy*dy + dz*dz) ;
    if (d < min_d)
    {
      min_d = d ;
      min_v = vno ;
    }
  }

  return(min_v) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISuseCurvatureDifference(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *vertex ;
  float   kmin, kmax ;

  kmin = 100000.0f ;
  kmax = -100000.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    vertex->curv = fabs(vertex->k1 - vertex->k2) ;
    if (vertex->curv > kmax)
    {
      kmax = vertex->curv ;
    }
    if (vertex->curv < kmin)
    {
      kmin = vertex->curv ;
    }
  }

  mris->min_curv = kmin ;
  mris->max_curv = kmax ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISuseCurvatureMax(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;
  float   kmin, kmax ;

  kmin = 100000.0f ;
  kmax = -100000.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (fabs(v->k1) > fabs(v->k2))
    {
      v->curv = v->k1 ;
    }
    else
    {
      v->curv = v->k2 ;
    }
    /*    v->curv = MAX(fabs(v->k1), fabs(v->k2)) ;*/
    if (v->curv > kmax)
    {
      kmax = v->curv ;
    }
    if (v->curv < kmin)
    {
      kmin = v->curv ;
    }
    if (v->curv < 0)
    {
      DiagBreak() ;
    }
  }

  fprintf(stdout, "kmin = %2.2f, kmax = %2.2f\n", kmin, kmax) ;
  mris->min_curv = kmin ;
  mris->max_curv = kmax ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISuseCurvatureMin(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;
  float   kmin, kmax ;

  kmin = 100000.0f ;
  kmax = -100000.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (fabs(v->k1) > fabs(v->k2))
    {
      v->curv = v->k2 ;
    }
    else
    {
      v->curv = v->k1 ;
    }
    /*    v->curv = MIN(v->k1, v->k2) ;*/
    if (v->curv > kmax)
    {
      kmax = v->curv ;
    }
    if (v->curv < kmin)
    {
      kmin = v->curv ;
    }
    if (v->curv < 0)
    {
      DiagBreak() ;
    }
  }

  mris->min_curv = kmin ;
  mris->max_curv = kmax ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISuseCurvatureStretch(MRI_SURFACE *mris)
{
  int    vno, n ;
  VERTEX *v ;
  float   kmin, kmax, dist, dist_orig, curv, dist_scale, max_stretch, stretch ;

  dist_scale = sqrt(mris->orig_area / mris->total_area) ;
  kmin = 100000.0f ;
  kmax = -100000.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    max_stretch = 0.0f ;
    for (curv = 0.0f, n = 0 ; n < v->vtotal ; n++)
    {
      dist = dist_scale * v->dist[n] ;
      dist_orig = v->dist_orig[n] ;
      stretch = dist - dist_orig ;
      if (stretch > max_stretch)
      {
        max_stretch = stretch ;
      }
    }
    v->curv = max_stretch ;
    if (v->curv > kmax)
    {
      kmax = v->curv ;
    }
    if (v->curv < kmin)
    {
      kmin = v->curv ;
    }
    if (v->curv < 0)
    {
      DiagBreak() ;
    }
  }

  mris->min_curv = kmin ;
  mris->max_curv = kmax ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISuseNegCurvature(MRI_SURFACE *mris)
{
  int    vno, fno ;
  VERTEX *v ;
  FACE   *f ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = 0 ;
    for (fno = 0 ; fno < v->num ; fno++)
    {
      f = &mris->faces[v->f[fno]] ;
      if (f->area < 0.0f)
      {
        v->curv = 1.0f ;
      }
    }
  }

  mris->min_curv = 0 ;
  mris->max_curv = 1 ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
// get the vertex number
int
MRIStalairachToVertex(MRI_SURFACE *mris, double xt, double yt, double zt)
{
  int     vno ;
  double    xw, yw, zw ;

  TransformWithMatrix(mris->TalSRASToSRAS_, xt, yt, zt, &xw, &yw, &zw);
#if 0
  transform_point(mris->inverse_linear_transform, xt, yt, zt, &xw, &yw, &zw) ;
#endif

  vno = MRISfindClosestOriginalVertex(mris, xw, yw, zw) ;

  return(vno) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScanonicalToVertex(MRI_SURFACE *mris, double phi, double theta)
{
  int     vno ;
  double    xw, yw, zw ;

  MRIScanonicalToWorld(mris, phi, theta, &xw, &yw, &zw);
  vno = MRISfindClosestCanonicalVertex(mris, xw, yw, zw) ;
  return(vno) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISsurfaceRASToTalairachVoxel(MRI_SURFACE *mris, MRI *mri, double xw, double yw,
                               double zw, double *pxv, double *pyv, double *pzv)
{
  //   conformed -->  SRAS
  //       |            |
  //       |            | SRASToRAS
  //       V            V
  //      src   --->   RAS
  //       |            |
  //       |            |  MNI xfm
  //       V            V
  //   talvol   --->  talRAS
  //        lta->dst stores this
  // we assume that talvol and src has the same direction cosine
  //   talvol -> talRAS =
  //
  // double  xt, yt, zt ;
  MRI *talVol = 0;
  VOL_GEOM talgeom;
  MATRIX *SRASToTalVol = 0;
  MATRIX *SRASToTalRAS = 0;  // not to be confused with SRASToTalSRAS_
  MATRIX *SRASToRAS = 0;
  MATRIX *talRASToTalVol = 0;

  LT *lt = &mris->lta->xforms[0];

  ////////////////////////////////////////////////////
  SRASToRAS = MatrixAlloc(4, 4, MATRIX_REAL);
  MatrixIdentity(4, SRASToRAS);
  *MATRIX_RELT(SRASToRAS, 1,4) = lt->src.c_r;
  *MATRIX_RELT(SRASToRAS, 2,4) = lt->src.c_a;
  *MATRIX_RELT(SRASToRAS, 3,4) = lt->src.c_s;
  ///////////////////////////////////////////////////
  SRASToTalRAS = MatrixMultiply(lt->m_L, SRASToRAS, NULL);
  ///////////////////////////////////////////////////
  talgeom=lt->dst;
  talVol =
    MRIallocHeader(talgeom.width, talgeom.height, talgeom.depth, MRI_UCHAR,1);
  useVolGeomToMRI(&talgeom, talVol);
  talRASToTalVol = extract_r_to_i(talVol);
  //////////////////////////////////////////////////
  // now combine to get SRAS->talVol
  SRASToTalVol = MatrixMultiply(talRASToTalVol, SRASToTalRAS, NULL);

  TransformWithMatrix(SRASToTalVol, xw, yw, zw, pxv, pyv, pzv);

  MatrixFree(&SRASToRAS);
  MatrixFree(&SRASToTalRAS);
  MatrixFree(&talRASToTalVol);
  MatrixFree(&SRASToTalVol);

#if 0
  transform_point(mris->linear_transform, xw, yw, zw, &xt, &yt, &zt) ;
  MRIworldToVoxel(mri, xt, yt, zt, pxv, pyv, pzv) ;
#endif
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISvertexToVoxel(MRI_SURFACE *mris,
                  VERTEX *v,
                  MRI *mri,
                  double *pxv, double *pyv, double *pzv)
{
  double  xw, yw, zw ;

  xw = v->x ;
  yw = v->y ;
  zw = v->z ;
  MRISsurfaceRASToVoxelCached(mris, mri, xw, yw, zw, pxv, pyv, pzv) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISvertexCoordToVoxel(MRI_SURFACE *mris, VERTEX *v, MRI *mri, int coords,
                       double *pxv, double *pyv, double *pzv)
{
  double  xw=0., yw=0., zw =0.;

  MRISgetCoords(v, coords, &xw, &yw, &zw);
  MRISsurfaceRASToVoxelCached(mris, mri, xw, yw, zw, pxv, pyv, pzv) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISorigVertexToVoxel
(MRI_SURFACE *mris, VERTEX *v, MRI *mri,double *pxv, double *pyv, double *pzv)
{
  double  xw, yw, zw ;

  xw = v->origx ;
  yw = v->origy ;
  zw = v->origz ;
  MRISsurfaceRASToVoxelCached(mris, mri, xw, yw, zw, pxv, pyv, pzv) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwhiteVertexToVoxel
(MRI_SURFACE *mris, VERTEX *v, MRI *mri,double *pxv, double *pyv, double *pzv)
{
  double  xw, yw, zw ;

  xw = v->whitex ;
  yw = v->whitey ;
  zw = v->whitez ;
  MRISsurfaceRASToVoxelCached(mris, mri, xw, yw, zw, pxv, pyv, pzv) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISaverageVertexPositions(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  x, y, z, num ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      x = v->x ;
      y = v->y ;
      z = v->z ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        num++ ;
        x += vn->x ;
        y += vn->y ;
        z += vn->z ;
      }
      num++ ;   /* account for central vertex */
      v->tdx = x / num ;
      v->tdy = y / num ;
      v->tdz = z / num ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->x = v->tdx ;
      v->y = v->tdy ;
      v->z = v->tdz ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISaverageEveryOtherVertexPositions(MRI_SURFACE *mris, int navgs, int which)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  x, y, z, num ;
  VERTEX *v, *vn ;

  which = ISODD(which) ;
  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = which ; vno < mris->nvertices ; vno += 2)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      x = v->x ;
      y = v->y ;
      z = v->z ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        num++ ;
        x += vn->x ;
        y += vn->y ;
        z += vn->z ;
      }
      num++ ;   /* account for central vertex */
      v->tdx = x / num ;
      v->tdy = y / num ;
      v->tdz = z / num ;
    }
    for (vno = which ; vno < mris->nvertices ; vno += 2)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->x = v->tdx ;
      v->y = v->tdy ;
      v->z = v->tdz ;
    }
  }
  return(NO_ERROR) ;
}
static int
mrisCountCompressed(MRI_SURFACE *mris, double min_dist)
{
  int    vno, n, num ;
  VERTEX *v, *vn ;
  double d, dx, dy, dz ;

  for (vno = num = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      dx = vn->x-v->x ;
      dy = vn->y-v->y ;
      dz = vn->z-v->z ;
      d = sqrt(dx*dx + dy*dy + dz*dz) ;
      if (d < min_dist)
      {
        num++ ;
      }
    }
  }
  return(num) ;
}

static int
mrisComputePlaneTerm(MRI_SURFACE *mris, double l_plane, double l_spacing)
{
  int     vno, n, vnum ;
  MATRIX  *M, *m_evectors ;
  VERTEX  *v, *vn ;
  double  dx, dy, dz, norm, dist, a, b, c, d, xc, yc, zc, dxt, dyt, dzt ;
  float   evalues[3] ;
  d = 0.0f;

  if (FZERO(l_plane) && FZERO(l_spacing))
  {
    return(NO_ERROR) ;
  }

  M = MatrixAlloc(3, 3, MATRIX_REAL) ;
  m_evectors = MatrixAlloc(3, 3, MATRIX_REAL) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }

    vnum = v->vnum ;     // try with just closest nbrs
    if (v->vnum < 4)
    {
      vnum = v->v2num ;
    }
    vnum = v->vtotal ;

    if (vnum < 4)
    {
      continue ;  // can't estimate it
    }
    for (xc = yc = zc = 0.0, n = 0 ; n < vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      xc += vn->x ;
      yc += vn->y ;
      zc += vn->z ;
    }
    xc /= vnum ;
    yc /= vnum ;
    zc /= vnum ;
    MatrixClear(M) ;
    for (dxt = dyt = dzt = 0.0, n = 0 ; n < vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      *MATRIX_RELT(M,1,1) += SQR(vn->x-xc) ;
      *MATRIX_RELT(M,2,2) += SQR(vn->y-yc) ;
      *MATRIX_RELT(M,3,3) += SQR(vn->z-zc) ;

      *MATRIX_RELT(M,2,1) += (vn->x-xc)*(vn->y-yc) ;
      *MATRIX_RELT(M,1,2) += (vn->x-xc)*(vn->y-yc) ;

      *MATRIX_RELT(M,3,1) += (vn->x-xc)*(vn->z-zc) ;
      *MATRIX_RELT(M,1,3) += (vn->x-xc)*(vn->z-zc) ;

      *MATRIX_RELT(M,3,2) += (vn->y-yc)*(vn->z-zc) ;
      *MATRIX_RELT(M,2,3) += (vn->y-yc)*(vn->z-zc) ;

      dx = v->x-vn->x ;
      dy = v->y-vn->y ;
      dz = v->z-vn->z ;
      norm = sqrt(dx*dx + dy*dy + dz*dz) ;
      if (DZERO(norm) || norm > .5)
      {
        continue ;
      }
//      norm *= norm;   // 1/r^2
      dx /= norm;
      dy /= norm ;
      dz /= norm ;
      norm = sqrt(dx*dx + dy*dy + dz*dz) ;
      dxt += l_spacing * dx ;
      dyt += l_spacing * dy ;
      dzt += l_spacing * dz ;
    }
    dxt /= vnum ;
    dyt /= vnum ;
    dzt /= vnum ;
    MatrixEigenSystem(M, evalues, m_evectors) ;

    // evalues are distance squared to plane, so use smallest one, which is in 3rd col
    a = *MATRIX_RELT(m_evectors,1,3) ;
    b = *MATRIX_RELT(m_evectors,2,3) ;
    c = *MATRIX_RELT(m_evectors,3,3) ;
    norm = sqrt(a*a + b*b + c*c) ;
    a /= norm;
    b /= norm ;
    c /= norm ;
    dist = (a*(v->x-xc) + b*(v->y-yc) + c*(v->z-zc))  ;
    if (vno == Gdiag_no)
      printf("vno %d, best fitting plane = (%2.1f %2.1f %2.1f %2.1f), dist = %2.2f, moving by (%2.2f, %2.2f, %2.2f)\n",
             vno, a, b, c, d, dist, dist*a, dist*b, dist*c) ;
    dist *= l_plane ;
    dxt -= dist*a ;
    dyt -= dist*b ;
    dzt -= dist*c ;
    norm = sqrt(dxt*dxt + dyt*dyt + dzt*dzt) ;
    if (norm > 1)
    {
      dxt /= norm;
      dyt /= norm;
      dzt /= norm;
    }
    v->dx += dxt ;
    v->dy += dyt ;
    v->dz += dzt ;
  }

  MatrixFree(&m_evectors);
  MatrixFree(&M) ;
  return(NO_ERROR) ;
}
// fit and return point/normal represetation of best-fitting (LS) plane

int
mrisComputeOptimalPlane(MRI_SURFACE *mris, int *vertices, int nvertices, double *pxn, double *pyn, double *pzn, double *pxc, double *pyc, double *pzc)
{
  int     vno, n, vnum ;
  MATRIX  *M, *m_evectors ;
  VERTEX  *v ;
  double  a, b, c, xc, yc, zc, norm ;
  float   evalues[3] ;



  M = MatrixAlloc(3, 3, MATRIX_REAL) ;
  m_evectors = MatrixAlloc(3, 3, MATRIX_REAL) ;
  for (vnum = 0, xc = yc = zc = 0.0, n = 0 ; n < nvertices ; n++)
  {
    vno = vertices[n] ;
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }

    xc += v->x ;
    yc += v->y ;
    zc += v->z ;
    vnum++ ;
  }
  if (vnum < 4)
  {
    ErrorReturn(ERROR_BADPARM, (ERROR_BADPARM, "mrisComputeOptimalPlane: must specify at least 4 non-ripped verices\n") );
  }

  for (xc = yc = zc = 0.0, n = 0 ; n < nvertices ; n++)
  {
    vno = vertices[n] ;
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    *MATRIX_RELT(M,1,1) += SQR(v->x-xc) ;
    *MATRIX_RELT(M,2,2) += SQR(v->y-yc) ;
    *MATRIX_RELT(M,3,3) += SQR(v->z-zc) ;

    *MATRIX_RELT(M,2,1) += (v->x-xc)*(v->y-yc) ;
    *MATRIX_RELT(M,1,2) += (v->x-xc)*(v->y-yc) ;

    *MATRIX_RELT(M,3,1) += (v->x-xc)*(v->z-zc) ;
    *MATRIX_RELT(M,1,3) += (v->x-xc)*(v->z-zc) ;

    *MATRIX_RELT(M,3,2) += (v->y-yc)*(v->z-zc) ;
    *MATRIX_RELT(M,2,3) += (v->y-yc)*(v->z-zc) ;
  }
  MatrixEigenSystem(M, evalues, m_evectors) ;

  // evalues are distance squared to plane, so use smallest one, which is in 3rd col
  a = *MATRIX_RELT(m_evectors,1,3) ;
  b = *MATRIX_RELT(m_evectors,2,3) ;
  c = *MATRIX_RELT(m_evectors,3,3) ;
  norm = sqrt(a*a + b*b + c*c) ;
  a /= norm;
  b /= norm ;
  c /= norm ;

  *pxn = a ;
  *pyn = b ;
  *pzn = c ;
  *pxc = xc ;
  *pyc = yc ;
  *pzc = zc ;
  MatrixFree(&m_evectors);
  MatrixFree(&M) ;
  return(NO_ERROR) ;
}

int
MRISremoveCompressedRegions(MRI_SURFACE *mris, double min_dist)
{
  int               compressed, iters = 0, old_compressed, n_averages, nsize ;
  MHT               *mht = NULL ;
  double            delta_t, l_spring, l_convex, l_max_spring ; ;
  char              fname[STRLEN] ;
  INTEGRATION_PARMS parms ;

  {
    int fno ;

    for (fno = 0 ; fno < mris->nfaces ; fno++)
    {
      mris->faces[fno].orig_area = .5 ;
    }
  }

  memset(&parms, 0, sizeof(parms)) ;

  parms.l_parea = .002 ;
  l_spring = .01 ;
  l_convex = 0 ;
  l_max_spring = .1 ;
  n_averages = 256 ;

  compressed = old_compressed = mrisCountCompressed(mris, min_dist) ;
  if (compressed > 0)
  {
    printf("removing compressed regions in tessellation\n") ;
  }
  nsize = mris->nsize ;
  MRISsetNeighborhoodSize(mris, 3) ;
  MRIScomputeSecondFundamentalForm(mris) ;
  sprintf(fname, "uncompress%4.4d", iters) ;
  MRISwrite(mris, fname) ;
  MRISclearGradient(mris) ;
  parms.flags |= IPFLAG_NO_SELF_INT_TEST ;
  while ((compressed > 0) && (iters++ < 500))
  {
    MRISclearGradient(mris) ;
    if ((parms.flags & IPFLAG_NO_SELF_INT_TEST) == 0)
    {
      mht = MHTfillTable(mris, mht) ;
    }
    else
    {
      mht = NULL ;
    }
    if (Gdiag_no >= 0 && DIAG_VERBOSE_ON)
    {
      MRISprintVertexStats(mris, Gdiag_no, Gstdout, CURRENT_VERTICES) ;
    }

//    mrisComputeNonlinearTangentialSpringTerm(mris, 1, min_dist) ;
//    mrisComputeTangentialSpringTerm(mris, 1) ;
//    mrisComputeNormalizedSpringTerm(mris, 1) ;
    if (0)  // disable
    {
      mrisComputePlaneTerm(mris, 0, 0) ;
    }
    mrisComputeSpringTerm(mris, l_spring) ;
    mrisComputeBorderTerm(mris, 1-l_spring) ;
    mrisComputeConvexityTerm(mris, l_convex) ;
    MRISaverageGradients(mris, n_averages) ;
    mrisComputeMaxSpringTerm(mris, l_max_spring) ;
    mrisComputeAngleAreaTerms(mris, &parms) ;
    delta_t = mrisAsynchronousTimeStep(mris, 0, .2, mht, min_dist) ;
    MRIScomputeMetricProperties(mris) ;
    MRIScomputeSecondFundamentalForm(mris) ;
    old_compressed = compressed ;
    compressed = mrisCountCompressed(mris, min_dist) ;
    sprintf(fname, "uncompress%4.4d", iters) ;
    printf("ITER %d: compressed = %d, delta = %d, writing %s\n", iters, compressed, compressed-old_compressed, fname) ;
    MRISwrite(mris, fname) ;
  }

  if (mht)
  {
    MHTfree(&mht) ;
  }
  MRISsetNeighborhoodSize(mris, nsize) ;
  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/

#define MAX_TOTAL_MOVEMENT 5.0
#define MAX_MOVEMENT       .2
#define DELTA_M            (MAX_MOVEMENT/2.0)


#define DEBUG_V            33100

#define MAX_REDUCTIONS     2
#define REDUCTION_PCT      0.5

int
MRISpositionSurfaces(MRI_SURFACE *mris, MRI **mri_flash, int nvolumes,
                     INTEGRATION_PARMS *parms)
{
  /*  char   *cp ;*/
  int    niterations, n, write_iterations,
         nreductions = 0, ripped = 0, increased = 0 ;
  double pial_sse, sse, wm_sse, delta_t = 0.0,
                                dt, l_intensity, base_dt, last_sse, rms, mle_sse, last_mle_sse,
                                pct_sse_decrease, l_repulse, l_surf_repulse, last_wm_sse, last_pial_sse ;
  MHT    *mht = NULL ;
  struct timeb  then ;
  int msec ;
  MRI    *mri_brain = mri_flash[0] ;

  base_dt = parms->dt ;
  if (IS_QUADRANGULAR(mris))
  {
    MRISremoveTriangleLinks(mris) ;
  }
  TimerStart(&then) ;
  parms->mri_smooth = parms->mri_brain = mri_brain ;
  niterations = parms->niterations ;
  write_iterations = parms->write_iterations ;
  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    if (!parms->fp)
    {
      sprintf(fname, "%s.%s.out",
              mris->hemisphere==RIGHT_HEMISPHERE ? "rh":"lh",parms->base_name);
      if (!parms->start_t)
      {
        parms->fp = fopen(fname, "w") ;
      }
      else
      {
        parms->fp = fopen(fname, "a") ;
      }
      if (!parms->fp)
        ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                  Progname, fname) ;
    }
    mrisLogIntegrationParms(parms->fp, mris, parms) ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogIntegrationParms(stdout, mris, parms) ;
  }

  mrisClearMomentum(mris) ;
  MRIScomputeMetricProperties(mris) ;
  MRISstoreMetricProperties(mris) ;

  MRIScomputeNormals(mris) ;
  mrisClearDistances(mris) ;

  MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;
  wm_sse = MRIScomputeSSEExternal(mris, parms, &mle_sse) ;
  MRISrestoreVertexPositions(mris, PIAL_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;
  pial_sse = MRIScomputeSSE(mris, parms) ;
  sse = last_sse = wm_sse + pial_sse ;
  last_mle_sse = mle_sse ;
#if 0
  rms = (*gMRISexternalRMS)(mris, parms) ;
#else
  rms = sqrt(mle_sse/(float)mris->nvertices) ;
#endif

  if (Gdiag & DIAG_SHOW)
    fprintf
    (stdout,
     "%3.3d: dt: %2.4f, sse=%2.2f, pial sse=%2.2f, "
     "wm sse=%2.2f, rms=%2.2f\n",
     0, 0.0f, (float)sse/(float)mris->nvertices,
     (float)pial_sse/(float)mris->nvertices,
     (float)wm_sse/(float)mris->nvertices, (float)rms);
  /*  */
  if (Gdiag & DIAG_WRITE)
  {
    fprintf
    (parms->fp,
     "%3.3d: dt: %2.4f, sse=%2.2f, pial sse=%2.2f, "
     "wm sse=%2.2f, rms=%2.2f\n",
     0, 0.0f,
     (float)sse/(float)mris->nvertices,
     (float)pial_sse/(float)mris->nvertices,
     (float)wm_sse/(float)mris->nvertices, rms);
    fflush(parms->fp) ;
  }

  /* write out initial surface */
  if ((parms->write_iterations > 0) && (Gdiag&DIAG_WRITE) && !parms->start_t)
  {
    mrisWriteSnapshots(mris, parms, 0) ;
  }

  dt = parms->dt ;
  l_intensity = parms->l_intensity ;
  mris->noscale = TRUE ;
  l_repulse = parms->l_repulse ;
  l_surf_repulse = parms->l_surf_repulse ;
  for (n = parms->start_t ; n < parms->start_t+niterations ; n++)
  {
    /* compute and apply wm derivatative */
    MRISclearGradient(mris) ;
    mrisClearExtraGradient(mris) ;
    if (!increased)
    {
      if (gMRISexternalClearSSEStatus)
      {
        (*gMRISexternalClearSSEStatus)(mris) ;
      }
    }
    MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;  /* make wm positions current */
    MRISsaveVertexPositions(mris, WHITE_VERTICES) ;
    MRIScomputeMetricProperties(mris) ;
    if (gMRISexternalGradient)
      mle_sse =
        (*gMRISexternalGradient)(mris, parms) ;   /* this computes the
                                                     external sse for both
                                                     wm and pial */
    if (increased && gMRISexternalReduceSSEIncreasedGradients)
    {
      printf("decreasing gradient at vertices with delta SSE>0 by %2.2f\n",
             0.5/increased) ;
      (*gMRISexternalReduceSSEIncreasedGradients)(mris, 0.5/increased) ;
      if (gMRISexternalClearSSEStatus)
      {
        (*gMRISexternalClearSSEStatus)(mris) ;
      }
    }

    parms->l_repulse = l_repulse ;  /* use self-repulsion for wm surface */
    parms->l_surf_repulse = 0    ;  /* don't repel wm surface
                                       outwards from itself */
    mrisComputePositioningGradients(mris, parms) ;
    if (!FZERO(parms->l_link))
    {
      mrisComputeLinkTerm(mris, parms->l_link, 0) ;
    }
    if (!(parms->flags & IPFLAG_NO_SELF_INT_TEST))
    {
      mht = MHTfillTable(mris, mht) ;
    }
    last_wm_sse = MRIScomputeSSEExternal(mris,parms, &last_mle_sse) ;

    delta_t =
      mrisAsynchronousTimeStepNew(mris, 0, dt, mht, MAX_ASYNCH_NEW_MM) ;
    MRISsaveVertexPositions(mris, ORIGINAL_VERTICES) ;
    if (gMRISexternalTimestep)
    {
      (*gMRISexternalTimestep)(mris, parms) ;
    }
    wm_sse = MRIScomputeSSE(mris, parms) ;  /* needs update orig to
                                               compute sse - will compute
                                               external sse later */

    /* store current wm positions in WHITE vertices,
       and pial in INFLATED vertices for undo */
    MRISclearGradient(mris) ;
    MRISrestoreVertexPositions(mris, PIAL_VERTICES) ;  /* make pial positions
                                                          current */
    MRISsaveVertexPositions(mris, INFLATED_VERTICES) ; /* pial->inflated */
    MRIScomputeMetricProperties(mris) ;
    MRISrestoreExtraGradients(mris) ;    /* put pial deltas into v->d[xyz] */
    parms->l_repulse = 0 ;  /* don't use self-repulsion for pial surface */
    parms->l_surf_repulse = l_surf_repulse ;  /* repel pial surface
                                                 out from wm */
    mrisComputePositioningGradients(mris, parms) ;
    if (!FZERO(parms->l_link))
    {
      mrisComputeLinkTerm(mris, parms->l_link, 1) ;
    }
    if (!(parms->flags & IPFLAG_NO_SELF_INT_TEST))
    {
      mht = MHTfillTable(mris, mht) ;
    }
    last_pial_sse = MRIScomputeSSE(mris,parms) ;
    delta_t +=
      mrisAsynchronousTimeStepNew(mris, 0, dt, mht, MAX_ASYNCH_NEW_MM) ;
    MRISsaveVertexPositions(mris, PIAL_VERTICES) ;
    if (gMRISexternalTimestep)
    {
      (*gMRISexternalTimestep)(mris, parms) ;
    }
    delta_t /= 2 ;
    pial_sse =
      MRIScomputeSSEExternal(mris, parms, &mle_sse) ;  /* needs update pial
                                                          to compute sse.
                                                          mle_sse includes
                                                          wm and pial */
    printf("MLE sse %2.3f --> %2.3f, delta = %2.3f\n",
           last_mle_sse, mle_sse, mle_sse-last_mle_sse) ;
    last_sse = last_wm_sse + last_pial_sse + last_mle_sse ;
    sse = wm_sse + pial_sse ; /* pial sse includes current mle_sse */

    pct_sse_decrease = 1 - sse/last_sse ;
    pct_sse_decrease =
      1 - mle_sse / last_mle_sse ;  /* only terminate if surfaces have
                                       asymptoted to desired positions */
    if (pct_sse_decrease < parms->tol)  /* error didn't decrease much */
    {
      nreductions++ ;
      dt *= .5 ;

      if (pct_sse_decrease < 0)  /* error increased - reject time step */
      {
        increased++ ;
        printf("error increased by %2.3f%% - time step "
               "reduction #%d: dt=%2.3f, undoing step...\n",
               -100.0f*pct_sse_decrease, nreductions, dt) ;
        MRISrestoreVertexPositions(mris, WHITE_VERTICES) ;
        MRISsaveVertexPositions(mris, ORIGINAL_VERTICES) ;
        MRISrestoreVertexPositions(mris, INFLATED_VERTICES) ;
        MRISsaveVertexPositions(mris, PIAL_VERTICES) ;
        if (gMRISexternalTimestep)
        {
          (*gMRISexternalTimestep)(mris, parms) ;
        }
        sse = last_sse ;
        mle_sse = last_mle_sse ;
        /*        nreductions = MAX_REDUCTIONS+1 ;*/
        if (ripped)
        {
          break ;
        }
        n-- ; /* don't count this as a time step */
      }
      else
      {
        printf("error decreased by %2.4f%% - "
               "%dth time step reduction: dt=%2.3f\n",
               100.0f*pct_sse_decrease, nreductions, dt) ;
        increased = 0 ;
      }
      if ((nreductions > MAX_REDUCTIONS))
      {
#if 0
        if (ripped == 0)
        {
          nreductions = 0 ;
          dt = parms->dt ;
          ripped = 1 ;
          nreductions = 0 ;
          printf("****** ripping vertices that have asymptoted *****\n") ;
          if (gMRISexternalRipVertices)
          {
            (*gMRISexternalRipVertices)(mris, parms) ;
          }
          continue ;
        }
#endif
        n++ ;
        break ;
      }
    }
    else
    {
      last_mle_sse = mle_sse ;
      increased = 0 ;
    }


    if (parms->flags & IPFLAG_ADD_VERTICES)
    {
      float max_len ;

      MRISrestoreVertexPositions(mris, PIAL_VERTICES) ;
      MRIScomputeMetricProperties(mris) ;
      for (max_len = 1.5*8 ; max_len > 1 ; max_len /= 2)
        while (MRISdivideLongEdges(mris, max_len) > 0)
          {}

      MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
      MRIScomputeMetricProperties(mris) ;
      for (max_len = 1.5*8 ; max_len > 1 ; max_len /= 2)
        while (MRISdivideLongEdges(mris, max_len) > 0)
          {}

      if (gMRISexternalTimestep)
      {
        (*gMRISexternalTimestep)(mris, parms) ;
      }
    }

    /* recompute sse after external timestep, since outward and inward
       distances will have changed */
    MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
    MRIScomputeMetricProperties(mris) ;
#if 0
    wm_sse = MRIScomputeSSE(mris, parms) ;
    MRISrestoreVertexPositions(mris, PIAL_VERTICES) ;
    MRIScomputeMetricProperties(mris) ;
    pial_sse = MRIScomputeSSE(mris, parms) ;
    sse = last_sse = wm_sse + pial_sse ;
#endif
#if 0
    rms = (*gMRISexternalRMS)(mris, parms) ;
#else
    rms = sqrt(mle_sse/(float)mris->nvertices) ;
#endif
    if (Gdiag & DIAG_SHOW)
      printf("%3.3d: dt: %2.4f, sse=%2.2f, pial sse=%2.2f, wm sse=%2.2f, rms=%2.2f, (%2.2f%%)\n",
             n+1,(float)delta_t, (float)sse/(float)mris->nvertices,
             (float)pial_sse/(float)mris->nvertices,
             (float)wm_sse/(float)mris->nvertices, (float)rms,
             100.0f*pct_sse_decrease);

    if (Gdiag & DIAG_WRITE)
    {
      fprintf(parms->fp, "%3.3d: dt: %2.4f, sse=%2.2f, pial sse=%2.2f, "
              "wm sse=%2.2f, rms=%2.2f (%2.2f%%)\n",
              n+1,(float)delta_t, (float)sse/(float)mris->nvertices,
              (float)pial_sse/(float)mris->nvertices,
              (float)wm_sse/(float)mris->nvertices, (float)rms,
              100.0f*pct_sse_decrease) ;

      fflush(parms->fp) ;
    }
    if ((parms->write_iterations > 0) &&
        !((n+1)%write_iterations)&&(Gdiag&DIAG_WRITE))
    {
      mrisWriteSnapshots(mris, parms, n+1) ;
    }

    if ((Gdiag & DIAG_SHOW) && !((n+1)%5)  && DIAG_VERBOSE_ON)
    {
      MRISprintTessellationStats(mris, stderr) ;
    }
    if ((nreductions > MAX_REDUCTIONS) && ripped)
    {
      n++ ;  /* count this step */
      break ;
    }
  }

  MRISunrip(mris) ;

  parms->start_t = n ;
  parms->dt = base_dt ;
  if (Gdiag & DIAG_SHOW)
  {
    msec = TimerStop(&then) ;
    fprintf(stdout,"positioning took %2.1f minutes\n",
            (float)msec/(60*1000.0f));
  }
  if (Gdiag & DIAG_WRITE)
  {
    fclose(parms->fp) ;
    parms->fp = NULL ;
  }

  /*  MHTcheckSurface(mris, mht) ;*/
  if (!(parms->flags & IPFLAG_NO_SELF_INT_TEST))
  {
    MHTfree(&mht) ;
  }
  return(NO_ERROR) ;
}


int
MRISpositionSurface(MRI_SURFACE *mris, MRI *mri_brain, MRI *mri_smooth,
                    INTEGRATION_PARMS *parms)
{
  /*  char   *cp ;*/
  int    avgs, niterations, n, write_iterations, nreductions = 0, done ;
  double sse, delta_t = 0.0, rms, dt,
              l_intensity, base_dt, last_sse,last_rms, max_mm;
  MHT    *mht = NULL, *mht_v_orig = NULL, *mht_v_current = NULL,
          *mht_f_current = NULL, *mht_pial = NULL ;
  struct timeb  then ;
  int msec ;

  max_mm = MIN(MAX_ASYNCH_MM,
               MIN(mri_smooth->xsize,
                   MIN(mri_smooth->ysize, mri_smooth->zsize))/2) ;
  if (!FZERO(parms->l_surf_repulse))
  {
    mht_v_orig = MHTfillVertexTable(mris, NULL, ORIGINAL_VERTICES) ;
  }

  if (parms->l_osurf_repulse > 0)   // repel inwards from outer surface
  {
    mht_pial = MHTfillVertexTableRes(mris, NULL, PIAL_VERTICES,3.0) ;
  }
  base_dt = parms->dt ;
  if (IS_QUADRANGULAR(mris))
  {
    MRISremoveTriangleLinks(mris) ;
  }
  TimerStart(&then) ;
  parms->mri_brain = mri_brain ;
  parms->mri_smooth = mri_smooth ;
  niterations = parms->niterations ;
  write_iterations = parms->write_iterations ;
  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    if (!parms->fp)
    {
      sprintf(fname, "%s.%s.out",
              mris->hemisphere==RIGHT_HEMISPHERE ? "rh": mris->hemisphere == BOTH_HEMISPHERES ? "both" : "lh",parms->base_name);
      if (!parms->start_t)
      {
        parms->fp = fopen(fname, "w") ;
      }
      else
      {
        parms->fp = fopen(fname, "a") ;
      }
      if (!parms->fp)
        ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                  Progname, fname) ;
    }
    mrisLogIntegrationParms(parms->fp, mris, parms) ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogIntegrationParms(stdout, mris, parms) ;
  }

  mrisClearMomentum(mris) ;
  MRIScomputeMetricProperties(mris) ;
  MRISstoreMetricProperties(mris) ;

  MRIScomputeNormals(mris) ;
  mrisClearDistances(mris) ;

  MRISclearCurvature(mris) ;  /* curvature will be used to calculate sulc */

  /* write out initial surface */
  if ((parms->write_iterations > 0) && (Gdiag&DIAG_WRITE) && !parms->start_t)
  {
    mrisWriteSnapshot(mris, parms, 0) ;
  }

  avgs = parms->n_averages ;
  if (!FZERO(parms->l_histo))
  {
    last_rms = rms = mrisComputeHistoNegativeLikelihood(mris, parms) ;
  }
  else if (!FZERO(parms->l_map))
  {
    int nvox ;
    MRISsaveVertexPositions(mris, PIAL_VERTICES) ;
    if (parms->mri_volume_fractions)
      MRIfree(&parms->mri_volume_fractions) ;
    if (parms->mri_dtrans)
      MRIfree(&parms->mri_dtrans) ;
    parms->mri_volume_fractions = MRIcomputeLaminarVolumeFractions(mris, parms->resolution, parms->mri_brain, NULL) ;

    rms = mrisComputeNegativeLogPosterior(mris, parms, &nvox) ;
//    last_rms = rms = 1-exp(-rms/nvox) ;
    last_rms = rms = sqrt(rms/nvox) ;
  }
  else if (!FZERO(parms->l_map2d))
  {
    int nvox ;
    MRISsaveVertexPositions(mris, PIAL_VERTICES) ;
#if 0
    if (parms->h2d != NULL)
      HISTO2Dfree(&parms->h2d) ;
#endif
    if (parms->mri_volume_fractions)
      MRIfree(&parms->mri_volume_fractions) ;
    if (parms->mri_dtrans)
      MRIfree(&parms->mri_dtrans) ;
    if ((getenv("READ_VOLS") != NULL))
    {
      parms->mri_volume_fractions = MRIread("map2d.vfrac.0000.mgz") ;
      parms->mri_dtrans = MRIread("dtrans.mgz") ;
    }
    else
      parms->mri_volume_fractions = MRIcomputeLaminarVolumeFractions(mris, parms->resolution, parms->mri_brain, NULL) ;

    rms = mrisComputeNegativeLogPosterior2D(mris, parms, &nvox) ;
//    last_rms = rms = 1-exp(-rms/nvox) ;
    last_rms = rms = sqrt(rms/nvox) ;
  }
  else if (!FZERO(parms->l_location))
  {
    last_rms = rms = mrisRmsDistanceError(mris) ;
  }
  else
  {
    last_rms = rms = mrisRmsValError(mris, mri_brain) ;
  }
  last_sse = sse = MRIScomputeSSE(mris, parms) ;
  if (DZERO(parms->l_histo) == 0)
  {
    last_rms = rms = mrisComputeHistoNegativeLikelihood(mris, parms) ;
  }
  else if (DZERO(parms->l_intensity) && gMRISexternalRMS != NULL && parms->l_external > 0)
  {
    last_rms = rms = (*gMRISexternalRMS)(mris, parms) ;
  }
#if 0
  else
  {
    last_rms = rms = 10*sqrt(sse/MRISvalidVertices(mris)) ;
  }
#endif
  if (Gdiag & DIAG_SHOW)
    fprintf(stdout, "%3.3d: dt: %2.4f, sse=%2.1f, rms=%2.3f\n",
            0, 0.0f, (float)sse, (float)rms);

  if (Gdiag & DIAG_WRITE)
  {
    fprintf(parms->fp, "%3.3d: dt: %2.4f, sse=%2.1f, rms=%2.3f\n",
            0, 0.0f, (float)sse, (float)rms);
    fflush(parms->fp) ;
  }

  dt = parms->dt ;
  l_intensity = parms->l_intensity ;
  for (n = parms->start_t ; n < parms->start_t+niterations ; n++)
  {
    parms->t = n ;
#if 0
    if (n == parms->start_t+niterations-5)
    {
      dt = parms->dt / 4.0f ;  /* take some small steps at the end */
      /*      l_intensity = 0.0f ;*/
    }
    if (n == parms->start_t+niterations-2)
    {
      dt = dt / 4.0f ;        /* take some really small steps at the end */
      /*      l_intensity = 0.0f ;*/
    }
#endif
    if (!FZERO(parms->l_repulse))
    {
      mht_v_current = MHTfillVertexTable(mris, mht_v_current,CURRENT_VERTICES);
      mht_f_current = MHTfillTable(mris, mht_f_current) ;
    }
    if (!(parms->flags & IPFLAG_NO_SELF_INT_TEST))
    {
#if 0
      if (mris->avg_vertex_dist < 0.6)
      {
        mht = MHTfillTableAtResolution(mris, mht, CURRENT_VERTICES, 0.5) ;
      }
      else
#endif
        mht = MHTfillTable(mris, mht) ;
    }
    MRISclearGradient(mris) ;
    mrisComputeTargetLocationTerm(mris, parms->l_location, parms) ;
    mrisComputeIntensityTerm(mris, l_intensity, mri_brain, mri_smooth,
                             parms->sigma, parms);
    mrisComputeShrinkwrapTerm(mris, mri_brain, parms->l_shrinkwrap) ;
    mrisComputeExpandwrapTerm(mris, mri_brain, parms->l_expandwrap) ;
    mrisComputeIntensityGradientTerm(mris, parms->l_grad,mri_brain,mri_smooth);
    mrisComputeSurfaceRepulsionTerm(mris, parms->l_surf_repulse, mht_v_orig);
    mrisComputeHistoTerm(mris, parms) ;
    mrisComputePosteriorTerm(mris, parms) ;
    mrisComputePosterior2DTerm(mris, parms) ;
    if (parms->l_osurf_repulse > 0)
      mrisComputeWhichSurfaceRepulsionTerm
      (mris, -parms->l_osurf_repulse, mht_pial, PIAL_VERTICES,.1);
    if (gMRISexternalGradient)
    {
      (*gMRISexternalGradient)(mris, parms) ;
    }

    /*                mrisMarkSulcalVertices(mris, parms) ;*/
    mrisComputeLaplacianTerm(mris, parms->l_lap) ;
#if 1
    mrisAverageSignedGradients(mris, avgs) ;
#else
    mrisAverageWeightedGradients(mris, avgs) ;
#endif
    /*                mrisUpdateSulcalGradients(mris, parms) ;*/

    /* smoothness terms */
    mrisComputeSpringTerm(mris, parms->l_spring) ;
    mrisComputeNormalizedSpringTerm(mris, parms->l_spring_norm) ;
    mrisComputeRepulsiveTerm(mris, parms->l_repulse, mht_v_current,
                             mht_f_current) ;
    mrisComputeThicknessSmoothnessTerm(mris, parms->l_tsmooth) ;
    mrisComputeThicknessMinimizationTerm(mris, parms->l_thick_min, parms) ;
    mrisComputeThicknessParallelTerm(mris, parms->l_thick_parallel, parms) ;
    mrisComputeNormalSpringTerm(mris, parms->l_nspring) ;
    mrisComputeQuadraticCurvatureTerm(mris, parms->l_curv) ;
    /*    mrisComputeAverageNormalTerm(mris, avgs, parms->l_nspring) ;*/
    /*    mrisComputeCurvatureTerm(mris, parms->l_curv) ;*/
    mrisComputeNonlinearSpringTerm(mris, parms->l_nlspring, parms) ;
    mrisComputeTangentialSpringTerm(mris, parms->l_tspring) ;
    mrisComputeNonlinearTangentialSpringTerm(mris, parms->l_nltspring, parms->min_dist) ;
    mrisComputeMaxSpringTerm(mris, parms->l_max_spring) ;
    mrisComputeAngleAreaTerms(mris, parms) ;

#if 0
    switch (parms->integration_type)
    {
    case INTEGRATE_LM_SEARCH:
      delta_t = mrisLineMinimizeSearch(mris, parms) ;
      break ;
    default:
    case INTEGRATE_LINE_MINIMIZE:
      delta_t = mrisLineMinimize(mris, parms) ;
      break ;
    case INTEGRATE_MOMENTUM:
      delta_t = MRISmomentumTimeStep(mris, parms->momentum, parms->dt,
                                     parms->tol, avgs) ;
      break ;
    case INTEGRATE_ADAPTIVE:
      mrisAdaptiveTimeStep(mris, parms);
      break ;
    }
#else
    enforce_links(mris) ;
    do
    {
      MRISsaveVertexPositions(mris, TMP2_VERTICES) ;
      mrisScaleTimeStepByCurvature(mris) ;
      MRISclearMarks(mris) ;
      delta_t = mrisAsynchronousTimeStep(mris, parms->momentum, dt,mht,
                                         max_mm) ;
      parms->t = n+1 ;  // for diags
#if 0
      if (Gdiag & DIAG_WRITE)
      {
        char fname[STRLEN] ;
        sprintf(fname, "%s.marked.%3.3d.mgz", parms->base_name, n) ;
        printf("writing vertices that would have intersected to %s\n", fname) ;
        MRISwriteMarked(mris, fname) ;
      }
#endif
      if (Gdiag_no >= 0 && mris->vertices[Gdiag_no].marked == 0)  // diag vertex was cropped
      {
        DiagBreak() ;
      }
      if (parms->smooth_intersections)
      {
        MRISerodeMarked(mris, 4) ;
        if (Gdiag_no >= 0 && mris->vertices[Gdiag_no].marked == 0)  // diag vertex was cropped
        {
          DiagBreak() ;
        }
        MRISsoapBubbleVertexPositions(mris, 500) ;
      }

      if (parms->uncompress)
      {
        MRISremoveCompressedRegions(mris, .2) ;
      }

      if (gMRISexternalTimestep)
      {
        (*gMRISexternalTimestep)(mris, parms) ;
      }
      if (!(parms->flags & IPFLAG_NO_SELF_INT_TEST))
      {
        MHTcheckFaces(mris, mht) ;
      }
      MRIScomputeMetricProperties(mris) ;
      if (!FZERO(parms->l_histo))
      {
        rms = mrisComputeHistoNegativeLikelihood(mris, parms) ;
      }
      else if (!FZERO(parms->l_map))
      {
	int nvox ;
	MRISsaveVertexPositions(mris, PIAL_VERTICES) ;
	if (parms->mri_volume_fractions)
	  MRIfree(&parms->mri_volume_fractions) ;
	parms->mri_volume_fractions = MRIcomputeLaminarVolumeFractions(mris, parms->resolution, parms->mri_brain, NULL) ;
        rms = mrisComputeNegativeLogPosterior(mris, parms, &nvox) ;
	rms = sqrt(rms/nvox) ;
      }
      else if (!FZERO(parms->l_map2d))
      {
	int nvox ;
	MRISsaveVertexPositions(mris, PIAL_VERTICES) ;
#if 0
	if (parms->h2d != NULL)
	  HISTO2Dfree(&parms->h2d) ;
#endif
	if (parms->mri_volume_fractions)
	  MRIfree(&parms->mri_volume_fractions) ;
	if (parms->mri_dtrans)
	  MRIfree(&parms->mri_dtrans) ;
	parms->mri_volume_fractions = MRIcomputeLaminarVolumeFractions(mris, parms->resolution, parms->mri_brain, NULL) ;
        rms = mrisComputeNegativeLogPosterior2D(mris, parms, &nvox) ;
	rms = sqrt(rms/nvox) ;
      }
      else if (!FZERO(parms->l_location))
      {
        rms = mrisRmsDistanceError(mris) ;
      }
      else if (DZERO(parms->l_intensity) && gMRISexternalRMS != NULL && parms->l_external > 0)
      {
        rms = (*gMRISexternalRMS)(mris, parms) ;
      }
      else
      {
        rms = mrisRmsValError(mris, mri_brain) ;
      }
      sse = MRIScomputeSSE(mris, parms) ;
      done = 1 ;
      /* check to see if the error decreased substantially, if not
      reduce the  step size  */
      if ((parms->check_tol && (last_rms-rms)/last_rms < parms->tol) ||
          ((parms->check_tol == 0) && FZERO(parms->l_location) && (rms > last_rms-0.05)))
      {
        nreductions++ ;
        parms->dt *= REDUCTION_PCT ;
        dt = parms->dt ;
        fprintf(stdout,
                "rms = %2.2f, time step reduction %d of %d to %2.3f...\n",
                rms, nreductions, MAX_REDUCTIONS+1, dt) ;
        mrisClearMomentum(mris) ;
#if 1
        if (rms > last_rms)  /* error increased - reject step */
        {
          MRISrestoreVertexPositions(mris, TMP2_VERTICES) ;
          MRIScomputeMetricProperties(mris) ;

          /* if error increased and we've only reduced the time
          step a few times, try taking a smaller step (done=0).
          */
          done = (nreductions > MAX_REDUCTIONS) ;
        }
#endif
      }
      if (Gdiag_no >= 0 && DIAG_VERBOSE_ON)
      {
        MRISprintVertexStats(mris, Gdiag_no, Gstdout, CURRENT_VERTICES) ;
      }
    }
    while (!done) ;
#if 0
    last_sse = sse ;
    last_rms = rms ;
#endif
#endif
    enforce_link_positions(mris) ;
    mrisTrackTotalDistanceNew(mris) ;  /* computes signed
                             deformation amount */
#if 0
    if (!FZERO(parms->l_histo))
    {
      rms = mrisComputeHistoNegativeLikelihood(mris, parms) ;
    }
    else if (!FZERO(parms->l_map))
    {
      rms = mrisComputeNegativeLogPosterior(mris, parms) ;
    }
    else if (!FZERO(parms->l_map2d))
    {
      rms = mrisComputeNegativeLogPosterior2D(mris, parms) ;
    }
    else if (!FZERO(parms->l_location))
    {
      rms = mrisRmsDistanceError(mris) ;
    }
    else if (DZERO(parms->l_intensity) && gMRISexternalRMS != NULL && parms->l_external > 0)
    {
      rms = (*gMRISexternalRMS)(mris, parms) ;
    }
    else
    {
      rms = mrisRmsValError(mris, mri_brain) ;
    }
    sse = MRIScomputeSSE(mris, parms) ;
#endif
    if (Gdiag & DIAG_SHOW)
      fprintf(stdout, "%3.3d: dt: %2.4f, sse=%2.1f, rms=%2.3f (%2.3f%%)\n",
              n+1,(float)delta_t, (float)sse, (float)rms, 100*(last_rms-rms)/last_rms);

    if (Gdiag & DIAG_WRITE)
    {
      fprintf(parms->fp, "%3.3d: dt: %2.4f, sse=%2.1f, rms=%2.3f (%2.3f%%)\n",
              n+1,(float)delta_t, (float)sse, (float)rms, 100*(last_rms-rms)/last_rms);
      fflush(parms->fp) ;
    }

    if ((parms->write_iterations > 0) &&
        !((n+1)%write_iterations)&&(Gdiag&DIAG_WRITE))
    {
      mrisWriteSnapshot(mris, parms, n+1) ;
    }

    if ((Gdiag & DIAG_SHOW) && !((n+1)%5) && DIAG_VERBOSE_ON)
    {
      MRISprintTessellationStats(mris, stderr) ;
    }
    if (Gdiag_no >= 0)
    {
      Real xv, yv, zv ;
      VERTEX *v ;
      v = &mris->vertices[Gdiag_no] ;
      MRISvertexToVoxel(mris, v, mri_brain, &xv, &yv, &zv) ;
      printf("v %d: (%2.1f, %2.1f, %2.1f), vox = (%2.0f, %2.0f %2.0f)\n",
             Gdiag_no, v->x, v->y, v->z, xv, yv, zv) ;
    }
    if (nreductions > MAX_REDUCTIONS)
    {
      n++ ;  /* count this step */
      break ;
    }
    last_sse = sse ;
    last_rms = rms ;
  }

  parms->start_t = n ;
  parms->dt = base_dt ;
  if (Gdiag & DIAG_SHOW)
  {
    msec = TimerStop(&then) ;
    fprintf(stdout,"positioning took %2.1f minutes\n",
            (float)msec/(60*1000.0f));
  }
  if (Gdiag & DIAG_WRITE)
  {
    fclose(parms->fp) ;
    parms->fp = NULL ;
  }

  /*  MHTcheckSurface(mris, mht) ;*/
  if (!(parms->flags & IPFLAG_NO_SELF_INT_TEST) && mht)
  {
    MHTfree(&mht) ;
  }
  if (mht_v_current)
  {
    MHTfree(&mht_v_current) ;
  }
  if (mht_f_current)
  {
    MHTfree(&mht_f_current) ;
  }
  if (mht_v_orig)
  {
    MHTfree(&mht_v_orig) ;
  }
  return(NO_ERROR) ;
}


int
MRISpositionSurface_mef(MRI_SURFACE *mris,
                        MRI *mri_30,
                        MRI *mri_5,
                        INTEGRATION_PARMS *parms,
                        float weight30, float weight5)
{
  /*  char   *cp ;*/
  int    avgs, niterations, n, write_iterations, nreductions = 0, done ;
  double delta_t = 0.0, rms, dt, l_intensity, base_dt, last_rms, max_mm,
         sse, last_sse, delta_rms ;
  MHT    *mht = NULL, *mht_v_orig = NULL, *mht_v_current = NULL,*mht_f_current = NULL;
  struct timeb  then ;
  int msec ;

  max_mm = MIN(MAX_ASYNCH_MM,
               MIN(mri_30->xsize,
                   MIN(mri_30->ysize, mri_30->zsize))/2) ;

  //note that the following is for pial surface avoid intersection with white
  if (!FZERO(parms->l_surf_repulse))
  {
    mht_v_orig = MHTfillVertexTable(mris, NULL, ORIGINAL_VERTICES) ;
  }

  base_dt = parms->dt ;
  if (IS_QUADRANGULAR(mris))
  {
    MRISremoveTriangleLinks(mris) ;
  }
  TimerStart(&then) ;
  //the following are used in mrisComputeIntensityError() and computeSSE()
  parms->mri_brain = NULL; //mri_30 ;
  parms->mri_smooth = NULL; //mri_5 ;
  niterations =
    parms->niterations ; /* should be different for white and pial;
                            yeah 25 for white and 30 for pial */
  write_iterations = parms->write_iterations ;
  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    if (!parms->fp)
    {
      sprintf(fname, "%s.%s.out",
              mris->hemisphere==RIGHT_HEMISPHERE ? "rh":"lh",parms->base_name);
      if (!parms->start_t)
      {
        parms->fp = fopen(fname, "w") ;
      }
      else
      {
        parms->fp = fopen(fname, "a") ;
      }
      if (!parms->fp)
        ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                  Progname, fname) ;
    }
    mrisLogIntegrationParms(parms->fp, mris, parms) ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    mrisLogIntegrationParms(stdout, mris, parms) ;
  }

  mrisClearMomentum(mris) ;
  MRIScomputeMetricProperties(mris) ;
  MRISstoreMetricProperties(mris) ;

  MRIScomputeNormals(mris) ;
  mrisClearDistances(mris) ;

  MRISclearCurvature(mris) ;  /* curvature will be used to calculate sulc */

  /* write out initial surface */
  if ((parms->write_iterations > 0) && (Gdiag&DIAG_WRITE) && !parms->start_t)
  {
    mrisWriteSnapshot(mris, parms, 0) ;
  }

  avgs = parms->n_averages ;
  last_rms =
    rms =
      mrisRmsValError_mef(mris, mri_30, mri_5, weight30, weight5) ;
  last_sse = sse = mrisComputeSSE_MEF(mris, parms, mri_30, mri_5, weight30, weight5, mht_v_orig) ;
  //this computation results were never used

  if (Gdiag & DIAG_SHOW)
    fprintf(stdout, "%3.3d: dt: %2.4f, rms=%2.2f\n",
            0, 0.0f, (float)rms);

  if (Gdiag & DIAG_WRITE)
  {
    fprintf(parms->fp, "%3.3d: dt: %2.4f, rms=%2.2f\n",
            0, 0.0f,  (float)rms);
    fflush(parms->fp) ;
  }

  dt = parms->dt ;
  l_intensity = parms->l_intensity ;
  for (n = parms->start_t ; n < parms->start_t+niterations ; n++)
  {
    if (!FZERO(parms->l_repulse))
    {
      mht_v_current = MHTfillVertexTable(mris, mht_v_current,CURRENT_VERTICES);
      mht_f_current = MHTfillTable(mris, mht_f_current);
    }
    if (!(parms->flags & IPFLAG_NO_SELF_INT_TEST))
    {
      mht = MHTfillTable(mris, mht) ;
    }
    MRISclearGradient(mris) ;
    mrisComputeIntensityTerm_mef(mris, l_intensity, mri_30, mri_5,
                                 parms->sigma, weight30, weight5, parms);
    //the following term is not used for white, but used for pial!
    mrisComputeSurfaceRepulsionTerm(mris, parms->l_surf_repulse, mht_v_orig);
#if 1
    mrisAverageSignedGradients(mris, avgs) ;
#else
    mrisAverageWeightedGradients(mris, avgs) ;
#endif
    /*                mrisUpdateSulcalGradients(mris, parms) ;*/

    /* smoothness terms */
    mrisComputeSpringTerm(mris, parms->l_spring) ;
    mrisComputeLaplacianTerm(mris, parms->l_lap) ;
    mrisComputeNormalizedSpringTerm(mris, parms->l_spring_norm) ;
    mrisComputeRepulsiveTerm(mris,parms->l_repulse,mht_v_current,mht_f_current);
    mrisComputeThicknessSmoothnessTerm(mris, parms->l_tsmooth) ;
    mrisComputeThicknessMinimizationTerm(mris, parms->l_thick_min, parms) ;
    mrisComputeThicknessParallelTerm(mris, parms->l_thick_parallel, parms) ;
    mrisComputeNormalSpringTerm(mris, parms->l_nspring) ;
    mrisComputeQuadraticCurvatureTerm(mris, parms->l_curv) ;
    mrisComputeNonlinearSpringTerm(mris, parms->l_nlspring, parms) ;
    mrisComputeTangentialSpringTerm(mris, parms->l_tspring) ;
    mrisComputeNonlinearTangentialSpringTerm(mris, parms->l_nltspring, parms->min_dist) ;


    do
    {
      MRISsaveVertexPositions(mris, WHITE_VERTICES) ;
      delta_t = mrisAsynchronousTimeStep(mris, parms->momentum, dt,mht,
                                         max_mm) ;
      if (!(parms->flags & IPFLAG_NO_SELF_INT_TEST))
      {
        MHTcheckFaces(mris, mht) ;
      }
      MRIScomputeMetricProperties(mris) ;
      rms = mrisRmsValError_mef(mris, mri_30, mri_5, weight30, weight5) ;
      sse = mrisComputeSSE_MEF(mris, parms, mri_30, mri_5, weight30, weight5, mht_v_orig) ;
      done = 1 ;
#if 1
      if (parms->check_tol)
      {
        delta_rms = parms->tol*last_rms ;
      }
      else
      {
        delta_rms = 0.05 ;  // don't worry about energy functional decreasing, just continue
      }
      if (parms->check_tol && (rms > last_rms-delta_rms))  // error increased - reduce step size
#else
      if (sse > last_sse-(last_sse*parms->tol))
#endif
      {
        nreductions++ ;
        parms->dt *= REDUCTION_PCT ;
        dt = parms->dt ;
        fprintf(stdout,
                "rms = %2.2f, time step reduction %d of %d to %2.3f...\n",
                rms, nreductions, MAX_REDUCTIONS+1, dt) ;
        mrisClearMomentum(mris) ;
        if (rms > last_rms)  /* error increased - reject step */
        {
          MRISrestoreVertexPositions(mris, WHITE_VERTICES) ;
          MRIScomputeMetricProperties(mris) ;

          /* if error increased and we've only reduced the time
             step a few times, try taking a smaller step (done=0).
          */
          done = (nreductions > MAX_REDUCTIONS) ;
        }
      }
    }
    while (!done) ;
    last_sse = sse ;
    last_rms = rms ;

    mrisTrackTotalDistanceNew(mris) ;  /* computes signed
                                          deformation amount */
    parms->rms = rms = mrisRmsValError_mef(mris, mri_30, mri_5, weight30, weight5) ;
    //  sse = MRIScomputeSSE(mris, parms) ;
    if (Gdiag & DIAG_SHOW)
      fprintf(stdout, "%3.3d: dt: %2.4f, rms=%2.2f\n",
              n+1,(float)delta_t,  (float)rms);

    if (Gdiag & DIAG_WRITE)
    {
      fprintf(parms->fp, "%3.3d: dt: %2.4f, rms=%2.2f\n",
              n+1,(float)delta_t, (float)rms);
      fflush(parms->fp) ;
    }

    if ((parms->write_iterations > 0) &&
        !((n+1)%write_iterations)&&(Gdiag&DIAG_WRITE))
    {
      mrisWriteSnapshot(mris, parms, n+1) ;
    }

    if ((Gdiag & DIAG_SHOW) && !((n+1)%5) && DIAG_VERBOSE_ON)
    {
      MRISprintTessellationStats(mris, stderr) ;
    }
    if (nreductions > MAX_REDUCTIONS)
    {
      n++ ;  /* count this step */
      break ;
    }

    if (gMRISexternalTimestep)
    {
      (*gMRISexternalTimestep)(mris, parms) ;
    }
  }

  parms->start_t = n ;
  parms->dt = base_dt ;
  if (Gdiag & DIAG_SHOW)
  {
    msec = TimerStop(&then) ;
    fprintf(stdout,"positioning took %2.1f minutes\n",
            (float)msec/(60*1000.0f));
  }
  if (Gdiag & DIAG_WRITE)
  {
    fclose(parms->fp) ;
    parms->fp = NULL ;
  }

  /*  MHTcheckSurface(mris, mht) ;*/
  if (!(parms->flags & IPFLAG_NO_SELF_INT_TEST))
  {
    MHTfree(&mht) ;
  }
  if (mht_v_current)
  {
    MHTfree(&mht_v_current) ;
  }
  if (mht_f_current)
  {
    MHTfree(&mht_f_current) ;
  }
  if (mht_v_orig)
  {
    MHTfree(&mht_v_orig) ;
  }
  return(NO_ERROR) ;
}



int
MRISmoveSurface(MRI_SURFACE *mris, MRI *mri_brain, MRI  *mri_smooth,
                INTEGRATION_PARMS *parms)
{
  /*  char   *cp ;*/
  double sse_before, sse_after, rms_before, rms_after ;
  MHT    *mht = NULL ;
  int     vno ;
  VERTEX  *v ;

  if (IS_QUADRANGULAR(mris))
  {
    MRISremoveTriangleLinks(mris) ;
  }
  parms->mri_brain = mri_brain ;
  parms->mri_smooth = mri_smooth ;
  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    if (!parms->fp)
    {
      sprintf
      (fname, "%s.%s.out",
       mris->hemisphere==RIGHT_HEMISPHERE ? "rh":"lh",parms->base_name);
      if (!parms->start_t)
      {
        parms->fp = fopen(fname, "w") ;
      }
      else
      {
        parms->fp = fopen(fname, "a") ;
      }
      if (!parms->fp)
        ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                  Progname, fname) ;
    }
  }

  MRIScomputeMetricProperties(mris) ;
  MRISstoreMetricProperties(mris) ;

  MRIScomputeNormals(mris) ;

  rms_before = mrisRmsValError(mris, mri_brain) ;
  sse_before = MRIScomputeSSE(mris, parms) ;
  if (Gdiag & DIAG_SHOW)
    fprintf(stdout, "before expansion, sse = %2.3f, rms = %2.3f\n",
            (float)sse_before, (float)rms_before) ;

  if (Gdiag & DIAG_WRITE)
  {
    /* write out initial surface */
    if (parms->write_iterations > 0)
    {
      fprintf(stdout, "writing out pre expansion surface.\n") ;
      MRISwrite(mris, "pre") ;
    }
    fprintf(parms->fp, "before expansion, sse = %2.1f, rms = %2.1f\n",
            (float)sse_before, (float)rms_before) ;
    fflush(parms->fp) ;
  }

  if (!(parms->flags & IPFLAG_NO_SELF_INT_TEST))
  {
    mht = MHTfillTable(mris, mht) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v->dx = v->nx * v->d ;
    v->dy = v->ny * v->d ;
    v->dz = v->nz * v->d ;
  }
  mrisAsynchronousTimeStep(mris, 0.0, 1.0,mht, 3.0f) ;
  MRIScomputeMetricProperties(mris) ;
  rms_after = mrisRmsValError(mris, mri_brain) ;
  sse_after = MRIScomputeSSE(mris, parms) ;
  if (Gdiag & DIAG_SHOW)
    fprintf(stdout, "after expansion, sse = %2.1f, rms = %2.1f\n",
            (float)sse_after, (float)rms_after) ;

  if (Gdiag & DIAG_WRITE)
  {
    if (parms->write_iterations > 0)
    {
      fprintf(stdout, "writing post expansion surface...\n") ;
      MRISwrite(mris, "post") ;
    }
    fprintf(parms->fp, "after expansion, sse = %2.3f, rms = %2.3f\n",
            (float)sse_after, (float)rms_after) ;
    fflush(parms->fp) ;
  }

  if (Gdiag & DIAG_WRITE)
  {
    fclose(parms->fp) ;
    parms->fp = NULL ;
  }

  /*  MHTcheckSurface(mris, mht) ;*/
  if (!(parms->flags & IPFLAG_NO_SELF_INT_TEST))
  {
    MHTfree(&mht) ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
MRI *
MRISwriteSurfaceIntoVolume(MRI_SURFACE *mris, MRI *mri_template, MRI *mri)
{
  int fno ;

  if (!mri)
  {
    mri =
      MRIalloc(256*2,256*2,256*2,MRI_BITMAP); // assumes the volume is 512^3
    MRIcopyHeader(mri_template, mri) ;
    MRIsetResolution(mri, 0.5, 0.5, 0.5) ; // resolution to 0.5 mm
    mri->xstart = mri_template->xstart ;
    mri->xend = mri_template->xend ;
    mri->ystart = mri_template->ystart ;
    mri->yend = mri_template->yend ;
    mri->zstart = mri_template->zstart ;
    mri->zend = mri_template->zend ;
  }
  else
  {
    MRIclear(mri) ;
  }

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    mrisFillFace(mris, mri, fno) ;
  }

  return(mri) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Fill in a triangle to prevent self-intersection at SAMPLE_DIST
  intervals (should be 1/2 resolution of mri volume).

  V0    b     V2
  o----------o
  |        /
  |      /
  a |    /
  |  /
  |/
  o
  V1      b        V2
  ------------------------------------------------------*/
static int
mrisFillFace(MRI_SURFACE *mris, MRI *mri, int fno)
{
  return(mrisHatchFace(mris, mri, fno, 1)) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Description
  each face has 2 triangles defined by it:

  V0    b     V2
  o----------o
  |        /
  |      /
  a |    /
  |  /
  |/
  o
  V1      b        V2
  ------------------------------------------------------*/
#define SAMPLE_DIST   0.25

static int
mrisHatchFace(MRI_SURFACE *mris, MRI *mri, int fno, int on)
{
  double   x, y, z, xa, ya, za, xc, yc, zc, t0, t1, adx, ady, adz, dx, dy, dz,
           cdx, cdy, cdz, alen, clen, delta_t0, delta_t1, len ;
  int    xv, yv, zv, i ;
  VERTEX *v0, *v1, *v2 ;
  FACE   *face ;

  face = &mris->faces[fno] ;
  if (face->ripflag)
  {
    return(NO_ERROR) ;
  }

  for (i = 0 ; i < 1 ; i++)
  {
    switch (i)
    {
    default:
    case 0:
      v0 = &mris->vertices[face->v[0]] ;
      v1 = &mris->vertices[face->v[1]] ;
      v2 = &mris->vertices[face->v[2]] ;
      break ;
    case 1:
      v0 = &mris->vertices[face->v[1]] ;
      v1 = &mris->vertices[face->v[2]] ;
      v2 = &mris->vertices[face->v[0]] ;
      break ;
    case 2:
      v0 = &mris->vertices[face->v[2]] ;
      v1 = &mris->vertices[face->v[0]] ;
      v2 = &mris->vertices[face->v[1]] ;
      break ;
    }

    v0 = &mris->vertices[face->v[0]] ;
    v1 = &mris->vertices[face->v[1]] ;
    v2 = &mris->vertices[face->v[2]] ;
    adx = v1->x - v0->x ;
    ady = v1->y - v0->y ;
    adz = v1->z - v0->z ;
    alen = sqrt(SQR(adx)+SQR(ady)+SQR(adz)) ;
    cdx = v2->x - v0->x ;
    cdy = v2->y - v0->y ;
    cdz = v2->z - v0->z ;
    clen = sqrt(SQR(cdx)+SQR(cdy)+SQR(cdz)) ;

    /*
      sample along legs of the triangle making sure the maximum spacing
      between samples (along the longer leg) is SAMPLE_DIST.
    */

    /*
      move along v0->v1 and v3->v2 lines and
      draw in crossing line to fill face
      t0 parameterizes lines from v0->v1 and v0->v2
    */
    if (FZERO(alen) && FZERO(clen))
    {
      delta_t0 = 0.99 ;
    }
    else
      delta_t0 =
        (alen > clen) ? (SAMPLE_DIST / alen) : (SAMPLE_DIST / clen ) ;
    if (FZERO(delta_t0))
      ErrorReturn(ERROR_BADPARM,
                  (ERROR_BADPARM,
                   "mrisFillFace: face %d has infinite leg (%d, %d)\n",
                   fno, alen, clen)) ;

    if (delta_t0 >= 1.0)
    {
      delta_t0 = 0.99 ;
    }

    /* delta_t0 is % of alen or clen (whichever is bigger) of SAMPLE_DIST */
    for (t0 = 0 ; t0 <= 1.0f ; t0 += delta_t0)
    {
      /* compute points (xa,ya,za) and (xc,yc,zc)
         on the a and c lines resp. */
      xa = v0->x + t0*adx ;
      ya = v0->y + t0*ady ;
      za = v0->z + t0*adz ;
      xc = v0->x + t0*cdx ;
      yc = v0->y + t0*cdy ;
      zc = v0->z + t0*cdz ;
      dx = xc-xa ;
      dy = yc-ya ;
      dz = zc-za ;
      len = sqrt(SQR(dx)+SQR(dy)+SQR(dz)) ;
      if (FZERO(len))
      {
        delta_t1 = 0.99 ;
      }
      else
      {
        delta_t1 = SAMPLE_DIST / len ;  /* sample at SAMPLE_DIST intervals */
        if (delta_t1 >= 1.0f)
        {
          delta_t1 = 0.99 ;
        }
      }

      /* now draw a line from (xa,ya,za) to (xc, yc, zc) */
      for (t1 = 0 ; t1 <= 1.0f ; t1 += delta_t1)
      {
        /* compute a point on the line connecting a and c */
        x = xa + t1*dx ;
        y = ya + t1*dy ;
        z = za + t1*dz ;
        // MRIworldToVoxel(mri, x,y,z,&x,&y,&z);/* volume coordinate */
        MRISsurfaceRASToVoxel
        (mris, mri, x, y, z, &x, &y, &z);/* volume coordinate */
        xv = nint(x) ;
        yv = nint(y) ;
        zv = nint(z);/* voxel coordinate */
        if (on)
        {
          MRIset_bit(mri, xv, yv, zv) ;  /* mark it filled */
        }
        else
        {
          MRIclear_bit(mri, xv, yv, zv) ;  /* mark it empty */
        }
      }
      /* compute last point on line */
      t1 = 1.0f ;
      x = xa + t1*dx ;
      y = ya + t1*dy ;
      z = za + t1*dz ;
      MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &x, &y, &z);//volume coordinate
      xv = nint(x) ;
      yv = nint(y) ;
      zv = nint(z) ;  /* voxel coordinate */
      if (on)
      {
        MRIset_bit(mri, xv, yv, zv) ;  /* mark it filled */
      }
      else
      {
        MRIclear_bit(mri, xv, yv, zv) ;  /* mark it empty */
      }
    }

    /* compute last line on the a and c lines resp. */
    t0 = 1.0f ;
    xa = v0->x + t0*adx ;
    ya = v0->y + t0*ady ;
    za = v0->z + t0*adz ;
    xc = v0->x + t0*cdx ;
    yc = v0->y + t0*cdy ;
    zc = v0->z + t0*cdz ;
    dx = xc-xa ;
    dy = yc-ya ;
    dz = zc-za ;
    len = sqrt(SQR(dx)+SQR(dy)+SQR(dz)) ;
    if (FZERO(len))
    {
      delta_t1 = 0.99 ;
    }
    else
    {
      delta_t1 = SAMPLE_DIST / len ;  /* sample at SAMPLE_DIST intervals */
      if (delta_t1 >= 1.0f)
      {
        delta_t1 = 0.99 ;
      }
    }

    /* now draw a line from (xa,ya,za) to (xc, yc, zc) */
    for (t1 = 0 ; t1 <= 1.0f ; t1 += delta_t1)
    {
      /* compute a point on the line connecting a and c */
      x = xa + t1*dx ;
      y = ya + t1*dy ;
      z = za + t1*dz ;
      // MRIworldToVoxel(mri, x, y, z, &x, &y, &z);/* volume coordinate */
      MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &x, &y, &z);//volume coordinate
      xv = nint(x) ;
      yv = nint(y) ;
      zv = nint(z) ;  /* voxel coordinate */
      if (on)
      {
        MRIset_bit(mri, xv, yv, zv) ;  /* mark it filled */
      }
      else
      {
        MRIclear_bit(mri, xv, yv, zv) ;  /* mark it empty */
      }
    }
    /* compute last point on line */
    t1 = 1.0f ;
    x = xa + t1*dx ;
    y = ya + t1*dy ;
    z = za + t1*dz ;
    MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &x, &y, &z) ; //volume coordinate
    xv = nint(x) ;
    yv = nint(y) ;
    zv = nint(z) ;  /* voxel coordinate */
    if (on)
    {
      MRIset_bit(mri, xv, yv, zv) ;  /* mark it filled */
    }
    else
    {
      MRIclear_bit(mri, xv, yv, zv) ;  /* mark it empty */
    }
  }

  return(NO_ERROR) ;
}
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisEraseFace(MRI_SURFACE *mris, MRI *mri, int fno)
{
  return(mrisHatchFace(mris, mri, fno, 0)) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Compute the cortical thickness at each vertex by measuring the
  distance from it to the pial surface.

  This routine assumes that the white matter surface is stored in
  ORIGINAL_VERTICES, and that the current vertex positions reflect
  the pial surface.
  ------------------------------------------------------*/

#if 1
int
MRISfindClosestOrigVertices(MRI_SURFACE *mris, int nbhd_size)
{
  int     vno, n, vlist[100000], vtotal, ns, i,
          vnum, nbr_count[100], min_n, min_vno ;
  VERTEX  *v, *vn, *vn2 ;
  float   dx, dy, dz, dist, min_dist, nx, ny, nz, dot ;

  memset(nbr_count, 0, 100*sizeof(int)) ;

  /* current vertex positions are gray matter, orig are white matter */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    dx = v->x - v->origx ;
    dy = v->y - v->origy ;
    dz = v->z - v->origz ;
    min_dist = sqrt(dx*dx + dy*dy + dz*dz) ;
    v->marked = 1 ;
    vtotal = 1 ;
    vlist[0] = vno ;
    min_n = 0 ;
    min_vno = vno ;
    for (ns = 1 ; ns <= nbhd_size ; ns++)
    {
      vnum = 0 ;  /* will be # of new neighbors added to list */
      for (i = 0 ; i < vtotal ; i++)
      {
        vn = &mris->vertices[vlist[i]] ;
        if (vn->ripflag)
        {
          continue ;
        }
        if (vn->marked && vn->marked < ns-1)
        {
          continue ;
        }
        for (n = 0 ; n < vn->vnum ; n++)
        {
          vn2 = &mris->vertices[vn->v[n]] ;
          if (vn2->ripflag || vn2->marked)  /* already processed */
          {
            continue ;
          }
          vlist[vtotal+vnum++] = vn->v[n] ;
          vn2->marked = ns ;
          dx = vn2->x-v->origx ;
          dy = vn2->y-v->origy ;
          dz = vn2->z-v->origz ;
          dot = dx*nx + dy*ny + dz*nz ;
          if (dot < 0) /* must be outwards from surface */
          {
            continue ;
          }
          dot = vn2->nx*nx + vn2->ny*ny + vn2->nz*nz ;
          if (dot < 0) /* must be outwards from surface */
          {
            continue ;
          }
          dist = sqrt(dx*dx + dy*dy + dz*dz) ;
          if (dist < min_dist)
          {
            min_n = ns ;
            min_dist = dist ;
            if (min_n == nbhd_size && DIAG_VERBOSE_ON)
              fprintf(stdout, "%d --> %d = %2.3f\n",
                      vno,vn->v[n], dist) ;
            min_vno = vn->v[n] ;
          }
        }
      }
      vtotal += vnum ;
    }

    nbr_count[min_n]++ ;
    for (n = 0 ; n < vtotal ; n++)
    {
      vn = &mris->vertices[vlist[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      vn->marked = 0 ;
    }
    v->curv = min_vno ;
  }


  for (n = 0 ; n <= nbhd_size ; n++)
  {
    fprintf(stdout, "%d vertices at %d distance\n", nbr_count[n], n) ;
  }
  return(NO_ERROR) ;
}
/*
  find the closest pial vertex and use it's spherical coords to initialize
  the thickness minimization. Put the v->c[xyz] coords of the nearest pial vertex into v->[xyz] of each vertex.
*/
int
MRISfindClosestPialVerticesCanonicalCoords(MRI_SURFACE *mris, int nbhd_size)
{
  int     vno, n, vlist[100000], vtotal, ns, i,
          vnum, nbr_count[100], min_n, min_vno ;
  VERTEX  *v, *vn, *vn2 ;
  float   dx, dy, dz, dist, min_dist, nx, ny, nz, dot ;

  memset(nbr_count, 0, 100*sizeof(int)) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    nx = v->wnx ;
    ny = v->wny ;
    nz = v->wnz ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    dx = v->pialx - v->whitex ;
    dy = v->pialy - v->whitey ;
    dz = v->pialz - v->whitez ;
    min_dist = sqrt(dx*dx + dy*dy + dz*dz) ;
    v->marked = 1 ;
    vtotal = 1 ;
    vlist[0] = vno ;
    min_n = 0 ;
    min_vno = vno ;
    for (ns = 1 ; ns <= nbhd_size ; ns++)
    {
      vnum = 0 ;  /* will be # of new neighbors added to list */
      for (i = 0 ; i < vtotal ; i++)
      {
        vn = &mris->vertices[vlist[i]] ;
        if (vn->ripflag)
        {
          continue ;
        }
        if (vn->marked && vn->marked < ns-1)
        {
          continue ;
        }
        for (n = 0 ; n < vn->vnum ; n++)
        {
          vn2 = &mris->vertices[vn->v[n]] ;
          if (vn2->ripflag || vn2->marked)  /* already processed */
          {
            continue ;
          }
          vlist[vtotal+vnum++] = vn->v[n] ;
          vn2->marked = ns ;
          dx = vn2->pialx-v->whitex ;
          dy = vn2->pialy-v->whitey ;
          dz = vn2->pialz-v->whitez ;
          dot = dx*nx + dy*ny + dz*nz ;
          if (dot < 0) /* must be outwards from surface */
          {
            continue ;
          }
          dot = vn2->wnx*nx + vn2->wny*ny + vn2->wnz*nz ;
          if (dot < 0) /* must be outwards from surface */
          {
            continue ;
          }
          dist = sqrt(dx*dx + dy*dy + dz*dz) ;
          if (dist < min_dist)
          {
            min_n = ns ;
            min_dist = dist ;
            if (min_n == nbhd_size && DIAG_VERBOSE_ON)
              fprintf(stdout, "%d --> %d = %2.3f\n",
                      vno,vn->v[n], dist) ;
            min_vno = vn->v[n] ;
          }
        }
      }
      vtotal += vnum ;
    }

    nbr_count[min_n]++ ;
    for (n = 0 ; n < vtotal ; n++)
    {
      vn = &mris->vertices[vlist[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      vn->marked = 0 ;
    }
    v->curv = min_vno ;
    v->x = mris->vertices[min_vno].cx ;
    v->y = mris->vertices[min_vno].cy ;
    v->z = mris->vertices[min_vno].cz ;
  }


  for (n = 0 ; n <= nbhd_size ; n++)
  {
    fprintf(stdout, "%d vertices at %d distance\n", nbr_count[n], n) ;
  }
  return(NO_ERROR) ;
}
int
MRISmeasureCorticalThickness(MRI_SURFACE *mris, int nbhd_size, float max_thick)
{
  int     vno, n, vlist[100000], vtotal, ns, i, vnum, nbr_count[100], min_n,
          nwg_bad, ngw_bad ;
  VERTEX  *v, *vn, *vn2 ;
  float   dx, dy, dz, dist, min_dist, nx, ny, nz, dot ;

  memset(nbr_count, 0, 100*sizeof(int)) ;
  nwg_bad = ngw_bad = 0 ;

  /* current vertex positions are gray matter, orig are white matter */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    if (!(vno % 25000))
    {
      fprintf(stdout, "%d of %d vertices processed\n", vno,mris->nvertices) ;
    }
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      v->curv = 0 ;
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    dx = v->x - v->origx ;
    dy = v->y - v->origy ;
    dz = v->z - v->origz ;
    min_dist = sqrt(dx*dx + dy*dy + dz*dz) ;
    v->marked = 1 ;
    vtotal = 1 ;
    vlist[0] = vno ;
    min_n = 0 ;
    for (ns = 1 ; ns <= nbhd_size ; ns++)
    {
      vnum = 0 ;  /* will be # of new neighbors added to list */
      for (i = 0 ; i < vtotal ; i++)
      {
        vn = &mris->vertices[vlist[i]] ;
        if (vn->ripflag)
        {
          continue ;
        }
        if (vn->marked && vn->marked < ns-1)
        {
          continue ;
        }
        for (n = 0 ; n < vn->vnum ; n++)
        {
          vn2 = &mris->vertices[vn->v[n]] ;
          if (vn2->ripflag || vn2->marked)  /* already processed */
          {
            continue ;
          }
          vlist[vtotal+vnum++] = vn->v[n] ;
          vn2->marked = ns ;
          dx = vn2->x-v->origx ;
          dy = vn2->y-v->origy ;
          dz = vn2->z-v->origz ;
          dot = dx*nx + dy*ny + dz*nz ;
          if (dot < 0) /* must be outwards from surface */
          {
            continue ;
          }
          dot = vn2->nx*nx + vn2->ny*ny + vn2->nz*nz ;
          if (dot < 0) /* must be outwards from surface */
          {
            continue ;
          }
          dist = sqrt(dx*dx + dy*dy + dz*dz) ;
          if (dist < min_dist)
          {
            min_n = ns ;
            min_dist = dist ;
            if (min_n == nbhd_size && DIAG_VERBOSE_ON)
              fprintf(stdout, "%d --> %d = %2.3f\n",
                      vno,vn->v[n], dist) ;
          }
        }
      }
      vtotal += vnum ;
    }

    nbr_count[min_n]++ ;
    for (n = 0 ; n < vtotal ; n++)
    {
      vn = &mris->vertices[vlist[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      vn->marked = 0 ;
    }
    if (min_dist > max_thick)
    {
      nwg_bad++ ;
      min_dist = max_thick ;
    }
    if (min_dist < 0)
    {
      DiagBreak() ;
    }
    v->curv = min_dist ;
  }


  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    if (!(vno % 25000))
    {
      fprintf(stdout, "%d of %d vertices processed\n", vno,mris->nvertices) ;
    }
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    dx = v->x - v->origx ;
    dy = v->y - v->origy ;
    dz = v->z - v->origz ;
    min_dist = sqrt(dx*dx + dy*dy + dz*dz) ;
    v->marked = 1 ;
    vtotal = 1 ;
    vlist[0] = vno ;
    min_n = 0 ;
    for (ns = 1 ; ns <= nbhd_size ; ns++)
    {
      vnum = 0 ;  /* will be # of new neighbors added to list */
      for (i = 0 ; i < vtotal ; i++)
      {
        vn = &mris->vertices[vlist[i]] ;
        if (vn->ripflag)
        {
          continue ;
        }
        if (vn->marked && vn->marked < ns-1)
        {
          continue ;
        }
        for (n = 0 ; n < vn->vnum ; n++)
        {
          vn2 = &mris->vertices[vn->v[n]] ;
          if (vn2->ripflag || vn2->marked)  /* already processed */
          {
            continue ;
          }
          vlist[vtotal+vnum++] = vn->v[n] ;
          vn2->marked = ns ;
          dx = v->x-vn2->origx ;
          dy = v->y-vn2->origy ;
          dz = v->z-vn2->origz ;
          dot = dx*nx + dy*ny + dz*nz ;
          if (dot < 0) /* must be outwards from surface */
          {
            continue ;
          }
          dot = vn2->nx*nx + vn2->ny*ny + vn2->nz*nz ;
          if (dot < 0) /* must be outwards from surface */
          {
            continue ;
          }
          dist = sqrt(dx*dx + dy*dy + dz*dz) ;
          if (dist < min_dist)
          {
            min_n = ns ;
            min_dist = dist ;
            if (min_n == nbhd_size && DIAG_VERBOSE_ON)
              fprintf(stdout, "%d --> %d = %2.3f\n",
                      vno,vn->v[n], dist) ;
          }
        }
      }
      vtotal += vnum ;
    }

    nbr_count[min_n]++ ;
    for (n = 0 ; n < vtotal ; n++)
    {
      vn = &mris->vertices[vlist[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      vn->marked = 0 ;
    }
    if (DIAG_VERBOSE_ON && fabs(v->curv - min_dist) > 4.0)
      fprintf(stdout, "v %d, white->gray=%2.2f, gray->white=%2.2f\n",
              vno, v->curv, min_dist) ;
    if (min_dist > max_thick)
    {
      min_dist = max_thick ;
      ngw_bad++ ;
    }
    if (min_dist < 0)
    {
      DiagBreak() ;
    }
    v->curv = (v->curv+min_dist)/2 ;
    if (v->curv < 0)
    {
      DiagBreak() ;
    }
  }

  fprintf(stdout, "thickness calculation complete, %d:%d truncations.\n",
          nwg_bad, ngw_bad) ;
  for (n = 0 ; n <= nbhd_size ; n++)
  {
    fprintf(stdout, "%d vertices at %d distance\n", nbr_count[n], n) ;
  }
  return(NO_ERROR) ;
}
#else
#define MAX_THICKNESS 6.0f
int
MRISmeasureCorticalThickness(MRI_SURFACE *mris)
{
  int     vno ;
  VERTEX  *v ;
  float   max_out_dist ;
  MHT     *mht ;

  mht = MHTfillTable(mris, NULL) ;  /* fill table with pial surface position */
  MRISsaveVertexPositions(mris, TMP_VERTICES) ;

  /* compute white matter vertex normals */
  MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
  MRIScomputeNormals(mris);
  MRISsmoothSurfaceNormals(mris, 10) ;

  /* must restore gray matter surface so self-intersection will work */
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    if (!(vno%50))
    {
      DiagHeartbeat((float)vno / (float)(mris->nvertices-1)) ;
    }
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    max_out_dist =
      mrisFindNormalDistance(mris, mht, vno, 1.5*MAX_THICKNESS, CURRENT_VERTICES);
    if (max_out_dist > MAX_THICKNESS)   /* can't compute it properly */
    {
      float  dx, dy, dz ;
      dx = v->x - v->origx ;
      dy = v->y - v->origy ;
      dz = v->z - v->origz ;
      v->curv = sqrt(dx*dx+dy*dy+dz*dz) ;
      v->marked = 1 ;
    }
    else
    {
      v->curv = max_out_dist ;
    }
  }

  MHTfree(&mht) ;
  return(NO_ERROR) ;
}
#endif
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisFindNextOutwardFace(MRI_SURFACE *mris, MHT *mht, int vno, double max_dist)
{
  int     nfound, flist[1000], *fptr, total_found, i, j ;
  double  dist, d ;
  VERTEX  *v ;

  v = &mris->vertices[vno] ;

  for (total_found = nfound = 0, dist = 0.0 ; dist <= max_dist ; dist += .25)
  {
    d = dist ;
    fptr = &flist[total_found] ;
    nfound =
      mrisAllNormalDirectionCurrentTriangleIntersections
      (mris, v,mht,&d,fptr);
    if (nfound > 0)
    {
      for (i = 0 ; i < total_found ; i++)
      {
        for (j = 0 ; j < nfound ; j++)
        {
          if (flist[i] == fptr[j])
          {
            fptr[j] = -1 ;  /* was already found */
          }
        }
      }
      for (j = 0 ; j < nfound ; j++)
      {
        if (fptr[j] >= 0)
        {
          if (total_found ==1000)
            ErrorExit(ERROR_BADPARM,
                      "too many intersecting faces.  "
                      "check filled volume for correctness\n");
          flist[total_found++] = fptr[j] ;
        }
      }
      for (i = 0 ; i < total_found ; i++)
        if (vertexInFace(mris, vno, flist[i]))
        {
          flist[i] = -1 ;
        }
      nfound = total_found ;
      for (fptr = flist,total_found = 0, j = 0 ; j < nfound ; j++, fptr++)
      {
        if (*fptr >= 0)
        {
          if (total_found ==1000)
            ErrorExit(ERROR_BADPARM, "too many intersecting faces.  "
                      "check filled volume for correctness\n");
          flist[total_found++] = *fptr ;
        }
      }
    }
    if (total_found > 0)
    {
      if (vno == Gdiag_no)
      {
        fprintf(stdout, "v %d @ (%2.2f, %2.2f, %2.2f), f ",
                vno, v->x,v->y,v->z);
        for (i = 0 ; i < v->num ; i++)
        {
          fprintf(stdout, "%d ", v->f[i]) ;
        }
        fprintf(stdout, "\n") ;
        for (i = 0 ; i < total_found ; i++)
        {
          FACE *f = &mris->faces[flist[i]] ;
          fprintf(stdout, "\tface %d with vertices (%d, %d, %d)\n",
                  flist[i], f->v[0], f->v[1], f->v[2]) ;
        }
      }
      return(flist[0]) ;
    }
  }
  return(-1) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisFindNextInwardFace(MRI_SURFACE *mris, MHT *mht, int vno, double max_dist)
{
  int     nfound, flist[1000], *fptr, total_found, i, j ;
  double  dist, d ;
  VERTEX  *v ;

  v = &mris->vertices[vno] ;
  v->nx *= -1 ;
  v->ny *= -1 ;
  v->nz *= -1 ;
  for (total_found = nfound = 0, dist = 0.0 ; dist <= max_dist ; dist += .25)
  {
    d = dist ;
    fptr = &flist[total_found] ;
    nfound =
      mrisAllNormalDirectionCurrentTriangleIntersections
      (mris, v,mht,&d,fptr);
    if (nfound > 0)
    {
      for (i = 0 ; i < total_found ; i++)
      {
        for (j = 0 ; j < nfound ; j++)
        {
          if (flist[i] == fptr[j])
          {
            fptr[j] = -1 ;  /* was already found */
          }
        }
      }
      for (j = 0 ; j < nfound ; j++)
      {
        if (fptr[j] >= 0)
        {
          if (total_found ==1000)
            ErrorExit(ERROR_BADPARM, "too many intersecting faces. "
                      " check filled volume for correctness\n");
          flist[total_found++] = fptr[j] ;
        }
      }
      for (i = 0 ; i < total_found ; i++)
        if (vertexInFace(mris, vno, flist[i]))
        {
          flist[i] = -1 ;
        }
      nfound = total_found ;
      for (fptr = flist,total_found = 0, j = 0 ; j < nfound ; j++, fptr++)
      {
        if (*fptr >= 0)
        {
          if (total_found ==1000)
            ErrorExit
            (ERROR_BADPARM,
             "too many intersecting faces.  "
             "check filled volume for correctness\n");
          flist[total_found++] = *fptr ;
        }
      }
    }
    if (total_found > 0)
    {
      v->nx *= -1 ;
      v->ny *= -1 ;
      v->nz *= -1 ;
      return(flist[0]) ;
    }
  }
  v->nx *= -1 ;
  v->ny *= -1 ;
  v->nz *= -1 ;
  return(-1) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
static double
mrisFindNormalDistance(MRI_SURFACE *mris, MHT *mht, int vno, double max_dist, int which)
{
  double   dist ;
  VERTEX   *v ;

  v = &mris->vertices[vno] ;
  if (v->ripflag)
  {
    return(0.0) ;
  }

  for (dist = 0.0f ; dist < max_dist ; dist += .05)
  {
    if (mrisNormalDirectionTriangleIntersection
        (mris, v, mht, &dist,NULL, which) > 0)
    {
      return(dist) ;
    }
  }

  return(dist) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  See if the line in the normal direction passing
  through vertex v intersects any of the triangles at the
  given location.
  ------------------------------------------------------*/
static int
mrisDirectionTriangleIntersection(MRI_SURFACE *mris, float x0, float y0,
                                  float z0, float nx, float ny,
                                  float nz, MHT *mht, double *pdist)
{
  double  dist, min_dist, U0[3], U1[3], U2[3], pt[3], dir[3], int_pt[3], dot ;
  float   x, y, z, dx, dy, dz ;
  MHBT    *bucket ;
  MHB     *bin ;
  int     i, found, fno, ret ;
  static MHBT *last_bucket = NULL ;
  static float lastx, lasty, lastz = -1 ;

  dist = *pdist ;
  dir[0] = nx ;
  dir[1] = ny ;
  dir[2] = nz ;
  pt[0] = x0  ;
  pt[1] = y0  ;
  pt[2] = z0  ;
  x = x0 + nx * dist ;
  y = y0 + ny * dist ;
  z = z0 + nz * dist ;

  min_dist = 10000.0f ;
#if 1
  bucket = MHTgetBucket(mht, x, y, z) ;
  if (bucket == NULL)
  {
    return(0) ;
  }

#if 0
  if (lastx == x0 && lasty == y0 && lastz == z0 && bucket == last_bucket)
  {
    return(0) ;
  }
#endif

  lastx = x0 ;
  lasty = y0 ;
  lastz = z0 ;
  last_bucket = bucket ;

  for (bin = bucket->bins, found = i = 0 ; i < bucket->nused ; i++, bin++)
  {
    fno = bin->fno ;
    if (fno == 1287 || fno == 5038)
    {
      DiagBreak() ;
    }
#else
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
#endif
    load_triangle_vertices(mris, fno, U0, U1, U2, CURRENT_VERTICES) ;
    ret = triangle_ray_intersect(pt, dir, U0, U1, U2, int_pt) ;
    if (ret)
    {
      dx = int_pt[0] - x0 ;
      dy = int_pt[1] - y0 ;
      dz = int_pt[2] - z0 ;
      dist = sqrt(dx*dx + dy*dy + dz*dz) ;
      dot = dx*nx + dy*ny + dz*nz ;
      if (dot >= 0 && dist < min_dist)
      {
        found = 1 ;
        *pdist = min_dist = dist ;
      }
    }
  }
  return(found) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  See if the line in the normal direction passing
  through vertex v intersects any of the triangles at the
  given location.
  ------------------------------------------------------*/
#if 0
static int
mrisNormalDirectionTriangleIntersection(MRI_SURFACE *mris, VERTEX *v,
                                        MHT *mht, double *pdist, int *flist, int which)
{
  double  dist, min_dist, U0[3], U1[3], U2[3], pt[3], dir[3], int_pt[3], dot ;
  float   nx, ny, nz, x, y, z, dx, dy, dz ;
  MHBT    *bucket ;
  MHB     *bin ;
  int     i, found, fno, ret ;


  dist = *pdist ;
  nx = v->nx ;
  ny = v->ny ;
  nz = v->nz ;
  dir[0] = v->nx ;
  dir[1] = v->ny ;
  dir[2] = v->nz ;
  pt[0] = v->origx  ;
  pt[1] = v->origy  ;
  pt[2] = v->origz  ;
  x = v->origx + nx * dist ;
  y = v->origy + ny * dist ;
  z = v->origz + nz * dist ;

  bucket = MHTgetBucket(mht, x, y, z) ;
  if (bucket == NULL)
  {
    return(-1) ;
  }

  min_dist = 10000.0f ;
  for (bin = bucket->bins, found = i = 0 ; i < bucket->nused ; i++, bin++)
  {
    fno = bin->fno ;

    load_triangle_vertices(mris, fno, U0, U1, U2, which) ;
    ret = triangle_ray_intersect(pt, dir, U0, U1, U2, int_pt) ;
    if (ret)
    {
      dx = int_pt[0] - v->origx ;
      dy = int_pt[1] - v->origy ;
      dz = int_pt[2] - v->origz ;
      dist = sqrt(dx*dx + dy*dy + dz*dz) ;
      dot = dx*nx + dy*ny + dz*nz ;
      if (dot >= 0 && dist < min_dist)
      {
        if (flist)
        {
          flist[found] = fno ;
        }
        found++ ;
        if (found ==1000)
          ErrorExit
          (ERROR_BADPARM,
           "too many intersecting faces.  "
           "check filled volume for correctness\n");
        *pdist = min_dist = dist ;
      }
    }
  }
  return(found) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  See if the line in the normal direction passing
  through vertex v intersects any of the triangles at the
  given location.
  ------------------------------------------------------*/
static int
mrisAllNormalDirectionCurrentTriangleIntersections(MRI_SURFACE *mris,
    VERTEX *v, MHT *mht,
    double *pdist, int *flist)
{
  double  dist, min_dist, U0[3], U1[3], U2[3], pt[3], dir[3], int_pt[3] ;
  float   nx, ny, nz, x, y, z, dx, dy, dz, dot ;
  MHBT    *bucket ;
  MHB     *bin ;
  int     i, found, fno, ret ;
  static MHBT *last_bucket = NULL ;
  static VERTEX *last_v = NULL ;


  dist = *pdist ;
  nx = v->nx ;
  ny = v->ny ;
  nz = v->nz ;
  dir[0] = v->nx ;
  dir[1] = v->ny ;
  dir[2] = v->nz ;
  pt[0] = v->x  ;
  pt[1] = v->y  ;
  pt[2] = v->z  ;
  x = v->x + nx * dist ;
  y = v->y + ny * dist ;
  z = v->z + nz * dist ;

  bucket = MHTgetBucket(mht, x, y, z) ;
  if (bucket == NULL)
  {
    return(-1) ;
  }

  if (last_v == v && bucket == last_bucket)
  {
    return(-2) ;
  }
  last_v = v ;
  last_bucket = bucket ;

  min_dist = 10000.0f ;
  for (bin = bucket->bins, found = i = 0 ; i < bucket->nused ; i++, bin++)
  {
    fno = bin->fno ;

    load_triangle_vertices(mris, fno, U0, U1, U2, CURRENT_VERTICES) ;
    ret = triangle_ray_intersect(pt, dir, U0, U1, U2, int_pt) ;
    if (ret)
    {
      dx = int_pt[0] - v->x ;
      dy = int_pt[1] - v->y ;
      dz = int_pt[2] - v->z ;
      dot = dx*nx + dy*ny + dz*nz ;
      if (dot < 0)   /* in direciton antiparallel to normal direction */
      {
        continue ;
      }
      dist = sqrt(dot) ;
      if (flist)
      {
        flist[found] = fno ;
      }
      found++ ;
      if (found ==1000)
        ErrorExit
        (ERROR_BADPARM,
         "too many intersecting faces.  "
         "check filled volume for correctness\n");
      if (dist < min_dist)
      {
        *pdist = min_dist = dist ;
      }
    }
  }
  return(found) ;
}
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  See if the line in the normal direction passing
  through vertex v intersects any of the triangles at the
  given location.
  ------------------------------------------------------*/
static int
mrisAllCurrentTriangleIntersections(MRI_SURFACE *mris, float x, float y,
                                    float z, float nx, float ny, float nz,
                                    MHT *mht, int *flist)
{
  double  U0[3], U1[3], U2[3], pt[3], dir[3], int_pt[3] ;
  MHBT    *bucket ;
  MHB     *bin ;
  int     i, found, fno, ret ;


  dir[0] = nx ;
  dir[1] = ny ;
  dir[2] = nz ;
  pt[0] = x  ;
  pt[1] = y  ;
  pt[2] = z  ;

  bucket = MHTgetBucket(mht, x, y, z) ;
  if (bucket == NULL)
  {
    return(-1) ;
  }

  for (bin = bucket->bins, found = i = 0 ; i < bucket->nused ; i++, bin++)
  {
    fno = bin->fno ;

    load_triangle_vertices(mris, fno, U0, U1, U2, CURRENT_VERTICES) ;
    ret = triangle_ray_intersect(pt, dir, U0, U1, U2, int_pt) ;
    if (ret)
    {
      flist[found] = fno ;
      found++ ;
      if (found ==1000)
        ErrorExit
        (ERROR_BADPARM,
         "too many intersecting faces.  "
         "check filled volume for correctness\n");
    }
  }
  return(found) ;
}
#endif

static int
load_orig_triangle_vertices(MRI_SURFACE *mris, int fno, double U0[3],
                            double U1[3], double U2[3])
{
  VERTEX *v ;
  FACE   *face ;

  face = &mris->faces[fno] ;
  v = &mris->vertices[face->v[0]] ;
  U0[0] = v->origx ;
  U0[1] = v->origy ;
  U0[2] = v->origz ;
  v = &mris->vertices[face->v[1]] ;
  U1[0] = v->origx ;
  U1[1] = v->origy ;
  U1[2] = v->origz ;
  v = &mris->vertices[face->v[2]] ;
  U2[0] = v->origx ;
  U2[1] = v->origy ;
  U2[2] = v->origz ;
  return(NO_ERROR) ;
}
static int
load_triangle_vertices(MRI_SURFACE *mris, int fno, double U0[3], double U1[3],
                       double U2[3], int which)
{
  VERTEX *v ;
  FACE   *face ;

  face = &mris->faces[fno] ;
  switch (which)
  {
  default:
  case CURRENT_VERTICES:
    v = &mris->vertices[face->v[0]] ;
    U0[0] = v->x ;
    U0[1] = v->y ;
    U0[2] = v->z ;
    v = &mris->vertices[face->v[1]] ;
    U1[0] = v->x ;
    U1[1] = v->y ;
    U1[2] = v->z ;
    v = &mris->vertices[face->v[2]] ;
    U2[0] = v->x ;
    U2[1] = v->y ;
    U2[2] = v->z ;
    break ;
  case WHITE_VERTICES:
    v = &mris->vertices[face->v[0]] ;
    U0[0] = v->whitex ;
    U0[1] = v->whitey ;
    U0[2] = v->whitez ;
    v = &mris->vertices[face->v[1]] ;
    U1[0] = v->whitex ;
    U1[1] = v->whitey ;
    U1[2] = v->whitez ;
    v = &mris->vertices[face->v[2]] ;
    U2[0] = v->whitex ;
    U2[1] = v->whitey ;
    U2[2] = v->whitez ;
    break ;
  case PIAL_VERTICES:
    v = &mris->vertices[face->v[0]] ;
    U0[0] = v->pialx ;
    U0[1] = v->pialy ;
    U0[2] = v->pialz ;
    v = &mris->vertices[face->v[1]] ;
    U1[0] = v->pialx ;
    U1[1] = v->pialy ;
    U1[2] = v->pialz ;
    v = &mris->vertices[face->v[2]] ;
    U2[0] = v->pialx ;
    U2[1] = v->pialy ;
    U2[2] = v->pialz ;
    break ;
  }
  return(NO_ERROR) ;
}
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisFindClosestFilledVoxel(MRI_SURFACE *mris, MRI *mri_filled, int vno,
                           double max_dist)
{
  VERTEX  *v ;
  double  min_dist, dist, xd, yd, zd ;
  int     xoff, yoff, zoff, whalf, x, y, z, xi, yi, zi, window_size ;
  double    xw, yw, zw ;

  v = &mris->vertices[vno] ;
  if (v->ripflag)
  {
    return(0.0) ;
  }
  MRISvertexToVoxel(mris, v, mri_filled, &xw, &yw, &zw) ;
  x = nint(xw) ;
  y = nint(yw) ;
  ;
  z = nint(zw) ;

  window_size = nint(max_dist/mri_filled->xsize + 0.5) ;
  whalf = (window_size-1)/2 ;

  min_dist = 10.0*max_dist*max_dist ;
  for (zoff = -whalf ; zoff <= whalf ; zoff++)
  {
    zi = mri_filled->zi[zoff+z] ;
    zd = zi - z ;
    for (yoff = -whalf ; yoff <= whalf ; yoff++)
    {
      yi = mri_filled->yi[yoff+y] ;
      yd = yi-y ;
      for (xoff = -whalf ; xoff <= whalf ; xoff++)
      {
        xi = mri_filled->xi[xoff+x] ;
        if (MRItest_bit(mri_filled, xi, yi, zi))
        {
          xd = xi-x ;
          dist = xd*xd+yd*yd+zd*zd ;
          if (dist < min_dist)
          {
            min_dist = dist ;
          }
        }
      }
    }
  }

  min_dist = sqrt(min_dist) * mri_filled->xsize ;

  return(min_dist) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISsoapBubbleVertexPositions(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum, n ;
  float  x, y, z, num ;
  VERTEX *v, *vn ;
  int    nmarked ;

  MRIScopyMarkedToMarked3(mris) ;
  for (i = 0 ; i < navgs ; i++)
  {
    if (Gdiag_no >=0 && (mris->vertices[Gdiag_no].marked == 0))
    {
      v = &mris->vertices[Gdiag_no] ;
      printf("v %d @ (%2.1f, %2.1f, %2.1f) will be moved during soap bubble:\n", Gdiag_no,v->x,v->y,v->z) ;
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        printf("\tnbr %d=%d, marked = %d, (%2.1f, %2.1f, %2.1f)\n", n, v->v[n], vn->marked,
               vn->x, vn->y, vn->z) ;
      }
      DiagBreak() ;
    }
    for (nmarked = vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 1)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      x = y = z = 0;
      num = 0;
      /*      if (v->marked == 2)*/
      {
        x = v->x ;
        y = v->y ;
        z = v->z ;
        num++ ;   /* account for central vertex */
      }
      pnb = v->v ;
      vnum = v->vnum ;
      for (vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
#if 0
        if (vn->ripflag ||
            !vn->marked ||
            vn->marked > 2) /* no valid data */
#else
        if (vn->ripflag) /* no valid data */
#endif
          continue ;
        num++ ;
        x += vn->x ;
        y += vn->y ;
        z += vn->z ;
      }
      if (num>0)
      {
        v->tdx = x / num ;
        v->tdy = y / num ;
        v->tdz = z / num ;
        if (!v->marked)
        {
          nmarked++ ;
        }
        v->marked = 3 ;  /* need modification */
      }
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 1)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        printf("iter %d: moving v %d from (%2.1f, %2.1f, %2.1f) --> (%2.1f, %2.1f, %2.1f)\n", i, vno, v->tdx, v->tdy, v->tdz, v->x, v->y, v->z) ;
      }
      if (v->marked)
      {
        v->x = v->tdx ;
        v->y = v->tdy ;
        v->z = v->tdz ;
      }
      if (v->marked == 3)  /* needs modification */
      {
        v->marked = 2 ;  /* modified, but not fixed */
      }
    }
    if (nmarked && (Gdiag & DIAG_SHOW) && DIAG_VERBOSE_ON)
    {
      printf("%d: %d vertices marked\n", i,nmarked);
    }
#if 0
    if (!nmarked)
    {
      break ;
    }
#endif
  }

  MRIScopyMarked3ToMarked(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISweightedSoapBubbleVertexPositions(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum, n ;
  float  x, y, z ;
  VERTEX *v, *vn ;
  int    nmarked ;
  double  norm, total_norm ;
#if 0
  double  xn, yn, zn, xc, yc, zc ;
  int     *vertices = NULL, nv ;
  FILE    *fp = NULL ;

  if (Gdiag_no >= 0)
  {
    MRIScopyMarkedToMarked3(mris) ; // save current marks
    MRISripMarked(mris) ;   // only part of surface to smooth is unmarked
    mris->vertices[Gdiag_no].marked = 1 ;
    MRISdilateMarked(mris, 1000) ;  // to ripped borders

    vertices = (int *)calloc(mris->nvertices, sizeof(int)) ;
    for (nv = vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag == 0)  // find ripped border and fit plane to it
      {
        continue ;
      }
      for (n = 0 ; n < v->vnum ; n++)
        if (mris->vertices[v->v[n]].marked == 1)
        {
          break ;
        }
      if (n < v->vnum)
      {
        vertices[nv++] = vno ;
      }
    }
    mrisComputeOptimalPlane(mris, vertices, nmarked, &xn, &yn, &zn, &xc, &yc, &zc);
    MRISunrip(mris) ;
    MRIScopyMarked3ToMarked(mris) ;
    fp = fopen("soap.dat", "w") ;
  }
#endif

  for (i = 0 ; i < navgs ; i++)
  {
    if (Gdiag_no >=0 && (mris->vertices[Gdiag_no].marked == 0))
    {
      v = &mris->vertices[Gdiag_no] ;
      printf("v %d @ (%2.1f, %2.1f, %2.1f) will be moved during soap bubble:\n", Gdiag_no,v->x,v->y,v->z) ;
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        printf("\tnbr %d=%d, marked = %d, (%2.1f, %2.1f, %2.1f)\n", n, v->v[n], vn->marked,
               vn->x, vn->y, vn->z) ;
      }
      DiagBreak() ;
    }
    for (nmarked = vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 1)
      {
        v->tdx = v->x ;
        v->tdy = v->y ;
        v->tdz = v->z ;
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      total_norm = 1.0 ;  // central vertex gets unit weight
      x = v->x ;
      y = v->y ;
      z = v->z ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (vnb = 0 ; vnb < vnum ; vnb++)
      {
        norm = 1.0 ;
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag) /* no valid data */
        {
          norm *= 20 ;
        }
        x += norm*vn->x ;
        y += norm*vn->y ;
        z += norm*vn->z ;
        total_norm += norm ;
      }
      if (total_norm>0)
      {
        v->tdx = x / total_norm ;
        v->tdy = y / total_norm ;
        v->tdz = z / total_norm ;
        if (!v->marked)
        {
          nmarked++ ;
        }
        v->marked = 3 ;  /* need modification */
      }
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 1)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        printf("iter %d: moving v %d from (%2.1f, %2.1f, %2.1f) --> (%2.1f, %2.1f, %2.1f)\n", i, vno, v->tdx, v->tdy, v->tdz, v->x, v->y, v->z) ;
      }
      if (v->marked)
      {
        v->x = v->tdx ;
        v->y = v->tdy ;
        v->z = v->tdz ;
      }
      if (v->marked == 3)  /* needs modification */
      {
        v->marked = 2 ;  /* modified, but not fixed */
      }
    }
    if (nmarked && (Gdiag & DIAG_SHOW) && DIAG_VERBOSE_ON)
    {
      printf("%d: %d vertices marked\n", i,nmarked);
    }
#if 0
    if (!nmarked)
    {
      break ;
    }
#endif
    if (DIAG_VERBOSE_ON)
      MRISprintVertexStats(mris, Gdiag_no, Gstdout, CURRENT_VERTICES) ;
  }
#if 0
  if (fp)
  {
    fclose(fp) ;
  }
  if (vertices)
  {
    free(vertices) ;
  }
#endif

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISsoapBubbleOrigVertexPositions(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  x, y, z, num ;
  VERTEX *v, *vn ;
  int    nmarked, num_none_marked = 0 ;

  /*
    v->marked:

    0 -  never processed
    1 -  fixed value
    2 -  has had value computed via previous soap bubble.
    3 -  has had value computed on this soap bubble, but not yet usable.
  */
  for (i = 0 ; i < navgs ; i++)
  {
    for (nmarked = vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 1)
      {
        continue ;
      }
      x = y = z = 0;
      num = 0;
      if (v->marked == 2)  /* computed on previous iteration, use value */
      {
        x = v->origx ;
        y = v->origy ;
        z = v->origz ;
        num++ ;   /* account for central vertex */
      }
      pnb = v->v ;
      vnum = v->vnum ;
      for (vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag ||
            !vn->marked ||
            vn->marked > 2) /* no valid data */
        {
          continue ;
        }
        num++ ;
        x += vn->origx ;
        y += vn->origy ;
        z += vn->origz ;
      }
      if (num>0)
      {
        v->tdx = x / num ;
        v->tdy = y / num ;
        v->tdz = z / num ;
        if (!v->marked)
        {
          nmarked++ ;
        }
        v->marked = 3 ;  /* need modification */
      }
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 1)
      {
        continue ;
      }
      if (v->marked)        /* update value */
      {
        v->origx = v->tdx ;
        v->origy = v->tdy ;
        v->origz = v->tdz ;
      }
      if (v->marked == 3)  /* needs modification */
      {
        v->marked = 2 ;  /* modified, but not fixed */
      }
    }
    if (Gdiag & DIAG_SHOW)
    {
      printf("%d: %d vertices marked\n", i,nmarked);
    }
    if (!nmarked && ++num_none_marked > 5)
    {
      break ;
    }
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->marked == 1)
    {
      continue ;
    }
    v->marked = 0 ;
  }
  return(NO_ERROR) ;
}
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISsoapBubbleVertexPositions(MRI_SURFACE *mris, int navgs, float pct_fixed)
{
  int    i, vno, vnb, *pnb, vnum, j ;
  float  x, y, z, num ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < navgs ; i++)
  {
    MRISclearMarks(mris) ;
    MRISmarkRandomVertices(mris, pct_fixed) ;
    for (j = 0 ; j < 10 ; j++)
    {
      for (vno = 0 ; vno < mris->nvertices ; vno++)
      {
        v = &mris->vertices[vno] ;
        if (v->ripflag || v->marked)
        {
          continue ;
        }
        x = v->x ;
        y = v->y ;
        z = v->z ;
        pnb = v->v ;
        vnum = v->vnum ;
        for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
        {
          vn = &mris->vertices[*pnb++] ;/*neighboring vertex pointer */
          if (vn->ripflag)
          {
            continue ;
          }
          num++ ;
          x += vn->x ;
          y += vn->y ;
          z += vn->z ;
        }
        num++ ;   /* account for central vertex */
        v->tdx = x / num ;
        v->tdy = y / num ;
        v->tdz = z / num ;
      }
      for (vno = 0 ; vno < mris->nvertices ; vno++)
      {
        v = &mris->vertices[vno] ;
        if (v->ripflag || v->marked)
        {
          continue ;
        }
        v->x = v->tdx ;
        v->y = v->tdy ;
        v->z = v->tdz ;
      }
    }
  }
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/

int
MRISmarkRandomVertices(MRI_SURFACE *mris, float prob_marked)
{
  int    vno ;
  VERTEX *v ;
  float  r ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    r = randomNumber(0.0, 1.0) ;
    if (r < prob_marked)
    {
      v->marked = 1 ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISclearMarks(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->marked = 0 ;
  }
  return(NO_ERROR) ;
}

int MRISclearFaceMarks(MRIS *mris)
{
  int    fno ;
  FACE *f ;

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    f->marked = 0 ;
  }
  return(NO_ERROR) ;
}



/*-----------------------------------------------------
  Parameters:

    Returns value:

    Description
    ------------------------------------------------------*/
int
MRISclearFixedValFlags(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->fixedval = FALSE ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyFixedValFlagsToMarks(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->marked = v->fixedval ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISclearAnnotations(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->annotation = 0 ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISsetMarks(MRI_SURFACE *mris, int mark)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->marked = mark ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISsequentialAverageVertexPositions(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  x, y, z, num ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked)
      {
        continue ;
      }
      x = v->x ;
      y = v->y ;
      z = v->z ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++] ; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        num++ ;
        x += vn->x ;
        y += vn->y ;
        z += vn->z ;
      }
      num++ ;   /* account for central vertex */
      v->x = x / num ;
      v->y = y / num ;
      v->z = z / num ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
#define WHALF                 (5-1)/2
static int
mrisComputeWhiteSurfaceValues(MRI_SURFACE *mris, MRI *mri_brain,
                              MRI *mri_wm, float nsigma)
{
  double    val, x, y, z ;
  int     total_vertices, vno, xv, yv, zv, xo, yo, zo, xi, yi, zi, nvox ;
  float   total, total_sq, sigma, mean_wm, mean_gray, mean ;
  VERTEX  *v ;

  /* first compute intensity of local gray/white boundary */
  mean_wm = mean_gray = 0.0f ;

  for (total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->d = 0.0f ;
    MRISvertexToVoxel(mris, v, mri_wm, &x, &y, &z) ;
    xv = nint(x) ;
    yv = nint(y) ;
    zv = nint(z) ;

    /* compute mean and variance of wm in a neighborhood of voxel */
    total = total_sq = 0.0f ;
    nvox = 0 ;
    for (zo = zv-WHALF ; zo <= zv + WHALF ; zo++)
    {
      zi = mri_wm->zi[zo] ;
      for (yo = yv-WHALF ; yo <= yv + WHALF ; yo++)
      {
        yi = mri_wm->yi[yo] ;
        for (xo = xv-WHALF ; xo <= xv + WHALF ; xo++)
        {
          xi = mri_wm->xi[xo] ;
          val = (double)MRIvox(mri_wm, xi, yi, zi) ;
          if (val > WM_MIN_VAL)
          {
#if 0
            if (MRIneighborsOff(mri_wm, xi, yi, zi, WM_MIN_VAL) == 0)
            {
              continue ;  /* not a border voxel */
            }
#endif
            val =
              (double)MRIvox(mri_brain, xi, yi, zi) ;
            /* use smoothed val */
            total += val ;
            total_sq += val * val ;
            nvox++ ;
          }
        }
      }
    }
    if (!nvox)
    {
      v->val = 0.0f ;
    }
    else
    {
      mean = total / (float)nvox ;
      sigma = sqrt(total_sq / (float)nvox - mean*mean) ;
      MRISvertexToVoxel(mris, v, mri_wm, &x, &y, &z) ;
      MRIsampleVolume(mri_brain, x, y, z, &val) ;
      v->val = mean - nsigma * sigma ;
      mean_gray += v->val ;
      mean_wm += mean ;
      total_vertices++ ;
    }

  }
  mean_wm /= (float)total_vertices ;
  mean_gray /= (float)total_vertices ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (FZERO(v->val))   /* no border voxels nearby */
    {
      v->val = mean_gray ;
    }
  }

#if 0
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = mean_gray ;
  }
#endif

  fprintf(stdout, "mean wm=%2.1f, gray=%2.1f, averaging targets and "
          "smoothing surface...", mean_wm, mean_gray) ;
  return(NO_ERROR) ;
}
#else
#if 1
#define MAX_CSF   55.0f
#define STEP_SIZE 0.1
int
MRIScomputeWhiteSurfaceValues(MRI_SURFACE *mris,MRI *mri_brain,MRI *mri_smooth)
{
  double    val, x, y, z, min_val, xw, yw, zw,mag,max_mag, xw1, yw1, zw1,
            previous_val, next_val ;
  int     total_vertices, vno, nmissing = 0 ;
  float   mean_white, dist, nx, ny, nz ;
  VERTEX  *v ;

  /* first compute intensity of local gray/white boundary */
  mean_white = 0.0f ;

  MRISclearMarks(mris) ;  /* for soap bubble smoothing later */
  for (total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    /*
    search outwards and inwards and find the local gradient maximum
    at a location with a reasonable MR intensity value. This will
    be the location of the edge.
    */

    /* search in the normal direction to find the min value */
    min_val = -10.0f ;
    mag = 5.0f ;
    max_mag = 0.0f ;
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
    x = v->x+nx ;
    y = v->y + ny ;
    z = v->z + nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw1, &yw1, &zw1) ;
    nx = xw1 - xw ;
    ny = yw1 - yw ;
    nz = zw1 - zw ;
    for (dist = -3.0f ; dist < 10.0f ; dist += STEP_SIZE)
    {
      x = v->x+v->nx*(dist-1) ;
      y = v->y + v->ny*(dist-1) ;
      z = v->z + v->nz*(dist-1) ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
      MRIsampleVolume(mri_brain, xw, yw, zw, &previous_val) ;
      if (previous_val < 120 && previous_val > 95)  /* in right range */
      {
        x = v->x + v->nx*dist ;
        y = v->y + v->ny*dist ;
        z = v->z + v->nz*dist ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;

        /* see if we are at a local maximum in the gradient magnitude */
        MRIsampleVolumeDerivative(mri_smooth, xw, yw, zw,
                                  nx, ny, nz, &mag) ;
        MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;

        /* if gradient is big and pointing towards wm */
        if ((previous_val > val) && (fabs(mag) > max_mag))
        {
          x = v->x + v->nx*(dist+1) ;
          y = v->y + v->ny*(dist+1) ;
          z = v->z + v->nz*(dist+1) ;
          // MRIworldToVoxel(mri_brain, x, y, z, &xw, &yw, &zw) ;
          MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
          MRIsampleVolume(mri_brain, xw, yw, zw, &next_val) ;
          if (next_val > 60 && next_val < 95)
          {
            max_mag = fabs(mag) ;
            min_val = val ;
          }
        }
      }
    }

    if (min_val > 0)
    {
      v->val = min_val ;
      v->mean = max_mag ;
      mean_white += min_val ;
      total_vertices++ ;
      v->marked = 1 ;
    }
    else
    {
      nmissing++ ;
    }
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d, target value = %2.1f, mag = %2.1f\n",
              Gdiag_no, v->val, v->mean) ;
  }
  mean_white /= (float)total_vertices ;
  MRISsoapBubbleVals(mris, 100) ;
  MRISclearMarks(mris) ;

  /*  MRISaverageVals(mris, 3) ;*/
  fprintf(stdout, "mean white matter surface=%2.1f, %d missing vertices\n",
          mean_white, nmissing) ;
  return(NO_ERROR) ;
}
#else
/*-----------------------------------------------------
Parameters:

Returns value:

Description
------------------------------------------------------*/
int
MRIScomputeWhiteSurfaceValues
(MRI_SURFACE *mris, MRI *mri_brain,
 MRI *mri_wm, float nsigma)
{
  double    val, x, y, z ;
  int     total_vertices, vno, xv, yv, zv, xo, yo,
          zo, xi, yi, zi, nwhite_vox, ngray_vox ;
  float   total_white, total_gray, total_sq_white, total_sq_gray, std_white,
          mean_white, mean_gray, total_mean_gray, total_mean_white, std_gray ;
  VERTEX  *v ;

  /* first compute intensity of local gray/white boundary */
  total_vertices = 0 ;
  total_mean_white = total_mean_gray = 0.0f ;
  total_sq_white = total_sq_gray = 0.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->d = 0.0f ;
    MRISvertexToVoxel(mris, v, mri_wm, &x, &y, &z) ;
    xv = nint(x) ;
    yv = nint(y) ;
    zv = nint(z) ;

    /* compute mean and variance of white in a neighborhood of voxel */
    total_white = 0.0f ;
    nwhite_vox = 0 ;
    total_gray = 0.0f ;
    ngray_vox = 0 ;
    for (zo = zv-WHALF ; zo <= zv + WHALF ; zo++)
    {
      zi = mri_wm->zi[zo] ;
      for (yo = yv-WHALF ; yo <= yv + WHALF ; yo++)
      {
        yi = mri_wm->yi[yo] ;
        for (xo = xv-WHALF ; xo <= xv + WHALF ; xo++)
        {
          xi = mri_wm->xi[xo] ;
          val = (double)MRIvox(mri_wm, xi, yi, zi) ;
          if (val > WM_MIN_VAL)  /* white matter */
          {
            if (MRIneighborsOff(mri_wm, xi, yi, zi, WM_MIN_VAL) == 0)
            {
              continue ;  /* not a border voxel */
            }
            val =
              (double)MRIvox(mri_brain, xi, yi, zi) ;  /* use smoothed
            val */
            total_white += val ;
            total_sq_white += val*val ;
            nwhite_vox++ ;
          }
          else    /* gray matter */
          {
            if (MRIneighborsOn
                (mri_wm, xi, yi, zi, WM_MIN_VAL+1) == 0)
            {
              continue ;  /* not a border voxel */
            }
            val = (double)MRIvox(mri_brain, xi, yi, zi) ;  /* use
            smoothed
            val */
            total_gray += val ;
            total_sq_gray += val*val ;
            ngray_vox++ ;
          }
        }
      }
    }
    if (!nwhite_vox || !ngray_vox)
    {
      v->val = 0.0f ;
    }
    else
    {
      mean_white = total_white / (float)nwhite_vox ;
      mean_gray = total_gray / (float)ngray_vox ;
      std_white =
        sqrt(total_sq_white/(float)nwhite_vox-mean_white*mean_white);
      std_gray =
        sqrt(total_sq_gray / (float)ngray_vox-mean_gray*mean_gray);
      std_white = 0.0f ;   /* only use white matter */
      if (mean_gray > mean_white)   /* shouldn't happen */
      {
        if (DIAG_VERBOSE_ON)
          fprintf
          (stdout,
           "mean gray (%2.1f) > mean white (%2.1f) at v %d!\n",
           mean_gray, mean_white, vno) ;
        v->val = mean_white ;
      }
      else
        v->val =
          (std_gray*mean_white+std_white*mean_gray)/(std_gray+std_white);
      total_vertices++ ;
      total_mean_white += mean_white ;
      total_mean_gray += mean_gray ;
    }
    v->mean = 20.0f ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d, target value = %2.1f, mag = %2.1f\n",
              Gdiag_no, v->val, v->mean) ;
  }
  total_mean_white /= (float)total_vertices ;
  total_mean_gray /= (float)total_vertices ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (FZERO(v->val))   /* no border voxels nearby */
    {
      v->val = (total_mean_gray+total_mean_white)/2 ;
    }
  }

#if 0
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = mean_gray ;
  }
#endif

  fprintf(stdout, "mean white=%2.1f, gray=%2.1f\n", total_mean_white,
          total_mean_gray) ;
  return(NO_ERROR) ;
}
#endif
#endif

#define MAX_SAMPLES 1000
int
MRIScomputeBorderValues(MRI_SURFACE *mris,MRI *mri_brain,
                        MRI *mri_smooth, double inside_hi, double border_hi,
                        double border_low, double outside_low, double outside_hi,
                        double sigma,
                        float max_thickness,
                        FILE *log_fp,
                        int which,
                        MRI *mri_mask,
                        double thresh)
{
  double    val, x, y, z, max_mag_val, xw, yw, zw,mag,max_mag, max_mag_dist=0.0f,
                                                               previous_val, next_val, min_val,inward_dist,outward_dist,xw1,yw1,zw1,
                                                               min_val_dist, orig_dist, dx, dy, dz, previous_mag, next_mag ;
  int  total_vertices, vno, nmissing = 0, nout = 0, nin = 0, nfound = 0,
                            nalways_missing = 0, local_max_found,
                            ngrad_max, ngrad, nmin, num_changed=0, i ;
  float   mean_border, mean_in, mean_out, dist, nx, ny, nz, mean_dist, step_size,
          dists[MAX_SAMPLES], mri[MAX_SAMPLES], dm[MAX_SAMPLES] ;
  double  current_sigma ;
  VERTEX  *v ;
  FILE    *fp = NULL ;
  MRI     *mri_tmp ;

  step_size = mri_brain->xsize/2 ;
  if (mri_brain->type == MRI_UCHAR)
  {
    mri_tmp = MRIreplaceValues(mri_brain, NULL, 255, 0) ;
  }
  else
  {
    mri_tmp = MRIcopy(mri_brain, NULL) ;
  }

  /* first compute intensity of local gray/white boundary */
  mean_dist = mean_in = mean_out = mean_border = 0.0f ;
  ngrad_max = ngrad = nmin = 0 ;
  MRISclearMarks(mris) ;  /* for soap bubble smoothing later */
  for (total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
    x = v->x + v->nx ;
    y = v->y + v->ny ;
    z = v->z + v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw1, &yw1, &zw1) ;
    nx = xw1 - xw ;
    ny = yw1 - yw ;
    nz = zw1 - zw ;
    dist = sqrt(SQR(nx)+SQR(ny)+SQR(nz)) ;
    if (FZERO(dist))
    {
      dist = 1 ;
    }
    nx /= dist ;
    ny /= dist ;
    nz /= dist ;

    /*
      find the distance in the directions parallel and anti-parallel to
      the surface normal in which the gradient is pointing 'inwards'.
      The border will then be constrained to be within that region.
    */
    inward_dist = 1.0 ;
    outward_dist = -1.0 ;
    for (current_sigma = sigma;
         current_sigma <= 10*sigma;
         current_sigma *= 2)
    {
      for (dist = 0 ; dist > -max_thickness ; dist -= step_size)
      {
        dx = v->x-v->origx ;
        dy = v->y-v->origy ;
        dz = v->z-v->origz ;
        orig_dist = fabs(dx*v->nx + dy*v->ny + dz*v->nz) ;
        if (fabs(dist)+orig_dist > max_thickness)
        {
          break ;
        }
        x = v->x + v->nx*dist ;
        y = v->y + v->ny*dist ;
        z = v->z + v->nz*dist ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
        MRIsampleVolumeDerivativeScale(mri_tmp, xw, yw, zw,
                                       nx, ny,nz,&mag,
                                       current_sigma);
        if (mag >= 0.0)
        {
          break ;
        }
        MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
        if (val > border_hi)
        {
          break ;
        }
        if (mri_mask)
        {
          MRIsampleVolume(mri_mask, xw, yw, zw, &val) ;
          if (val > thresh)
          {
            break ;
          }
        }
      }
      inward_dist = dist+step_size/2 ;

      if (DIAG_VERBOSE_ON && mri_brain->xsize < 1.95 && mag >= 0.0)  // refine inward_dist for hires volumes
      {
        for (dist = inward_dist ; dist > -max_thickness ; dist -= step_size/2)
        {
          x = v->x + v->nx*dist ;
          y = v->y + v->ny*dist ;
          z = v->z + v->nz*dist ;
          MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
          MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;

          x = v->x + v->nx*(dist+step_size/2) ;
          y = v->y + v->ny*(dist+step_size/2) ;
          z = v->z + v->nz*(dist+step_size/2) ;
          MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
          MRIsampleVolume(mri_brain, xw, yw, zw, &next_val) ;
          if (next_val < val)  // found max inwards intensity
          {
            break ;
          }
        }
        inward_dist = dist ;
      }

      for (dist = 0 ; dist < max_thickness ; dist += step_size)
      {
        dx = v->x-v->origx ;
        dy = v->y-v->origy ;
        dz = v->z-v->origz ;
        orig_dist = fabs(dx*v->nx + dy*v->ny + dz*v->nz) ;
        if (fabs(dist)+orig_dist > max_thickness)
        {
          break ;
        }
        x = v->x + v->nx*dist ;
        y = v->y + v->ny*dist ;
        z = v->z + v->nz*dist ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
        MRIsampleVolumeDerivativeScale
        (mri_tmp, xw, yw, zw, nx, ny,nz, &mag,
         current_sigma);
        if (mag >= 0.0)
        {
          break ;
        }
        MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
        if (val < border_low)
        {
          break ;
        }
        if (mri_mask)
        {
          MRIsampleVolume(mri_mask, xw, yw, zw, &val) ;
          if (val > thresh)
          {
            break ;
          }
        }
      }
      outward_dist = dist-step_size/2 ;
      if (!finite(outward_dist))
      {
        DiagBreak() ;
      }
      if (inward_dist <= 0 || outward_dist >= 0)
      {
        break ;
      }
    }

    if (inward_dist > 0 && outward_dist < 0)
    {
      current_sigma = sigma ;  /* couldn't find anything */
    }

    if (vno == Gdiag_no)
    {
      char fname[STRLEN] ;
      sprintf(fname, "v%d.%2.0f.log", Gdiag_no, sigma*100) ;
      fp = fopen(fname, "w") ;
      fprintf(stdout,
              "v %d: inward dist %2.2f, outward dist %2.2f, sigma %2.1f\n",
              vno, inward_dist, outward_dist, current_sigma) ;
    }

    v->val2 = current_sigma ;
    /*
      search outwards and inwards and find the local gradient maximum
      at a location with a reasonable MR intensity value. This will
      be the location of the edge.
    */

    /* search in the normal direction to find the min value */
    max_mag_val = -10.0f ;
    mag = 5.0f ;
    max_mag = 0.0f ;
    min_val = 10000.0 ;
    min_val_dist = 0.0f ;
    local_max_found = 0 ;
    for (i = 0, dist = inward_dist ; dist <= outward_dist ; dist += STEP_SIZE)
    {
      x = v->x + v->nx*dist ;
      y = v->y + v->ny*dist ;
      z = v->z + v->nz*dist ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
      MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
      dists[i] = dist;
      mri[i] = val ;
      i++ ;

#if 1
      x = v->x + v->nx*(dist-STEP_SIZE) ;
      y = v->y + v->ny*(dist-STEP_SIZE) ;
      z = v->z + v->nz*(dist-STEP_SIZE) ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
      MRIsampleVolume(mri_brain, xw, yw, zw, &previous_val) ;
#else
      /* find max val within 1 mm in inwards direction */
      {
        float  d ;
        double   tmp_val ;

        previous_val = 0 ;
        for (d = 0.25 ; d <= 1.5 ; d += 0.25)
        {
          x = v->x + v->nx*(d-1) ;
          y = v->y + v->ny*(d-1) ;
          z = v->z + v->nz*(d-1) ;
          MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
          MRIsampleVolume(mri_brain, xw, yw, zw, &tmp_val) ;
          if (tmp_val > previous_val)
          {
            previous_val = tmp_val ;
          }
        }
      }
#endif

      /* the previous point was inside the surface */
      if (previous_val < inside_hi && previous_val >= border_low)
      {
        /* see if we are at a local maximum in the gradient magnitude */
        x = v->x + v->nx*dist ;
        y = v->y + v->ny*dist ;
        z = v->z + v->nz*dist ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
        MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;

        x = v->x + v->nx*(dist+STEP_SIZE) ;
        y = v->y + v->ny*(dist+STEP_SIZE) ;
        z = v->z + v->nz*(dist+STEP_SIZE) ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
        MRIsampleVolumeDerivativeScale(mri_tmp, xw, yw, zw, nx, ny, nz,
                                       &next_mag, sigma);

        x = v->x + v->nx*(dist-STEP_SIZE) ;
        y = v->y + v->ny*(dist-STEP_SIZE) ;
        z = v->z + v->nz*(dist-STEP_SIZE) ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
        MRIsampleVolumeDerivativeScale(mri_tmp, xw, yw, zw, nx, ny, nz,
                                       &previous_mag, sigma);

        if (val < min_val)
        {
          min_val = val ;  /* used if no gradient max is found */
          min_val_dist = dist ;
        }

        /* if gradient is big and val is in right range */
        x = v->x + v->nx*dist;
        y = v->y + v->ny*dist;
        z = v->z + v->nz*dist;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
        MRIsampleVolumeDerivativeScale(mri_tmp, xw, yw, zw, nx, ny, nz,&mag,sigma);
        // only for hires volumes - if intensities are increasing don't keep going - in gm
        if (which == GRAY_WHITE && mri_brain->xsize < 1.95 &&
            val > previous_val && next_val > val)
        {
          break ;
        }
        if (which == GRAY_CSF)
        {
          /*
            sample the next val we would process.
            If it is too low, then we
            have definitely reached the border,
            and the current gradient
            should be considered a local max.

            Don't want to do this for gray/white,
            as the gray/white gradient
            often continues seemlessly into the gray/csf.
          */
          x = v->x + v->nx*(dist+STEP_SIZE) ;
          y = v->y + v->ny*(dist+STEP_SIZE) ;
          z = v->z + v->nz*(dist+STEP_SIZE) ;
          MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
          MRIsampleVolume(mri_brain, xw, yw, zw, &next_val) ;
          if (next_val < border_low)
          {
            next_mag = 0 ;
          }
        }

        if (vno == Gdiag_no)
          fprintf(fp, "%2.3f  %2.3f  %2.3f  %2.3f  %2.3f\n",
                  dist, val, mag, previous_mag, next_mag) ;

        /*
          if no local max has been found, or this one
          has a greater magnitude,
          and it is in the right intensity range....
        */
        if (
          /* (!local_max_found || (fabs(mag) > max_mag)) && */
          (fabs(mag) > fabs(previous_mag)) &&
          (fabs(mag) > fabs(next_mag)) &&
          (val <= border_hi) && (val >= border_low)
        )
        {
          x = v->x + v->nx*(dist+1) ;
          y = v->y + v->ny*(dist+1) ;
          z = v->z + v->nz*(dist+1) ;
          MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
          MRIsampleVolume(mri_brain, xw, yw, zw, &next_val) ;
          /*
            if next val is in the right range, and the intensity at
            this local max is less than the one at the previous local
            max, assume it is the correct one.
          */
          if ((next_val >= outside_low) &&
              (next_val <= border_hi) &&
              (next_val <= outside_hi) &&
#if 0
              (!local_max_found || (val < max_mag_val)))
#else
              (!local_max_found || (max_mag < fabs(mag))))
#endif
          {
            local_max_found = 1 ;
            max_mag_dist = dist ;
            max_mag = fabs(mag) ;
            max_mag_val = val ;
          }
        }
        else
        {
          /*
            if no local max found yet, just used largest gradient
            if the intensity is in the right range.
          */
          if ((local_max_found == 0) &&
              (fabs(mag) > max_mag) &&
              (val <= border_hi) &&
              (val >= border_low)
             )
          {
            x = v->x + v->nx*(dist+1) ;
            y = v->y + v->ny*(dist+1) ;
            z = v->z + v->nz*(dist+1) ;
            MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
            MRIsampleVolume(mri_brain, xw, yw, zw, &next_val) ;
            if (next_val >= outside_low && next_val <= border_hi &&
                next_val < outside_hi)
            {
              max_mag_dist = dist ;
              max_mag = fabs(mag) ;
              max_mag_val = val ;
            }
          }
        }

      }
    }

    if (vno == Gdiag_no)
    {
      fclose(fp) ;
    }
    if (mri_brain->xsize < 1.95)
    {
#ifdef WSIZE
#undef WSIZE
#endif
#define WSIZE 7
      int  len = i, i1, whalf = WSIZE, num ;
      float max_mri, peak = 0, outside = 1 ;

      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      {
        int n ;
        for (n = 0 ; n < v->vnum ; n++)
          if (v->v[n] == Gdiag_no)
          {
            DiagBreak() ;
          }
      }
      max_mri = 0 ;
      for (i = 0 ; i < len ; i++)
      {
        if (mri[i] > max_mri)
        {
          max_mri = mri[i] ;
        }
        if (i < len-1 && i > 0)
        {
          dm[i] = mri[i+1] - mri[i-1] ;
        }
        else
        {
          dm[i] = 0 ;
        }
      }

      if (max_mag_val > 0 && max_mri/(1.15) > max_mag_val)
      {
        for (i = 0 ; i < len ; i++)
        {
          if (dm[i] > 0)
          {
            continue ;
          }
          peak = dm[i] ;
          for (num = 0, outside = 0.0, i1 = MAX(0,i-whalf) ; i1 <= MIN(i+whalf,len-1) ; i1++)
          {
            outside += dm[i1] ;
            num++ ;
            if (dm[i1] < dm[i])
            {
              break ;  // not a local maxima in the negative direction
            }
          }
          outside /= num ;
          if (i1 > i+whalf)  // found a local maximum
          {
            break ;
          }
        }
        if (i < len-whalf && peak/outside > 1.5)   // it was a local max - set the target to here
        {
          if (vno == Gdiag_no)
            printf("v %d: resetting target to local max at %2.2f: I=%d, peak=%2.2f, outside=%2.2f, ratio=%2.2f\n",
                   vno, dists[i], (int)mri[i], peak, outside, peak/outside) ;
          max_mag_val = mri[i] ;
          max_mag = fabs(dm[i]) ;
          max_mag_dist = dists[i] ;
        }
      }
    }


    if (which == GRAY_CSF && local_max_found == 0 && max_mag_dist > 0)
    {
      float outlen ;
      int   allgray = 1 ;

      /* check to make sure it's not ringing near the gray white boundary,
         by seeing if there is uniform stuff outside that could be gray matter.
      */
      for (outlen = max_mag_dist ;
           outlen < max_mag_dist+2 ;
           outlen += STEP_SIZE)
      {
        x = v->x + v->nx*outlen ;
        y = v->y + v->ny*outlen ;
        z = v->z + v->nz*outlen ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
        MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
        if ((val < outside_hi /*border_low*/) || (val > border_hi))
        {
          allgray = 0 ;
          break ;
        }
      }
      if (allgray)
      {
        if (Gdiag_no == vno)
          printf("v %d: exterior gray matter detected, "
                 "ignoring large gradient at %2.3f (I=%2.1f)\n",
                 vno, max_mag_dist, max_mag_val) ;
        max_mag_val = -10 ;   /* don't worry about largest gradient */
        max_mag_dist = 0 ;
        num_changed++ ;
      }
    }

    if (max_mag_val > 0)   /* found the border value */
    {
      if (local_max_found)
      {
        ngrad_max++ ;
      }
      else
      {
        ngrad++ ;
      }
      if (max_mag_dist > 0)
      {
        nout++ ;
        nfound++ ;
        mean_out += max_mag_dist ;
      }
      else
      {
        nin++ ;
        nfound++ ;
        mean_in -= max_mag_dist ;
      }

      if (max_mag_val < border_low)
      {
        max_mag_val = border_low ;
      }
      mean_dist += max_mag_dist ;
      v->val = max_mag_val ;
      v->mean = max_mag ;
      mean_border += max_mag_val ;
      total_vertices++ ;
      v->d = max_mag_dist ;
      v->marked = 1 ;
    }
    else         /* couldn't find the border value */
    {
      if (min_val < 1000)
      {
        nmin++ ;
        v->d = min_val_dist ;
#if 0
        if (min_val > border_hi)  /* found a low value, but not low enough */
        {
          min_val = border_hi ;
        }
        else if (min_val < border_low)
        {
          min_val = border_low ;
        }
#else
        if (min_val < border_low)
        {
          min_val = border_low ;
        }
#endif
        v->val = min_val ;
        mean_border += min_val ;
        total_vertices++ ;
        v->marked = 1 ;
      }
      else
      {
        /* don't overwrite old target intensity if it was there */
        /*        v->val = -1.0f ;*/
        v->d = 0 ;
        if (v->val < 0)
        {
          nalways_missing++ ;
#if 0
          v->val = (border_low+border_hi)/2 ;
#endif
          v->marked = 0 ;
        }
        else
        {
          v->marked = 1 ;
        }
        nmissing++ ;
      }
    }
    if (vno == Gdiag_no)
      fprintf(stdout,
              "v %d, target value = %2.1f, mag = %2.1f, dist = %2.2f, %s\n",
              Gdiag_no, v->val, v->mean, v->d,
              local_max_found ? "local max" : max_mag_val > 0 ? "grad":"min");
#if 0
    if (vno == 44289 || vno == 91080 || vno == 92286 || vno == 46922)
      fprintf(stdout, "v %d, target value = %2.1f, mag = %2.1f, dist=%2.2f\n",
              Gdiag_no, v->val, v->mean, v->d) ;
#endif
  }
  mean_dist /= (float)(total_vertices-nmissing) ;
  mean_border /= (float)total_vertices ;
#if 0
  mean_in /= (float)total_vertices ;
  mean_out /= (float)total_vertices ;
#else
  if (nin > 0)
  {
    mean_in /= (float)nin ;
  }
  if (nout > 0)
  {
    mean_out /= (float)nout ;
  }
#endif

#if 0
  MRISsoapBubbleVals(mris, 100) ;
#endif

  /*  MRISaverageVals(mris, 3) ;*/
  fprintf(stdout,
          "mean border=%2.1f, %d (%d) missing vertices, mean dist %2.1f "
          "[%2.1f (%%%2.1f)->%2.1f (%%%2.1f))]\n",
          mean_border, nmissing, nalways_missing, mean_dist,
          mean_in, 100.0f*(float)nin/(float)nfound,
          mean_out, 100.0f*(float)nout/(float)nfound) ;
  fprintf(stdout, "%%%2.0f local maxima, %%%2.0f large gradients "
          "and %%%2.0f min vals, %d gradients ignored\n",
          100.0f*(float)ngrad_max/(float)mris->nvertices,
          100.0f*(float)ngrad/(float)mris->nvertices,
          100.0f*(float)nmin/(float)mris->nvertices, num_changed) ;
  if (log_fp)
  {
    fprintf(log_fp,
            "mean border=%2.1f, %d (%d) missing vertices, mean dist %2.1f "
            "[%2.1f (%%%2.1f)->%2.1f (%%%2.1f))]\n",
            mean_border, nmissing, nalways_missing, mean_dist,
            mean_in, 100.0f*(float)nin/(float)nfound,
            mean_out, 100.0f*(float)nout/(float)nfound) ;
    fprintf(log_fp, "%%%2.0f local maxima, %%%2.0f large gradients "
            "and %%%2.0f min vals, %d gradients ignored\n",
            100.0f*(float)ngrad_max/(float)mris->nvertices,
            100.0f*(float)ngrad/(float)mris->nvertices,
            100.0f*(float)nmin/(float)mris->nvertices, num_changed) ;
  }
  return(NO_ERROR) ;
}
#if 1
int
MRIScomputeInvertedGrayWhiteBorderValues
(MRI_SURFACE *mris,MRI *mri_brain,
 MRI *mri_smooth, double inside_hi, double border_hi,
 double border_low, double outside_low, double outside_hi,
 double sigma,
 float max_thickness, FILE *log_fp)
{
  double    val, x, y, z, xw, yw, zw, dist, prev_val, next_val ;
  int     total_vertices, vno, inward_increasing, ngray, nwhite ;
  VERTEX  *v ;
  double    mean_white, mean_gray, std_white, std_gray, nsigma, gw_thresh  ;

  std_white = std_gray = mean_white = mean_gray = 0.0 ;
  for (ngray = nwhite = total_vertices = vno = 0 ;
       vno < mris->nvertices ;
       vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    total_vertices++ ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    /* search for local maximum */
    for (dist = 0 ; dist < 10 ; dist += SAMPLE_DIST)
    {
      x = v->x-dist*v->nx ;
      y = v->y-dist*v->ny ;
      z = v->z-dist*v->nz ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
      MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
      if (MRIindexNotInVolume(mri_brain, xw, yw, zw) == 0)
      {
        x = v->x-(dist+SAMPLE_DIST)*v->nx ;
        y = v->y-(dist+SAMPLE_DIST)*v->ny ;
        z = v->z-(dist+SAMPLE_DIST)*v->nz ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
        MRIsampleVolume(mri_brain, xw, yw, zw, &next_val) ;

        x = v->x-(dist-SAMPLE_DIST)*v->nx ;
        y = v->y-(dist-SAMPLE_DIST)*v->ny ;
        z = v->z-(dist-SAMPLE_DIST)*v->nz ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
        MRIsampleVolume(mri_brain, xw, yw, zw, &prev_val) ;
        if (val > next_val && val > prev_val)
        {
          if (vno == Gdiag_no)
          {
            printf("white val found at %2.1f\n", val) ;
          }
          nwhite++ ;
          mean_white += val ;
          std_white += (val*val) ;
          break ;
        }
      }
    }
    x = v->x+1.0*v->nx ;
    y = v->y+1.0*v->ny ;
    z = v->z+1.0*v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
    MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
    if (MRIindexNotInVolume(mri_brain, xw, yw, zw) == 0)
    {
      mean_gray += val ;
      std_gray += (val*val) ;
      ngray++ ;
    }
  }

  mean_white /= (float)nwhite ;
  std_white = sqrt(std_white / (float)nwhite - mean_white*mean_white) ;
  mean_gray /= (float)ngray ;
  std_gray = sqrt(std_gray / (float)ngray - mean_gray*mean_gray) ;
  nsigma = (mean_gray-mean_white) / (std_gray+std_white) ;
  gw_thresh = mean_white + nsigma*std_white ;
  printf
  ("white %2.1f +- %2.1f,    gray %2.1f +- %2.1f, G/W boundary at %2.1f\n",
   mean_white, std_white, mean_gray, std_gray, gw_thresh) ;

  inward_increasing = mean_gray < mean_white ;
  for (total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v->val = gw_thresh ;
  }

  return(NO_ERROR) ;
}
int
MRIScomputeMaxGradBorderValues(MRI_SURFACE *mris,MRI *mri_brain,
                               MRI *mri_smooth, double sigma,
                               float max_thickness, float dir, FILE *log_fp,
                               MRI *mri_wm, int callno)
{
  int     total_vertices, vno, n, num, found ;
  VERTEX  *v, *vn ;
  double    x, y, z, xv, yv, zv, dist, grad, max_grad, max_grad_dist, sigma_vox,
            nx, ny, nz, sample_dist, mag,max_grad_val, min_val, val, wm_mean, wm_std, wm_hi, wm_lo ;
  MRI     *mri_median ;
  MRI_REGION box ;

  box.x = nint(5/mri_brain->xsize) ;
  box.y = nint(5/mri_brain->ysize) ;
  box.z = nint(5/mri_brain->zsize) ;
  box.dx = mri_brain->width - 2*nint(5/mri_brain->xsize) ;
  box.dy = mri_brain->height - 2*nint(5/mri_brain->ysize) ;
  box.dz = mri_brain->depth - 2*nint(5/mri_brain->zsize) ;

  if (0)
  {
    //mri_median = MRImedian(mri_brain, NULL, 3, &box) ;
    //MRIwrite(mri_median, "median.mgz") ;
  }
  else
  {
    mri_median = mri_brain ;
  }

  sample_dist = .5*mri_brain->xsize ;

  // first compute white matter statistics over space

  sigma_vox = sigma / mri_brain->xsize ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    // compute surface normal in voxel coords
    MRISsurfaceRASToVoxelCached(mris, mri_brain, v->x, v->y, v->z, &xv, &yv, &zv) ;
    x = v->x+v->nx ;
    y = v->y+v->ny ;
    z = v->z+v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &nx, &ny, &nz) ;
    nx -= xv ;
    ny -= yv ;
    nz -= zv ;
    mag = sqrt(nx*nx + ny*ny + nz*nz) ;
    if (FZERO(mag))
    {
      continue ;
    }
    nx /= mag ;
    ny /= mag ;
    nz /= mag ;

    // search inwards for min value to estimate wm value
    min_val = 1e10 ;
    for (dist = 0 ; dist <= 2 ; dist += sample_dist)
    {
      x = v->x-dist*v->nx ;
      y = v->y-dist*v->ny ;
      z = v->z-dist*v->nz ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xv, &yv, &zv) ;
      if (MRIindexNotInVolume(mri_brain, xv, yv, zv) == 0)
      {
        MRIsampleVolume(mri_median, xv, yv, zv, &val) ;
        if (val < min_val)
        {
          int   xi = nint(xv), yi = nint(yv), zi = nint(zv), wsize ;
          float min_wm_val, mean_wm_val, std_wm_val ;
          if (mri_wm)
          {
            wsize = nint(3.0/mri_wm->xsize) ;
            wsize = (wsize/2)*2 + 1 ;
            min_wm_val = MRIvoxelMin(mri_wm, xi, yi, zi, wsize) ;
            mean_wm_val = MRIvoxelMean(mri_wm, xi, yi, zi, wsize, 0) ;
            std_wm_val = MRIvoxelStd(mri_wm, xi, yi, zi, mean_wm_val,wsize) ;

            if (min_val > min_wm_val)
            {
              min_val = val ;
            }
            else
            {
              DiagBreak() ;
            }
          }
          else
          {
            min_val = val ;
          }
        }
      }
    }
    v->val = min_val ;
  }

  // let user do smoothing  MRISaverageVals(mris, 10) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    wm_mean = v->val ;
    wm_std = v->val*v->val ;
    v->valbak = v->val2bak = v->val ;  // min and max
    for (num = 1, n = 0 ; n < v->vtotal ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      if (vn->val < v->valbak)
      {
        v->valbak = vn->val ;
      }
      if (vn->val > v->val2bak)
      {
        v->val2bak = vn->val ;
      }
      wm_mean += vn->val ;
      wm_std += vn->val*vn->val ;
      num++ ;
    }
    wm_mean /= num ;
    wm_std = sqrt(wm_std/num - wm_mean*wm_mean) ;
    v->val2 = v->val = wm_mean ;
    v->imag_val = wm_std ;
  }
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    MRISwriteValues(mris, "wm.mgz") ;
  }

  for (total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    total_vertices++ ;

    // compute surface normal in voxel coords
    MRISsurfaceRASToVoxelCached(mris, mri_brain, v->x, v->y, v->z, &xv, &yv, &zv) ;
    x = v->x+v->nx ;
    y = v->y+v->ny ;
    z = v->z+v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &nx, &ny, &nz) ;
    nx -= xv ;
    ny -= yv ;
    nz -= zv ;
    mag = sqrt(nx*nx + ny*ny + nz*nz) ;
    if (FZERO(mag))
    {
      continue ;
    }
    nx /= mag ;
    ny /= mag ;
    nz /= mag ;

    // +- 2 standard deviations around the local mean
    // don't let std get too small
    wm_mean = v->val2 ;
    wm_std =  v->imag_val ;
    wm_std = MAX(wm_std, wm_mean*.1) ;  // don't let std be too low
    if (dir > 0)  // allow outside to be brighter to allow for partial volume
    {
      wm_hi = wm_mean + 10*wm_std ;
      wm_lo = wm_mean - 2*wm_std ;
    }
    else
    {
      wm_hi = wm_mean + 2*wm_std ;
      wm_lo = wm_mean - 7*wm_std ;
    }
    max_grad = 0 ;
    max_grad_dist = 0 ;
    found = 0 ;
    /* search outwards for local maximum */
    for (dist = 0 ; dist <= max_thickness ; dist += sample_dist)
    {
      x = v->x+dist*v->nx ;
      y = v->y+dist*v->ny ;
      z = v->z+dist*v->nz ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xv, &yv, &zv) ;
      if (MRIindexNotInVolume(mri_brain, xv, yv, zv) == 0)
      {
        MRIsampleVolume(mri_brain, xv, yv, zv, &val) ;
        if (val < wm_lo || val > wm_hi)
        {
          break ;
        }
        MRIsampleVolumeDerivativeScale(mri_brain, xv, yv, zv, nx, ny, nz, &grad, sigma_vox) ;
        if (grad*dir < 0)  // out of viable region
        {
          if (callno > 0 || dist > max_thickness/2)
          {
            break ;
          }
        }
        if (dir*grad > dir*max_grad)  // in the right direction
        {
          max_grad = grad ;
          max_grad_dist = dist ;
          MRIsampleVolume(mri_brain, xv, yv, zv, &max_grad_val) ;
          found = 1 ;
        }
      }
    }
    /* search inwards for local maximum */
    for (dist = 0 ; dist >= -max_thickness ; dist -= sample_dist)
    {
      x = v->x+dist*v->nx ;
      y = v->y+dist*v->ny ;
      z = v->z+dist*v->nz ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xv, &yv, &zv) ;
      if (MRIindexNotInVolume(mri_brain, xv, yv, zv) == 0)
      {
        MRIsampleVolume(mri_brain, xv, yv, zv, &val) ;
        if (val < wm_lo || val > wm_hi)
        {
          continue ;  // allow search to continue as we haven't reached valid region yet
        }
        MRIsampleVolumeDerivativeScale(mri_brain, xv, yv, zv, nx, ny, nz, &grad, sigma_vox) ;
        if (grad*dir < 0)  // out of viable region
        {
          break ;
        }
        if (fabs(grad) > fabs(max_grad))  // in the right direction
        {
          max_grad = grad ;
          max_grad_dist = dist ;
          MRIsampleVolume(mri_brain, xv, yv, zv, &max_grad_val) ;
          found = 1 ;
        }
      }
    }

    if (found)
    {
      if (vno == Gdiag_no)
        printf("max grad %2.3f found at distance %2.2f, val = %2.0f in [%2.0f %2.0f]\n",
               max_grad, max_grad_dist, max_grad_val, wm_lo, wm_hi) ;
      v->val = max_grad_val ;
      v->marked = 1 ;
    }
    else
    {
      v->marked = 0 ;
      if (vno == Gdiag_no)
      {
        printf("v %d: could not find valid gradient maximum\n", vno) ;
      }
    }
  }
  for (total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    v->val2 = sigma ;
  }

  MRISsoapBubbleVals(mris, 100) ;
  if (mri_median != mri_brain)
  {
    MRIfree(&mri_median) ;
  }
  return(NO_ERROR) ;
}
int
MRIScomputeMaxGradBorderValuesPial(MRI_SURFACE *mris,MRI *mri_brain,
                                   MRI *mri_smooth, double sigma,
                                   float max_thickness, float dir, FILE *log_fp,
                                   int callno, MRI *mri_mask)
{
  int     total_vertices, vno, n, num, found ;
  VERTEX  *v, *vn ;
  double    x, y, z, xv, yv, zv, dist, grad, max_grad, max_grad_dist, sigma_vox, xm, ym, zm,
            nx, ny, nz, sample_dist, mag,max_grad_val, min_val, val, wm_mean, wm_std, wm_hi, wm_lo ;
  MRI     *mri_median, *mri_targets ;
  MRI_REGION box ;
  MATRIX  *m_vox2vox ;
  VECTOR  *v1, *v2 ;
  float   mval ;

  mri_targets = MRIclone(mri_brain, NULL) ;

  m_vox2vox = MRIgetVoxelToVoxelXform(mri_brain, mri_mask) ;
  v1 = VectorAlloc(4, MATRIX_REAL) ;
  v2 = VectorAlloc(4, MATRIX_REAL) ;
  VECTOR_ELT(v1, 4) = 1.0 ;
  VECTOR_ELT(v2, 4) = 1.0 ;

  box.x = nint(5/mri_brain->xsize) ;
  box.y = nint(5/mri_brain->ysize) ;
  box.z = nint(5/mri_brain->zsize) ;
  box.dx = mri_brain->width - 2*nint(5/mri_brain->xsize) ;
  box.dy = mri_brain->height - 2*nint(5/mri_brain->ysize) ;
  box.dz = mri_brain->depth - 2*nint(5/mri_brain->zsize) ;

  if (0)
  {
    //mri_median = MRImedian(mri_brain, NULL, 3, &box) ;
    //MRIwrite(mri_median, "median.mgz") ;
  }
  else
  {
    mri_median = mri_brain ;
  }

  sample_dist = .5*mri_brain->xsize ;

  // first compute white matter statistics over space

  sigma_vox = sigma / mri_brain->xsize ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    v->marked = 0 ;  // vertex is no good until marked is changed to 1
    // compute surface normal in voxel coords
    MRISsurfaceRASToVoxelCached(mris, mri_brain, v->x, v->y, v->z, &xv, &yv, &zv) ;
    x = v->x+v->nx ;
    y = v->y+v->ny ;
    z = v->z+v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &nx, &ny, &nz) ;
    nx -= xv ;
    ny -= yv ;
    nz -= zv ;
    mag = sqrt(nx*nx + ny*ny + nz*nz) ;
    if (FZERO(mag))
    {
      continue ;
    }
    nx /= mag ;
    ny /= mag ;
    nz /= mag ;

    /* search inwards for min value */
    min_val = 1e10 ;
    for (dist = 0 ; dist <= 3 ; dist += sample_dist)
    {
      x = v->x+dist*v->nx ;
      y = v->y+dist*v->ny ;
      z = v->z+dist*v->nz ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xv, &yv, &zv) ;
      V3_X(v1) = xv ;
      V3_Y(v1) = yv ;
      V3_Z(v1) = zv ;
      MatrixMultiply(m_vox2vox, v1, v2) ;
      xm = V3_X(v2) ;
      ym = V3_Y(v2) ;
      zm = V3_Z(v2) ;
      mval = MRIgetVoxVal(mri_mask, xm, ym, zm, 0) ;
      if (!FZERO(mval))
      {
        continue ;  // not in interior
      }
      if (MRIindexNotInVolume(mri_brain, xv, yv, zv) == 0)
      {
        MRIsampleVolume(mri_median, xv, yv, zv, &val) ;
        if (val < min_val)
        {
          v->marked = 1 ;
          min_val = val ;
        }
      }
    }
    if (v->marked == 0)
    {
      DiagBreak() ;
      if (vno == Gdiag_no)
      {
        printf("v %d: could not find any interior voxels\n", vno) ;
      }
    }
    v->val = min_val ;
  }

  // let user do smoothing  MRISaverageVals(mris, 10) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag || v->marked == 0)
    {
      continue ;
    }
    wm_mean = v->val ;
    wm_std = v->val*v->val ;
    v->valbak = v->val2bak = v->val ;  // min and max
    for (num = 1, n = 0 ; n < v->vtotal ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->ripflag || vn->marked == 0)
      {
        continue ;
      }
      if (vn->val < v->valbak)
      {
        v->valbak = vn->val ;
      }
      if (vn->val > v->val2bak)
      {
        v->val2bak = vn->val ;
      }
      wm_mean += vn->val ;
      wm_std += vn->val*vn->val ;
      num++ ;
    }
    wm_mean /= num ;
    wm_std = sqrt(wm_std/num - wm_mean*wm_mean) ;
    v->val2 = v->val = wm_mean ;
    v->imag_val = wm_std ;
  }
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    MRISwriteValues(mris, "wm.mgz") ;
  }

  for (total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag || v->marked == 0)
    {
      continue ;
    }
    total_vertices++ ;

    // compute surface normal in voxel coords
    MRISsurfaceRASToVoxelCached(mris, mri_brain, v->x, v->y, v->z, &xv, &yv, &zv) ;
    x = v->x+v->nx ;
    y = v->y+v->ny ;
    z = v->z+v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &nx, &ny, &nz) ;
    nx -= xv ;
    ny -= yv ;
    nz -= zv ;
    mag = sqrt(nx*nx + ny*ny + nz*nz) ;
    if (FZERO(mag))
    {
      continue ;
    }
    nx /= mag ;
    ny /= mag ;
    nz /= mag ;

    // +- 2 standard deviations around the local mean
    // don't let std get too small
    wm_mean = v->val2 ;
    wm_std =  v->imag_val ;
    wm_std = MAX(wm_std, wm_mean*.1) ;  // don't let std be too low
    if (dir > 0)  // allow outside to be brighter to allow for partial volume
    {
      wm_hi = wm_mean + 10*wm_std ;
      wm_lo = wm_mean - 2*wm_std ;
    }
    else
    {
      wm_hi = wm_mean + 2*wm_std ;
      wm_lo = wm_mean - 7*wm_std ;
    }
    min_val = 2*wm_hi ;
    found = 0 ;
    /* search outwards for local maximum */
    max_grad = max_grad_val = max_grad_dist = 0 ;
    for (dist = 0 ; dist <= max_thickness ; dist += sample_dist)
    {
      x = v->x+dist*v->nx ;
      y = v->y+dist*v->ny ;
      z = v->z+dist*v->nz ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xv, &yv, &zv) ;
      V3_X(v1) = xv ;
      V3_Y(v1) = yv ;
      V3_Z(v1) = zv ;
      MatrixMultiply(m_vox2vox, v1, v2) ;
      xm = V3_X(v2) ;
      ym = V3_Y(v2) ;
      zm = V3_Z(v2) ;
      mval = MRIgetVoxVal(mri_mask, xm, ym, zm, 0) ;
      if (FZERO(mval))
      {
        continue ;  // not in possible region
      }
      if (MRIindexNotInVolume(mri_brain, xv, yv, zv) == 0)
      {
        MRIsampleVolume(mri_brain, xv, yv, zv, &val) ;
#if 0
        if (val < wm_lo || val > wm_hi)
        {
          break ;
        }
#endif
        MRIsampleVolumeDerivativeScale(mri_brain, xv, yv, zv, nx, ny, nz, &grad, sigma_vox) ;
        if (grad*dir < 0)  // out of viable region
        {
          if (callno > 0 || dist > max_thickness/2)
          {
            break ;
          }
        }
        else if ((dir*grad > 0) && val < min_val)
        {
          min_val = val ;
          found = 1 ;
          max_grad_dist = dist ;
          max_grad_val = val ;
        }

        if (dir*grad > dir*max_grad)  // in the right direction
        {
          max_grad = grad ;
#if 0
          max_grad_dist = dist ;
          max_grad_val = val ;
          found = 1 ;
#endif
        }
      }
    }
    /* search inwards for local maximum */
    for (dist = 0 ; dist >= -max_thickness ; dist -= sample_dist)
    {
      x = v->x+dist*v->nx ;
      y = v->y+dist*v->ny ;
      z = v->z+dist*v->nz ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xv, &yv, &zv) ;
      V3_X(v1) = xv ;
      V3_Y(v1) = yv ;
      V3_Z(v1) = zv ;
      MatrixMultiply(m_vox2vox, v1, v2) ;
      xm = V3_X(v2) ;
      ym = V3_Y(v2) ;
      zm = V3_Z(v2) ;
      mval = MRIgetVoxVal(mri_mask, xm, ym, zm, 0) ;
      if (FZERO(mval))
      {
        continue ;  // not in possible region
      }
      if (MRIindexNotInVolume(mri_brain, xv, yv, zv) == 0)
      {
        MRIsampleVolume(mri_brain, xv, yv, zv, &val) ;
#if 0
        if (val < wm_lo || val > wm_hi)
        {
          continue ;  // allow search to continue as we haven't reached valid region yet
        }
#endif
        MRIsampleVolumeDerivativeScale(mri_brain, xv, yv, zv, nx, ny, nz, &grad, sigma_vox) ;
        if (grad*dir < 0)  // out of viable region
        {
          break ;
        }
        if ((dir*grad > 0) && val < min_val)
        {
          min_val = val ;
          found = 1 ;
          max_grad_dist = dist ;
          max_grad_val = val ;
        }

        if (fabs(grad) > fabs(max_grad))  // in the right direction
        {
          max_grad = grad ;
#if 0
          max_grad_dist = dist ;
          MRIsampleVolume(mri_brain, xv, yv, zv, &max_grad_val) ;
          found = 1 ;
#endif
        }
      }
    }

    if (found)
    {
      if (vno == Gdiag_no)
        printf("max grad %2.3f found at distance %2.2f, val = %2.0f in [%2.0f %2.0f]\n",
               max_grad, max_grad_dist, max_grad_val, wm_lo, wm_hi) ;
      v->val = max_grad_val ;
      v->tx = v->x+max_grad_dist*v->nx ;
      v->ty = v->y+max_grad_dist*v->ny ;
      v->tz = v->z+max_grad_dist*v->nz ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, v->tx, v->ty, v->tz, &xv, &yv, &zv) ;
      if (MRIindexNotInVolume(mri_targets, xv, yv, zv) == 0)
      {
        MRIsetVoxVal(mri_targets, xv, yv, zv, 0, 1.0) ;
      }
      else
      {
        DiagBreak() ;
      }
      v->marked = 1 ;
    }
    else
    {
      v->marked = 0 ;
      if (vno == Gdiag_no)
      {
        printf("v %d: could not find valid gradient maximum\n", vno) ;
      }
    }
  }
  for (total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    v->val2 = sigma ;
  }

  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    MRIwrite(mri_targets, "targets.mgz") ;
  }
  MRISsoapBubbleVals(mris, 100) ;
  if (mri_median != mri_brain)
  {
    MRIfree(&mri_median) ;
  }
  MatrixFree(&m_vox2vox) ;
  VectorFree(&v1) ;
  VectorFree(&v2) ;
  return(NO_ERROR) ;
}
#else
int
MRIScomputeInvertedGrayWhiteBorderValues
(MRI_SURFACE *mris,MRI *mri_brain,
 MRI *mri_smooth, double inside_hi, double border_hi,
 double border_low, double outside_low, double outside_hi,
 double sigma,
 float max_thickness, FILE *log_fp)
{
  double    val, x, y, z, xw, yw, zw ;
  int     total_vertices, vno, inward_increasing, ngray, nwhite ;
  VERTEX  *v ;
  double    mean_white, mean_gray, std_white, std_gray, nsigma, gw_thresh  ;

  std_white = std_gray = mean_white = mean_gray = 0.0 ;
  for (ngray = nwhite = total_vertices = vno = 0 ;
       vno < mris->nvertices ;
       vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    total_vertices++ ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x+1.0*v->nx ;
    y = v->y+1.0*v->ny ;
    z = v->z+1.0*v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw);
    MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
    if (MRIindexNotInVolume(mri_brain, xw, yw, zw) == 0)
    {
      mean_gray += val ;
      std_gray += (val*val) ;
      ngray++ ;
    }

    x = v->x-0.5*v->nx ;
    y = v->y-0.5*v->ny ;
    z = v->z-0.5*v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw);
    MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
    if (MRIindexNotInVolume(mri_brain, xw, yw, zw) == 0)
    {
      mean_white += val ;
      std_white += (val*val) ;
      nwhite++ ;
    }
  }

  mean_white /= (float)nwhite ;
  std_white = sqrt(std_white / (float)nwhite - mean_white*mean_white) ;
  mean_gray /= (float)ngray ;
  std_gray = sqrt(std_gray / (float)ngray - mean_gray*mean_gray) ;
  nsigma = (mean_gray-mean_white) / (std_gray+std_white) ;
  gw_thresh = mean_white + nsigma*std_white ;
  printf("white %2.1f +- %2.1f,    gray %2.1f +- %2.1f, "
         "G/W boundary at %2.1f\n",
         mean_white, std_white, mean_gray, std_gray, gw_thresh) ;

  inward_increasing = mean_gray < mean_white ;
  for (total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v->val = gw_thresh ;
  }

  return(NO_ERROR) ;
}
#endif
#define MAX_SAMPLES 1000
int
MRIScomputeInvertedPialBorderValues
(MRI_SURFACE *mris,MRI *mri_brain,
 MRI *mri_smooth, double inside_hi, double border_hi,
 double border_low, double outside_low, double outside_hi,
 double sigma,
 float max_thickness, FILE *log_fp)
{
  double val, x, y, z, xw, yw, zw, dist, prev_val, next_val ;
  int total_vertices, vno, inward_increasing, ngray, ncsf ;
  VERTEX  *v ;
  double mean_csf, mean_gray, std_csf, std_gray, nsigma, gw_thresh, csf_dist  ;

  std_gray = mean_gray = 0.0 ;
  for (ngray = total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    total_vertices++ ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    /* first find distance to inflection point */
    csf_dist = -1 ;
    for (dist = 0 ; dist < 10 ; dist += SAMPLE_DIST)
    {
      x = v->x+dist*v->nx ;
      y = v->y+dist*v->ny ;
      z = v->z+dist*v->nz ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw);
      MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
      if (MRIindexNotInVolume(mri_brain, xw, yw, zw) == 0)
      {
        x = v->x+(dist+SAMPLE_DIST)*v->nx ;
        y = v->y+(dist+SAMPLE_DIST)*v->ny ;
        z = v->z+(dist+SAMPLE_DIST)*v->nz ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw);
        MRIsampleVolume(mri_brain, xw, yw, zw, &next_val) ;

        x = v->x+(dist-SAMPLE_DIST)*v->nx ;
        y = v->y+(dist-SAMPLE_DIST)*v->ny ;
        z = v->z+(dist-SAMPLE_DIST)*v->nz ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw);
        MRIsampleVolume(mri_brain, xw, yw, zw, &prev_val) ;
        if (val < next_val && val < prev_val)
        {
          if (vno == Gdiag_no)
          {
            printf("csf val found at %2.1f\n", val) ;
          }
          csf_dist = dist ;
          break ;
        }
      }
    }
    if (csf_dist < 0)
    {
      continue ;
    }


    // compute gray values as 1 mm outside g/w surface.
    // Won't be right everywhere...
    dist = csf_dist/2 ;
    x = v->x+dist*v->nx ;
    y = v->y+dist*v->ny ;
    z = v->z+dist*v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw);
    MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
    if (MRIindexNotInVolume(mri_brain, xw, yw, zw) == 0)
    {
      mean_gray += val ;
      std_gray += (val*val) ;
      ngray++ ;
    }
  }

  mean_gray /= (float)ngray ;
  std_gray = sqrt(std_gray / (float)ngray - mean_gray*mean_gray) ;

  std_csf = mean_csf = 0.0 ;
  for (ncsf = total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    total_vertices++ ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    /* search for local maximum */
    for (dist = 0 ; dist < 10 ; dist += SAMPLE_DIST)
    {
      x = v->x+dist*v->nx ;
      y = v->y+dist*v->ny ;
      z = v->z+dist*v->nz ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw);
      MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
      if (val >= mean_gray-0.5*std_gray)
      {
        continue ;
      }
      if (MRIindexNotInVolume(mri_brain, xw, yw, zw) == 0)
      {
        x = v->x+(dist+SAMPLE_DIST)*v->nx ;
        y = v->y+(dist+SAMPLE_DIST)*v->ny ;
        z = v->z+(dist+SAMPLE_DIST)*v->nz ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw);
        MRIsampleVolume(mri_brain, xw, yw, zw, &next_val) ;

        x = v->x+(dist-SAMPLE_DIST)*v->nx ;
        y = v->y+(dist-SAMPLE_DIST)*v->ny ;
        z = v->z+(dist-SAMPLE_DIST)*v->nz ;
        MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw);
        MRIsampleVolume(mri_brain, xw, yw, zw, &prev_val) ;
        if (val < next_val && val < prev_val)
        {
          if (vno == Gdiag_no)
          {
            printf("csf val found at %2.1f\n", val) ;
          }
          ncsf++ ;
          mean_csf += val ;
          std_csf += (val*val) ;
          break ;
        }
      }
    }
  }


  mean_csf /= (float)ncsf ;
  std_csf = sqrt(std_csf / (float)ncsf - mean_csf*mean_csf) ;
  nsigma = (mean_gray-mean_csf) / (std_gray+std_csf) ;
  gw_thresh = mean_csf + nsigma*std_csf ;
  printf("csf %2.1f +- %2.1f,  "
         "gray %2.1f +- %2.1f, pial boundary at %2.1f\n",
         mean_csf, std_csf, mean_gray, std_gray, gw_thresh) ;

  inward_increasing = mean_gray < mean_csf ;
  for (total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v->val = gw_thresh ;
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/

int
MRIScomputeGraySurfaceValues(MRI_SURFACE *mris,MRI *mri_brain,MRI *mri_smooth,
                             float gray_surface)
{
  double    val, x, y, z, min_val, xw, yw, zw, dx, dy, dz, mag, max_mag ;
  int     total_vertices, vno, nmissing ;
  float   mean_gray, dist ;
  VERTEX  *v ;

  if (gray_surface <= 0.0f)
  {
    gray_surface = MAX_CSF ;
  }

  /* first compute intensity of local gray/white boundary */
  mean_gray = 0.0f ;

  MRISclearMarks(mris) ;   /* for use in soap bubble later */
  for (nmissing = total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    /*
      search outwards and inwards and find the local gradient maximum
      at a location with a reasonable MR intensity value. This will
      be the location of the edge.
    */

    /* search in the normal direction to find the min value */
    min_val = -10.0f ;
    mag = 5.0f ;
    max_mag = 0.0f ;
    for (dist = 0.0f ; dist < 6.0f ; dist += STEP_SIZE)
    {
      x = v->x + v->nx*dist ;
      y = v->y + v->ny*dist ;
      z = v->z + v->nz*dist ;
      // MRIworldToVoxel(mri_brain, x, y, z, &xw, &yw, &zw) ;
      MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw) ;
      MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
      if (val < 70 && val > gray_surface)  /* in right range */
      {
        /* see if we are at a local maximum in the gradient magnitude */
        MRIsampleVolumeGradient(mri_smooth, xw, yw, zw, &dx, &dy, &dz) ;
        mag = sqrt(dx*dx + dy*dy + dz*dz) ;

        if (mag > max_mag)
        {
          max_mag = mag ;
          min_val = val ;
        }
      }
    }
    if (!finite(min_val) || !finite(max_mag) || !finite(mag))
    {
      DiagBreak() ;
    }
    if (min_val > 0)
    {
      v->marked = 1 ;
      v->val = min_val ;
      v->mean = max_mag ;
      mean_gray += min_val ;
      total_vertices++ ;
    }
    else
    {
      nmissing++ ;
      v->val = 0.0f ;
    }

    if (vno == Gdiag_no)
      fprintf(stdout, "v %d, target value = %2.1f, mag = %2.1f\n",
              Gdiag_no, v->val, v->mean) ;
  }
  mean_gray /= (float)total_vertices ;
  MRISsoapBubbleVals(mris, 100) ;
  MRISclearMarks(mris) ;
  /*  MRISaverageVals(mris, 3) ;*/
  fprintf(stdout, "mean pial surface=%2.1f, %d missing\n", mean_gray,nmissing);
  return(NO_ERROR) ;
}
/*-----------------------------------------------------*/
/*!
  \fn int MRISreverseCoords(MRI_SURFACE *mris, int which_reverse, int reverse_face_order, int which_coords)
  \brief Reverse sign of one of the dimensions of the surface coords.
  If reversing X, the order of the verticies is also reversed.
*/
int   MRISreverseCoords(MRI_SURFACE *mris, int which_direction, int reverse_face_order, int which_coords)
{
  int    vno ;
  float  x=0, y=0, z=0 ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    switch (which_coords)
    {
    case CURRENT_VERTICES:
      x = v->x ;
      y = v->y ;
      z = v->z ;
      break ;
    case CANONICAL_VERTICES:
      x = v->cx ;
      y = v->cy ;
      z = v->cz ;
      break ;
    case ORIGINAL_VERTICES:
      x = v->origx ;
      y = v->origy ;
      z = v->origz ;
      break ;
    default:
      ErrorExit(ERROR_UNSUPPORTED, "MRISreverseCoords: unsupported which_vertices %d", which_coords) ;
    }

    switch (which_direction)
    {
    default:
    case REVERSE_X:
      x = -x ;
      break ;
    case REVERSE_Y:
      y = -y ;
      break ;
    case REVERSE_Z:
      z = -z ;
      break ;
    }
    switch (which_coords)
    {
    case CURRENT_VERTICES:
      v->x     = x ;
      v->y     = y ;
      v->z     = z ;
      break ;
    case CANONICAL_VERTICES:
      v->cx    = x ;
      v->cy    = y ;
      v->cz    = z ;
      break ;
    case ORIGINAL_VERTICES:
      v->origx = x ;
      v->origy = y ;
      v->origz = z ;
      break ;
    default:
      ErrorExit(ERROR_UNSUPPORTED, "MRISreverseCoords: unsupported which_vertices %d", which_coords) ;
    }
  }
  if(which_direction == REVERSE_X && reverse_face_order)   // swap order of faces
  {
    MRISreverseFaceOrder(mris);
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------*/
/*!
  \fn int MRISreverse(MRI_SURFACE *mris, int which)
  \brief Reverse sign of one of the dimensions of the surface coords.
  If reversing X, the order of the verticies is also reversed.
*/
int MRISreverse(MRI_SURFACE *mris, int which, int reverse_face_order)
{
  int    vno ;
  float  x, y, z ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;
    switch (which)
    {
    default:
    case REVERSE_X:
      x = -x ;
      break ;
    case REVERSE_Y:
      y = -y ;
      break ;
    case REVERSE_Z:
      z = -z ;
      break ;
    }
    v->x = x ;
    v->y = y ;
    v->z = z ;
  }
  if(which == REVERSE_X && reverse_face_order)   // swap order of faces
  {
    MRISreverseFaceOrder(mris);
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------*/
/*!
  \fn int MRISreverseFaceOrder(MRIS *mris)
  \brief Reverse order of the vertices in each face. This
  is needed when changing the sign of the x surface coord.
*/
int MRISreverseFaceOrder(MRIS *mris)
{
  int  fno, vno0, vno1, vno2 ;
  FACE *f ;

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    vno0 = f->v[0] ;
    vno1 = f->v[1] ;
    vno2 = f->v[2] ;
    f->v[0] = vno2 ;
    f->v[1] = vno1 ;
    f->v[2] = vno0 ;
    mrisSetVertexFaceIndex(mris, vno0, fno) ;
    mrisSetVertexFaceIndex(mris, vno1, fno) ;
    mrisSetVertexFaceIndex(mris, vno2, fno) ;
  }
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
#define X_DOM   0
#define Y_DOM   1
#define Z_DOM   2


static int
mrisFindNormalDistanceLimits(MRI_SURFACE *mris, MRI *mri_filled, int vno,
                             float max_dist,
                             float *pmax_outward_distance,
                             float *pmax_inward_distance)
{
  VERTEX   *v, *vn ;
  float    dx, dy, dz, len, max_outward, max_inward, dot, dist ;
  double     nx, ny, nz, xw, yw, zw, x, y, z, x0, y0, z0,
             ax, ay, az ;
  int      n, xv, yv, zv, xv0, yv0, zv0, dom, xsign, ysign, zsign ;

  max_inward = max_outward = max_dist ;
  v = &mris->vertices[vno] ;

  /* compute normal vector in mri_filled coordinate system */
  MRIvoxelToWorld(mri_filled, 0, 0, 0, &xw, &yw, &zw) ;  /* origin */
  nx = xw + (double)v->nx ;
  ny = yw + (double)v->ny ;
  nz = zw + (double)v->nz ;
  MRIworldToVoxel(mri_filled, nx, ny, nz, &nx, &ny, &nz) ;

  MRISvertexToVoxel(mris, v, mri_filled, &x0, &y0, &z0) ;
  xv0 = nint(x0) ;
  yv0 = nint(y0) ;
  zv0 = nint(z0) ;
  xsign = nx > 0 ? 1 : -1 ;
  ysign = ny > 0 ? 1 : -1 ;
  zsign = nz > 0 ? 1 : -1 ;

  /* compute max outward movement without self-intersection */

  /*
    first check to make sure no neihgbors occupy the same voxel in
    the filled volume and are in the normal direction. If they are,
    don't allow any movement in that direction.
  */
  for (n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;
    MRISvertexToVoxel(mris, vn, mri_filled, &x, &y, &z) ;
    xv = nint(x) ;
    yv = nint(y) ;
    zv = nint(z) ;
    dx = v->x - vn->x ;
    dy = v->y - vn->y ;
    dz = v->z - vn->z ;
    len = sqrt(SQR(dx*dx)+SQR(dy*dy)+SQR(dz*dz)) ;
    /*
      don't let vertices within the same filled voxel move towards each other
      and cross.
    */
    if ((len <= 2.5*MAX_MOVEMENT) && (xv == xv0 && yv == yv0 && zv == zv0))
    {
      dot = v->nx * dx + v->ny * dy + v->nz * dz ;
      if (dot < 0)
      {
        max_inward = 0 ;  /* don't allow inward movement */
      }
      else
      {
        max_outward = 0 ;  /* don't allow outward movement */
      }
    }
  }

  /*
    now compute differentials, and use Bresenham type algorithm to
    move in 6-connected fashion in order to check for self-intersection.
  */
  ax = fabs(nx) ;
  ay = fabs(ny) ;
  az = fabs(nz) ;
  if (ax > ay && ax > az)    /* nx biggest - set it to unit movement */
  {
    len = nx ;
    nx = (double)xsign ;
    ny /= len ;
    nz /= len ;
    dom = X_DOM ;
  }
  else if (ay > az)          /* ny biggest - set it to unit movement */
  {
    len = ny ;
    ny = (double)ysign ;
    nx /= len ;
    nz /= len ;
    dom = Y_DOM ;
  }
  else                       /* nz biggest - set it to unit movement */
  {
    len = nz ;
    nz = (double)zsign ;
    ny /= len ;
    nx /= len ;
    dom = Z_DOM ;
  }
  ax = fabs(nx) ;
  ay = fabs(ny) ;
  az = fabs(nz) ;

  dx = ax ;
  dy = ay ;
  dz = az ;
  xv = xv0 ;
  yv = yv0 ;
  zv = zv0 ;
  x = x0 ;
  y = y0 ;
  z = z0 ;
  dist = 0.0f ;
  do
  {
    if (dom == X_DOM)/* take unit step in x direction, and possibly other */
    {
      if ((dy > dz) && (dy >= 1.0f))   /* take step in y direction */
      {
        yv += ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        y += ny ;
        dy -= 1.0 ;
      }
      if (dz >= 1.0f)  /* take unit step in z direction */
      {
        zv += zsign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        z += nz ;
        dz -= 1.0 ;
      }
      if (dy >= 1.0f)  /* take unit step in z direction */
      {
        yv += ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        y += ny ;
        dy -= 1.0 ;
      }
      xv += xsign ;
      if (MRItest_bit(mri_filled, xv, yv, zv))
      {
        if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
        {
          break ;
        }
      }
      dx -= 1.0 ;
      x += nx ;
    }
    else if (dom == Y_DOM)
    {
      if ((dx > dz) && (dx >= 1.0f))   /* take step in x direction */
      {
        xv += ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        x += nx ;
        dx -= 1.0 ;
      }
      if (dz >= 1.0f)  /* take unit step in z direction */
      {
        zv += zsign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        z += nz ;
        dz -= 1.0 ;
      }
      if (dx >= 1.0f)  /* take unit step in x direction */
      {
        xv += xsign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        x += ny ;
        dx -= 1.0 ;
      }
      yv += ysign ;
      if (MRItest_bit(mri_filled, xv, yv, zv))
      {
        if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
        {
          break ;
        }
      }
      dy -= 1.0 ;
      y += ny ;
    }
    else    /* z dominant - take unit step in z direction (at least) */
    {
      if ((dy > dx) && (dy >= 1.0f))   /* take step in y direction */
      {
        yv += ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        y += ny ;
        dy -= 1.0 ;
      }
      if (dx >= 1.0f)  /* take unit step in x direction */
      {
        xv += xsign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        x += nx ;
        dx -= 1.0 ;
      }
      if (dy >= 1.0f)  /* take unit step in y direction */
      {
        yv += ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        y += ny ;
        dy -= 1.0 ;
      }
      zv += zsign ;
      if (MRItest_bit(mri_filled, xv, yv, zv))
      {
        if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
        {
          break ;
        }
      }
      dz -= 1.0 ;
      z += nz ;
    }
    dist = sqrt(SQR(mri_filled->xsize*(x-x0))+
                SQR(mri_filled->ysize*(y-y0))+
                SQR(mri_filled->zsize*(z-z0))) ;
    dx += ax ;
    dy += ay ;
    dz += az ;
  }
  while (dist < max_outward) ;

  if (dist > max_outward)
  {
    dist = max_outward ;
  }
  *pmax_outward_distance = max_outward = dist ;

  /*
    now do the same thing in the inward direction
  */
  dx = ax ;
  dy = ay ;
  dz = az ;
  xv = xv0 ;
  yv = yv0 ;
  zv = zv0 ;
  x = x0 ;
  y = y0 ;
  z = z0 ;
  dist = 0.0f ;
  do
  {
    if (dom == X_DOM) /* take unit step in x direction, and possibly other */
    {
      if ((dy > dz) && (dy >= 1.0f))   /* take step in y direction */
      {
        yv -= ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        y -= ny ;
        dy -= 1.0 ;
      }
      if (dz >= 1.0f)  /* take unit step in z direction */
      {
        zv -= zsign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        z -= nz ;
        dz -= 1.0 ;
      }
      if (dy >= 1.0f)  /* take unit step in z direction */
      {
        yv -= ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        y -= ny ;
        dy -= 1.0 ;
      }
      xv -= xsign ;
      if (MRItest_bit(mri_filled, xv, yv, zv))
      {
        if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
        {
          break ;
        }
      }
      dx -= 1.0 ;
      x -= nx ;
    }
    else if (dom == Y_DOM)
    {
      if ((dx > dz) && (dx >= 1.0f))   /* take step in x direction */
      {
        xv -= ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        x -= nx ;
        dx -= 1.0 ;
      }
      if (dz >= 1.0f)  /* take unit step in z direction */
      {
        zv -= zsign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        z -= nz ;
        dz -= 1.0 ;
      }
      if (dx >= 1.0f)  /* take unit step in x direction */
      {
        xv -= xsign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        x -= ny ;
        dx -= 1.0 ;
      }
      yv -= ysign ;
      if (MRItest_bit(mri_filled, xv, yv, zv))
      {
        if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
        {
          break ;
        }
      }
      dy -= 1.0 ;
      y -= ny ;
    }
    else    /* z dominant - take unit step in z direction (at least) */
    {
      if ((dy > dx) && (dy >= 1.0f))   /* take step in y direction */
      {
        yv -= ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        y -= ny ;
        dy -= 1.0 ;
      }
      if (dx >= 1.0f)  /* take unit step in x direction */
      {
        xv -= xsign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        x -= nx ;
        dx -= 1.0 ;
      }
      if (dy >= 1.0f)  /* take unit step in y direction */
      {
        yv -= ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        y -= ny ;
        dy -= 1.0 ;
      }
      zv -= zsign ;
      if (MRItest_bit(mri_filled, xv, yv, zv))
      {
        if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
        {
          break ;
        }
      }
      dz -= 1.0 ;
      z -= nz ;
    }
    dist = sqrt(SQR(mri_filled->xsize*(x-x0))+
                SQR(mri_filled->ysize*(y-y0))+
                SQR(mri_filled->zsize*(z-z0))) ;
    dx += ax ;
    dy += ay ;
    dz += az ;
  }
  while (dist < max_inward) ;

  if (dist > max_inward)
  {
    dist = max_inward ;
  }
  if (!FZERO(dist))
  {
    DiagBreak() ;
  }
  *pmax_inward_distance = max_inward = dist ;


  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisLimitGradientDistance(MRI_SURFACE *mris, MHT *mht, int vno)
{
#if 1 // NJS: else code causes mris_expand test failure Aug2012
  VERTEX   *v ;

  v = &mris->vertices[vno] ;

  mrisRemoveNeighborGradientComponent(mris, vno) ;
  if (MHTisVectorFilled(mht, mris, vno, v->odx, v->ody, v->odz))
  {
    mrisRemoveNormalGradientComponent(mris, vno) ;
    if (MHTisVectorFilled(mht, mris, vno, v->odx, v->ody, v->odz))
    {
      v->odx = v->ody = v->odz = 0.0 ;
      return(NO_ERROR) ;
    }
  }
#else // NJS
  VERTEX   *v ;
  double   scale = 1.0 ;

  v = &mris->vertices[vno] ;

  v->marked = 1 ;
  mrisRemoveNeighborGradientComponent(mris, vno) ;
  if (MHTisVectorFilled(mht, mris, vno, v->odx, v->ody, v->odz))
  {
    mrisRemoveNormalGradientComponent(mris, vno) ;
    if (vno == Gdiag_no)
    {
      printf("removing vno %d normal component\n", vno) ;
      if (MHTisVectorFilled(mht, mris, vno, v->odx, v->ody, v->odz))
      {
        printf("********* cropping vno %d gradient *****************\n", vno) ;
      }
    }
    while (MHTisVectorFilled(mht, mris, vno, v->odx, v->ody, v->odz))
    {
      v->marked = 0 ;
      scale *= 0 ;
      v->odx *= 0 ;
      v->ody *= 0 ;
      v->odz *= 0 ;   // was .9
      if (FZERO(v->odx) && FZERO(v->ody) && FZERO(v->odz))
      {
        break ;
      }
    }
    if (vno == Gdiag_no)
    {
      printf("final scale = %f\n", scale) ;
    }
    return(NO_ERROR) ;
  }
#endif//NJS

  return(NO_ERROR) ;
}
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisLimitGradientDistance(MRI_SURFACE *mris, MRI *mri_filled, int vno)
{
  VERTEX   *v, *vn ;
  float    dx, dy, dz, len, max_outward, dot, dist ;
  double     nx, ny, nz, xw, yw, zw, x, y, z, x0, y0, z0,
             ax, ay, az ;
  int      n, xv, yv, zv, xv0, yv0, zv0, dom, xsign, ysign, zsign ;

  v = &mris->vertices[vno] ;
  max_outward = sqrt(SQR(v->odx)+SQR(v->ody)+SQR(v->odz)) ;

  /* compute gradient in mri_filled coordinate system */
  MRIvoxelToWorld(mri_filled, 0, 0, 0, &xw, &yw, &zw) ;  /* origin */
  dx = v->odx ;
  dy = v->ody ;
  dz = v->odz ;
  len = sqrt(SQR(dx)+SQR(dy)+SQR(dz)) ;
  if (FZERO(len))
  {
    return(NO_ERROR) ;
  }
  dx /= len ;
  dy /= len ;
  dz /= len ;
  nx = xw + (double)dx ;
  ny = yw + (double)dy ;
  nz = zw + (double)dz ;
  MRIworldToVoxel(mri_filled, nx, ny, nz, &nx, &ny, &nz) ;

  MRISvertexToVoxel(mris, v, mri_filled, &x0, &y0, &z0) ;
  xv0 = nint(x0) ;
  yv0 = nint(y0) ;
  zv0 = nint(z0) ;
  xsign = nx > 0 ? 1 : -1 ;
  ysign = ny > 0 ? 1 : -1 ;
  zsign = nz > 0 ? 1 : -1 ;

  /* compute max outward movement without self-intersection */

  /*
    first check to make sure no neighbors occupy the same voxel in
    the filled volume and are in the gradient direction. If they are,
    don't allow any movement in that direction.
  */
  for (n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;
    MRISvertexToVoxel(mris, vn, mri_filled, &x, &y, &z) ;
    xv = nint(x) ;
    yv = nint(y) ;
    zv = nint(z) ;
    dx = v->x - vn->x ;
    dy = v->y - vn->y ;
    dz = v->z - vn->z ;
    len = sqrt(SQR(dx*dx)+SQR(dy*dy)+SQR(dz*dz)) ;
    /*
      don't let vertices within the same filled voxel move towards each other
      and cross.
    */
    if ((len <= 2.5*MAX_MOVEMENT) && (xv == xv0 && yv == yv0 && zv == zv0))
    {
      dot = v->odx * dx + v->ody * dy + v->odz * dz ;
      if (dot >= 0)
      {
        /* take out component toward neighbor */
#if 1
        v->odx -= dot * dx ;
        v->ody -= dot * dy ;
        v->odz -= dot * dz ;
#else
        max_outward = 0 ;   /* don't allow outward movement */
#endif
      }
    }
  }

  /*
    now compute differentials, and use Bresenham type algorithm to
    move in 6-connected fashion in order to check for self-intersection.
  */
  ax = fabs(nx) ;
  ay = fabs(ny) ;
  az = fabs(nz) ;
  if (ax > ay && ax > az)    /* nx biggest - set it to unit movement */
  {
    len = nx ;
    nx = (double)xsign ;
    ny /= len ;
    nz /= len ;
    dom = X_DOM ;
  }
  else if (ay > az)          /* ny biggest - set it to unit movement */
  {
    len = ny ;
    ny = (double)ysign ;
    nx /= len ;
    nz /= len ;
    dom = Y_DOM ;
  }
  else                       /* nz biggest - set it to unit movement */
  {
    len = nz ;
    nz = (double)zsign ;
    ny /= len ;
    nx /= len ;
    dom = Z_DOM ;
  }
  ax = fabs(nx) ;
  ay = fabs(ny) ;
  az = fabs(nz) ;

  dx = ax ;
  dy = ay ;
  dz = az ;
  xv = xv0 ;
  yv = yv0 ;
  zv = zv0 ;
  x = x0 ;
  y = y0 ;
  z = z0 ;
  dist = 0.0f ;
  do
  {
    if (dom == X_DOM)/* take unit step in x direction, and possibly other */
    {
      if ((dy > dz) && (dy >= 1.0f))   /* take step in y direction */
      {
        yv += ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        y += ny ;
        dy -= 1.0 ;
      }
      if (dz >= 1.0f)  /* take unit step in z direction */
      {
        zv += zsign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        z += nz ;
        dz -= 1.0 ;
      }
      if (dy >= 1.0f)  /* take unit step in z direction */
      {
        yv += ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        y += ny ;
        dy -= 1.0 ;
      }
      xv += xsign ;
      if (MRItest_bit(mri_filled, xv, yv, zv))
      {
        if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
        {
          break ;
        }
      }
      dx -= 1.0 ;
      x += nx ;
    }
    else if (dom == Y_DOM)
    {
      if ((dx > dz) && (dx >= 1.0f))   /* take step in x direction */
      {
        xv += ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        x += nx ;
        dx -= 1.0 ;
      }
      if (dz >= 1.0f)  /* take unit step in z direction */
      {
        zv += zsign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        z += nz ;
        dz -= 1.0 ;
      }
      if (dx >= 1.0f)  /* take unit step in x direction */
      {
        xv += xsign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        x += ny ;
        dx -= 1.0 ;
      }
      yv += ysign ;
      if (MRItest_bit(mri_filled, xv, yv, zv))
      {
        if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
        {
          break ;
        }
      }
      dy -= 1.0 ;
      y += ny ;
    }
    else    /* z dominant - take unit step in z direction (at least) */
    {
      if ((dy > dx) && (dy >= 1.0f))   /* take step in y direction */
      {
        yv += ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        y += ny ;
        dy -= 1.0 ;
      }
      if (dx >= 1.0f)  /* take unit step in x direction */
      {
        xv += xsign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        x += nx ;
        dx -= 1.0 ;
      }
      if (dy >= 1.0f)  /* take unit step in y direction */
      {
        yv += ysign ;
        if (MRItest_bit(mri_filled, xv, yv, zv))
        {
          if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
          {
            break ;
          }
        }
        y += ny ;
        dy -= 1.0 ;
      }
      zv += zsign ;
      if (MRItest_bit(mri_filled, xv, yv, zv))
      {
        if (!mrisNeighborAtVoxel(mris, mri_filled, vno, xv, yv, zv))
        {
          break ;
        }
      }
      dz -= 1.0 ;
      z += nz ;
    }
    dist = sqrt(SQR(mri_filled->xsize*(x-x0))+
                SQR(mri_filled->ysize*(y-y0))+
                SQR(mri_filled->zsize*(z-z0))) ;
    dx += ax ;
    dy += ay ;
    dz += az ;
  }
  while (dist < max_outward) ;

  if (dist > max_outward)
  {
    dist = max_outward ;
  }

  if (FZERO(dist))
  {
    v->odx = v->ody = v->odz = 0.0f ;
  }
  else   /* limit gradient to max_outward length */
  {
    dx = v->odx ;
    dy = v->ody ;
    dz = v->odz ;
    len = sqrt(SQR(dx)+SQR(dy)+SQR(dz)) ;
    v->odx = max_outward * v->odx / len ;
    v->ody = max_outward * v->ody / len ;
    v->odz = max_outward * v->odz / len ;
  }
  return(NO_ERROR) ;
}
#endif
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisDebugVertex(MRI_SURFACE *mris, int vno)
{
  int     n ;
  VERTEX  *v, *vn ;
  float   d, dx, dy, dz ;

  v = &mris->vertices[vno] ;
  fprintf(stdout,
          "vertex #%d @ (%2.2f, %2.2f, %2.2f), n = (%2.2f, %2.2f, %2.2f) "
          "(%2.2f, %2.2f, %2.2f), val=%2.1f\n",
          vno, v->x, v->y, v->z, v->nx, v->ny, v->nz, v->dx, v->dy, v->dz,
          v->val) ;

  for (n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;
    dx = vn->x - v->x ;
    dy = vn->y - v->y ;
    dz = vn->z - v->z ;
    d = sqrt(dx*dx + dy*dy + dz*dz) ;
    fprintf(stdout,
            "\tn %d: %6.6d, delta = (%2.3f, %2.3f, %2.3f), dist = %2.3f "
            "(%2.2f, %2.2f, %2.2f), val=%2.1f\n",
            n, v->v[n], dx, dy, dz, d, vn->dx, vn->dy, vn->dz, vn->val) ;
  }
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisRmsValError(MRI_SURFACE *mris, MRI *mri)
{
  int     vno, n, xv, yv, zv ;
  double    val, total, delta, x, y, z ;
  VERTEX  *v ;

  for (total = 0.0, n = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->val < 0)
    {
      continue ;
    }
    n++ ;
    MRISvertexToVoxel(mris, v, mri, &x, &y, &z) ;
    xv = nint(x) ;
    yv = nint(y) ;
    zv = nint(z) ;
    MRIsampleVolume(mri, x, y, z, &val) ;
    delta = (val - v->val) ;
    if (fabs(delta) > 100)
    {
      DiagBreak() ;
    }
    else if (fabs(delta) > 1000)
    {
      DiagBreak() ;
    }
    else if (fabs(delta) > 10000)
    {
      DiagBreak() ;
    }
    else if (fabs(delta) > 100000)
    {
      DiagBreak() ;
    }

    if (!devFinite(delta))
    {
      DiagBreak() ;
    }
    total += delta*delta ;
    if (sqrt(total / (double)n) > 1000)
    {
      DiagBreak() ;
    }
  }
  return(sqrt(total / (double)n)) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/


static double
mrisRmsValError_mef(MRI_SURFACE *mris,
                    MRI *mri_30,
                    MRI *mri_5,
                    float weight30, float weight5)
{
  int     vno, n, max_vno; //, xv, yv, zv ;
  double    val30, val5, total, delta, x, y, z, error, max_del ;
  VERTEX  *v ;

  max_del = 0 ;
  max_vno = 0 ;
  for (total = 0.0, n = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->val < 0)
    {
      continue ;
    }
    n++ ;
    MRISvertexToVoxel(mris, v, mri_30, &x, &y, &z) ;
    //      xv = nint(x) ; yv = nint(y) ; zv = nint(z) ;
    MRIsampleVolume(mri_30, x, y, z, &val30) ;
    MRIsampleVolume(mri_5, x, y, z, &val5) ;
    delta = (val30 - v->val) ;
    total += delta*delta*weight30;
    error = delta*delta ;
    if (error > v->val2bak && v->val2bak > 0)
    {
      DiagBreak() ;
    }
    if (error-v->val2bak > max_del)
    {
      max_del = error-v->val2bak ;
      max_vno = vno ;
    }
    v->val2bak = error ;
    delta = (val5 - v->valbak) ;
    total += delta*delta*weight5;
  }
  return(sqrt(total / (double)n)) ;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
static int
mrisNeighborAtVoxel(MRI_SURFACE *mris, MRI *mri, int vno, int xv,int yv,int zv)
{
  int      n, xnv, ynv, znv ;
  VERTEX   *v, *vn ;
  double     xn, yn, zn ;

  v = &mris->vertices[vno] ;
  for (n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;
    MRISvertexToVoxel(mris, v, mri, &xn, &yn, &zn) ;
    xnv = nint(xn) ;
    ynv = nint(yn) ;
    znv = nint(zn) ;
    if (xnv == xv && ynv == yv && znv == zv)
    {
      return(1) ;
    }
  }
  return(0) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRIScomputeAnalyticDistanceError(MRI_SURFACE *mris, int which, FILE *fp)
{
  int     vno, n, vtotal, *pv, ndists ;
  VERTEX  *v, *vn ;
  float   d, xd, yd, zd, circumference = 0.0f, angle, odist ;
  double  pct_orig, pct, mean, mean_orig_error, mean_error,
          smean_error, smean_orig_error ;
  VECTOR  *v1, *v2 ;

  v1 = VectorAlloc(3, MATRIX_REAL) ;
  v2 = VectorAlloc(3, MATRIX_REAL) ;

  mean_orig_error = mean_error = pct_orig = pct=  mean = 0.0 ;
  smean_orig_error = smean_error = 0.0 ;
  ndists = 0 ;
  for (vno=0; vno<mris->nvertices; vno++)
  {
    v = &mris->vertices[vno];
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    vtotal = v->vtotal ;
    switch (which)
    {
    default:   /* don't really know what to do in other cases */
    case MRIS_PLANE:
      for (pv = v->v, n = 0 ; n < vtotal ; n++)
      {
        vn = &mris->vertices[*pv++] ;
        if (vn->ripflag)
        {
          continue ;
        }
        xd = v->origx - vn->origx ;
        yd = v->origy - vn->origy ;
        zd = v->origz - vn->origz ;
        d = xd*xd + yd*yd + zd*zd ;
        odist = sqrt(d) ;
        mean_orig_error += fabs(v->dist_orig[n] - odist) ;
        mean_error += fabs(v->dist[n] - odist) ;
        smean_orig_error += (v->dist_orig[n] - odist) ;
        smean_error += (v->dist[n] - odist) ;
        mean += odist ;
        ndists++ ;
      }
      break ;
    case MRIS_PARAMETERIZED_SPHERE:
    case MRIS_SPHERE:
      VECTOR_LOAD(v1, v->origx, v->origy, v->origz) ;  /* radius vector */
      if (FZERO(circumference))   /* only calculate once */
      {
        circumference = M_PI * 2.0 * V3_LEN(v1) ;
      }
      for (pv = v->v, n = 0 ; n < vtotal ; n++)
      {
        vn = &mris->vertices[*pv++] ;
        if (vn->ripflag)
        {
          continue ;
        }
        VECTOR_LOAD(v2, vn->origx, vn->origy, vn->origz) ;  /* radius vector */
        angle = fabs(Vector3Angle(v1, v2)) ;
        d = circumference * angle / (2.0 * M_PI) ;
        odist = d ;
        mean_orig_error += fabs(v->dist_orig[n] - odist) ;
        mean_error += fabs(v->dist[n] - odist) ;
        smean_orig_error += (v->dist_orig[n] - odist) ;
        smean_error += (v->dist[n] - odist) ;
        mean += fabs(odist) ;
        ndists++ ;
      }
      break ;
    }
  }

  mean /= (double)ndists ;
  mean_error /= (double)ndists ;
  mean_orig_error /= (double)ndists ;
  smean_orig_error /= (double)ndists ;
  smean_error /= (double)ndists ;
  pct = mean_error / mean ;
  pct_orig = mean_orig_error / mean ;
  fprintf(stdout,
          "mean orig = %2.3f mm (%%%2.2f), final = %2.3f mm (%%%2.2f)\n",
          mean_orig_error, 100.0*pct_orig, mean_error, 100.0*pct) ;
  fprintf(stdout, "signed mean orig error = %2.3f, final mean error = %2.3f\n",
          smean_orig_error, smean_error) ;
  if (fp)
  {
    char  *cp ;
    float measured_error, disturb_pct ;

    cp = getenv("FS_DISTURB_DISTANCES") ;
    if (cp)
    {
      disturb_pct = atof(cp) ;
    }
    else
    {
      disturb_pct = 0.0 ;
    }
    measured_error = MRISpercentDistanceError(mris) ;
    fprintf(fp, "%2.3f  %2.3f  %2.3f  %2.3f  %2.3f  %2.3f  %2.3f\n",
            100.0f*(float)MRISvalidVertices(mris) / (float)mris->nvertices,
            disturb_pct,
            100.0*pct_orig, mean_orig_error, 100.0*pct, mean_error,
            measured_error) ;
#if 0
    fprintf(fp,
            "mean orig = %2.3f mm (%%%2.2f), final = %2.3f mm (%%%2.2f)\n",
            mean_orig_error, 100.0*pct_orig, mean_error, 100.0*pct) ;
    fprintf(fp, "signed mean orig error = %2.3f, final mean error = %2.3f\n",
            smean_orig_error, smean_error) ;
#endif
  }
  VectorFree(&v1) ;
  VectorFree(&v2) ;
  return(pct) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRISstoreAnalyticDistances(MRI_SURFACE *mris, int which)
{
  int     vno, n, vtotal, *pv ;
  VERTEX  *v, *vn ;
  float   d, xd, yd, zd, circumference = 0.0f, angle, odist ;
  double  pct_orig, pct, mean, mean_orig_error, mean_error,
          smean_error, smean_orig_error ;
  VECTOR  *v1, *v2 ;

  v1 = VectorAlloc(3, MATRIX_REAL) ;
  v2 = VectorAlloc(3, MATRIX_REAL) ;

  mean_orig_error = mean_error = pct_orig = pct=  mean = 0.0 ;
  smean_orig_error = smean_error = 0.0 ;
  for (vno=0; vno<mris->nvertices; vno++)
  {
    v = &mris->vertices[vno];
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    vtotal = v->vtotal ;
    switch (which)
    {
    default:   /* don't really know what to do in other cases */
    case MRIS_PLANE:
      for (pv = v->v, n = 0 ; n < vtotal ; n++)
      {
        vn = &mris->vertices[*pv++] ;
        if (vn->ripflag)
        {
          continue ;
        }
        xd = v->origx - vn->origx ;
        yd = v->origy - vn->origy ;
        zd = v->origz - vn->origz ;
        d = xd*xd + yd*yd + zd*zd ;
        odist = sqrt(d) ;
        v->dist_orig[n] = odist ;
      }
      break ;
    case MRIS_PARAMETERIZED_SPHERE:
    case MRIS_SPHERE:
      VECTOR_LOAD(v1, v->origx, v->origy, v->origz) ;  /* radius vector */
      if (FZERO(circumference))   /* only calculate once */
      {
        circumference = M_PI * 2.0 * V3_LEN(v1) ;
      }
      for (pv = v->v, n = 0 ; n < vtotal ; n++)
      {
        vn = &mris->vertices[*pv++] ;
        if (vn->ripflag)
        {
          continue ;
        }
        VECTOR_LOAD(v2, vn->origx, vn->origy, vn->origz) ;  /* radius vector */
        angle = fabs(Vector3Angle(v1, v2)) ;
        d = circumference * angle / (2.0 * M_PI) ;
        v->dist_orig[n] = d ;
      }
      break ;
    }
  }

  VectorFree(&v1) ;
  VectorFree(&v2) ;
  return(pct) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISdisturbOriginalDistances(MRI_SURFACE *mris, double max_pct)
{
  int    vno, n ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    for (n = 0 ; n < v->vtotal ; n++)
    {
      v->dist_orig[n] *= (1.0 + randomNumber(-max_pct/100.0f, max_pct/100.0f));
    }
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISnegateValues(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val *= -1.0 ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyMeansToValues(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = v->mean ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyImaginaryMeansToValues(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = v->mean_imag ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyStandardErrorsToValues(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = v->std_error ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISaccumulateMeansInVolume(MRI_SURFACE *mris, MRI *mri, int mris_dof,
                            int mri_dof, int coordinate_system, int sno)
{
  VERTEX    *vertex ;
  double      ndof, x, y, z, mean ;
  int       vno, xv, yv, zv ;

  ndof = (double)(mris_dof + mri_dof) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->val != 0.0f)
    {
      x = vertex->x ;
      y = vertex->y ;
      z = vertex->z ;
      switch (coordinate_system)
      {
      case TALAIRACH_COORDS:
        // MRISworldToTalairachVoxel(mris, mri, x, y, z, &x, &y, &z) ;
        MRISsurfaceRASToTalairachVoxel(mris, mri, x, y, z, &x, &y, &z) ;
        break ;
      default:  /* surface-based */
        // MRIworldToVoxel(mri, x, y, z, &x, &y, &z) ;
        MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &x, &y, &z) ;
        break ;
      }
      xv = nint(x) ;
      yv = nint(y) ;
      zv = nint(z) ;
      if ((xv >= 0 && xv < mri->width) &&
          (yv >= 0 && yv < mri->height) &&
          (zv >= 0 && zv < mri->depth))
      {
        mean = MRIFseq_vox(mri, xv, yv, zv, sno) ;
        mean = (mris_dof * vertex->val + mri_dof * mean) / ndof ;
        MRIFseq_vox(mri, xv, yv, zv, sno) = mean ;
      }
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  actually these are squared standard errors
  ------------------------------------------------------*/
int
MRISaccumulateStandardErrorsInVolume(MRI_SURFACE *mris, MRI *mri,
                                     int mris_dof, int mri_dof,
                                     int coordinate_system, int sno)
{
  VERTEX    *vertex ;
  double      ndof, x, y, z, mris_sigma, mri_sigma ;
  int       vno, xv, yv, zv ;

  ndof = (double)(mris_dof + mri_dof) ;

  /*
    now that we have the values read in, go through the surface, and
    map each vertex into the structural volume via its ellipsoidal
    coordinate.
  */

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->val != 0.0f)
    {
      x = vertex->x ;
      y = vertex->y ;
      z = vertex->z ;
      switch (coordinate_system)
      {
      case TALAIRACH_COORDS:
        //MRISworldToTalairachVoxel(mris, mri, x, y, z, &x, &y, &z) ;
        MRISsurfaceRASToTalairachVoxel(mris, mri, x, y, z, &x, &y, &z) ;
        break ;
      default:  /* surface-based */
        // MRIworldToVoxel(mri, x, y, z, &x, &y, &z) ;
        MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &x, &y, &z) ;
        break ;
      }
      xv = nint(x) ;
      yv = nint(y) ;
      zv = nint(z) ;

      if ((xv < 0 || xv >= mri->width) ||
          ((yv < 0) || (yv >= mri->height)) ||
          ((zv < 0) || (zv >= mri->depth)))
      {
        continue ;
      }

      mri_sigma = MRIFseq_vox(mri, xv, yv, zv, sno) ; /* variance */
      mris_sigma = vertex->val  ;
      mri_sigma = mris_sigma*SQR(mris_dof) + mri_sigma*SQR(mri_dof) ;
      mri_sigma /= SQR(ndof) ;
      if (!finite(mri_sigma))
      {
        fprintf(stderr, "variance not finite at vno %d!\n", vno) ;
        DiagBreak() ;
      }
      MRIFseq_vox(mri, xv, yv, zv, sno) = mri_sigma ;
    }
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISaccumulateMeansOnSurface(MRI_SURFACE *mris, int total_dof,int new_dof)
{
  int    vno, ndof ;
  VERTEX *v ;

  ndof = total_dof + new_dof ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    v->mean = (v->mean*total_dof + v->val*new_dof) / ndof ;
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISaccumulateImaginaryMeansOnSurface(MRI_SURFACE *mris, int total_dof,
                                      int new_dof)
{
  int    vno, ndof ;
  VERTEX *v ;

  ndof = total_dof + new_dof ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    v->mean_imag = (v->mean_imag*total_dof + v->val*new_dof) / ndof ;
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  actually these are squared standard errors
  ------------------------------------------------------*/
int
MRISaccumulateStandardErrorsOnSurface(MRI_SURFACE *mris,
                                      int total_dof,int new_dof)
{
  int    vno, ndof ;
  VERTEX *v ;
  double var ;

  ndof = total_dof + new_dof ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    var = (v->std_error * SQR(total_dof) +
           v->val * SQR(new_dof)) / SQR(ndof);
    v->std_error = var ;
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  actually these are squared standard errors
  ------------------------------------------------------*/
int
MRIScomputeAverageCircularPhaseGradient(MRI_SURFACE *mris, LABEL *area,
                                        float *pdx, float *pdy, float *pdz)
{
  int     N, vno, n, i ;
  VERTEX  *v, *vn ;
  VECTOR  *vdf, *vfz ;
  MATRIX  *mz, *mzt, *mztz, *mztz_inv, *mztz_inv_zt ;
  double  x0, y0, z0, f0, x1, y1, z1, f1, dx, dy, dz, df ;

  dx = dy = dz = 0.0 ;
  for (i = 0 ; i < area->n_points ; i++)
  {
    vno = area->lv[i].vno ;
    v = &mris->vertices[vno] ;
    x0 = v->x ;
    y0 = v->y ;
    z0 = v->z ;
    f0 = atan2(v->imag_val, v->val) ;

    /* first count # of valid neighbors */
    for (N = n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      N++ ;
    }
    /* now allocate vectors and matrix */
    vdf = VectorAlloc(N, MATRIX_REAL) ;    /* function deltas */
    if (mris->patch)
    {
      mz = MatrixAlloc(N, 2, MATRIX_REAL) ;  /* vertex spacing deltas */
    }
    else
    {
      mz = MatrixAlloc(N, 3, MATRIX_REAL) ;  /* vertex spacing deltas */
    }

    /* now fill in matrix and vector entries */
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      x1 = vn->x ;
      y1 = vn->y ;
      z1 = vn->z ;
      f1 = atan2(vn->imag_val,vn->val);
      df = f1 - f0 ;
      while (df > M_PI)
      {
        df -= 2*M_PI ;
      }
      while (df < -M_PI)
      {
        df += 2*M_PI ;
      }
      VECTOR_ELT(vdf, n+1) = df ;
      *MATRIX_RELT(mz, n+1, 1) = x1 - x0 ;
      *MATRIX_RELT(mz, n+1, 2) = y1 - y0 ;
      if (!mris->patch)
      {
        *MATRIX_RELT(mz, n+1, 3) = z1 - z0 ;
      }
    }
    mzt = MatrixTranspose(mz, NULL) ;
    mztz = MatrixMultiply(mzt, mz, NULL) ;
    mztz_inv = MatrixSVDInverse(mztz, NULL) ;
    if (mztz_inv)
    {
      mztz_inv_zt = MatrixMultiply(mztz_inv, mzt, NULL) ;
      vfz = MatrixMultiply(mztz_inv_zt, vdf, NULL) ;
      v->dx = VECTOR_ELT(vfz, 1) ;
      v->dy = VECTOR_ELT(vfz, 2) ;
      if (!mris->patch)
      {
        v->dz = VECTOR_ELT(vfz, 3) ;
      }
      else
      {
        v->dz = 0.0f ;
      }
      dx += v->dx ;
      dy += v->dy ;
      dz += v->dz ;
    }

    VectorFree(&vdf) ;
    MatrixFree(&mz) ;
    MatrixFree(&mzt) ;
    MatrixFree(&mztz) ;
    if (mztz_inv)
    {
      VectorFree(&vfz) ;
      MatrixFree(&mztz_inv) ;
      MatrixFree(&mztz_inv_zt) ;
    }
  }

  *pdx = dx /= (float)area->n_points ;
  *pdy = dy /= (float)area->n_points ;
  *pdz = dz /= (float)area->n_points ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeIntensityError(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int     vno ;
  VERTEX  *v ;
  float   x, y, z ;
  double    val0, xw,yw,zw ;
  double  sse, del0 ;

  if (FZERO(parms->l_intensity))
  {
    return(0.0f) ;
  }

  for (sse = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->val < 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    MRISvertexToVoxel(mris, v, parms->mri_brain, &xw, &yw, &zw) ;
    MRIsampleVolume(parms->mri_brain, xw, yw, zw, &val0) ;

    del0 = v->val - val0 ;
    sse += (del0 * del0) ;
  }

  return(sse) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeTargetLocationError(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int     vno ;
  VERTEX  *v ;
  double    dx, dy, dz ;
  double  sse, mag ;

  if (FZERO(parms->l_location))
    return(0.0f) ;

  for (sse = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
      continue ;

    if (vno == Gdiag_no)
      DiagBreak() ;

    dx = v->x - v->targx ; dy = v->y - v->targy ; dz = v->z - v->targz ;

    mag = dx * dx + dy * dy + dz*dz ;
    if (mag > 50)
      DiagBreak() ;

    if (!devFinite(mag))
      DiagBreak() ;

    sse += mag ;
  }

  return(sse) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeIntensityGradientError(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int     vno ;
  VERTEX  *v ;
  float   x, y, z ;
  double    mag0, xw, yw, zw, dx, dy, dz ;
  double  sse, del0 ;

  if (FZERO(parms->l_grad))
  {
    return(0.0f) ;
  }

  for (sse = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    // MRIworldToVoxel(parms->mri_smooth, x, y, z, &xw, &yw, &zw) ;
#if 0
    MRISsurfaceRASToVoxelCached(mris, parms->mri_smooth, x, y, z, &xw, &yw, &zw) ;
#else
    MRISsurfaceRASToVoxelCached(mris, parms->mri_smooth, x, y, z, &xw, &yw, &zw) ;
#endif
    MRIsampleVolumeGradient(parms->mri_smooth, xw, yw, zw, &dx, &dy, &dz) ;
    mag0 = sqrt(dx*dx + dy*dy + dz*dz) ;

    del0 = v->mean - mag0 ;
    sse += (del0 * del0) ;
  }

  return(sse) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Compute the ratio of the two principal curvatures and
  store it in the vertex->curv variable.
  ------------------------------------------------------*/
int
MRISuseCurvatureRatio(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;
  float  min_curv, max_curv, k1, k2, curv ;

  /*  MRIScomputeSecondFundamentalForm(mris) ;*/

  min_curv = 10000.0f ;
  max_curv = -min_curv ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (fabs(v->k1) > fabs(v->k2))
    {
      k1 = v->k1 ;
      k2 = v->k2 ;
    }
    else
    {
      k1 = v->k2 ;
      k2 = v->k1 ;
    }

    if (!FZERO(k2))
    {
      curv = fabs(k1 / k2) ;
      if (curv < min_curv)
      {
        min_curv = curv ;
      }
      if (curv > max_curv)
      {
        max_curv = curv ;
      }

      v->curv = curv ;
    }
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (fabs(v->k1) > fabs(v->k2))
    {
      k1 = v->k1 ;
      k2 = v->k2 ;
    }
    else
    {
      k1 = v->k2 ;
      k2 = v->k1 ;
    }

    if (FZERO(k2))
    {
      if (FZERO(k1))
      {
        curv = 0.0 ;
      }
      else
      {
        curv = k1 < 0 ? min_curv : max_curv ;
      }
      v->curv = curv ;
    }
  }

  mris->min_curv = min_curv ;
  mris->max_curv = max_curv ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Compute the contrast of the two principal curvatures and
  store it in the vertex->curv variable.
  ------------------------------------------------------*/
int
MRISuseCurvatureContrast(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;
  float  min_curv, max_curv, k1, k2, curv, min_k ;

  /*  MRIScomputeSecondFundamentalForm(mris) ;*/

  min_k = 10000.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (v->k1 < min_k)
    {
      min_k = v->k1 ;
    }
    if (v->k2 < min_k)
    {
      min_k = v->k2 ;
    }
  }

  min_curv = 10000.0f ;
  max_curv = -min_curv ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (v->k1 > v->k2)
    {
      k1 = v->k1 ;
      k2 = v->k2 ;
    }
    else
    {
      k1 = v->k2 ;
      k2 = v->k1 ;
    }
    k1 -= min_k ;
    k2 -= min_k ;
    curv = (k1 - k2) / (k1+k2) ;

    if (curv < min_curv)
    {
      min_curv = curv ;
    }
    if (curv > max_curv)
    {
      max_curv = curv ;
    }

    v->curv = curv ;
  }

  mris->min_curv = min_curv ;
  mris->max_curv = max_curv ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisComputeSphereError(MRI_SURFACE *mris, double l_sphere, double r0)
{
  int     vno ;
  VERTEX  *v ;
  double  del, sse, x, y, z, x0, y0, z0, r ;

  if (FZERO(l_sphere))
  {
    return(0.0f) ;
  }

  x0 = (mris->xlo+mris->xhi)/2.0f ;
  y0 = (mris->ylo+mris->yhi)/2.0f ;
  z0 = (mris->zlo+mris->zhi)/2.0f ;
  for (sse = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = (double)v->x-x0 ;
    y = (double)v->y-y0 ;
    z = (double)v->z-z0 ;
    r = sqrt(x*x + y*y + z*z) ;

    del = r0 - r ;
    sse += (del * del) ;
#if 0
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d sphere term: (%2.3f, %2.3f, %2.3f)\n",
              vno, v->dx, v->dy, v->dz) ;
#endif
  }

  return(sse) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScanonicalToWorld(MRI_SURFACE *mris, double phi, double theta,
                     double *pxw, double *pyw, double *pzw)
{
  double x, y, z, radius ;

  radius = mris->radius ;
  *pxw = x = radius * sin(phi) * cos(theta) ;
  *pyw = y = radius * sin(phi) * sin(theta) ;
  *pzw = z = radius * cos(phi) ;
  return(NO_ERROR) ;
}
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisClipGradient(MRI_SURFACE *mris, float max_len)
{
  int     vno ;
  VERTEX  *v ;
  float   dx, dy, dz, len ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    dx = v->dx ;
    dy = v->dy ;
    dz = v->dz ;
    len = sqrt(dx*dx+dy*dy+dz*dz) ;
    if (len > max_len)
    {
      len = max_len / len ;
      v->dx *= len ;
      v->dy *= len ;
      v->dz *= len ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisClipMomentumGradient(MRI_SURFACE *mris, float max_len)
{
  int     vno ;
  VERTEX  *v ;
  float   dx, dy, dz, len ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    dx = v->odx ;
    dy = v->ody ;
    dz = v->odz ;
    len = sqrt(dx*dx+dy*dy+dz*dz) ;
    if (len > max_len)
    {
      len = max_len / len ;
      v->odx *= len ;
      v->ody *= len ;
      v->odz *= len ;
    }
  }
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyCurvatureToValues(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = v->curv ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyVal2ToVal(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = v->val2 ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
   copy the v->val2bak field into the v->val for every vertex
  ------------------------------------------------------*/
int
MRIScopyVal2BakToVal(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = v->val2bak ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyCurvatureToImagValues(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->imag_val = v->curv ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyValuesToCurvature(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = v->val ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyImagValuesToCurvature(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = v->imag_val ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyCurvatureFromValues(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = v->val ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyCurvatureFromImagValues(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = v->imag_val ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScomputeDistanceErrors(MRI_SURFACE *mris, int nbhd_size, int max_nbrs)
{
  VERTEX  *v ;
  int     vno, n, nvertices ;
  double  dist_scale, pct, dist, odist, mean, mean_error, smean,
          total_mean_error, total_mean ;

  MRIScomputeMetricProperties(mris) ;
  if (mris->patch)
  {
    dist_scale = 1.0 ;
  }
  else
  {
    dist_scale = sqrt(mris->orig_area / mris->total_area) ;
  }

  total_mean = total_mean_error = mean = 0.0 ;
  for (pct = 0.0, nvertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      v->val = 0.0f ;
      continue ;
    }
    for (smean = mean_error = mean = 0.0, n = 0 ; n < v->vtotal ; n++)
    {
      nvertices++ ;
      dist = dist_scale*v->dist[n] ;
      odist = v->dist_orig[n] ;
#if 0
      mean += (dist - odist) * (dist - odist) ;
#else
      mean += odist ;
#endif
      total_mean += odist ;
      smean += dist - odist ;
#define USE_FABS  1
#if USE_FABS
      mean_error += fabs(dist-odist) ;
      total_mean_error += fabs(dist-odist) ;
#else
      mean_error += (dist-odist)*(dist-odist) ;
      total_mean_error += (dist-odist)*(dist-odist) ;
#endif
      if (!FZERO(odist))
      {
        pct += fabs(dist - odist) / odist ;
      }
    }
    mean /= (double)v->vtotal ;
#if USE_FABS
    mean_error /= (double)v->vtotal ;
#else
    mean_error = sqrt(mean_error / (double)v->vtotal) ;
#endif
#if 0
    if (smean < 0.0f)
    {
      mean_error *= -1.0f ;
    }
#endif
    v->val = mean_error / mean ;
  }

#if USE_FABS
  total_mean_error /= (double)nvertices ;
#else
  total_mean_error = sqrt(total_mean_error / (double)nvertices) ;
#endif
  total_mean /= (double)nvertices ;
  total_mean_error /= total_mean ;
  fprintf(stdout, "mean dist = %2.3f, rms error = %2.2f%%\n",
          total_mean, 100.0*total_mean_error) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISwriteTriangularSurface(MRI_SURFACE *mris, const char *fname)
{
  int      k, n ;
  FILE     *fp;
  time_t   tt ;
  char     *user, *time_str ;

  user = getenv("USER") ;
  if (!user)
  {
    user = getenv("LOGNAME") ;
  }
  if (!user)
  {
    user = "UNKNOWN" ;
  }
  tt = time(&tt) ;
  time_str = ctime(&tt) ;
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    fprintf(stdout, "writing surface file %s, created by %s on %s.\n",
            fname, user, time_str) ;
  fp = fopen(fname,"w");
  if (fp==NULL)
    ErrorReturn(ERROR_BADFILE,
                (ERROR_BADFILE,"MRISwrite(%s): can't create file\n",fname));
  fwrite3(TRIANGLE_FILE_MAGIC_NUMBER,fp);
  fprintf(fp, "created by %s on %s\n", user, time_str) ;
  fwriteInt(mris->nvertices,fp);
  fwriteInt(mris->nfaces,fp);   /* # of triangles */
  for (k = 0 ; k < mris->nvertices ; k++)
  {
    fwriteFloat(mris->vertices[k].x, fp) ;
    fwriteFloat(mris->vertices[k].y, fp) ;
    fwriteFloat(mris->vertices[k].z, fp) ;
  }
  for (k = 0 ; k < mris->nfaces ; k++)
  {
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      fwriteInt(mris->faces[k].v[n],fp);
    }
  }
  /* write whether vertex data was using
     the real RAS rather than conformed RAS */
  fwriteInt(TAG_OLD_USEREALRAS, fp);
  fwriteInt(mris->useRealRAS, fp);

  fwriteInt(TAG_OLD_SURF_GEOM, fp);
  writeVolGeom(fp, &mris->vg);

  // write other tags
  if (!FZERO(mris->group_avg_surface_area))
  {
    long long here ;
    printf("writing group avg surface area %2.0f cm^2 into surface file\n",
           mris->group_avg_surface_area/100.0) ;
    TAGwriteStart(fp, TAG_GROUP_AVG_SURFACE_AREA, &here, sizeof(float)) ;
    fwriteFloat(mris->group_avg_surface_area, fp) ;
    TAGwriteEnd(fp, here) ;
  }
  {
    int i ;

    for (i = 0 ; i < mris->ncmds ; i++)
      TAGwrite(fp, TAG_CMDLINE, mris->cmdlines[i],
               strlen(mris->cmdlines[i])+1) ;
  }
  fclose(fp);
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static SMALL_SURFACE *
mrisReadTriangleFileVertexPositionsOnly(const char *fname)
{
  SMALL_VERTEX   *v ;
  int            nvertices, nfaces, magic, vno ;
  char           line[STRLEN] ;
  FILE           *fp ;
  SMALL_SURFACE  *mriss ;

  fp = fopen(fname, "rb") ;
  if (!fp)
    ErrorReturn(NULL,(ERROR_NOFILE,
                      "mrisReadTriangleFile(%s): could not open file",fname));

  fread3(&magic, fp) ;
  fgets(line, 200, fp) ;
  fscanf(fp, "\n") ;
  /*  fscanf(fp, "\ncreated by %s on %s\n", user, time_str) ;*/
  nvertices = freadInt(fp);
  nfaces = freadInt(fp);

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    fprintf(stdout,"surface %s: %d vertices and %d faces.\n",
            fname, nvertices,nfaces);

  mriss = (SMALL_SURFACE *)calloc(1, sizeof(SMALL_SURFACE)) ;
  if (!mriss)
    ErrorReturn(NULL,
                (ERROR_NOMEMORY,
                 "MRISreadVerticesOnly: could not allocate surface")) ;

  mriss->nvertices = nvertices ;
  mriss->vertices = (SMALL_VERTEX *)calloc(nvertices, sizeof(SMALL_VERTEX)) ;
  if (!mriss->nvertices)
  {
    free(mriss) ;
    ErrorReturn(NULL,
                (ERROR_NOMEMORY,
                 "MRISreadVerticesOnly: could not allocate surface")) ;
  }
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mriss->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v->x = freadFloat(fp);
    v->y = freadFloat(fp);
    v->z = freadFloat(fp);
#if 0
    v->label = NO_LABEL ;
#endif
    if (fabs(v->x) > 10000 || !finite(v->x))
      ErrorExit(ERROR_BADFILE, "%s: vertex %d x coordinate %f!",
                Progname, vno, v->x) ;
    if (fabs(v->y) > 10000 || !finite(v->y))
      ErrorExit(ERROR_BADFILE, "%s: vertex %d y coordinate %f!",
                Progname, vno, v->y) ;
    if (fabs(v->z) > 10000 || !finite(v->z))
      ErrorExit(ERROR_BADFILE, "%s: vertex %d z coordinate %f!",
                Progname, vno, v->z) ;
  }
  fclose(fp);
  return(mriss) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisReadTriangleFilePositions(MRI_SURFACE *mris, const char *fname)
{
  VERTEX      *v ;
  int         nvertices, nfaces, magic, vno ;
  char        line[STRLEN] ;
  FILE        *fp ;
#if 0
  FACE        *f ;
  int         fno, n ;
#endif

  fp = fopen(fname, "rb") ;
  if (!fp)
    ErrorReturn
    (ERROR_NOFILE,(ERROR_NOFILE,
                   "mrisReadTriangleFile(%s): could not open file",fname));

  fread3(&magic, fp) ;
  fgets(line, 200, fp) ;
  fscanf(fp, "\n") ;
  /*  fscanf(fp, "\ncreated by %s on %s\n", user, time_str) ;*/
  nvertices = freadInt(fp);
  nfaces = freadInt(fp);

  if (nvertices != mris->nvertices || nfaces != mris->nfaces)
    ErrorReturn
    (ERROR_BADPARM,
     (ERROR_BADPARM, "mrisReadTriangleFile(%s): surface doesn't match %s\n",
      fname, mris->fname)) ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    fprintf(stdout,"surface %s: %d vertices and %d faces.\n",
            fname, nvertices,nfaces);

  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->x = freadFloat(fp);
    v->y = freadFloat(fp);
    v->z = freadFloat(fp);
  }

#if 0
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      f->v[n] = freadInt(fp);
      if (f->v[n] >= mris->nvertices || f->v[n] < 0)
        ErrorExit(ERROR_BADFILE, "f[%d]->v[%d] = %d - out of range!\n",
                  fno, n, f->v[n]) ;
    }
  }
#endif

  fclose(fp);
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static MRI_SURFACE *
mrisReadTriangleFile(const char *fname, double pct_over)
{
  VERTEX      *v ;
  FACE        *f ;
  int         nvertices, nfaces, magic, vno, fno, n ;
  char        line[STRLEN] ;
  FILE        *fp ;
  MRI_SURFACE *mris ;
  int         tag;

  fp = fopen(fname, "rb") ;
  if (!fp)
    ErrorReturn(NULL,(ERROR_NOFILE,
                      "mrisReadTriangleFile(%s): could not open file",fname));

  fread3(&magic, fp) ;
  fgets(line, 200, fp) ;
  fscanf(fp, "\n") ;
  /*  fscanf(fp, "\ncreated by %s on %s\n", user, time_str) ;*/
  nvertices = freadInt(fp);
  nfaces = freadInt(fp);

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    fprintf(stdout,"surface %s: %d vertices and %d faces.\n",
            fname, nvertices,nfaces);

  mris = MRISoverAlloc(pct_over*nvertices, pct_over*nfaces,nvertices,nfaces) ;
  mris->type = MRIS_TRIANGULAR_SURFACE ;

  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v->x = freadFloat(fp);
    v->y = freadFloat(fp);
    v->z = freadFloat(fp);
#if 0
    v->label = NO_LABEL ;
#endif
    v->num = 0;   /* will figure it out */
    if (fabs(v->x) > 10000 || !finite(v->x))
      ErrorExit(ERROR_BADFILE, "%s: vertex %d x coordinate %f!",
                Progname, vno, v->x) ;
    if (fabs(v->y) > 10000 || !finite(v->y))
      ErrorExit(ERROR_BADFILE, "%s: vertex %d y coordinate %f!",
                Progname, vno, v->y) ;
    if (fabs(v->z) > 10000 || !finite(v->z))
      ErrorExit(ERROR_BADFILE, "%s: vertex %d z coordinate %f!",
                Progname, vno, v->z) ;
  }

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      f->v[n] = freadInt(fp);
      if (f->v[n] >= mris->nvertices || f->v[n] < 0)
        ErrorExit(ERROR_BADFILE, "f[%d]->v[%d] = %d - out of range!\n",
                  fno, n, f->v[n]) ;
    }

    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      mris->vertices[mris->faces[fno].v[n]].num++;
    }
  }
  // new addition
  mris->useRealRAS = 0;

  // read tags
  {
    long long len ;

    while ((tag = TAGreadStart(fp, &len)) != 0)
    {
      switch (tag)
      {
      case TAG_GROUP_AVG_SURFACE_AREA:
        mris->group_avg_surface_area = freadFloat(fp) ;
#if 0
        fprintf(stdout,
                "reading group avg surface area %2.0f cm^2 from file\n",
                mris->group_avg_surface_area/100.0) ;
#endif
        break ;
      case TAG_OLD_SURF_GEOM:
        readVolGeom(fp, &mris->vg);
        break ;
      case TAG_OLD_USEREALRAS:
        if (!freadIntEx(&mris->useRealRAS,fp)) // set useRealRAS
        {
          mris->useRealRAS = 0;  // if error, set to default
        }
        break ;
      case TAG_CMDLINE:
        if (mris->ncmds > MAX_CMDS)
          ErrorExit
          (ERROR_NOMEMORY,
           "MRISread(%s): too many commands (%d) in file",
           fname,mris->ncmds);
        mris->cmdlines[mris->ncmds] = calloc(len+1, sizeof(char)) ;
        if (mris->cmdlines[mris->ncmds] == NULL)
          ErrorExit
          (ERROR_NOMEMORY,
           "MRISread(%s): could not allocate %d byte cmdline",
           fname, len) ;
        mris->cmdlines[mris->ncmds][len] = 0 ;
        fread(mris->cmdlines[mris->ncmds], sizeof(char), len, fp) ;
        mris->ncmds++ ;
        break ;
      default:
        TAGskip(fp, tag, (long long)len) ;
        break ;
      }
    }
  }

  fclose(fp);
  return(mris) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisRemoveNormalGradientComponent(MRI_SURFACE *mris, int vno)
{
  VERTEX   *v ;
  float    dot ;

  v = &mris->vertices[vno] ;
  if (v->ripflag)
  {
    return(NO_ERROR) ;
  }

  dot = v->nx*v->odx + v->ny*v->ody + v->nz*v->odz ;
  v->odx -= dot*v->nx ;
  v->ody -= dot*v->ny ;
  v->odz -= dot*v->nz ;

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#define MIN_NBR_DIST  (0.25)

static int
mrisRemoveNeighborGradientComponent(MRI_SURFACE *mris, int vno)
{
  VERTEX   *v, *vn ;
  int      n ;
  float    dx, dy, dz, dot, x, y, z, dist ;

  v = &mris->vertices[vno] ;
  if (v->ripflag)
  {
    return(NO_ERROR) ;
  }

  x = v->x ;
  y = v->y ;
  z = v->z ;
  for (n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;
    dx = vn->x - x ;
    dy = vn->y - y ;
    dz = vn->z - z ;
    dist = sqrt(dx*dx + dy*dy + dz*dz) ;

    /* too close - take out gradient component in this dir. */
    if (dist <= MIN_NBR_DIST)
    {
      dx /= dist ;
      dy /= dist ;
      dz /= dist ;
      dot = dx*v->odx + dy*v->ody + dz*v->odz ;
      if (dot > 0.0)
      {
        v->odx -= dot*dx ;
        v->ody -= dot*dy ;
        v->odz -= dot*dz ;
      }
    }
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISbuildFileName(MRI_SURFACE *mris, const char *sname, char *fname)
{
  char   path[STRLEN], *slash, *dot ;

  slash = strchr(sname, '/') ;
  if (!slash)              /* no path - use same one as mris was read from */
  {
    dot = strchr(sname, '.') ;
    FileNamePath(mris->fname, path) ;
    if (dot && (*(dot-1) == 'h') && (*(dot-2) == 'l' || *(dot-2) == 'r'))
    {
      sprintf(fname, "%s/%s", path, sname) ;
    }
    else   /* no hemisphere specified */
      sprintf(fname, "%s/%s.%s", path,
              mris->hemisphere == LEFT_HEMISPHERE ? "lh" :
              mris->hemisphere == BOTH_HEMISPHERES ? "both" : "rh", sname) ;
  }
  else
  {
    strcpy(fname, sname) ;  /* path specified explicitly */
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#define MAX_HISTO 1000
int
MRISmodeFilterVals(MRI_SURFACE *mris, int niter)
{
  int    histo[MAX_HISTO];
  int    i, n, vno, ino, index, max_histo, max_index, nchanged, nzero ;
  VERTEX *v, *vn ;

  MRISclearMarks(mris) ;  /* v->marked = 0 means it hasn't converged yet */
  for (ino  = 0 ; ino < niter ; ino++)
  {
    nzero = nchanged = 0 ;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (v->ripflag || v->marked)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      if (nint(v->val) == 0)
      {
        nzero++ ;
      }
      // initialize
      memset(histo, 0, sizeof(histo)) ;
      // create histogram
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        index = (int)nint(vn->val) ;
        if (index < 0 || index >= MAX_HISTO)
        {
          continue ;
        }
        histo[index]++ ;
      }
      max_histo = histo[0] ;
      max_index = 0 ;
      for (i = 1 ; i < MAX_HISTO ; i++)
      {
        if (histo[i] > max_histo)
        {
          max_histo = histo[i] ;
          max_index = i ;
        }
      }
      v->valbak = max_index ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (v->val != v->valbak)
      {
        v->marked = 0 ;  /* process it again */
        nchanged++ ;
      }
      else
      {
        v->marked = 1 ;  /* didn't change */
      }
      v->val = v->valbak ;
    }

    /* unmark all nbrs of unmarked vertices */
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 1)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        vn->marked = 0 ;   /* process it again */
      }
    }
    printf("iter %d: %d changed, %d zero\n", ino, nchanged, nzero) ;
    if (!nchanged)
    {
      break ;
    }
  }
  MRISclearMarks(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISmodeFilterZeroVals(MRI_SURFACE *mris)
{
  int    histo[MAX_HISTO], i, n, vno, ino,
         index, max_histo, max_index, nchanged, nzero ;
  VERTEX *v, *vn ;

  MRISclearMarks(mris) ;  /* v->marked = 0 means it hasn't converged yet */
  ino = 0 ;
  do
  {
    nzero = nchanged = 0 ;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (v->ripflag || v->marked)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      if (nint(v->val) == 0)
      {
        nzero++ ;
      }
      memset(histo, 0, sizeof(histo)) ;
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        index = (int)nint(vn->val) ;
        if (index < 0 || index >= MAX_HISTO)
        {
          continue ;
        }
        histo[index]++ ;
      }
      max_histo = 0 ;
      max_index = 0 ;
      for (i = 1 ; i < MAX_HISTO ; i++)
      {
        if (histo[i] > max_histo)
        {
          max_histo = histo[i] ;
          max_index = i ;
        }
      }
      v->valbak = max_index ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (v->val != v->valbak)
      {
        v->marked = 0 ;  /* process it again */
        nchanged++ ;
      }
      else
      {
        v->marked = 1 ;  /* didn't change */
      }
      v->val = v->valbak ;
    }

    /* unmark all nbrs of unmarked vertices */
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 1)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        vn->marked = 0 ;   /* process it again */
      }
    }
    printf("iter %d: %d changed, %d zero\n", ino++, nchanged, nzero) ;
    if (!nchanged)
    {
      break ;
    }
  }
  while (nchanged > 0 && nzero > 0) ;
  MRISclearMarks(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#define MAX_ANNOTATION 20000
int
MRISmodeFilterAnnotations(MRI_SURFACE *mris, int niter)
{
  int    histo[MAX_ANNOTATION], i, n, vno, ino, index, max_histo,
         max_annotation, annotations[MAX_ANNOTATION], nchanged = 0 ;
  VERTEX *v, *vn ;

  //reset the annotation table using the surface's own
  //colortable when it's available
  if (mris->ct != NULL)
  {
    set_atable_from_ctable(mris->ct);
  }

  for (ino  = 0 ; ino < niter ; ino++)
  {
    for (nchanged = vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      memset(histo, 0, sizeof(histo)) ;
      memset(annotations, 0, sizeof(annotations)) ;
      for (n = 0 ; n < v->vtotal ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        index = annotation_to_index(vn->annotation) ;
        if (index < 0)
        {
          continue ;
        }
        if (index >= MAX_ANNOTATION)
        {
          fprintf(stderr,"\nERROR: index:%d >= MAX_ANNOTATION:%d in "
                  "MRISmodeFilterAnnotations!\n",index,MAX_ANNOTATION);
          exit(1);
        }
        histo[index]++ ;
        annotations[index] = vn->annotation ;
      }
      index = annotation_to_index(v->annotation) ;
      if (index >= MAX_ANNOTATION)
      {
        fprintf(stderr,"\nERROR: index:%d >= MAX_ANNOTATION:%d in "
                "MRISmodeFilterAnnotations!\n",index,MAX_ANNOTATION);
        exit(1);
      }
      max_histo = histo[index] ;
      max_annotation = v->annotation ;
      for (i = 1 ; i < MAX_ANNOTATION ; i++)
      {
        if (histo[i] > max_histo)
        {
          max_histo = histo[i] ;
          max_annotation = annotations[i] ;
        }
      }
      v->undefval = max_annotation ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (v->annotation != v->undefval)
      {
        nchanged++ ;
      }
      v->annotation = v->undefval ;
    }
    if (nchanged == 0)
    {
      break ;
    }
  }
  printf("%d filter iterations complete (%d requested, %d changed)\n",
         ino, niter, nchanged) ;
  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISsoapBubbleVals(MRI_SURFACE *mris, int navgs)
{
  int     vno, n, i, cmpt, nmarked ;
  VERTEX  *v, *vn ;
  double  mean ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    fprintf(stdout,
            "performing soap bubble smoothing of vals for %d iterations.\n",
            navgs) ;
  for (i = 0 ; i < navgs ; i++)
  {
    for (nmarked = vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || (v->marked==1))
      {
        continue ;
      }

      /* compute average of self and neighbors */
      mean = 0.0 ;
      cmpt = 0 ;
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        if (vn->marked)
        {
          mean += vn->val ;
          cmpt++ ;
        }
      }
      if (cmpt>0)   /* had some neighbors with real values */
      {
        v->val = mean / (double)(cmpt) ;
        if (!v->marked)  /* has never been computed before */
        {
          nmarked++ ;
        }
        v->marked = 2 ;  /* has a real value, but is not fixed */
      }
    }
#if 0
    if (!nmarked)
    {
      break ;
    }
#endif
  }

  /*  fprintf(stdout, "\n") ;*/
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
    apply a soap bubble to the vertex->d field
     (used for target distances frequently)
  ------------------------------------------------------*/
int
MRISsoapBubbleD(MRI_SURFACE *mris, int navgs)
{
  int     vno, n, i, cmpt, nmarked ;
  VERTEX  *v, *vn ;
  double  mean ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    fprintf(stdout,
            "performing soap bubble smoothing of D vals for %d iterations.\n",
            navgs) ;
  for (i = 0 ; i < navgs ; i++)
  {
    for (nmarked = vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || (v->marked==1))
      {
        continue ;
      }

      /* compute average of self and neighbors */
      mean = 0.0 ;
      cmpt = 0 ;
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        if (vn->marked)
        {
          mean += vn->d ;
          cmpt++ ;
        }
      }
      if (cmpt>0)   /* had some neighbors with real values */
      {
        v->d = mean / (double)(cmpt) ;
        if (!v->marked)  /* has never been computed before */
        {
          nmarked++ ;
        }
        v->marked = 2 ;  /* has a real value, but is not fixed */
      }
    }
#if 0
    if (!nmarked)
    {
      break ;
    }
#endif
  }

  /*  fprintf(stdout, "\n") ;*/
  return(NO_ERROR) ;
}
int
MRISremoveTriangleLinks(MRI_SURFACE *mris)
{
  int    fno, which ;
  FACE   *f ;

  if (!IS_QUADRANGULAR(mris))
  {
    return(NO_ERROR) ;
  }
  if (mris->triangle_links_removed)
  {
    return(NO_ERROR) ;
  }

  mris->triangle_links_removed = 1 ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "removing non-quadrangular links.\n") ;
  }

  for (fno = 0 ; fno < mris->nfaces ; fno += 2)
  {
    f = &mris->faces[fno] ;
    if (f->ripflag)
    {
      continue ;
    }
    which = WHICH_FACE_SPLIT(f->v[0], f->v[1]) ;
    if (EVEN(which))
    {
      mrisRemoveVertexLink(mris, f->v[1], f->v[2]) ;
      mrisRemoveVertexLink(mris, f->v[2], f->v[1]) ;
    }
    else
    {
      mrisRemoveVertexLink(mris, f->v[0], f->v[2]) ;
      mrisRemoveVertexLink(mris, f->v[2], f->v[0]) ;
    }
  }
  return(NO_ERROR) ;
}
static int
mrisRemoveVertexLink(MRI_SURFACE *mris, int vno1, int vno2)
{
  int    n ;
  VERTEX *v ;

  v = &mris->vertices[vno1] ;
  for (n = 0 ; n < v->vnum ; n++)
    if (v->v[n] == vno2)
    {
      break ;
    }

  if (n < v->vnum)
  {
    memmove(v->v+n, v->v+n+1, (v->vtotal-(n+1))*sizeof(int)) ;
    v->vnum-- ;
    v->vtotal-- ;
  }
  return(NO_ERROR) ;
}

/*
  nsubs = 1 --> divide edge in half
        = 2 --> divide edge in half twice, add 3 vertices
        = 3 --> divide edge in half three times, add 7 vertices
*/
#define MAX_SURFACE_FACES 200000
int
MRISdivideEdges(MRI_SURFACE *mris, int nsubdivisions)
{
  int      nadded, sub, nfaces, fno, nvertices, faces[MAX_SURFACE_FACES], index;
  FACE     *f ;

  for (nadded = sub = 0 ; sub < nsubdivisions ; sub++)
  {
    nfaces = mris->nfaces ;
    nvertices = mris->nvertices ; // before adding any
    for (fno = 0 ; fno < nfaces ; fno++)
    {
      faces[fno] = fno ;
    }
    for (fno = 0 ; fno < nfaces ; fno++)
    {
      int tmp ;

      index = (int)randomNumber(0.0, (double)(nfaces-0.0001)) ;
      tmp = faces[fno] ;
      if (faces[fno] == Gdiag_no || faces[index] == Gdiag_no)
      {
        DiagBreak() ;
      }
      faces[fno] = faces[index] ;
      faces[index] = tmp ;
    }

    for (index = 0 ; index < nfaces ; index++)
    {
      fno = faces[index] ;
      f = &mris->faces[fno] ;
      if (fno == Gdiag_no)
      {
        DiagBreak() ;
      }

      if (f->v[0] < nvertices && f->v[1] < nvertices)
        if (mrisDivideEdge(mris, f->v[0], f->v[1]) == NO_ERROR)
        {
          nadded++ ;
        }
      if (f->v[0] < nvertices && f->v[2] < nvertices)
        if (mrisDivideEdge(mris, f->v[0], f->v[2]) == NO_ERROR)
        {
          nadded++ ;
        }
      if (f->v[1] < nvertices && f->v[2] < nvertices)
        if (mrisDivideEdge(mris, f->v[1], f->v[2]) == NO_ERROR)
        {
          nadded++ ;
        }
    }
  }

  if (Gdiag & DIAG_SHOW && nadded > 0)
  {
    fprintf(stdout,
            "MRISdivideEdges(%d): %d vertices added: # of vertices=%d, # of faces=%d.\n",
            nsubdivisions, nadded, mris->nvertices, mris->nfaces) ;
#if 0
    eno = MRIScomputeEulerNumber(mris, &nvertices, &nfaces, &nedges) ;
    fprintf(stdout, "euler # = v-e+f = 2g-2: %d - %d + %d = %d --> %d holes\n",
            nvertices, nedges, nfaces, eno, 2-eno) ;
#endif
  }
  return(nadded) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISdivideLongEdges(MRI_SURFACE *mris, double thresh)
{
  double   dist ;
  int      vno, nadded, n /*,nvertices, nfaces, nedges, eno*/ ;
  VERTEX   *v, *vn ;
  float    x, y, z ;

  /* make it squared so we don't need sqrts later */
  for (nadded = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;

    /*
      only add vertices if average neighbor vector is in
      normal direction, that is, if the region is concave or sulcal.
    */
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dist = sqrt(SQR(vn->x-x) + SQR(vn->y - y) + SQR(vn->z - z));
      if (dist > thresh)
      {
        if (mrisDivideEdge(mris, vno, v->v[n]) == NO_ERROR)
        {
          nadded++ ;
        }
      }
    }
  }

  if (Gdiag & DIAG_SHOW && nadded > 0)
  {
    fprintf(stdout,
            "%2.2f mm: %d vertices added: # of vertices=%d, # of faces=%d.\n",
            thresh, nadded, mris->nvertices, mris->nfaces) ;
#if 0
    eno = MRIScomputeEulerNumber(mris, &nvertices, &nfaces, &nedges) ;
    fprintf(stdout, "euler # = v-e+f = 2g-2: %d - %d + %d = %d --> %d holes\n",
            nvertices, nedges, nfaces, eno, 2-eno) ;
#endif
  }
  return(nadded) ;
}
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisAddVertices(MRI_SURFACE *mris, double thresh)
{
  double   dist ;
  int      vno, nadded, n,nvertices, nfaces, nedges, eno ;
  VERTEX   *v, *vn ;
  float    x, y, z ;

  /* make it squared so we don't need sqrts later */
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "dividing edges more than %2.2f mm long.\n", thresh) ;
  }
  for (nadded = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    x = v->origx ;
    y = v->origy ;
    z = v->origz ;

    /*
      only add vertices if average neighbor vector is in
      normal direction, that is, if the region is concave or sulcal.
    */
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dist = sqrt(SQR(vn->origx-x) + SQR(vn->origy - y) + SQR(vn->origz - z));
      if (dist > thresh)
      {
        if (mrisDivideEdge(mris, vno, v->v[n]) == NO_ERROR)
        {
          nadded++ ;
        }
      }
    }
  }

  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "%d vertices added: # of vertices=%d, # of faces=%d.\n",
            nadded, mris->nvertices, mris->nfaces) ;
    eno = MRIScomputeEulerNumber(mris, &nvertices, &nfaces, &nedges) ;
    fprintf(stdout, "euler # = v-e+f = 2g-2: %d - %d + %d = %d --> %d holes\n",
            nvertices, nedges, nfaces, eno, 2-eno) ;
  }
  return(nadded) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#define MAX_VERTEX_NEIGHBORS 50
#define MAX_FACES            50
static int
mrisDivideEdge(MRI_SURFACE *mris, int vno1, int vno2)
{
  VERTEX   *v1, *v2, *vnew ;
  int      vnew_no, n, m, fno, n1, n2, flist[100] ;
  FACE     *face ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "dividing edge %d --> %d\n", vno1, vno2) ;
  }

  if (vno1 == Gdiag_no || vno2 == Gdiag_no || mris->nvertices == Gdiag_no)
  {
    printf("dividing edge %d --> %d, adding vertex number %d\n",
           vno1, vno2, mris->nvertices) ;
    DiagBreak() ;
  }
  v1 = &mris->vertices[vno1] ;
  v2 = &mris->vertices[vno2] ;
  if (v1->ripflag || v2->ripflag || mris->nvertices >= mris->max_vertices ||
      mris->nfaces >= (mris->max_faces-1))
  {
    return(ERROR_NO_MEMORY) ;
  }

  /* check to make sure these vertices or the faces they are part of
     have enough room to expand.
  */
  if (v1->vnum >= MAX_VERTEX_NEIGHBORS || v2->vnum >= MAX_VERTEX_NEIGHBORS ||
      v1->num  >= MAX_FACES ||     v2->num >= MAX_FACES)
  {
    return(ERROR_NO_MEMORY) ;
  }


  /* add 1 new vertex, 2 new faces, and 2 new edges */
  vnew_no = mris->nvertices ;
  vnew = &mris->vertices[vnew_no] ;
  vnew->x = (v1->x + v2->x) / 2 ;
  vnew->y = (v1->y + v2->y) / 2 ;
  vnew->z = (v1->z + v2->z) / 2 ;
  vnew->tx = (v1->tx + v2->tx) / 2 ;
  vnew->ty = (v1->ty + v2->ty) / 2 ;
  vnew->tz = (v1->tz + v2->tz) / 2 ;

  vnew->infx = (v1->infx + v2->infx) / 2 ;
  vnew->infy = (v1->infy + v2->infy) / 2 ;
  vnew->infz = (v1->infz + v2->infz) / 2 ;

  vnew->pialx = (v1->pialx + v2->pialx) / 2 ;
  vnew->pialy = (v1->pialy + v2->pialy) / 2 ;
  vnew->pialz = (v1->pialz + v2->pialz) / 2 ;

  vnew->cx = (v1->cx + v2->cx) / 2 ;
  vnew->cy = (v1->cy + v2->cy) / 2 ;
  vnew->cz = (v1->cz + v2->cz) / 2 ;
  vnew->x = (v1->x + v2->x) / 2 ;
  vnew->y = (v1->y + v2->y) / 2 ;
  vnew->z = (v1->z + v2->z) / 2 ;
  vnew->odx = (v1->odx + v2->odx) / 2 ;
  vnew->ody = (v1->ody + v2->ody) / 2 ;
  vnew->odz = (v1->odz + v2->odz) / 2 ;
  vnew->val = (v1->val + v2->val) / 2 ;
  vnew->origx = (v1->origx + v2->origx) / 2 ;
  vnew->origy = (v1->origy + v2->origy) / 2 ;
  vnew->origz = (v1->origz + v2->origz) / 2 ;
  vnew->vnum = 2 ;    /* at least connected to two bisected vertices */

  /* count the # of faces that both vertices are part of */
  for (n = 0 ; n < v1->num ; n++)
  {
    fno = v1->f[n] ;
    face = &mris->faces[fno] ;
    for (m = 0 ; m < VERTICES_PER_FACE ; m++)
      if (face->v[m] == vno2)
      {
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
        {
          fprintf(stdout, " face %d shared.\n", fno) ;
        }
        flist[vnew->num++] = fno ;
        if (vnew->num == 100)
        {
          ErrorExit(ERROR_BADPARM, "Too many faces to divide edge");
        }
        vnew->vnum++ ;
        vnew->vtotal = vnew->vnum ;
      }
  }

  mris->nvertices++ ;

  /* will be part of two new faces also */
  // total array size is going to be vnew->num*2!
  if (vnew->num == 50)
  {
    ErrorExit(ERROR_BADPARM, "Too many faces to divide edge");
  }
  for (n = 0 ; n < vnew->num ; n++)
  {
    flist[vnew->num+n] = mris->nfaces+n ;
  }
  vnew->num *= 2 ;
#if 0
  flist[vnew->num++] = mris->nfaces ;
  flist[vnew->num++] = mris->nfaces+1 ;
  vnew->num = 4 ;
  vnew->vnum = 4 ;
#endif
  vnew->f = (int *)calloc(vnew->num, sizeof(int)) ;
  if (!vnew->f)
  {
    ErrorExit(ERROR_NOMEMORY, "could not allocate %dth face list.\n", vnew_no);
  }
  vnew->n = (uchar *)calloc(vnew->num, sizeof(uchar)) ;
  if (!vnew->n)
  {
    ErrorExit(ERROR_NOMEMORY, "could not allocate %dth face list.\n", vnew_no);
  }
  vnew->v = (int *)calloc(vnew->vnum, sizeof(int)) ;
  if (!vnew->v)
    ErrorExit(ERROR_NOMEMORY, "could not allocate %dth vertex list.\n",
              vnew_no);

#if 0
  vnew->v[0] = vno1 ;
  vnew->v[0] = vno2 ;
  vnew->vnum = 2 ;
  vnew->num = 0;
#else
  vnew->num = vnew->vnum = 0 ;
#endif

  /* divide every face that both vertices are part of in two */
  for (n = 0 ; n < v1->num ; n++)
  {
    fno = v1->f[n] ;
    face = &mris->faces[fno] ;
    for (m = 0 ; m < VERTICES_PER_FACE ; m++)
      if (face->v[m] == vno2)
      {
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
          fprintf(stdout, "dividing face %d along edge %d-->%d.\n",
                  fno, vno1, vno2) ;
        if (face->v[m] == Gdiag_no || vno2 == Gdiag_no)
        {
          DiagBreak() ;
        }
        mrisDivideFace(mris, fno, vno1, vno2, vnew_no) ;
      }
  }

  /* build vnew->f and vnew->n lists by going through all faces v1 and
     v2 are part of */
  for (fno = 0 ; fno < vnew->num ; fno++)
  {
    vnew->f[fno] = flist[fno] ;
    face = &mris->faces[flist[fno]] ;
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
      if (face->v[n] == vnew_no)
      {
        vnew->n[fno] = (uchar)n ;
      }
  }

  /* remove vno1 from vno2 list and visa-versa */
  for (n = 0 ; n < v1->vnum ; n++)
    if (v1->v[n] == vno2)
    {
      v1->v[n] = vnew_no ;
      break ;
    }
  for (n = 0 ; n < v2->vnum ; n++)
    if (v2->v[n] == vno1)
    {
      v2->v[n] = vnew_no ;
      break ;
    }
  /* build vnew->v list by going through faces it is part of and
     rejecting duplicates
  */
  for (fno = 0 ; fno < vnew->num ; fno++)
  {
    face = &mris->faces[vnew->f[fno]] ;
    n1 = vnew->n[fno] == 0 ? VERTICES_PER_FACE-1 : vnew->n[fno]-1 ;
    n2 = vnew->n[fno] == VERTICES_PER_FACE-1 ? 0 : vnew->n[fno]+1 ;
    vno1 = face->v[n1] ;
    vno2 = face->v[n2] ;

    /* go through this faces vertices and see if they should be added to v[] */
    for (n = 0 ; n < vnew->vnum ; n++)
    {
      if (vnew->v[n] == vno1)
      {
        vno1 = -1 ;
      }
      if (vnew->v[n] == vno2)
      {
        vno2 = -1 ;
      }
    }
    if (vno1 >= 0)
    {
      vnew->v[vnew->vnum++] = vno1 ;
    }
    if (vno2 >= 0)
    {
      vnew->v[vnew->vnum++] = vno2 ;
    }
    vnew->vtotal = vnew->vnum ;
  }
  if (0 && Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "%d edges and %d faces.\n", vnew->vnum, vnew->num) ;
  }

  if (!vnew->vnum || !v1->vnum || !v2->vnum)
  {
    fprintf(stderr, "empty vertex (%d <-- %d --> %d!\n",
            vno1, vnew_no, vno2) ;
    DiagBreak() ;
  }
  if (vnew->vnum != 4 || vnew->num != 4)
  {
    DiagBreak() ;
  }
  mrisInitializeNeighborhood(mris, vnew_no) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisDivideFace(MRI_SURFACE *mris, int fno, int vno1, int vno2, int vnew_no)
{
  FACE   *f1, *f2 ;
  VERTEX *v1, *v2, *v3, *vnew ;
  int    fnew_no, n, vno3, flist[5000], vlist[5000], nlist[5000] ;

  if (vno1 == Gdiag_no || vno2 == Gdiag_no || vnew_no == Gdiag_no)
  {
    DiagBreak() ;
  }

  /* divide this face in two, reusing one of the face indices, and allocating
     one new one
  */
  if (mris->nfaces >= mris->max_faces)
  {
    return(ERROR_NO_MEMORY) ;
  }

  fnew_no = mris->nfaces++ ;

  f1 = &mris->faces[fno] ;
  f2 = &mris->faces[fnew_no] ;
  v1 = &mris->vertices[vno1] ;
  v2 = &mris->vertices[vno2] ;
  vnew = &mris->vertices[vnew_no] ;
  memmove(f2->v, f1->v, VERTICES_PER_FACE * sizeof(int));

  /* set v3 to be other vertex in face being divided */

  /* 1st construct f1 by replacing vno2 with vnew_no */
  for (vno3 = -1, n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    if (f1->v[n] == vno2)   /* replace it with vnew */
    {
      f1->v[n] = vnew_no ;
      vnew->f[vnew->num] = fno ;
      vnew->n[vnew->num++] = (uchar)n ;
    }
    else if (f1->v[n] != vno1)
    {
      vno3 = f1->v[n] ;
    }
  }
  v3 = &mris->vertices[vno3] ;

  if (vno1 == Gdiag_no || vno2 == Gdiag_no || vno3 == Gdiag_no)
  {
    DiagBreak() ;
  }

  /* now construct f2 */

  /*  replace vno1 with vnew_no in f2 */
  for (n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    if (f2->v[n] == vno1)   /* replace it with vnew */
    {
      f2->v[n] = vnew_no ;
      vnew->f[vnew->num] = fnew_no ;
      vnew->n[vnew->num++] = (uchar)n ;
    }
  }

  /* now replace f1 in vno2 with f2 */
  for (n = 0 ; n < v2->num ; n++)
    if (v2->f[n] == fno)
    {
      v2->f[n] = fnew_no ;
    }


  /* add new face and edge connected to new vertex to v3 */
  memmove(flist, v3->f, v3->num*sizeof(v3->f[0])) ;
  memmove(vlist, v3->v, v3->vnum*sizeof(v3->v[0])) ;
  memmove(nlist, v3->n, v3->num*sizeof(v3->n[0])) ;
  free(v3->f) ;
  free(v3->v) ;
  free(v3->n) ;
  v3->v = (int *)calloc(v3->vnum+1,sizeof(int));
  if (!v3->v)
    ErrorExit(ERROR_NO_MEMORY,"mrisDivideFace: could not allocate %d vertices",
              v3->vnum) ;
  v3->f = (int *)calloc(v3->num+1,sizeof(int));
  if (!v3->f)
    ErrorExit(ERROR_NO_MEMORY, "mrisDivideFace: could not allocate %d faces",
              v3->num) ;
  v3->n = (uchar *)calloc(v3->num+1,sizeof(uchar));
  if (!v3->n)
    ErrorExit(ERROR_NO_MEMORY, "mrisDivideFace: could not allocate %d nbrs",
              v3->n) ;
  memmove(v3->f, flist, v3->num*sizeof(v3->f[0])) ;
  memmove(v3->n, nlist, v3->num*sizeof(v3->n[0])) ;
  memmove(v3->v, vlist, v3->vnum*sizeof(v3->v[0])) ;
  v3->v[v3->vnum++] = vnew_no ;
  v3->vtotal = v3->vnum ;
  v3->f[v3->num] = fnew_no ;

  /*  find position of v3 in new face f2 */
  for (n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    if (f2->v[n] == vno3)
    {
      v3->n[v3->num] = n ;
      break ;
    }
  }
  if (n >= VERTICES_PER_FACE)
    fprintf(stderr, "could not find v3 (%d) in new face %d!\n",
            vno3, fnew_no) ;
  v3->num++ ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "face %d: (%d, %d, %d)\n",
            fno, f1->v[0], f1->v[1], f1->v[2]);
    fprintf(stdout, "face %d: (%d, %d, %d)\n",
            fnew_no, f2->v[0], f2->v[1], f2->v[2]);
  }
#if 1
  mrisInitializeNeighborhood(mris, vno3) ;
#else
  /*
  NOTE!!!!!! This won't work if the neighborhood size is 1
  */
  if (v3->dist)
  {
    memmove(dlist, v3->dist, v3->vtotal*sizeof(v3->dist[0])) ;
    free(v3->dist) ;
    v3->dist = (float *)calloc(v3->vtotal+1, sizeof(float)) ;
    if (!v3->dist)
      ErrorExit(ERROR_NOMEMORY, "mrisDivideFace: could not allocate %d dists",
                v3->vtotal+1) ;
    memmove(v3->dist, dlist, v3->vtotal*sizeof(v3->dist[0])) ;
  }
  if (v3->dist_orig)
  {
    memmove(dlist, v3->dist_orig, v3->vtotal*sizeof(v3->dist_orig[0])) ;
    free(v3->dist_orig) ;
    v3->dist_orig = (float *)calloc(v3->vtotal+1, sizeof(float)) ;
    if (!v3->dist_orig)
      ErrorExit(ERROR_NOMEMORY,
                "mrisDivideFace: could not allocate %d dist_origs",
                v3->vtotal+1) ;
    memmove(v3->dist_orig, dlist, v3->vtotal*sizeof(v3->dist_orig[0])) ;
  }
#endif
  return(NO_ERROR) ;
}
#if 0

static double mrisComputeVertexNormalSpacingStats(MRI_SURFACE *mris,
    static int mrisTessellateFace(MRI_SURFACE *mris, int fno) ;
    static int VertexReplaceNeighbor(VERTEX *v, int vno_old, int vno_new) ;
    double *psigma);

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisAddVertices(MRI_SURFACE *mris, double nsigma)
{
  double   mean, sigma, dist, thresh, dot ;
  int      vno, nadded, n,nvertices, nfaces, nedges, eno, added ;
  VERTEX   *v, *vn ;
  float    x, y, z, sx, sy, sz, nx, ny, nz ;

#if 1
  mean = MRIScomputeVertexSpacingStats(mris, &sigma, NULL, NULL, NULL, NULL, CURRENT_VERTICES) ;
#else
  mean = mrisComputeVertexNormalSpacingStats(mris, &sigma) ;
  thresh *= thresh ;   /* make it squared so we don't need sqrts later */
#endif
  thresh = mean + sigma * nsigma ;
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "dividing edges more than %2.2f mm long.\n", thresh) ;
  }
  for (nadded = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    /* calculate average normal displacement to neighbors */
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
    sx = sy = sz = 0.0 ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (!vn->ripflag)
      {
        sx += vn->x - x;
        sy += vn->y - y;
        sz += vn->z - z;
      }
    }
    dot = sx*nx+sy*ny+sz*nz;   /* projection onto normal */

    /*
      only add vertices if average neighbor vector is in
      normal direction, that is, if the region is concave or sulcal.
    */
    for (added = n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dist = sqrt(SQR(vn->x - x) + SQR(vn->y - y) + SQR(vn->z - z)) ;
      if (dist > thresh)
      {
        if (mrisDivideEdge(mris, vno, v->v[n]) == NO_ERROR)
        {
          nadded++ ;
        }
      }
    }

    /* check for sulcal vertices that have asymptoted */
    if (!added && v->marked && dot >= 0.0f)
    {
      dot = v->odx * nx + v->ody * ny + v->odz * nz ;
      if (dot > 0.0f)
      {
        for (n = 0 ; n < v->vnum ; n++)
        {
          vn = &mris->vertices[v->v[n]] ;
          dist = sqrt(SQR(vn->x - x) + SQR(vn->y - y) + SQR(vn->z - z)) ;
          if (dist > mean)
          {
            if (mrisDivideEdge(mris, vno, v->v[n]) == NO_ERROR)
            {
              added++ ;
            }
          }
        }
      }
    }
    nadded += added ;
  }
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "%d vertices added: # of vertices=%d, # of faces=%d.\n",
            nadded, mris->nvertices, mris->nfaces) ;
    eno = MRIScomputeEulerNumber(mris, &nvertices, &nfaces, &nedges) ;
    fprintf(stdout, "euler # = v-e+f = 2g-2: %d - %d + %d = %d --> %d holes\n",
            nvertices, nedges, nfaces, eno, 2-eno) ;
  }
  return(mean) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  NOT FINISHED!!!!!!
  ------------------------------------------------------*/
static  int
mrisTessellateFace(MRI_SURFACE *mris, int fno)
{
  VERTEX  *vc, *v1, *v2, *v, *vnew[3] ;
  int     n, vno1, vno2, vnew_no, nv, fnew_no, vc_no, vlist[15] ;
  float   x, y, z, dx, dy, dz, ox, oy, oz, val ;
  FACE    *f, *fnew ;

  if (mris->nvertices + 4 >= mris->max_vertices)
  {
    return(ERROR_NO_MEMORY) ;
  }
  if (mris->nfaces + 5 >= mris->max_faces)
  {
    return(ERROR_NO_MEMORY) ;
  }

  f = &mris->faces[fno] ;

  /* find centroid of current face and put a vertex there */
  ox = oy = oz = x = y = z = dx = dy = dz = val = 0.0 ;
  for (n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    v = &mris->vertices[f->v[n]] ;
    x += v->x ;
    y += v->y ;
    z += v->z ;
    dx += v->odx ;
    dy += v->ody ;
    dz += v->odz ;
    ox += v->origx ;
    oy += v->origy ;
    oz += v->origz ;
    val += v->val ;
  }

  vc_no = mris->nvertices++ ;
  vc = &mris->vertices[vc_no] ;
  vc->val = val / (float)VERTICES_PER_FACE ;
  vc->x = x / (float)VERTICES_PER_FACE ;
  vc->y = y / (float)VERTICES_PER_FACE ;
  vc->z = z / (float)VERTICES_PER_FACE ;
  vc->odx = dx / (float)VERTICES_PER_FACE ;
  vc->ody = dy / (float)VERTICES_PER_FACE ;
  vc->odz = dz / (float)VERTICES_PER_FACE ;
  vc->origx = ox / (float)VERTICES_PER_FACE ;
  vc->origy = oy / (float)VERTICES_PER_FACE ;
  vc->origz = oz / (float)VERTICES_PER_FACE ;
  vc->vnum = 0 ;
  vc->num = 6 ;

  /* now allocate 3 vertices which bisect each edge of the face */
  vlist[0] = f->v[0] ;
  nv = 1 ;
  for (n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    vno1 = f->v[n] ;
    vno2 = n < VERTICES_PER_FACE-1 ? f->v[n+1] : f->v[0] ;
    v1 = &mris->vertices[vno1] ;
    v2 = &mris->vertices[vno2] ;
    vnew_no = mris->nvertices++ ;
    v = vnew[n] = &mris->vertices[vnew_no] ;
    v->val = (v1->val+v2->val) / 2.0f ;

    v->x = (v1->x+v2->x) / 2.0f ;
    v->y = (v1->y+v2->y) / 2.0f ;
    v->z = (v1->z+v2->z) / 2.0f ;

    v->odx = (v1->odx+v2->odx) / 2.0f ;
    v->ody = (v1->ody+v2->ody) / 2.0f ;
    v->odz = (v1->odz+v2->odz) / 2.0f ;

    v->origx = (v1->origx+v2->origx) / 2.0f ;
    v->origy = (v1->origy+v2->origy) / 2.0f ;
    v->origz = (v1->origz+v2->origz) / 2.0f ;
    v->num = 0 ;
    VertexReplaceNeighbor(v1, vno2, vnew_no) ;
    VertexReplaceNeighbor(v2, vno1, vnew_no) ;
    vlist[nv++] = vnew_no ;
    vlist[nv++] = vno2 ;

    /* now build the new vertex's neighbor list */
    v->vnum = 3 ;
    v->v[0] = vno1 ;
    v->v[1] = vno2 ;
    v->v[2] = vc_no ;
    vc->v[vc->vnum++] = vno1 ;
    vc->v[vc->vnum++] = vnew_no ;
    vc->vtotal = vc->vnum ;
  }

  /*
    at this point all the vertices and edges are in place. Now
    put in new faces, reusing the one we are supertessellating.
  */
  for (n = 0 ; n < nv-1 ; n++)
  {
    if (!n)
    {
      fnew_no = fno ;
    }
    else
    {
      fnew_no = mris->nfaces++ ;
    }
    fnew = &mris->faces[fnew_no] ;
    fnew->v[0] = vlist[n] ;
    fnew->v[1] = vlist[n+1] ;
    fnew->v[2] = vc_no ;
  }

  return(NO_ERROR) ;
}
static int
VertexReplaceNeighbor(VERTEX *v, int vno_old, int vno_new)
{
  int n ;

  for (n = 0 ; n < v->vnum ; n++)
  {
    if (v->v[n] == vno_old)
    {
      v->v[n] = vno_new ;
      break ;
    }
  }
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRIScomputeFaceAreaStats(MRI_SURFACE *mris, double *psigma,
                         double *pmin, double *pmax)
{
  double   total_area, mean, var, nf, sigma, min_area, max_area, area,
           area_scale ;
  int      fno ;
  FACE     *f ;

  MRIScomputeMetricProperties(mris) ;

  if (mris->patch)
  {
    area_scale = 1.0 ;
  }
  else
  {
    area_scale = mris->orig_area / mris->total_area ;
  }

  min_area = 1000 ;
  max_area = -1 ;
  for (var = nf = total_area = 0.0, fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    if (f->ripflag)
    {
      continue ;
    }
    area = area_scale * f->area ;
    total_area += area ;
    nf++ ;
    var += area*area ;
    if (area > max_area)
    {
      max_area = area ;
    }
    if (area < min_area)
    {
      min_area = area ;
    }
  }
  mean = total_area / nf ;
  *psigma = sigma = sqrt(var / nf - mean*mean) ;
  if (pmin)
  {
    *pmin = min_area ;
  }
  if (pmax)
  {
    *pmax = max_area ;
  }
  return(mean) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRIScomputeVertexSpacingStats(MRI_SURFACE *mris, double *psigma,
                              double *pmin, double *pmax, int *pvno,int *pvno2,
                              int which_vertices)
{
  double   total_dist, mean, var, nv, dist, sigma, min_dist, max_dist,
           dist_scale ;
  int      vno, n ;
  VERTEX   *v, *vn ;

  MRIScomputeMetricProperties(mris) ;
  if (mris->patch)
  {
    dist_scale = 1.0 ;
  }
  else
  {
    dist_scale = sqrt(mris->orig_area / mris->total_area) ;
  }
  dist_scale = 1.0f ;
  min_dist = 1000 ;
  max_dist = -1 ;
  for (var = nv = total_dist = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      nv++ ;
      switch (which_vertices)
      {
      default:
        ErrorExit(ERROR_BADPARM, "MRIScomputeVertexSpacingStats: unsupported vertex set %d",
                  which_vertices) ;
        dist = 0 ;
        break ;
      case ORIGINAL_VERTICES:
        dist = sqrt(SQR(vn->origx - v->origx) + SQR(vn->origy - v->origy) + SQR(vn->origz - v->origz));
        break ;
      case CURRENT_VERTICES:
        dist = sqrt(SQR(vn->x - v->x) + SQR(vn->y - v->y) + SQR(vn->z - v->z));
        break ;
#if 0
      case PIAL_VERTICES:
        dist = sqrt(SQR(vn->px - v->px) + SQR(vn->py - v->py) + SQR(vn->pz - v->pz));
        break ;
#endif
      case WHITE_VERTICES:
        dist = sqrt(SQR(vn->whitex-v->whitex) + SQR(vn->whitey-v->whitey) + SQR(vn->whitez-v->whitez));
        break ;
      case PIAL_VERTICES:
        dist = sqrt(SQR(vn->pialx-v->pialx) + SQR(vn->pialy-v->pialy) + SQR(vn->pialz-v->pialz));
        break ;
      case TARGET_VERTICES:
        dist = sqrt(SQR(vn->targx-v->targx) + SQR(vn->targy-v->targy) + SQR(vn->targz-v->targz));
        break ;
      }

      dist *= dist_scale ;
      if (dist > max_dist)
      {
        if (pvno)
        {
          *pvno = vno ;
        }
        if (pvno2)
        {
          *pvno2 = v->v[n] ;
        }
        max_dist = dist ;
      }
      if (dist < min_dist)
      {
        min_dist = dist ;
      }
      total_dist += dist ;
      var += dist*dist ;
    }
  }
  mean = total_dist / nv ;
  if (psigma)
  {
    *psigma = sigma = sqrt(var / nv - mean*mean) ;
  }
  if (pmin)
  {
    *pmin = min_dist ;
  }
  if (pmax)
  {
    *pmax = max_dist ;
  }
  return(mean) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRIScomputeTotalVertexSpacingStats(MRI_SURFACE *mris, double *psigma,
                                   double *pmin, double *pmax, int *pvno,
                                   int *pvno2)
{
  double   total_dist, mean, var, nv, dist, sigma, min_dist, max_dist,
           dist_scale ;
  int      vno, n ;
  VERTEX   *v, *vn ;

  MRIScomputeMetricProperties(mris) ;
  if (mris->patch)
  {
    dist_scale = 1.0 ;
  }
  else
  {
    dist_scale = sqrt(mris->orig_area / mris->total_area) ;
  }
  dist_scale = 1.0f ;
  min_dist = 1000 ;
  max_dist = -1 ;
  for (var = nv = total_dist = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (n = 0 ; n < v->vtotal ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      nv++ ;
      dist = sqrt(SQR(vn->x - v->x) + SQR(vn->y - v->y) + SQR(vn->z - v->z));
      dist *= dist_scale ;
      if (dist > max_dist)
      {
        if (pvno)
        {
          *pvno = vno ;
        }
        if (pvno2)
        {
          *pvno2 = v->v[n] ;
        }
        max_dist = dist ;
      }
      if (dist < min_dist)
      {
        min_dist = dist ;
      }
      total_dist += dist ;
      var += dist*dist ;
    }
  }
  mean = total_dist / nv ;
  if (psigma)
  {
    *psigma = sigma = sqrt(var / nv - mean*mean) ;
  }
  if (pmin)
  {
    *pmin = min_dist ;
  }
  if (pmax)
  {
    *pmax = max_dist ;
  }
  return(mean) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeCurvatureMinMax(MRI_SURFACE *mris)
{
  int      vno, found = 0 ;
  VERTEX   *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (found == 0)
    {
      mris->max_curv = mris->min_curv = v->curv ;
      found = 1 ;
    }
    else
    {
      if (v->curv > mris->max_curv)
      {
        mris->max_curv = v->curv ;
      }
      if (v->curv < mris->min_curv)
      {
        mris->min_curv = v->curv ;
      }
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISsetVals(MRI_SURFACE *mris, float val)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = val ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISscaleVals(MRI_SURFACE *mris, float scale)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val *= scale ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
float
MRISdistanceToSurface(MRI_SURFACE *mris, MHT *mht,float x0,float y0,float z0,
                      float nx, float ny, float nz)
{
  double   dist, len ;

#if 0
  {
    FACE   *f = &mris->faces[0] ;
    VERTEX *v0, *v1, *v2 ;

    v0 = &mris->vertices[f->v[0]] ;
    v1 = &mris->vertices[f->v[1]] ;
    v2 = &mris->vertices[f->v[2]] ;

    x0 = (v1->x + v0->x) / 2 ;
    y0 = (v1->y + v0->y) / 2 ;
    z0 = (v1->z + v0->z) / 2 ;
    x0 += (v2->x - x0) / 2 ;
    y0 += (v2->y - y0) / 2 ;
    z0 += (v2->z - z0) / 2 ;
    x0 -= f->nx ;
    y0 -= f->ny ;
    z0 -= f->nz ;
    nx = f->nx ;
    ny = f->ny ;
    nz = f->nz ;
  }
#endif

  len = sqrt(nx*nx+ny*ny+nz*nz) ;
  nx /= len ;
  ny /= len ;
  nz /= len ;
  for (dist = 0.0f ; dist < 128 ; dist += .25)
  {
    if (mrisDirectionTriangleIntersection(mris, x0, y0, z0,
                                          nx, ny, nz, mht, &dist))
    {
      return(dist) ;
    }
  }

  return(0.0) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
    incrementally stores distance from white surface in v->val field -
    useful for calling iteratively
  ------------------------------------------------------*/
#define MAX_EXP_MM 0.1
int
MRISexpandSurface(MRI_SURFACE *mris,
                  float distance,
                  INTEGRATION_PARMS *parms,
                  int use_thick,
                  int nsurfaces)
{
  int    vno, n, niter, avgs, nrounds, surf_no, orig_start_t = parms->start_t ;
  VERTEX *v ;
  double dist, dx=0., dy=0., dz=0.0, dtotal, *pial_x, *pial_y, *pial_z ;
  char fname[STRLEN], *hemi, *cp ;
  INTEGRATION_PARMS thick_parms ;
  MRI_SURFACE       *mris_ico ;
  MHT               *mht = NULL ;

  if (Gdiag & DIAG_WRITE)
  {
    mrisLogStatus(mris, parms, parms->fp, 0.0f, -1) ;
  }
  mrisLogStatus(mris, parms, stdout, 0.0f, -1) ;
  pial_x = (double *)calloc(mris->nvertices, sizeof(double)) ;
  pial_y = (double *)calloc(mris->nvertices, sizeof(double)) ;
  pial_z = (double *)calloc(mris->nvertices, sizeof(double)) ;
  hemi = mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh" ;
  if (pial_x == NULL || pial_y == NULL || pial_z == NULL)
  {
    ErrorExit(ERROR_NOMEMORY, "MRISexpandSurface: could not allocaet %d element vertex array",mris->nvertices);
  }
  if (nsurfaces > 1)
  {
    if (parms->smooth_averages > 0)
    {
      MRISrestoreVertexPositions(mris, PIAL_VERTICES) ;
      MRISaverageVertexPositions(mris, parms->smooth_averages) ;
      MRISsaveVertexPositions(mris, PIAL_VERTICES) ;
      printf("smoothing vertex locations %d times\n", parms->smooth_averages) ;
      MRISrestoreVertexPositions(mris, WHITE_VERTICES) ;
      MRISaverageVertexPositions(mris, parms->smooth_averages) ;
      MRISsaveVertexPositions(mris, ORIGINAL_VERTICES) ;
      MRISsaveVertexPositions(mris, WHITE_VERTICES) ;
    }
    sprintf(fname, "%s.%s%3.3d", hemi,parms->base_name, 0);
    printf("writing expanded surface to %s...\n", fname) ;
    MRISwrite(mris, fname) ;
  }

  if (use_thick)
  {
    MRISripZeroThicknessRegions(mris) ;
  }
  if (parms == NULL)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->x += distance*v->nx ;
      v->y += distance*v->ny ;
      v->z += distance*v->nz ;
    }
  }
  else
  {
    MRISsaveVertexPositions(mris, ORIGINAL_VERTICES) ;
    if (use_thick)
    {
      memset(&thick_parms, 0, sizeof(thick_parms)) ;
      thick_parms.dt = 0.2 ;
      thick_parms.momentum = .5;
      thick_parms.l_nlarea = 1 ;
      thick_parms.l_thick_min = 0 ;
      thick_parms.tol = 1e-1 ;
      thick_parms.l_thick_parallel = 1 ;
      thick_parms.remove_neg = 1 ;
      cp = getenv("FREESURFER_HOME");
      if (cp == NULL)
      {
        ErrorExit(ERROR_BADPARM, "%s: FREESURFER_HOME not defined in environment", cp) ;
      }
      sprintf(fname,"%s/lib/bem/ic7.tri",cp);
      mris_ico = MRISread(fname) ;
      if (!mris_ico)
      {
        ErrorExit(ERROR_NOFILE, "%s: could not open surface file %s",Progname, fname) ;
      }
      MRISscaleBrain(mris_ico, mris_ico, mris->radius/mris_ico->radius) ;
      MRISsaveVertexPositions(mris_ico, CANONICAL_VERTICES) ;
      MRISrestoreVertexPositions(mris, CANONICAL_VERTICES) ;
      MRISminimizeThicknessFunctional(mris, &thick_parms, 10.0) ;

      // compute locations of pial surface vertices nearest to each orig one
      for (vno = 0 ; vno < mris->nvertices ; vno++)
      {
        v = &mris->vertices[vno] ;
        if (v->ripflag)
        {
          continue ;
        }
        if (vno == Gdiag_no)
        {
          DiagBreak() ;
        }
        pial_x[vno] = v->tx ;
        pial_y[vno] = v->ty ;
        pial_z[vno] = v->tz ;
      }
      MRISrestoreVertexPositions(mris, WHITE_VERTICES) ;
      MRISsaveVertexPositions(mris, ORIGINAL_VERTICES) ;
    }
    if ((parms->write_iterations > 0) && (Gdiag&DIAG_WRITE) && !parms->start_t)
    {
      mrisWriteSnapshot(mris, parms, 0) ;
    }
    mrisClearMomentum(mris) ;
    nrounds = log2(parms->n_averages) - log2(parms->min_averages+1)+2 ;
    printf("nrounds = %d\n", nrounds) ;
    if (use_thick)  // distance is a % of the total thickness
    {
      niter = nint(fabs(distance)*2 / (nsurfaces*parms->dt*MAX_EXP_MM)) ;
    }
    else
    {
      niter = nint(fabs(distance) / (nsurfaces*parms->dt*MAX_EXP_MM)) ;
    }
    if (Gdiag_no >= 0)
    {
      v = &mris->vertices[Gdiag_no] ;
      if (use_thick)
        printf("v %d: thickness=%2.2f, moving outwards %2.2fmm\n",
               Gdiag_no, v->curv, v->curv*distance) ;
      else
      {
        printf("v %d: moving outwards %2.2fmm\n", Gdiag_no, distance) ;
      }
    }

    for (surf_no = 0 ; surf_no < nsurfaces ; surf_no++)
    {
      // compute target locations for each vertex
      for (vno = 0 ; vno < mris->nvertices ; vno++)
      {
        v = &mris->vertices[vno] ;
        if (v->ripflag)
        {
          continue ;
        }
        if (vno == Gdiag_no)
        {
          DiagBreak() ;
        }
        if (use_thick)
        {
          dx = pial_x[vno]-v->origx ;
          dy = pial_y[vno]-v->origy ;
          dz = pial_z[vno]-v->origz ;
          dtotal = sqrt(dx*dx + dy*dy + dz*dz) ;
          if (FZERO(dtotal))
          {
            v->ripflag = 1 ;
          }
          dist = (surf_no+1) * distance * dtotal / ((float)nsurfaces) ;
          dx /= dtotal ;
          dy /= dtotal ;
          dz /= dtotal ;
          v->targx = v->origx + dx*dist ;
          v->targy = v->origy + dy*dist ;
          v->targz = v->origz + dz*dist ;
        }
        else  // just move outwards along surface normal
        {
          v->targx = v->origx + v->nx*distance ;
          v->targy = v->origy + v->ny*distance ;
          v->targz = v->origz + v->nz*distance ;
        }
      }
      for (avgs = parms->n_averages ;  avgs >= parms->min_averages ; avgs /= 2)
      {
        for (n = parms->start_t ; n < parms->start_t+niter ; n++)
        {
          printf("\rstep %d of %d     ", n+1-(surf_no*niter*nrounds), orig_start_t+nrounds*niter) ;
          fflush(stdout) ;
          MRIScomputeMetricProperties(mris) ;
          if (!(parms->flags & IPFLAG_NO_SELF_INT_TEST))
          {
            mht = MHTfillTable(mris, mht) ;
          }
          mrisComputeTargetLocationTerm(mris, parms->l_location, parms) ;
          mrisComputeSpringTerm(mris, parms->l_spring) ;
          mrisComputeConvexityTerm(mris, parms->l_convex) ;
          mrisComputeLaplacianTerm(mris, parms->l_lap) ;
          mrisComputeNormalizedSpringTerm(mris, parms->l_spring_norm) ;
          mrisComputeThicknessSmoothnessTerm(mris, parms->l_tsmooth) ;
          mrisComputeThicknessMinimizationTerm(mris, parms->l_thick_min, parms) ;
          mrisComputeThicknessParallelTerm(mris, parms->l_thick_parallel, parms) ;
          mrisComputeNormalSpringTerm(mris, parms->l_nspring) ;
          mrisComputeQuadraticCurvatureTerm(mris, parms->l_curv) ;
          mrisComputeNonlinearSpringTerm(mris, parms->l_nlspring, parms) ;
          mrisComputeTangentialSpringTerm(mris, parms->l_tspring) ;
          mrisComputeNonlinearTangentialSpringTerm(mris, parms->l_nltspring, parms->min_dist) ;
          MRISaverageGradients(mris, avgs) ;
          mrisAsynchronousTimeStep
          (mris, parms->momentum, parms->dt,mht,MAX_EXP_MM) ;

          if ((parms->write_iterations > 0) &&
              !((n+1)%parms->write_iterations)&&(Gdiag&DIAG_WRITE))
          {
            mrisWriteSnapshot(mris, parms, n+1) ;
          }
        }
        parms->start_t += niter ;
        if (avgs == 0)
        {
          break ;
        }
      }
      if (parms->smooth_averages > 0)
      {
        printf("\nsmoothing vertex locations %d times\n", parms->smooth_averages) ;
        MRISaverageVertexPositions(mris, parms->smooth_averages) ;
      }
      else
      {
        printf("\n") ;
      }
      sprintf(fname, "%s.%s%3.3d", hemi,parms->base_name, surf_no+1);
      if (nsurfaces > 1)
      {
        printf("writing expanded surface to %s...\n", fname) ;
        MRISwrite(mris, fname) ;
      }
    }
  }

  if (mht)
  {
    MHTfree(&mht) ;
  }
  free(pial_x) ;
  free(pial_y) ;
  free(pial_z) ;
  return(NO_ERROR) ;
}
int
MRISripZeroThicknessRegions(MRI_SURFACE *mris)
{
  VERTEX *v ;
  int    vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (FZERO(v->whitex-v->pialx) &&
        FZERO(v->whitey-v->pialy) &&
        FZERO(v->whitez-v->pialz))
    {
      v->ripflag = 1 ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Translate a surface by (dx, dy, dz)
  ------------------------------------------------------*/
int
MRIStranslate(MRI_SURFACE *mris, float dx, float dy, float dz)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->x += dx ;
    v->y += dy ;
    v->z += dz ;
  }
  mrisComputeSurfaceDimensions(mris) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  MRIStransform

  Parameters: mris, mri, lta, mri_dst

  Returns value: int

  Description
  Apply a linear transform (possibly octree) to a surface.
  Note that the LT is given in MRI coordinates, so the
  surface must be transformed into that coordinate system
  before applying the linear transform
  See also MRISmatrixMultiply().
  ------------------------------------------------------*/
#include "gcamorph.h"
int
MRIStransform(MRI_SURFACE *mris, MRI *mri, TRANSFORM *transform, MRI *mri_dst)
{
  LTA *lta ;
  int    vno ;
  VERTEX *v ;
  double   xw, yw, zw ;
  MATRIX *m=0;

  // for ras-to-ras transform
  MATRIX *RASFromSurfaceRAS = 0;
  MATRIX *surfaceRASFromRAS = 0;
  // for voxel-to-voxel transform
  MATRIX *voxelFromSurfaceRAS = 0;
  MATRIX *surfaceRASFromVoxel = 0;
  //
  MATRIX *surfaceRASFromSurfaceRAS = 0;
  LT *lt = 0;
  int srcPresent = 1;
  int dstPresent = 1;
  int error = NO_ERROR;
  char errMsg[256];
  int dstNotGiven=0;
  int srcNotGiven=0;

  if (transform->type == MORPH_3D_TYPE)
  {
    GCA_MORPH *gcam ;
    double        xs, ys, zs, xv, yv, zv ;
    float       xv2, yv2, zv2 ;
    MATRIX      *m_atlas_ras2vox, *m_surf_vox2ras, *m_surf_ras_to_atlas_ras ;
    VECTOR      *v1, *v2 ;

    /*
      transform point from surface (ras) coords to the source (atlas) volume
      that was used for the gcam:
    */

    gcam = (GCA_MORPH *)(transform->xform) ;
    if (!mri_dst)
    {
      dstNotGiven = 1;
      mri_dst = MRIalloc(gcam->image.width, gcam->image.height, gcam->image.depth,MRI_UCHAR);
      useVolGeomToMRI(&gcam->image, mri_dst);
    }
    if (!mri)
    {
      srcNotGiven = 1;
      mri = MRIalloc(gcam->atlas.width, gcam->atlas.height, gcam->atlas.depth,MRI_UCHAR);
      useVolGeomToMRI(&gcam->atlas, mri);
    }
    GCAMrasToVox(gcam, mri_dst) ;

    v1 = VectorAlloc(4, MATRIX_REAL) ;
    VECTOR_ELT(v1, 4) = 1.0 ;
    v2 = VectorAlloc(4, MATRIX_REAL) ;
    VECTOR_ELT(v2, 4) = 1.0 ;
    voxelFromSurfaceRAS = voxelFromSurfaceRAS_(mri);
    surfaceRASFromVoxel = surfaceRASFromVoxel_(mri_dst);
    m_surf_vox2ras =
      MRIgetVoxelToRasXform(mri) ;  // from "surface" volume to ras
    m_atlas_ras2vox =
      VGgetVoxelToRasXform(&gcam->atlas, NULL, 0) ;
    // from "surface" volume to ras
    // from surface ras to atlas ras
    m_surf_ras_to_atlas_ras =
      MatrixMultiply(m_surf_vox2ras, voxelFromSurfaceRAS, NULL) ;
    MatrixMultiply(m_atlas_ras2vox,
                   m_surf_ras_to_atlas_ras,
                   voxelFromSurfaceRAS) ;

    // now apply the transform
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }

      // transform vertex point to actual voxel point
      V3_X(v1) = v->x ;
      V3_Y(v1) = v->y ;
      V3_Z(v1) = v->z ;
      MatrixMultiply(voxelFromSurfaceRAS, v1, v2) ;
      xv = V3_X(v2) ;
      yv = V3_Y(v2) ;
      zv = V3_Z(v2) ;
#if 0
      TransformSampleInverse
      (transform, (float)xv, (float)yv, (float)zv, &xv2, &yv2, &zv2) ;
#else
      GCAMsampleMorph(gcam, xv, yv, zv, &xv2, &yv2, &zv2) ;
#endif
      MRIvoxelToSurfaceRAS(mri_dst, xv2, yv2, zv2, &xs, &ys, &zs) ;
      v->x = xs ;
      v->y = ys ;
      v->z = zs ;
    }
    mrisComputeSurfaceDimensions(mris) ;
    // save the volume information from dst
    getVolGeom(mri_dst, &mris->vg);
    VectorFree(&v1) ;
    VectorFree(&v2) ;
    MatrixFree(&voxelFromSurfaceRAS) ;
    MatrixFree(&surfaceRASFromVoxel) ;
    MatrixFree(&m_surf_vox2ras) ;
    MatrixFree(&m_atlas_ras2vox) ;
    MatrixFree(&m_surf_ras_to_atlas_ras) ;
    if (dstNotGiven)
    {
      MRIfree(&mri_dst) ;
    }
    if (srcNotGiven)
    {
      MRIfree(&mri) ;
    }
  }
  else
  {
    lta = (LTA *)(transform->xform) ;
    if (!mri_dst)
    {
      dstNotGiven = 1;
    }

    // depend on the type of transform you have to handle differently
    //
    //       orig              ------>      RAS   c_(ras) != 0
    //        |                              |
    //        |                              | identity
    //        V                              V
    //    conformed vol        ------>      RAS   c_(ras) != 0
    //        |                              |
    //        | identity                     | surfaceRASFromRAS
    //        V                              V
    //    conformed vol        ------>   surfaceRAS  c_(ras) = 0
    //
    // given a volume transform you have to create a surfaceRAS transform
    //
    // Note that vertices are given by surfaceRAS coordinates
    //
    // RAS-to-RAS transform
    //                  orig                 dst
    //    surfaceRAS--->RAS --(ras-to-ras)-->RAS -->surfaceRAS
    //
    // VOX-to-Vox transform
    //
    //    surfaceRAS--->Vox---(vox-to-vox)-->Vox -->surfaceRAS
    //
    //
    if (lta->num_xforms > 1)
    {
      ErrorExit(ERROR_BADPARM, "we cannot handle multiple transforms\n");
    }
    if (lta->num_xforms == 0)
    {
      ErrorExit(ERROR_BADPARM, "transform does not have transform ;-) \n");
    }

    // if volumes are not given, then try to get them from transform
    lt = &lta->xforms[0];

    /////////////////////////////////////////////////////////////////////
    // The following rather fragile treatment about volume info is
    // that lta may or may not store the valid src and dst info
    // when the transform was created
    // Another problem is due to the convention of conformed volume
    ////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////
    // check the c_ras values for mri side
    if (lta->type == LINEAR_RAS_TO_RAS)
    {
      if (mri && lt->src.valid == 1)
      {
        if (!(FZERO(lt->src.c_r - lt->src.c_r)
              && FZERO(lt->src.c_a - lt->src.c_a)
              && FZERO(lt->src.c_s - lt->src.c_s)))
        {
          fprintf
          (stderr,
           "WARNING:****************************************************\n");
          fprintf
          (stderr,
           "WARNING: c_(ras) values are not equal for the "
           "input volume and the transform src.\n");
          fprintf
          (stderr,
           "WARNING: The transformed surface position may be shifted.\n");
          fprintf
          (stderr,
           "WARNING:***************************************************\n");
        }
      }
      if (mri && mris->vg.valid == 1)
      {
        if (!(FZERO(mris->vg.c_r - mris->vg.c_r)
              && FZERO(mris->vg.c_a - mris->vg.c_a)
              && FZERO(mris->vg.c_s - mris->vg.c_s)))
        {
          fprintf
          (stderr,
           "WARNING:***************************"
           "******************************\n");
          fprintf
          (stderr,
           "WARNING: c_(ras) values are not equal for the input volume "
           "and the surface stored volume.\n");
          fprintf
          (stderr,
           "WARNING: The transformed surface position may be shifted.\n");
          fprintf
          (stderr,
           "WARNING:*******************************"
           "**************************\n");
        }
      }
    }

    // if mri is not given, then use the one stored in the transform
    if (!mri && lt->src.valid == 1)
    {
      srcPresent = 0;
      fprintf(stderr, "INFO:try to get src info from transform.\n");
      mri =
        MRIallocHeader(lt->src.width,
                       lt->src.height,
                       lt->src.depth,
                       MRI_UCHAR,1);
      mri->x_r = lt->src.x_r;
      mri->y_r = lt->src.y_r;
      mri->z_r = lt->src.z_r;
      mri->c_r = lt->src.c_r;
      mri->x_a = lt->src.x_a;
      mri->y_a = lt->src.y_a;
      mri->z_a = lt->src.z_a;
      mri->c_a = lt->src.c_a;
      mri->x_s = lt->src.x_s;
      mri->y_s = lt->src.y_s;
      mri->z_s = lt->src.z_s;
      mri->c_s = lt->src.c_s;
      mri->xsize = lt->src.xsize;
      mri->ysize = lt->src.ysize;
      mri->zsize = lt->src.zsize;
      mri->ras_good_flag = 1;
      MRIreInitCache(mri);
    }
    // if mri is not given and transform does not
    // have it, get it from the surface
    else if (!mri && mris->vg.valid == 1)
    {
      fprintf(stderr, "INFO:try to get src info from the surface.\n");
      mri = MRIallocHeader(mris->vg.width,
                           mris->vg.height,
                           mris->vg.depth,
                           MRI_UCHAR,1);
      mri->x_r = mris->vg.x_r;
      mri->y_r = mris->vg.y_r;
      mri->z_r = mris->vg.z_r;
      mri->c_r = mris->vg.c_r;
      mri->x_a = mris->vg.x_a;
      mri->y_a = mris->vg.y_a;
      mri->z_a = mris->vg.z_a;
      mri->c_a = mris->vg.c_a;
      mri->x_s = mris->vg.x_s;
      mri->y_s = mris->vg.y_s;
      mri->z_s = mris->vg.z_s;
      mri->c_s = mris->vg.c_s;
      mri->xsize = mris->vg.xsize;
      mri->ysize = mris->vg.ysize;
      mri->zsize = mris->vg.zsize;
      mri->ras_good_flag = 1;
      MRIreInitCache(mri);
    }
    else if (!mri)
    {
      error = 1;
      strcpy
      (errMsg,
       "When mri == NULL, the transform must have the valid src info.\n");
      goto mristransform_cleanup;
    }
    ///////////////////////////////////////////////////////////////////////////
    // mri_dst side
    // Note: if mri_dst is not given, override the one stored in the transform
    if (!mri_dst && lt->dst.valid == 1)
    {
      dstPresent = 0;
      if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      {
        fprintf(stderr, "INFO: Get dst info from transform.\n");
      }
      lt = &lta->xforms[0];
      mri_dst = MRIallocHeader(lt->dst.width,
                               lt->dst.height,
                               lt->dst.depth,
                               MRI_UCHAR,1);
      mri_dst->x_r = lt->dst.x_r;
      mri_dst->y_r = lt->dst.y_r;
      mri_dst->z_r = lt->dst.z_r;
      mri_dst->c_r = lt->dst.c_r;
      mri_dst->x_a = lt->dst.x_a;
      mri_dst->y_a = lt->dst.y_a;
      mri_dst->z_a = lt->dst.z_a;
      mri_dst->c_a = lt->dst.c_a;
      mri_dst->x_s = lt->dst.x_s;
      mri_dst->y_s = lt->dst.y_s;
      mri_dst->z_s = lt->dst.z_s;
      mri_dst->c_s = lt->dst.c_s;
      mri_dst->xsize = lt->dst.xsize;
      mri_dst->ysize = lt->dst.ysize;
      mri_dst->zsize = lt->dst.zsize;
      mri_dst->ras_good_flag = 1;
    }
    else if (!mri_dst)
    {
      fprintf(stderr, "WARNING:*********************************************************\n");
      fprintf(stderr, "WARNING: transform does not have valid destination volume.       \n");
      fprintf(stderr, "WARNING: The standard CORONAL volume with c_(ras) = 0 is assumed.\n");
      fprintf(stderr, "WARNING:*********************************************************\n");
      mri_dst = MRIallocHeader(lt->dst.width,
                               lt->dst.height,
                               lt->dst.depth,
                               MRI_UCHAR,1);
      mri_dst->x_r = -1;
      mri_dst->y_r = 0;
      mri_dst->z_r = 0;
      mri_dst->c_r = 0;
      mri_dst->x_a = 0;
      mri_dst->y_a =  0;
      mri_dst->z_a = 1;
      mri_dst->c_a = 0;
      mri_dst->x_s = 0;
      mri_dst->y_s = -1;
      mri_dst->z_s = 0;
      mri_dst->c_s = 0;
      mri_dst->xsize = 1;
      mri_dst->ysize = 1;
      mri_dst->zsize = 1;
      mri_dst->ras_good_flag = 1;
    }
    // WATCH /////////////////////////////////////////////////////////
    // When dst is not given, our convention is that the
    // dst is conformed and thus we need
    // to modify mri_dst to be coronal conformed volume
    // (even though transform target was not,
    // as in the case of MNI average_305 being non-coronal, non-conformed
    //////////////////////////////////////////////////////////////////
    if (dstNotGiven)
    {
      // assuming mri is conformed
      mri_dst->width =mri->width;
      mri_dst->height =mri->height;
      mri_dst->depth =mri->depth;
      mri_dst->xsize =mri->xsize;
      mri_dst->ysize =mri->ysize;
      mri_dst->zsize = mri->zsize;
      mri_dst->x_r = -1;
      mri_dst->y_r = 0;
      mri_dst->z_r = 0;
      mri_dst->x_a = 0;
      mri_dst->y_a = 0;
      mri_dst->z_a = 1;
      mri_dst->x_s = 0;
      mri_dst->y_s = -1;
      mri_dst->z_s = 0;
      // this means that we only retain c_ras info
    }
    // you must reinitialise cache
    MRIreInitCache(mri_dst);

    //  MatrixPrint(stderr, mri_dst->i_to_r__);

    ////////////////////////////////////////////////////////////////
    // Now we can calculate
    if (lta->type == LINEAR_RAS_TO_RAS)
    {
      //  we follow the right hand side of the map
      //
      //    conformed -----> surfaceRAS (c_ras = 0)
      //       |              |
      //       V              V
      //    conformed -----> RAS (c_ras != 0)
      //       |              |
      //       |             xfm
      //       V              v
      //  conformed dst ---> RAS (c_ras != 0)
      //       |              |
      //       V              V
      //  conformed dst ---> surfaceRAS (c_ras = 0)
      //
      if (mris->useRealRAS)
      {
        surfaceRASFromSurfaceRAS = MatrixCopy(lta->xforms[0].m_L, NULL);
      }
      else
      {
        RASFromSurfaceRAS = RASFromSurfaceRAS_(mri); // needs only c_(ras) info
        surfaceRASFromRAS =
          surfaceRASFromRAS_(mri_dst);  // need only c_(ras) info
        m = MatrixMultiply(lta->xforms[0].m_L, RASFromSurfaceRAS, NULL);
        surfaceRASFromSurfaceRAS = MatrixMultiply(surfaceRASFromRAS, m, NULL);
      }
    }
    else if (lta->type == LINEAR_VOX_TO_VOX)
    {
      if (mri->width != mri_dst->width
          || mri->height != mri_dst->height
          || mri->depth != mri_dst->depth)
      {
        fprintf(stderr, "WARNING:********************************************************\n");
        fprintf(stderr, "WARNING:voxel-to-voxel transform must have the same volume sizes.\n");
        fprintf(stderr, "WARNING:You gave src (%d, %dm, %d) vs. dst (%d, %d, %d).\n",
                mri->width, mri->height, mri->depth, mri_dst->width, mri_dst->height, mri_dst->depth);
        fprintf(stderr, "WARNING:The result of this transform is most likely wrong.\n");
        fprintf(stderr, "WARNING:********************************************************\n");
      }
      voxelFromSurfaceRAS = voxelFromSurfaceRAS_(mri);
      surfaceRASFromVoxel = surfaceRASFromVoxel_(mri_dst);
      //    MatrixPrint(stderr,  surfaceRASFromVoxel);
      m = MatrixMultiply(lta->xforms[0].m_L, voxelFromSurfaceRAS, NULL);
      surfaceRASFromSurfaceRAS = MatrixMultiply(surfaceRASFromVoxel, m, NULL);
    }
    // now apply the transform
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      // transform vertex point to actual voxel point
      TransformWithMatrix(surfaceRASFromSurfaceRAS,
                          v->x, v->y, v->z, &xw, &yw, &zw);
      v->x = xw ;
      v->y = yw ;
      v->z = zw ;
    }
    mrisComputeSurfaceDimensions(mris) ;
    // save the volume information from dst
    getVolGeom(mri_dst, &mris->vg);

mristransform_cleanup:
    // free memory //////////////////////////////
    if (RASFromSurfaceRAS)
    {
      MatrixFree(&RASFromSurfaceRAS);
    }
    if (surfaceRASFromRAS)
    {
      MatrixFree(&surfaceRASFromRAS);
    }
    if (m)
    {
      MatrixFree(&m);
    }
    if (voxelFromSurfaceRAS)
    {
      MatrixFree(&voxelFromSurfaceRAS);
    }
    if (surfaceRASFromVoxel)
    {
      MatrixFree(&surfaceRASFromVoxel);
    }
    if (surfaceRASFromSurfaceRAS)
    {
      MatrixFree(&surfaceRASFromSurfaceRAS);
    }
    if (!srcPresent && mri)
    {
      MRIfree(&mri);
    }
    if (!dstPresent && mri_dst)
    {
      MRIfree(&mri_dst);
    }
  }

  if (error)
  {
    ErrorExit(ERROR_BADPARM, errMsg);
    return -1; // just to satisfy compiler
  }
  else
  {
    return(NO_ERROR) ;
  }
}
/*------------------------------------------------------------------------
  MRISmatrixMultiply() - simply multiplies matrix M by the vertex xyz.
  See also MRIStransform().
  ------------------------------------------------------------------------*/
int MRISmatrixMultiply(MRIS *mris, MATRIX *M)
{
  int    vno ;
  VERTEX *v ;
  MATRIX *xyz, *Mxyz;

  xyz  = MatrixAlloc(4,1,MATRIX_REAL);
  xyz->rptr[4][1] = 1.0;
  Mxyz = MatrixAlloc(4,1,MATRIX_REAL);

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    xyz->rptr[1][1] = v->x;
    xyz->rptr[2][1] = v->y;
    xyz->rptr[3][1] = v->z;
    MatrixMultiply(M,xyz,Mxyz);

    v->x = Mxyz->rptr[1][1];
    v->y = Mxyz->rptr[2][1];
    v->z = Mxyz->rptr[3][1];
  }

  MatrixFree(&xyz);
  MatrixFree(&Mxyz);
  return(0);
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Scale a surface anisotropically.
  ------------------------------------------------------*/
int
MRISanisotropicScale(MRI_SURFACE *mris, float sx, float sy, float sz)
{
  VERTEX  *v;
  int     k;
  float   x0, y0, z0 ;

  mrisComputeSurfaceDimensions(mris) ;
  /* scale around the center */
  x0 = mris->xctr ;
  y0 = mris->yctr ;
  z0 = mris->zctr ;

  for (k=0; k<mris->nvertices; k++)
  {
    v = &mris->vertices[k];
    if (v->ripflag)
    {
      continue ;
    }
    v->x = (v->x - x0) * sx + x0 ;
    v->y = (v->y - y0) * sy + y0 ;
    v->z = (v->z - z0) * sz + z0 ;
  }

  mrisComputeSurfaceDimensions(mris) ;
  return(NO_ERROR) ;
}
static int mrisChooseFace(MRI_SURFACE *mris, MHT *mht, VERTEX *v)  ;
static int mrisFindUnambiguousFace(MRI_SURFACE *mris, MHT *mht, VERTEX *v,
                                   int *pnum) ;

#if 1
int
MRISinverseSphericalMap(MRI_SURFACE *mris, MRI_SURFACE *mris_ico)
{
  double r ;
  int    fno, vno, num_ambiguous = 0, nfound, i, max_count ;
  VERTEX *v ;
  MHT    *mht ;
  short  *vcount ;

  vcount = (short *)calloc(mris->nfaces, sizeof(short)) ;

  MRISfreeDists(mris) ;

  /* make sure they are they same size */
  r = MRISaverageRadius(mris_ico) ;
  MRISscaleBrain(mris_ico,mris_ico, 100.0/r);
  r = MRISaverageRadius(mris) ;
  MRISscaleBrain(mris, mris, 100.0/r);
  MRISstoreMetricProperties(mris) ;

  /*
    orig       positions are on cortical surface
    current    positions are on sphere.
  */
  mht = MHTfillTable(mris, NULL) ;

  /*
    for each vertex on the icosahedral surface, find what face it lies
    in on the spherical representation of the cortex. If it only lies
    within a single face, position it at the centroid of the original
    position of the face, and mark it as positioned.
  */
  MRISclearMarks(mris_ico) ;
  MRISclearMarks(mris) ;
  for (vno = 0 ; vno < mris_ico->nvertices ; vno++)
  {
    v = &mris_ico->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    fno = mrisFindUnambiguousFace(mris, mht, v, &nfound) ;
    if (fno >= 0)
    {
      vcount[fno]++ ;
#if 0
      mrisCalculateOriginalFaceCentroid(mris,fno,
                                        &v->origx,&v->origy,&v->origz);
#else
      mrisPlaceVertexInOrigFace(mris, v, fno) ;
#endif
      if (vno == Gdiag_no)
      {
        fprintf(stdout, "vertex %d maps to face %d at (%2.1f, %2.1f, %2.1f)\n",
                vno, fno, v->origx, v->origy, v->origz) ;
        mrisDumpFace(mris, fno, stderr) ;
      }
      v->marked = 1 ;
    }
    else
    {
      if (Gdiag & DIAG_SHOW)
      {
        fprintf(stdout, "v %d maps to %d faces\n", vno, nfound) ;
      }
      num_ambiguous++ ;
    }
  }
  fprintf(stdout, "%d non-invertible locations found - resolving ambiguity\n",
          num_ambiguous) ;

  MRISsoapBubbleOrigVertexPositions(mris_ico, 100) ;
  for (vno = 0 ; vno < mris_ico->nvertices ; vno++)
  {
    v = &mris_ico->vertices[vno] ;
    if (v->marked || v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    fno = mrisChooseFace(mris, mht, v) ;
    if (fno < 0)
      ErrorPrintf(ERROR_BADPARM, "unable to find face for ico vertex %d!!!\n",
                  vno) ;
    else
    {
#if 0
      mrisCalculateOriginalFaceCentroid(mris, fno, &v->x, &v->y, &v->z) ;
#else
      mrisPlaceVertexInOrigFace(mris, v, fno) ;
#endif
      vcount[fno]++ ;
    }
  }
  for (max_count = i = 0 ; i < 50 ; i++)
  {
    for (nfound = fno = 0 ; fno < mris->nfaces ; fno++)
    {
      if (vcount[fno] == i)
      {
        nfound++ ;
      }
    }
    if (nfound)
    {
      if (i > max_count)
      {
        max_count = i ;
      }
      fprintf(stdout, "%d mappings to a single face %d times.\n", i, nfound) ;
    }
  }

  fprintf(stdout, "faces mapped to %d times: \n", max_count) ;
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    if (vcount[fno] == max_count)
      fprintf(stdout, "\t%d (%d, %d, %d)\n",
              fno, mris->faces[fno].v[0],mris->faces[fno].v[1],
              mris->faces[fno].v[2]) ;
  }
  MHTfree(&mht) ;
  free(vcount) ;

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Given an intersection point int_pt in which a vertex intersects
  a face, compute the analagous location that the vertex should be
  placed in the faces original coordnates.

  note that fno refers to a face in mris and
  v is a vertex in mris_ico (not given), NOT mris.
  ------------------------------------------------------*/
static int
mrisPlaceVertexInOrigFace(MRI_SURFACE *mris, VERTEX *v, int fno)
{
  double  U0[3], U1[3], U2[3], pt[3], dir[3], int_pt[3], l1[3], l2[3], l2_len,
          l1_len, l_len, P[3], theta1, theta2, dot, theta_ratio, len_scale,
          e1[3], e2[3], etmp[3], x, y ;
  int     ret ;

  e2[0]=0.0;
  e2[1]=0.0;
  e2[2]=0.0;

  /* first compute point where normal to vertex intersects face */
  dir[0] = v->nx ;
  dir[1] = v->ny ;
  dir[2] = v->nz ;
  pt[0] = v->x  ;
  pt[1] = v->y  ;
  pt[2] = v->z  ;
  load_triangle_vertices(mris, fno, U0, U1, U2, CURRENT_VERTICES) ;
  ret = triangle_ray_intersect(pt, dir, U0, U1, U2, int_pt) ;
  if (ret == 0)   /* try in negative of normal direction */
  {
    dir[0] = -v->nx ;
    dir[1] = -v->ny ;
    dir[2] = -v->nz ;
    pt[0] = v->x  ;
    pt[1] = v->y  ;
    pt[2] = v->z  ;
    load_triangle_vertices(mris, fno, U0, U1, U2, CURRENT_VERTICES) ;
    ret = triangle_ray_intersect(pt, dir, U0, U1, U2, int_pt) ;
    if (ret == 0)
      ErrorReturn(ERROR_BADPARM,
                  (ERROR_BADPARM,
                   "mrisPlaceVertexInOrigFace: v does not intersect face!")) ;
  }

  /* now normalize the edges (l1 and l2) of the current triangle */
  SUB(l1, U1, U0) ;
  SUB(l2, U2, U0) ;
  SUB(P, int_pt, U0) ;
  l1_len = VLEN(l1) ;
  SCALAR_MUL(l1, 1.0/l1_len, l1) ;
  l2_len = VLEN(l2) ;
  SCALAR_MUL(l2, 1.0/l2_len, l2) ;
  l_len =  VLEN(P) ;
  SCALAR_MUL(P,  1.0/l_len, P) ;

  /*
    compute the angle between the two legs, and between P and l1.
    The ratio of these two angles will be used to place the vertex
    in the original triangle.
  */
  dot = DOT(l1, P) ;
  theta1 = acos(dot) ;
  if (theta1 < 0)
  {
    theta1 += 2*PI ;
  }
  dot = DOT(l1, l2) ;
  theta2 = acos(dot) ;
  if (theta2 < 0)
  {
    theta2 += 2*PI ;
  }
  if (!DZERO(theta2))
  {
    theta_ratio = theta1 / theta2 ;
  }
  else   /* degenerate triangle */
  {
    theta_ratio = 0 ;
  }

  /*
    express the ratio of the length of the line segment P-U0 as
    a scaled linear combination of the l1 and l2 (the legs of the
    triangle), where the relative weighting is based on the theta
    ratio. This will allow us to use the ratio and the original
    lengths of the legs to place the point in the corresponding location
    in the original triangle.
  */
  len_scale = l_len / (((1-theta_ratio)*l1_len)+theta_ratio*l2_len) ;
  load_orig_triangle_vertices(mris, fno, U0, U1, U2) ;
  SUB(l1, U1, U0) ;
  SUB(l2, U2, U0) ;
  l1_len = VLEN(l1) ;
  SCALAR_MUL(l1, 1.0/l1_len, l1) ;
  l2_len = VLEN(l2) ;
  SCALAR_MUL(l2, 1.0/l2_len, l2) ;
  l_len =  VLEN(P) ;
  SCALAR_MUL(P,  1.0/l_len,  P) ;

  /* compute angle between original legs */
  dot = DOT(l1, l2) ;
  theta2 = acos(dot) ;
  if (theta2 < 0)
  {
    theta2 += 2*PI ;
  }

  theta1 = theta_ratio * theta2 ;   /* analogous angle in orig triangle */

  /* construct basis vector for plane defined by original triangle */
  SCALAR_MUL(l1, 1.0, e1) ;  /* 1st basis vector is just l1 */
  CROSS(l1, l2, etmp) ;      /* vector orthogonal to l1 and l2 */
  CROSS(etmp, l1, e2) ;
  SCALAR_MUL(e2, (1.0/VLEN(e2)), e2) ;

  /*
    express length of line segment in original triangle as a linear
    combination of the original leg lengths, using the same weighting.
  */
  l_len = len_scale * (((1-theta_ratio)*l1_len)+theta_ratio*l2_len) ;

  /* rotate e1 by theta1 and scale it by l_len */
  x = l_len * cos(theta1) ;
  y = l_len * sin(theta1) ;

  /* express it in the global coordinate system */
  SCALAR_MUL(e1, x, e1) ;
  SCALAR_MUL(e2, y, e2) ;
  ADD(e1, e2, P) ;
  ADD(P, U0, P) ;

  v->origx = P[0] ;
  v->origy = P[1] ;
  v->origz = P[2] ;

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Find the face in which v lies. If it lies in more than one
  face, return not found.
  ------------------------------------------------------*/
static int
mrisFindUnambiguousFace(MRI_SURFACE *mris, MHT *mht, VERTEX *v, int *pnfound)
{
  int     nfound, flist[1000], *fptr, total_found, i, j ;
  double  dist, d ;

  for (total_found = nfound = 0, dist = -.25 ; dist <=.25 ; dist += .25)
  {
    d = dist ;
    fptr = &flist[total_found] ;
    nfound =
      mrisAllNormalDirectionCurrentTriangleIntersections(mris, v,mht,&d,fptr);
    if (nfound > 0)
    {
      for (i = 0 ; i < total_found ; i++)
      {
        for (j = 0 ; j < nfound ; j++)
        {
          if (flist[i] == fptr[j])
          {
            fptr[j] = -1 ;  /* was already found */
          }
        }
      }
      for (j = 0 ; j < nfound ; j++)
      {
        if (fptr[j] >= 0)
        {
          if (total_found == 1000)
          {
            ErrorExit(ERROR_BADPARM, "Too many ambiguous faces");
          }
          flist[total_found++] = fptr[j] ;
        }
      }
    }
  }

  *pnfound = total_found ;
  return(total_found == 1 ? flist[0] : -1) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Choose the face whose centroid is clostest to the orig position
  of v.
  ------------------------------------------------------*/
#if 1
static int
mrisChooseFace(MRI_SURFACE *mris, MHT *mht, VERTEX *v)
{
  int     fno, nfound, flist[1000], min_fno, i, j, total_found, *fptr ;
  double  dist, d ;
  float   dx, dy, dz, cx[1000], cy[1000], cz[1000], total_dist,max_dist;

  for (total_found = nfound = 0, dist = -.25 ; dist <=.25 ; dist += .25)
  {
    d = dist ;
    fptr = &flist[total_found] ;
    nfound =
      mrisAllNormalDirectionCurrentTriangleIntersections(mris, v,mht,&d,fptr);
    if (nfound > 0)
    {
      for (i = 0 ; i < total_found ; i++)
      {
        for (j = 0 ; j < nfound ; j++)
        {
          if (flist[i] == fptr[j])
          {
            fptr[j] = -1 ;  /* was already found */
          }
        }
      }
      for (j = 0 ; j < nfound ; j++)
      {
        if (fptr[j] >= 0)
        {
          if (total_found == 1000)
          {
            ErrorExit(ERROR_BADPARM, "Too many surface found");
          }
          flist[total_found++] = fptr[j] ;
        }
      }
    }
  }

  if (total_found <= 0)
  {
    return(-1) ;
  }

  /*
    use face which is furthest distance from negative faces.
  */
  max_dist = -10.0f ;
  min_fno = -1 ;

  for (i = 0 ; i < total_found ; i++)
  {
    fno = flist[i] ;
    mrisCalculateOriginalFaceCentroid(mris, fno, cx+i, cy+i, cz+i) ;
  }
  for (i = 0 ; i < total_found ; i++)
  {
    fno = flist[i] ;
    if (mris->faces[fno].area < 0)
    {
      continue ;  /* don't map it to one with negative area */
    }

    for (total_dist = 0.0, j = 0 ; j < total_found ; j++)
    {
      if (mris->faces[flist[j]].area > 0)
      {
        continue ;
      }
      dx = cx[j] - cx[i] ;
      dy = cy[j] - cy[i] ;
      dz = cz[j] - cz[i] ;
      dist = sqrt(dx*dx + dy*dy + dz*dz) ;
      total_dist += dist ;
    }
    if (total_dist > max_dist)
    {
      max_dist = dist ;
      min_fno = fno ;
    }
  }
  return(min_fno) ;
}
#else
static int
mrisChooseFace(MRI_SURFACE *mris, MHT *mht, VERTEX *v)
{
  int     fno, nfound, flist[1000], min_fno, i, j, total_found, *fptr ;
  float   x, y, z, dx, dy, dz ;
  double  dist, min_dist, d ;

  for (total_found = nfound = 0, dist = -.25 ; dist <=.25 ; dist += .25)
  {
    d = dist ;
    fptr = &flist[total_found] ;
    nfound =
      mrisAllNormalDirectionCurrentTriangleIntersections(mris, v,mht,&d,fptr);
    if (nfound > 0)
    {
      for (i = 0 ; i < total_found ; i++)
      {
        for (j = 0 ; j < nfound ; j++)
        {
          if (flist[i] == fptr[j])
          {
            fptr[j] = -1 ;  /* was already found */
          }
        }
      }
      for (j = 0 ; j < nfound ; j++)
      {
        if (fptr[j] >= 0)
        {
          if (total_found == 1000)
          {
            ErrorExit(ERROR_BADPARM, "Too many surfaces");
          }
          flist[total_found++] = fptr[j] ;
        }
      }
    }
  }

  if (total_found <= 0)
  {
    return(-1) ;
  }
  min_dist = 10000.0f ;
  min_fno = -1 ;

  for (i = 0 ; i < total_found ; i++)
  {
    fno = flist[i] ;
    mrisCalculateOriginalFaceCentroid(mris, fno, &x, &y, &z) ;
    dx = x - v->origx ;
    dy = y - v->origy ;
    dz = z - v->origz ;
    dist = sqrt(dx*dx + dy*dy + dz*dz) ;
    if (dist < min_dist)
    {
      min_dist = dist ;
      min_fno = fno ;
    }
  }
  return(min_fno) ;
}
#endif
#else
int
MRISinverseSphericalMap(MRI_SURFACE *mris, MRI_SURFACE *mris_ico)
{
  double r ;
  int    vno /*, fno, n, num*/ ;
#if 0
  VERTEX *v, *vn ;
  MHT    *mht ;
  float  x, y, z ;
#endif
  float orient ;
  static char ***flagvol, ***numvol ; /* volume of flags for neg area test */
  static float ***xvol, ***yvol, ***zvol ;
  static int allocated = 0;
  float flagvolres = 2.0, flagvolfov = 300;
  int flagvoldim,i,j;
  int ix, iy, iz ;

  MRISclearCurvature(mris) ;   /* curvature will be used to calculate sulc */
  r = MRISaverageRadius(mris) ;
  MRISscaleBrain(mris, mris, 100.0f/r) ;
  /*
  r = MRISaverageRadius(mris_ico) ; MRISscaleBrain(mris_ico,mris_ico,100.0f/r);
  */

  /*
  orig       positions are on orig
  cx,cy,cz   positions are on inflated surface
  current    positions are on sphere.
  */
  /*
  printf("begin MHTfillTableWithFaces\n");

  mht = MHTfillTableWithFaces(mris, NULL) ;

  printf("end MHTfillTableWithFaces\n");
  */

  flagvoldim = ceil(flagvolfov/flagvolres);
  if (!allocated)
  {
    fprintf(stdout, "allocating flagvol...\n") ;
    flagvol = (char ***)calloc(flagvoldim, sizeof(char **));
    numvol = (char ***)calloc(flagvoldim, sizeof(char **));
    xvol = (float ***)calloc(flagvoldim, sizeof(float **));
    yvol = (float ***)calloc(flagvoldim, sizeof(float **));
    zvol = (float ***)calloc(flagvoldim, sizeof(float **));
    for (i=0; i<flagvoldim; i++)
    {
      flagvol[i] = (char **)calloc(flagvoldim, sizeof(char *));
      numvol[i] = (char **)calloc(flagvoldim, sizeof(char *));
      xvol[i] = (float **)calloc(flagvoldim, sizeof(float *));
      yvol[i] = (float **)calloc(flagvoldim, sizeof(float *));
      zvol[i] = (float **)calloc(flagvoldim, sizeof(float *));
      for (j=0; j<flagvoldim; j++)
      {
        flagvol[i][j] = (char *)calloc(flagvoldim, sizeof(char));
        numvol[i][j] = (char *)calloc(flagvoldim, sizeof(char));
        xvol[i][j] = (float *)calloc(flagvoldim, sizeof(float));
        yvol[i][j] = (float *)calloc(flagvoldim, sizeof(float));
        zvol[i][j] = (float *)calloc(flagvoldim, sizeof(float));
      }
    }
    allocated = 1;
  }

  for (ix=0; ix<flagvoldim; ix++)
    for (iy=0; iy<flagvoldim; iy++)
      for (iz=0; iz<flagvoldim; iz++)
        numvol[ix][iy][iz] =
          xvol[ix][iy][iz] =
            yvol[ix][iy][iz] =
              zvol[ix][iy][iz] =
                flagvol[ix][iy][iz] = 0;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    orient = mris->vertices[vno].x*mris->vertices[vno].nx+
             mris->vertices[vno].y*mris->vertices[vno].ny+
             mris->vertices[vno].z*mris->vertices[vno].nz ;
    if (orient < 0)
    {
      printf("vertex %d inside out (orient = %f)\n",vno,orient);
      /*
      printf("x = (%3.1f, %3.1f,%3.1f) n = (%3.1f,%3.1f,%3.1f)\n",
      mris->vertices[vno].x,mris->vertices[vno].y,mris->vertices[vno].z,
      mris->vertices[vno].nx,mris->vertices[vno].ny,mris->vertices[vno].nz);
      */
      mris->vertices[vno].curv = 1;
    }
    else
    {
      mris->vertices[vno].curv = 0;
    }
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    ix = floor(0.5+(mris->vertices[vno].x+flagvolfov/2)/flagvolres);
    iy = floor(0.5+(mris->vertices[vno].y+flagvolfov/2)/flagvolres);
    iz = floor(0.5+(mris->vertices[vno].z+flagvolfov/2)/flagvolres);
    numvol[ix][iy][iz]++;
    xvol[ix][iy][iz] += mris->vertices[vno].cx;
    yvol[ix][iy][iz] += mris->vertices[vno].cy;
    zvol[ix][iy][iz] += mris->vertices[vno].cz;
    if (mris->vertices[vno].curv != 0) /* inverted vertex? */
    {
      flagvol[ix][iy][iz] = mris->vertices[vno].curv;
    }
  }

  for (ix=0; ix<flagvoldim; ix++)
    for (iy=0; iy<flagvoldim; iy++)
      for (iz=0; iz<flagvoldim; iz++)
        if (numvol[ix][iy][iz]>0)
        {
          xvol[ix][iy][iz] /= numvol[ix][iy][iz];
          yvol[ix][iy][iz] /= numvol[ix][iy][iz];
          zvol[ix][iy][iz] /= numvol[ix][iy][iz];
        }

  /* restore orig. vertex coords */
  for (vno = 0 ; vno < mris_ico->nvertices ; vno++)
  {
    mris_ico->vertices[vno].x = mris_ico->vertices[vno].origx;
    mris_ico->vertices[vno].y = mris_ico->vertices[vno].origy;
    mris_ico->vertices[vno].z = mris_ico->vertices[vno].origz;
  }

  for (vno = 0 ; vno < mris_ico->nvertices ; vno++)
  {
    ix = floor(0.5+(mris_ico->vertices[vno].x+flagvolfov/2)/flagvolres);
    iy = floor(0.5+(mris_ico->vertices[vno].y+flagvolfov/2)/flagvolres);
    iz = floor(0.5+(mris_ico->vertices[vno].z+flagvolfov/2)/flagvolres);
    mris_ico->vertices[vno].curv = flagvol[ix][iy][iz];
    if (mris_ico->vertices[vno].curv != 0)
    {
      mris_ico->vertices[vno].marked = 0;
      printf("ambiguous ico vertex %d\n",vno);
    }
    else
    {
      mris_ico->vertices[vno].marked = 1;
    }
    if (numvol[ix][iy][iz]>0)
    {
      mris_ico->vertices[vno].x = xvol[ix][iy][iz];
      mris_ico->vertices[vno].y = yvol[ix][iy][iz];
      mris_ico->vertices[vno].z = zvol[ix][iy][iz];
    }
    else
    {
      printf("### ico vertex %d missed volume\n",vno);
      mris_ico->vertices[vno].marked = 0;
    }
  }


  MRISsoapBubbleVertexPositions(mris_ico, 100) ;

  /*
  for (vno = 0 ; vno < mris_ico->nvertices ; vno++)
  {
  v = &mris_ico->vertices[vno] ;
  if (v->marked || v->ripflag)
  continue ;
  fno = mrisChooseFace(mris, mht, v) ;
  mrisCalculateCanonicalFaceCentroid(mris, fno, &v->x, &v->y, &v->z) ;
  }
  MHTfree(&mht) ;
  */
  return(NO_ERROR) ;
}
#endif
#define CROSS(dest,v1,v2)                       \
  dest[0]=v1[1]*v2[2]-v1[2]*v2[1];              \
  dest[1]=v1[2]*v2[0]-v1[0]*v2[2];              \
  dest[2]=v1[0]*v2[1]-v1[1]*v2[0];

#define VERTEX_DIF(leg, v0, v1)   leg[0] = v1->x-v0->x, \
    leg[1] = v1->y-v0->y,                               \
    leg[2] = v1->z-v0->z ;

#define DOT(v1,v2) (v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2])
#if 0
static float mrisComputeFaceStretch(MRI_SURFACE *mris, int fno) ;
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  mris is the original (hi-res) surface (from smoothwm).
  v is a vertex on the icosahedron.
  ------------------------------------------------------*/
static int
mrisChooseFace(MRI_SURFACE *mris, MHT *mht, VERTEX *v)
{
  int    i, /*fno,*/ flist[10000], nfaces, min_fno = 0, l ;
  MHBT   *bucket, bucket_bak  ;
  MHB    *bin ;
  FACE   *f ;
  VERTEX *v1, *v2, *v3 ;
  float  /*ut, vt, stretch,*/ n[3], leg[3], p[3], d[3], dot, ldot, leg2[3] ;

  bucket = MHTgetBucket(mht, v->x, v->y, v->z) ;
  bucket_bak = *bucket ;
  bin = bucket->bins ;
  for (nfaces = i = 0 ; i < bucket->nused ; i++, bin++)  /* check each face */
  {
    n[0] = n[1] = n[2] = 0.0f ;
    f = &mris->faces[bin->fno] ;
    for (l = 0 ; l < VERTICES_PER_FACE ; l++)
    {
      v1 = &mris->vertices[f->v[l]] ;
      n[0] += v1->nx ;
      n[1] += v1->ny ;
      n[2] += v1->nz ;
    }
    n[0] /= VERTICES_PER_FACE ;
    n[1] /= VERTICES_PER_FACE ;
    n[2] /= VERTICES_PER_FACE ;
    for (l = 0 ; l < VERTICES_PER_FACE ; l++)
    {
      v1 = &mris->vertices[f->v[l]] ;
      switch (l)
      {
      default:
      case 0:
        v2 = &mris->vertices[f->v[1]] ;
        v3 = &mris->vertices[f->v[2]] ;
        break ;
      case 1:
        v2 = &mris->vertices[f->v[2]] ;
        v3 = &mris->vertices[f->v[0]] ;
        break ;
      case 2:
        v2 = &mris->vertices[f->v[0]] ;
        v3 = &mris->vertices[f->v[1]] ;
        break ;
      }

      VERTEX_DIF(leg, v1, v2) ;   /* leg of triangle */
      VERTEX_DIF(leg2, v1, v3) ;  /* leg of triangle */

      /* express p as point in triangle plane */
      VERTEX_DIF(p, v1, v) ;     /* vector from vertex to point in question */
      dot = DOT(p,n) ;
      p[0] -= dot*n[0] ;
      p[1] -= dot*n[1] ;
      p[2] -= dot*n[2] ;
#if 0
      p[0] = ut*leg[0] + vt*leg2[0] ;
      p[1] = ut*leg[1] + vt*leg2[1] ;
      p[2] = ut*leg[2] + vt*leg2[2] ;
      ut = DOT(p, leg) ;
      vt = DOT(p, leg2) ;
#endif

      CROSS(d, leg, n) ;
      dot = DOT(d, p) ;
      ldot = DOT(d, leg2) ;

      /* on different side of leg from 3rd vertex */
      if (!FZERO(ldot) && !FZERO(dot) && dot*ldot < 0)
      {
        break ;
      }
    }
    if (l >= VERTICES_PER_FACE)
    {
      if (nfaces == 10000)
      {
        ErroExit(ERROR_BADPARM, "Too many faces");
      }
      flist[nfaces++] = bin->fno ;
    }
  }
  if (!nfaces)  /* something went wrong, but Anders will fix it */
  {
    float dist, min_dist ;

    fprintf(stderr, "no faces found on sphere!\n") ;
    bin = bucket->bins ;
    min_dist = 1000000.0f ;
    min_fno = 0 ;
    for (nfaces = i = 0 ; i < bucket->nused ; i++, bin++)
    {
      f = &mris->faces[bin->fno] ;
      v1 = &mris->vertices[f->v[0]] ;
      v2 = &mris->vertices[f->v[1]] ;
      v3 = &mris->vertices[f->v[2]] ;
#define VDIST(v1,v2) (sqrt(SQR(v1->x-v2->x)+SQR(v1->y-v2->y)+SQR(v1->z-v2->z)))
      dist = VDIST(v1,v) + VDIST(v2, v) + VDIST(v3,v) ;
      if (dist < min_dist)
      {
        min_dist = dist ;
        min_fno = bin->fno ;
      }
    }
  }
  else   /* pix the face that is closest to the soap bubble location */
  {
    float min_dist, x, y, z, dist, curv ;

    if (nfaces > 1)
    {
      DiagBreak() ;
      curv = 1.0f ;
    }
    else
    {
      curv = 0.0f ;
    }
    for ( i = 0 ; i < nfaces ; i++)/* check each face */
    {
      f = &mris->faces[flist[i]] ;
      for (l = 0 ; l < VERTICES_PER_FACE ; l++)
      {
        mris->vertices[f->v[l]].curv = curv ;
      }
    }

    min_dist = 100000.0f ;
    for (i = 0 ; i < nfaces ; i++)
    {
      mrisCalculateCanonicalFaceCentroid(mris, flist[i], &x, &y, &z) ;
      dist = sqrt(SQR(v->x-x)+SQR(v->y-y)+SQR(v->z-z)) ;
      if (dist < min_dist)
      {
        min_dist = dist ;
        min_fno = flist[i] ;
      }
    }
  }
  return(min_fno) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Scale a surface anisotropically.
  ------------------------------------------------------*/
static int
mrisFindUnambiguousFace(MRI_SURFACE *mris, MHT *mht, VERTEX *v)
{
  int    i, /*fno,*/ flist[10000], nfaces, min_fno = 0, l ;
  MHBT   *bucket ;
  MHB    *bin ;
  FACE   *f ;
  VERTEX *v1, *v2, *v3 ;
  float  /*ut, vt, */stretch, n[3], leg[3], p[3], d[3], dot, ldot, leg2[3] ;

  bucket = MHTgetBucket(mht, v->x, v->y, v->z) ;
  bin = bucket->bins ;
  for (nfaces = i = 0 ; i < bucket->nused ; i++, bin++)  /* check each face */
  {
    n[0] = n[1] = n[2] = 0.0f ;
    f = &mris->faces[bin->fno] ;
    for (l = 0 ; l < VERTICES_PER_FACE ; l++)
    {
      v1 = &mris->vertices[f->v[l]] ;
      n[0] += v1->nx ;
      n[1] += v1->ny ;
      n[2] += v1->nz ;
    }
    n[0] /= VERTICES_PER_FACE ;
    n[1] /= VERTICES_PER_FACE ;
    n[2] /= VERTICES_PER_FACE ;
    for (l = 0 ; l < VERTICES_PER_FACE ; l++)
    {
      v1 = &mris->vertices[f->v[l]] ;
      switch (l)
      {
      default:
      case 0:
        v2 = &mris->vertices[f->v[1]] ;
        v3 = &mris->vertices[f->v[2]] ;
        break ;
      case 1:
        v2 = &mris->vertices[f->v[2]] ;
        v3 = &mris->vertices[f->v[0]] ;
        break ;
      case 2:
        v2 = &mris->vertices[f->v[0]] ;
        v3 = &mris->vertices[f->v[1]] ;
        break ;
      }

      VERTEX_DIF(leg, v1, v2) ;   /* leg of triangle */
      VERTEX_DIF(leg2, v1, v3) ;  /* leg of triangle */

      /* express p as point in triangle plane */
      VERTEX_DIF(p, v1, v) ;     /* vector from vertex to point in question */
      dot = DOT(p,n) ;
      p[0] -= dot*n[0] ;
      p[1] -= dot*n[1] ;
      p[2] -= dot*n[2] ;
#if 0
      p[0] = ut*leg[0] + vt*leg2[0] ;
      p[1] = ut*leg[1] + vt*leg2[1] ;
      p[2] = ut*leg[2] + vt*leg2[2] ;
      ut = DOT(p, leg) ;
      vt = DOT(p, leg2) ;
#endif

      CROSS(d, leg, n) ;
      dot = DOT(d, p) ;
      ldot = DOT(d, leg2) ;

      /* on different side of leg from 3rd vertex */
      if (!FZERO(ldot) && !FZERO(dot) && dot*ldot < 0)
      {
        break ;
      }
    }
    if (l >= VERTICES_PER_FACE)
    {
      if (nfaces == 10000)
      {
        ErrorExit(ERROR_BADPARM, "Too many faces");
      }
      flist[nfaces++] = bin->fno ;
    }
  }
  if (!nfaces)
  {
    float dist, min_dist ;

    fprintf(stderr, "no faces found on sphere!\n") ;
    bin = bucket->bins ;
    min_dist = 1000000.0f ;
    min_fno = 0 ;
    for (nfaces = i = 0 ; i < bucket->nused ; i++, bin++)
    {
      f = &mris->faces[bin->fno] ;
      v1 = &mris->vertices[f->v[0]] ;
      v2 = &mris->vertices[f->v[1]] ;
      v3 = &mris->vertices[f->v[2]] ;
#define VDIST(v1,v2) (sqrt(SQR(v1->x-v2->x)+SQR(v1->y-v2->y)+SQR(v1->z-v2->z)))
      dist = VDIST(v1,v) + VDIST(v2, v) + VDIST(v3,v) ;
      if (dist < min_dist)
      {
        min_dist = dist ;
        min_fno = bin->fno ;
      }
    }
    printf("min_dist = %f (min_fno=%d)\n",min_dist,min_fno);

  }
  else
  {
    float min_stretch, curv ;

    if (nfaces > 1)
    {
      DiagBreak() ;
      curv = 1.0f ;
    }
    else
    {
      curv = 0.0f ;
    }
    for ( i = 0 ; i < nfaces ; i++)/* check each face */
    {
      f = &mris->faces[flist[i]] ;
      for (l = 0 ; l < VERTICES_PER_FACE ; l++)
      {
        mris->vertices[f->v[l]].curv = curv ;
      }
    }

    min_stretch = 100000.0f ;
    for (i = 0 ; i < nfaces ; i++)
    {
      stretch = mrisComputeFaceStretch(mris, flist[i]) ;
      if (stretch < min_stretch)
      {
        min_stretch = stretch ;
        min_fno = flist[i] ;
      }
    }
  }
  if (nfaces <= 1)
  {
    return(min_fno) ;
  }
  else
  {
    return(-1) ;
  }
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Scale a surface anisotropically.
  ------------------------------------------------------*/
static float
mrisComputeFaceStretch(MRI_SURFACE *mris, int fno)
{
  int    fv, n0, n1 ;
  float  stretch, max_stretch, dist, inflated_dist ;
  FACE   *f ;
  VERTEX *v0, *v1 ;

  f = &mris->faces[fno] ;
  max_stretch = -1.0f ;
  for (fv = 0 ; fv < VERTICES_PER_FACE ; fv++)
  {
    n0 = f->v[fv] ;
    n1 = fv < VERTICES_PER_FACE - 1 ? f->v[fv+1] : f->v[0] ;
    v0 = &mris->vertices[n0] ;
    v1 = &mris->vertices[n1] ;
    inflated_dist =
      SQR(v0->cx-v1->cx) + SQR(v0->cy-v1->cy) + SQR(v0->cz-v1->cz);
    dist =
      SQR(v0->origx-v1->origx) +
      SQR(v0->origy-v1->origy) + SQR(v0->origz-v1->origz);
    if (!FZERO(dist))
    {
      stretch = inflated_dist / dist ;
      if (stretch > max_stretch)
      {
        max_stretch = stretch ;
      }
    }
  }
  return(max_stretch) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Scale a surface anisotropically.
  ------------------------------------------------------*/
static int
mrisCalculateCanonicalFaceCentroid(MRI_SURFACE *mris, int fno,
                                   float *px, float *py, float *pz)
{
  float  x, y, z ;
  VERTEX *v0, *v1, *v2 ;
  FACE   *f ;

  f = &mris->faces[fno] ;
  v0 = &mris->vertices[f->v[0]] ;
  v1 = &mris->vertices[f->v[1]] ;
  v2 = &mris->vertices[f->v[2]] ;

  /* first bisect v1->v2 line */

  x = (v1->cx + v2->cx) / 2.0f ;
  y = (v1->cy + v2->cy) / 2.0f ;
  z = (v1->cz + v2->cz) / 2.0f ;

  /* now bisect v0->bisector line */
  *px = (v0->cx + x) / 2.0f ;
  *py = (v0->cy + y) / 2.0f ;
  *pz = (v0->cz + z) / 2.0f ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Scale a surface anisotropically.
  ------------------------------------------------------*/
static int
mrisCalculateOriginalFaceCentroid(MRI_SURFACE *mris, int fno,
                                  float *px, float *py, float *pz)
{
  float  x, y, z ;
  VERTEX *v0, *v1, *v2 ;
  FACE   *f ;

  f = &mris->faces[fno] ;
  v0 = &mris->vertices[f->v[0]] ;
  v1 = &mris->vertices[f->v[1]] ;
  v2 = &mris->vertices[f->v[2]] ;

  /* first bisect v1->v2 line */

  x = (v1->origx + v2->origx) / 2.0f ;
  y = (v1->origy + v2->origy) / 2.0f ;
  z = (v1->origz + v2->origz) / 2.0f ;

  /* now bisect v0->bisector line */
  *px = (v0->origx + x) / 2.0f ;
  *py = (v0->origy + y) / 2.0f ;
  *pz = (v0->origz + z) / 2.0f ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Scale a surface anisotropically.
  ------------------------------------------------------*/
static int
mrisCalculateFaceCentroid(MRI_SURFACE *mris, int fno, float *px, float *py,
                          float *pz)
{
  float  x, y, z ;
  VERTEX *v0, *v1, *v2 ;
  FACE   *f ;

  f = &mris->faces[fno] ;
  v0 = &mris->vertices[f->v[0]] ;
  v1 = &mris->vertices[f->v[1]] ;
  v2 = &mris->vertices[f->v[2]] ;

  /* first bisect v1->v2 line */

  x = (v1->x + v2->x) / 2.0f ;
  y = (v1->y + v2->y) / 2.0f ;
  z = (v1->z + v2->z) / 2.0f ;

  /* now bisect v0->bisector line */
  *px = (v0->x + x) / 2.0f ;
  *py = (v0->y + y) / 2.0f ;
  *pz = (v0->z + z) / 2.0f ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Scale a surface anisotropically.
  ------------------------------------------------------*/
int
MRISprintTessellationStats(MRI_SURFACE *mris, FILE *fp)
{
  double  mean, dsigma, dmin, dmax ;
  int     vno, vno2 ;

  mean = MRIScomputeVertexSpacingStats(mris, &dsigma, &dmin,&dmax,&vno,&vno2, CURRENT_VERTICES) ;
  fprintf(fp, "vertex spacing %2.2f +- %2.2f (%2.2f-->%2.2f) "
          "(max @ vno %d --> %d)\n",
          mean, dsigma, dmin, dmax, vno, vno2) ;
  mean = MRIScomputeFaceAreaStats(mris, &dsigma, &dmin, &dmax) ;
  fprintf(fp, "face area %2.2f +- %2.2f (%2.2f-->%2.2f)\n",
          mean, dsigma, dmin, dmax) ;

  if (dmax > 20)
  {
    VERTEX  *v, *vn ;
    int     n ;
    float   dist ;

    v = &mris->vertices[vno] ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dist = sqrt(SQR(vn->x - v->x) + SQR(vn->y - v->y) + SQR(vn->z - v->z));
      if (dist > 20)
      {
        fprintf(stdout, "\t%d --> %d = %2.1f mm\n", vno, v->v[n], dist) ;
      }
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static void
mrisDumpFace(MRI_SURFACE *mris, int fno, FILE *fp)
{
  FACE   *f ;
  VERTEX *v ;
  int    n ;

  f = &mris->faces[fno] ;
  fprintf(fp, "face %d, area %2.1f, orig area %2.1f\n",
          fno, f->area, f->orig_area) ;
  for (n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    v = &mris->vertices[f->v[n]] ;
    fprintf(fp,"\tv %d (%d) @ (%2.1f, %2.1f, %2.1f) o (%2.1f, %2.1f, %2.1f)\n",
            n, f->v[n], v->x, v->y, v->z, v->origx, v->origy, v->origz) ;
  }
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisStoreVtotalInV3num(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->v3num = v->vtotal ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISripDefectiveFaces(MRI_SURFACE *mris)
{
  FACE   *f ;
  int    fno, flist[1000], retained_i, i, j, nfaces, nripped, n ;
  double dist, min_face_dist, max_dist, r ;
  float  dx, dy, dz, cx[1000], cy[1000], cz[1000] ;
  MHT    *mht ;

  MRISclearCurvature(mris) ;
  r = MRISaverageRadius(mris) ;
  MRISscaleBrain(mris, mris, 100.0/r) ; //TO BE CHECKED
  mht = MHTfillTable(mris, NULL) ;

  /*
    first remove all faces with negative areas as they will be
    the 'underside' of a defect.
  */
#if 0
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    if (mris->faces[177616].v[2] > mris->nfaces)
    {
      DiagBreak() ;
    }
    f = &mris->faces[fno] ;
    if (f->ripflag)
    {
      continue ;
    }
    if (f->area < 0)
    {
      f->ripflag = 1 ;  /* part of a defect! */
      if (Gdiag & DIAG_SHOW)
      {
        fprintf(stdout, "ripping face %d\n", fno) ;
      }
      nripped++ ;
      for (i = 0 ; i < VERTICES_PER_FACE ; i++)
      {
        mris->vertices[f->v[i]].curv = -2.0f ;
      }
    }
  }
#endif
  for (nripped = fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    if (f->ripflag)
    {
      continue ;
    }
    nfaces = mrisFindAllOverlappingFaces(mris, mht, fno, flist) ;
    if (nfaces > 1)   /* overlapping faces - rip all but one of them */
    {
      /* retain the face that is furthest from any negative face */
      max_dist = 0.0f ;
      for (i = 0 ; i < nfaces ; i++)
      {
        mrisCalculateFaceCentroid(mris, flist[i], cx+i, cy+i, cz+i) ;
      }
      for (retained_i = -1, i = 0 ; i < nfaces ; i++)
      {
        if (mris->faces[flist[i]].area < 0)
        {
          continue ;  /* don't ever retain a negative face */
        }

        /* find the distance to the closest negative face */
        for (min_face_dist = 1000000.0, j = 0 ; j < nfaces ; j++)
        {
          if (mris->faces[flist[j]].area > 0)
          {
            continue ;  /* only consider distances to negative faces */
          }
          dx = cx[j] - cx[i] ;
          dy = cy[j] - cy[i] ;
          dz = cz[j] - cz[i] ;
          dist = (dx*dx+dy*dy+dz*dz) ;
          if (dist < min_face_dist)
          {
            min_face_dist = dist ;
          }
        }

        /*
          if this face is more distant than any other face to a negative
          face (so far), tentatively mark it as the one to keep.
        */
        if (min_face_dist > max_dist)
        {
          max_dist = min_face_dist ;
          retained_i = i ;
        }
      }

      if (retained_i >= 0) for (i = 0 ; i < nfaces ; i++)
        {
          VERTEX *v ;
          FACE   *f ;

          f = &mris->faces[flist[i]] ;
          if (i == retained_i)
          {
            for (n = 0 ; n < VERTICES_PER_FACE ; n++)
            {
              v = &mris->vertices[f->v[n]] ;
              if (FZERO(v->curv))
              {
                v->curv = 1.0 ;  /* good part of a defect! */
              }
            }
          }

          if (i == retained_i || f->ripflag)
          {
            continue ;
          }
          f->ripflag = 1 ;  /* part of a defect! */
          if (Gdiag & DIAG_SHOW)
          {
            fprintf(stdout, "ripping face %d\n", flist[i]) ;
          }
          nripped++ ;
          for (n = 0 ; n < VERTICES_PER_FACE ; n++)
          {
            v = &mris->vertices[f->v[n]] ;
            if (v->curv >= 0.0)
            {
              v->curv = f->area > 0 ? -1.0 : -2.0 ;
            }
          }
        }
    }
  }

  MRISscaleBrain(mris, mris, r/100.0) ;
  fprintf(stdout, "removing %d ripped faces from tessellation\n", nripped) ;
#if 0
  mrisRipVertices(mris) ;
#else
  {
#if 0
    int vno ;

    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      v->curv = 0 ;
      for (fno = 0 ; fno < v->num ; fno++)
      {
        f = &mris->faces[v->f[fno]] ;
        if (f->ripflag == 1)
        {
          v->curv = -1 ;
          break ;
        }
        else if (f->ripflag == 2)
        {
          v->curv = 1.0 ;
        }
      }
    }
#endif
    MRISwriteCurvature(mris, "defects") ;
  }
#endif
  /*  MRISremoveRipped(mris) ;*/
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int edgesIntersect(MRI_SURFACE *mris, EDGE *edge1, EDGE *edge2) ;
static int edgesIntersectStable(MRI_SURFACE *mris, EDGE *edge1, EDGE *edge2) ;

#if SPHERE_INTERSECTION

/* check for intersection on the sphere */
static int edgesIntersect(MRI_SURFACE *mris, EDGE *edge1, EDGE *edge2)
{
  VERTEX *v1, *v2 ;
  double n0[3],n1[3],n2[3],u0[3],u1[3],u2[3],u3[3],u[3];
  double a0,a1,a2,a3,a,b;

  //first test if some vertices are the same
  if (edge1->vno1 == edge2->vno1 || edge1->vno1 == edge2->vno2 ||
      edge1->vno2 == edge2->vno1 || edge1->vno2 == edge2->vno2)
  {
    return(0) ;
  }

  //INTERSECTION ONTO THE SPHERE

  //compute normals
  v1 = &mris->vertices[edge1->vno1] ;
  v2 = &mris->vertices[edge1->vno2] ;
  u0[0]=v1->cx;
  u0[1]=v1->cy;
  u0[2]=v1->cz;
  u1[0]=v2->cx;
  u1[1]=v2->cy;
  u1[2]=v2->cz;
  F_CROSS(u0,u1,n0);

  v1 = &mris->vertices[edge2->vno1] ;
  v2 = &mris->vertices[edge2->vno2] ;
  u2[0]=v1->cx;
  u2[1]=v1->cy;
  u2[2]=v1->cz;
  u3[0]=v2->cx;
  u3[1]=v2->cy;
  u3[2]=v2->cz;
  F_CROSS(u2,u3,n1);

  a0=F_DOT(u0,n1);
  a1=F_DOT(u1,n1);
  a2=F_DOT(u2,n0);
  a3=F_DOT(u3,n0);


  //if a0,a1, a2, or a3 are very small,
  //should definitely use edgesIntersectStable instead
#define SMALL_VALUES 0.0000001
  if (fabs(a0)<SMALL_VALUES ||
      fabs(a1)<SMALL_VALUES ||
      fabs(a2)<SMALL_VALUES ||
      fabs(a3)<SMALL_VALUES)
  {
    return edgesIntersectStable(mris,edge1,edge2);
  }

  a=a0*a1;
  b=a2*a3;

  if (a>0)
  {
    return(0);
  }
  else if (a<0)
  {
    //      fprintf(stderr,"-");
    if (b>0)
    {
      return(0);
    }
    else
    {
      return(1);
    }
  }
  else
  {
    //    fprintf(stderr,"+");
    if (b>0)
    {
      return(0);
    }
    else if (b<0)
    {
      return(1);
    }
    else
    {
      //special case again! The points are exactly aligned...
      double c0,c1,c2,c3,x1_min,x1_max,x2_min,x2_max;

#if 0
      fprintf(stderr,"^");
      {

        int r1,r2;
        r1=sphereEdgesIntersect(mris,edge1,edge2);
        r2=newEdgesIntersect3(mris,edge1,edge2);

        fprintf(stderr,"%d-%d",r1,r2);

        if (r1!=r2)
        {
          debugEdgesIntersect(mris,edge1,edge2);
        }

      }
#endif

      u[0]=(u0[0]+u1[0]+u2[0]+u3[0]);
      u[1]=(u0[1]+u1[1]+u2[1]+u3[1]);
      u[2]=(u0[2]+u1[2]+u2[2]+u3[2]);

      F_CROSS(u,n0,n2);

      c0=F_DOT(u0,n2);
      c1=F_DOT(u1,n2);
      c2=F_DOT(u2,n2);
      c3=F_DOT(u3,n2);

      x1_min=MIN(c0,c1);
      x1_max=MAX(c0,c1);
      x2_min=MIN(c2,c3);
      x2_max=MAX(c2,c3);

      return (x2_max >= x1_min && x2_min <= x1_max) ;
    }
  }
  return(0) ;
}

/* it should be a more stable implementation but a bit
   slower than the previous one */
static int edgesIntersectStable(MRI_SURFACE *mris, EDGE *edge1, EDGE *edge2)
{
  VERTEX *v1, *v2 ;
  double n0[3],n1[3],n2[3],u0[3],u1[3],u2[3],u3[3],u[3];
  double og0[3],og1[3],v_0[3],v_1[3];
  double a0,a1,a2,a3,a,b;

  //first test if some vertices are the same
  if (edge1->vno1 == edge2->vno1 || edge1->vno1 == edge2->vno2 ||
      edge1->vno2 == edge2->vno1 || edge1->vno2 == edge2->vno2)
  {
    return(0) ;
  }

  //INTERSECTION ONTO THE SPHERE
  v1 = &mris->vertices[edge1->vno1] ;
  v2 = &mris->vertices[edge1->vno2] ;
  og0[0]=(v1->cx+v2->cx)/2.0;
  og0[1]=(v1->cy+v2->cy)/2.0;
  og0[2]=(v1->cz+v2->cz)/2.0;

  //compute tangent vector
  v_0[0]=(v2->cx-v1->cx);
  v_0[1]=(v2->cy-v1->cy);
  v_0[2]=(v2->cz-v1->cz);


  //compute normal
  F_CROSS(og0,v_0,n0);

  v1 = &mris->vertices[edge2->vno1] ;
  v2 = &mris->vertices[edge2->vno2] ;
  og1[0]=(v1->cx+v2->cx)/2.0;
  og1[1]=(v1->cy+v2->cy)/2.0;
  og1[2]=(v1->cz+v2->cz)/2.0;

  //compute tangent vector
  v_1[0]=(v2->cx-v1->cx);
  v_1[1]=(v2->cy-v1->cy);
  v_1[2]=(v2->cz-v1->cz);

  //compute normal
  F_CROSS(og1,v_1,n1);

  //compute vectors
  v1 = &mris->vertices[edge1->vno1] ;
  v2 = &mris->vertices[edge1->vno2] ;
  u0[0]=v1->cx-og1[0];
  u0[1]=v1->cy-og1[1];
  u0[2]=v1->cz-og1[2];
  u1[0]=v2->cx-og1[0];
  u1[1]=v2->cy-og1[1];
  u1[2]=v2->cz-og1[2];
  v1 = &mris->vertices[edge2->vno1] ;
  v2 = &mris->vertices[edge2->vno2] ;
  u2[0]=v1->cx-og0[0];
  u2[1]=v1->cy-og0[1];
  u2[2]=v1->cz-og0[2];
  u3[0]=v2->cx-og0[0];
  u3[1]=v2->cy-og0[1];
  u3[2]=v2->cz-og0[2];

  a0=F_DOT(u0,n1);
  a1=F_DOT(u1,n1);
  a2=F_DOT(u2,n0);
  a3=F_DOT(u3,n0);

  a=a0*a1;
  b=a2*a3;

  if (a>0)
  {
    return(0);
  }
  else if (a<0)
  {
    if (b>0)
    {
      return(0);
    }
    else
    {
      return(1);
    }
  }
  else
  {
    //    fprintf(stderr,"+");
    if (b>0)
    {
      return(0);
    }
    else if (b<0)
    {
      return(1);
    }
    else
    {
      //special case again! The points are exactly aligned...
      double c0,c1,c2,c3,x1_min,x1_max,x2_min,x2_max;

      //fprintf(stderr,"-");

      u[0]=(u0[0]+u1[0]+u2[0]+u3[0]);
      u[1]=(u0[1]+u1[1]+u2[1]+u3[1]);
      u[2]=(u0[2]+u1[2]+u2[2]+u3[2]);

      F_CROSS(u,n0,n2);

      c0=F_DOT(u0,n2);
      c1=F_DOT(u1,n2);
      c2=F_DOT(u2,n2);
      c3=F_DOT(u3,n2);

      x1_min=MIN(c0,c1);
      x1_max=MAX(c0,c1);
      x2_min=MIN(c2,c3);
      x2_max=MAX(c2,c3);

      return (x2_max >= x1_min && x2_min <= x1_max) ;
    }
  }
  return(0) ;
}

#else
/* original version */
static int
edgesIntersect(MRI_SURFACE *mris, EDGE *edge1, EDGE *edge2)
{
  VERTEX *v1, *v2 ;
  double  b1, b2, m1, m2, x1_start, x1_end, y1_start, y1_end,
          x2_start, x2_end, y2_start, y2_end, x, y, x1min, x1max,
          y1min, y1max, x2min, x2max, y2min, y2max, cx, cy, cz ;
  double origin[3], e0[3], e1[3], e0_0, e0_1, e0_2, e1_0, e1_1, e1_2 ;

  if (edge1->vno1 == edge2->vno1 || edge1->vno1 == edge2->vno2 ||
      edge1->vno2 == edge2->vno1 || edge1->vno2 == edge2->vno2)
  {
    return(0) ;
  }

  mrisComputeCanonicalEdgeBasis(mris, edge1, edge2,origin,e0,e1);
  e0_0 = e0[0] ;
  e0_1 = e0[1] ;
  e0_2 = e0[2] ;
  e1_0 = e1[0] ;
  e1_1 = e1[1] ;
  e1_2 = e1[2] ;
  if (edge1->vno1 == Gdiag_no || edge2->vno1 == Gdiag_no ||
      edge1->vno2 == Gdiag_no || edge2->vno2 == Gdiag_no)
  {
    DiagBreak() ;
  }
  v1 = &mris->vertices[edge1->vno1] ;
  v2 = &mris->vertices[edge1->vno2] ;
  cx = v1->cx - origin[0] ;
  cy = v1->cy - origin[1] ;
  cz = v1->cz - origin[2] ;
  x1_start = cx*e0_0 + cy*e0_1 + cz*e0_2 ;
  y1_start = cx*e1_0 + cy*e1_1 + cz*e1_2 ;
  cx = v2->cx - origin[0] ;
  cy = v2->cy - origin[1] ;
  cz = v2->cz - origin[2] ;
  x1_end = cx*e0_0 + cy*e0_1 + cz*e0_2 ;
  y1_end = cx*e1_0 + cy*e1_1 + cz*e1_2 ;
  x1min = MIN(x1_start, x1_end) ;
  x1max = MAX(x1_start, x1_end) ;
  y1min = MIN(y1_start, y1_end) ;
  y1max = MAX(y1_start, y1_end) ;
  if (!FEQUAL(x1_start, x1_end))
  {
    m1 = (y1_end - y1_start) / (x1_end - x1_start) ;
    b1 = y1_end - m1 * x1_end ;
  }
  else
  {
    m1 = b1 = 0 ;  /* will be handled differently */
  }

  v1 = &mris->vertices[edge2->vno1] ;
  v2 = &mris->vertices[edge2->vno2] ;
  cx = v1->cx-origin[0] ;
  cy = v1->cy-origin[1] ;
  cz = v1->cz-origin[2];
  x2_start = cx*e0_0 + cy*e0_1 + cz*e0_2 ;
  y2_start = cx*e1_0 + cy*e1_1 + cz*e1_2 ;
  cx = v2->cx-origin[0] ;
  cy = v2->cy-origin[1] ;
  cz = v2->cz-origin[2];
  x2_end = cx*e0_0 + cy*e0_1 + cz*e0_2 ;
  y2_end = cx*e1_0 + cy*e1_1 + cz*e1_2 ;
  x2min = MIN(x2_start, x2_end) ;
  x2max = MAX(x2_start, x2_end) ;
  y2min = MIN(y2_start, y2_end) ;
  y2max = MAX(y2_start, y2_end) ;
#if 0
#define INT_EPSILON 0.000
  x1max += INT_EPSILON ;
  y1max += INT_EPSILON ;
  x2max += INT_EPSILON ;
  y2max += INT_EPSILON ;
  x1min -= INT_EPSILON ;
  y1min -= INT_EPSILON ;
  x2min -= INT_EPSILON ;
  y2min -= INT_EPSILON ;
#endif

#if 1
  /* non-overlapping intervals can't intersect */
  if (x1min > x2max || x1max < x2min || y1min > y2max || y1max < y2min)
  {
    return(0) ;
  }
#endif

  /* handle special cases first */
  if (FEQUAL(x1_start, x1_end))        /* l1 is vertical */
  {
    if (FEQUAL(x2_start, x2_end))      /* both vertical */
    {
      return (FEQUAL(x1_start, x2_start)) ;  /* same line */
    }
    m2 = (y2_end - y2_start) / (x2_end - x2_start) ;
    b2 = y2_end - m2 * x2_end ;
    y = m2 * x1_start + b2 ;           /* y coordinate of intersection */
    if (y >= y1min && y <= y1max)
    {
      return(1) ;
    }
  }
  else if (FEQUAL(x2_start, x2_end))   /* l2 is vertical */
  {
    if (FEQUAL(x1_start, x1_end))      /* both vertical */
    {
      return (FEQUAL(x1_start, x2_start)) ;  /* same line */
    }
    y = m1 * x2_start + b1 ;  /* y coord of intersection */
    if (y >= y2min && y <= y2max)
    {
      return(1) ;
    }
  }
  else    /* neither line is vertical, compute intersection point */
  {

    m2 = (y2_end - y2_start) / (x2_end - x2_start) ;
    b2 = y2_end - m2 * x2_end ;
    if (FEQUAL(m1, m2))                /* parallel lines */
    {
      if (FEQUAL(b1, b2))  /* same line, see if segments overlap */
      {
        return(x2max >= x1min && x2min <= x1max) ;
      }
      return(0) ;
    }
    x = (b2 - b1) / (m1-m2) ;            /* intersection point */
    if ((x <= x1max && x >= x1min) &&    /* is it in l1 interval? */
        (x <= x2max && x >= x2min))      /* is it in l2 interval? */
    {
      return(1) ;  /* both true - intersection */
    }
  }
  return(0) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisFindAllOverlappingFaces(MRI_SURFACE *mris, MHT *mht,int fno, int *flist)
{
  double   x0, x1, y0, y1, z0, z1, x, y, z ;
  int     i, n, m, total_found, all_faces[100000], nfaces ;
  MHBT    *bucket, *last_bucket ;
  MHB     *bin ;
  EDGE    edge1, edge2 ;
  FACE    *f1, *f2 ;
  VERTEX  *v ;


  f1 = &mris->faces[fno] ;
  if (fno == Gdiag_no)
  {
    DiagBreak() ;
  }
  x0 = y0 = z0 = 100000.0 ;
  x1 = y1 = z1 = -x0 ;
  for (n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    v = &mris->vertices[f1->v[n]] ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
    x0 = MIN(x, x0) ;
    y0 = MIN(y, y0) ;
    z0 = MIN(z, z0) ;
    x1 = MAX(x, x1) ;
    y1 = MAX(y, y1) ;
    z1 = MAX(z, z1) ;
  }

  nfaces = total_found = 0 ;
  flist[total_found++] = fno ;
  last_bucket = NULL ;
  for (x = x0 ; x <= x1 ; x += 0.5)
    for (y = y0 ; y <= y1 ; y += 0.5)
      for (z = z0 ; z <= z1 ; z += 0.5)
      {
        bucket = MHTgetBucket(mht, x, y, z) ;
        if (!bucket || bucket == last_bucket)
        {
          continue ;
        }
        last_bucket = bucket ;
        for (bin = bucket->bins, i = 0 ; i < bucket->nused ; i++, bin++)
        {
          f2 = &mris->faces[bin->fno] ;
          if (!f2->ripflag)  /* only add it once */
          {
            if (nfaces == 100000)
            {
              ErrorExit(ERROR_BADPARM, "Too many faces");
            }
            all_faces[nfaces++] = bin->fno ;
            f2->ripflag = 1 ;
          }
        }
      }
  for (i = 0 ; i < nfaces ; i++)     /* reset ripflag */
  {
    mris->faces[all_faces[i]].ripflag = 0 ;
  }

  for (i = 0 ; i < nfaces ; i++)
  {
    if (i == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (all_faces[i] < 0)  /* duplicate */
    {
      continue ;
    }
    f2 = &mris->faces[all_faces[i]] ;
    if (all_faces[i] == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      edge1.vno1 = f1->v[n] ;
      edge1.vno2 = f1->v[n == VERTICES_PER_FACE-1 ? 0 : n+1] ;
      for (m = 0 ; m < VERTICES_PER_FACE ; m++)
      {
        if (f2->ripflag)
        {
          continue ;
        }
        edge2.vno1 = f2->v[m] ;
        edge2.vno2 = f2->v[m == VERTICES_PER_FACE-1 ? 0 : m+1] ;
        if (edge2.vno1 == edge1.vno1 || edge2.vno1 == edge1.vno2 ||
            edge2.vno2 == edge1.vno1 || edge2.vno2 == edge1.vno2)
        {
          continue ;
        }
        if (edgesIntersect(mris, &edge1, &edge2))
        {
          f2->ripflag = 1 ;  /* use ripflag as a mark */
          if (total_found==1000)
            ErrorExit
            (ERROR_BADPARM,
             "Too many intersected faces for face %d (%d, %d, %d)",
             fno, f1->v[0], f1->v[1], f1->v[2]);
          flist[total_found++] = all_faces[i] ;
        }
      }
    }
  }

  for (i = 0 ; i < total_found ; i++)
  {
    f1 = &mris->faces[flist[i]] ;
    f1->ripflag = 0 ;
  }

  return(total_found) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  restore ripflag to 0 (NOTE: Won't undo MRISremoveRipped!!)
  ------------------------------------------------------*/
int
MRISunrip(MRI_SURFACE *mris)
{
  int    vno, fno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].ripflag = 0 ;
  }
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    mris->faces[fno].ripflag = 0 ;
  }
  return(NO_ERROR) ;
}

////////////////////////////////////////////////////////////////
// GENETIC ALGORITHM AND OTHER RETESSELLATION METHODS        //

// --------------------- maccros -------------------------- //

#define MARK_AMBIGUOUS_RETAIN   1
#define MARK_RETAIN             MARK_AMBIGUOUS_RETAIN
#define MARK_AMBIGUOUS          MARK_AMBIGUOUS_RETAIN
#define MARK_AMBIGUOUS_DISCARD  2
#define MARK_DISCARD            MARK_AMBIGUOUS_DISCARD
#define MARK_SEGMENTED          3

// ------------------- Structures -------------------------//
//now in topology/topo_parms.h

#define KEEP_VERTEX     0
#define DISCARD_VERTEX  1
#define FINAL_VERTEX    2


#define ET_OVERLAP_LIST_INCOMPLETE  0x0001

typedef struct
{
  int  nedges ;
  EDGE *edges ;
  int  **overlapping_edges ;  /* indices of all edges
                                 overlapping this one (i.e. [i][j]) */
  int  *noverlap ;
  unsigned char *flags ;
  int use_overlap;
}
EDGE_TABLE ;


typedef struct
{
  double        fitness ;
  int           nedges ;
  int           *ordering ;  /* order of edges in EDGE_TABLE
                                for retessellation */
  DEFECT        *defect ;
  EDGE_TABLE    *etable ;
  int           rank ;

  TP            tp; /* list of vertices,edges,faces
                       used in the tessellated defect */
  int retessellation_mode;

  MRI           *mri;
  MRI           *mri_defect; /* volume constituted by
                                the potential edges - just a pointer */
  MRI           *mri_defect_white;
  MRI           *mri_defect_gray;
  MRI           *mri_defect_sign;
  MRI           *mri_defect_initial_sign;
  MRI           *mri_defect_wm;

  int verbose_mode; /* verbose mode for debugging */

}
DEFECT_PATCH, DP ;

typedef struct
{
  int  vno ;     /* vertex # in surface */
  int  vnum ;    /* original # of 1 neighbors */
  int  vtotal ;
  int  *v ;      /* list of original neighbors */

  float origx,origy,origz;

  float nx,ny,nz;         /* curr normal */
  int *f;        /* list of original faces */
  uchar *n;        /* list of original vertex position */
  uchar num;       /* original number of faces */

}
VERTEX_STATE, VS ;

typedef struct
{
  DEFECT       *defect ;
  VERTEX_STATE *vs ;
  int          nvertices ;
  int          *vertex_trans ;  /* not allocated -
                                   pointer to preexisting table */
  int          nfaces ; /* number of used faces before retessellation */
}
DEFECT_VERTEX_STATE, DVS ;

/* this structure is used in the VERTEX structure (*vp) */
typedef struct
{
  int nedges;
  int *edges;
}
EDGE_POINTER, EP ;

typedef struct
{
  /* edges constituting the cluster */
  int *edges;
  int nedges;
  int max_edges;
  /* edge intersecting the edges of the cluster */
  int *xedges;
  int nxedges;
  int max_xedges;
}
SEGMENT;

// for the clustering of overlapping edges
typedef struct
{
  int n; /* position of this edge in the table */
  int vno1,vno2; /* vertices in the ORIGINAL tessellation */
  int segment; /* cluster number */

  int *xedges ; /* intersecting edges */
  int nxedges;
}
EDGE_STRUCTURE, ES ;

typedef struct
{
  SEGMENT  *segments ;
  int      nsegments ;
  int      max_segments ;
  MRIS     *mris ;
  /* the structure containing the edges */
  ES       *edges;
  int      nedges;
}
SEGMENTATION ;

typedef struct
{
  /* save the best configuration */
  int *best_ordering;
  float best_fitness;
  char *status;  // kept or discarded

  /* keep track of the result for the past iterations */
  int *nused;
  float *vertex_fitness;
}
RANDOM_PATCH, RP ;

typedef struct
{
  float c_x,c_y,c_z; /* canonical coordinates */
  float oc_x,oc_y,oc_z; /* orig coordinates in optimized configuations */
  float status; /* DISCARDED VERTEX OR KEPT VERTEX */
}
FS_VERTEX_INFO;

typedef struct
{
  int nvertices;
  int ninside; /* index of the first inside vertex */
  FS_VERTEX_INFO* vertices;
  float fitness; /* fitness associated with this patch */
  int status; /* valid patch or not */
}
MAPPING;

/* structure which encodes the information for the optimal mapping */
typedef struct
{
  MRIS *mris; /* structure encoding the original mapping */

  int *vertex_trans;
  int *face_trans;

  int nmappings; /* number of generated mappings */
  MAPPING orig_mapping;
  MAPPING mappings[10]; /* mapping (mapping 0 corresponds
                           to the initial mapping) */
}
OPTIMAL_DEFECT_MAPPING  ;

// -------------------- Declaration of Maccros --------------------- //

/* volume floats */
#define xVOL(mri,x) (mri->xsize*(x-mri->xstart))
#define yVOL(mri,y) (mri->ysize*(y-mri->ystart))
#define zVOL(mri,z) (mri->zsize*(z-mri->zstart))
/* volume integers */
#define iVOL(mri,x) ((int)(xVOL(mri,x)+0.5))
#define jVOL(mri,y) ((int)(yVOL(mri,y)+0.5))
#define kVOL(mri,z) ((int)(zVOL(mri,z)+0.5))
/* surface floats */
#define xSURF(mri,x) (mri->xstart+(float)x/mri->xsize)
#define ySURF(mri,y) (mri->ystart+(float)y/mri->ysize)
#define zSURF(mri,z) (mri->zstart+(float)z/mri->zsize)

#define  VOLUME_SCALE 2.0f

#define MAX_SEGMENTS 10
#define MAX_SEGMENT_EDGES 100

#define USE_SOME_VERTICES 0  //FLO
#define USE_ALL_VERTICES 1

#define USE_NO_OVERLAP 0
#define USE_OVERLAP    1
#define USE_OVERLAP_IN_MUTATION 2

#define MAX_PATCHES         1000
#define SELECTION_PCT       0.50
#define ELITISM_PCT         0.10
#define MUTATION_PCT        0.1
static double MUTATION_PCT_INIT =  (MUTATION_PCT*1.0) ;
#define REPLACEMENT_PCT     0.1   /* replace this many with
mutated versions of best */
#define MAX_UNCHANGED       3
static int max_unchanged = MAX_UNCHANGED ;

#define AREA_THRESHOLD     35.0f


// ----------------- Declaration of Static Functions ---------------------- //
//segmentation of the edges into clusters
static SEGMENTATION* SEGMENTATIONalloc(int max_segments, int max_edges);
static void SEGMENTATIONfree(SEGMENTATION **segmentation);
static int findSegment(SEGMENTATION *segmentation);
static int compatibility
(SEGMENTATION *segmentation, int segment_n, int edge_n);
static int addEdgeToSegment
(SEGMENTATION *segmentation, int segment_n, int edge_n);
static void segmentEdge(MRIS *mris, SEGMENTATION *segmentation, int edge_n);
static int mergeSegmentToSegment
(SEGMENTATION *segmentation, int segment_1, int segment_2);
static SEGMENTATION* segmentIntersectingEdges
(MRIS *mris, DEFECT *defect, int * vertex_trans,ES *es, int *nedges);
static void saveSegmentation
(MRIS *mris, MRIS *mris_corrected,
 DEFECT *defect,int *vertex_trans, ES *es, int nes,char *fname);
//generate an ordering based on the segmented overlapping edges
static void generateOrdering(DP *dp,SEGMENTATION *segmentation, int i);
static void savePatch(MRI *mri, MRIS *mris,
                      MRIS *mris_corrected,DVS *dvs,
                      DP *dp,char *fname,TOPOLOGY_PARMS *parms);
//compute statistics of the surface
static void mrisComputeSurfaceStatistics
(MRIS *mris,MRI *mri,HISTOGRAM *h_k1,HISTOGRAM *h_k2,
 MRI*mri_k1_k2,MRI *mri_gray_white,HISTOGRAM *h_dot);
static void computeDefectStatistics
(MRI *mri,MRIS *mris,DEFECT *defect, HISTOGRAM *h_white,
 HISTOGRAM *h_gray, MRI *mri_gw,HISTOGRAM *h_k1,
 HISTOGRAM *h_k2,MRI*mri_k1_k2,int verbose);
//initialization, free for the tessellated patch structure
static void TPinit(TP *tp);
static void TPfree(TP *tp);
static void TPprint(TP *tp);
static DEFECT_VERTEX_STATE *mrisRecordVertexState
(MRI_SURFACE *mris, DEFECT *defect,
 int *vertex_trans) ;
static int mrisRestoreFaceVertexState
(MRI_SURFACE *mris, DEFECT_VERTEX_STATE *dvs);
static int mrisRestoreVertexState
(MRI_SURFACE *mris, DEFECT_VERTEX_STATE *dvs) ;
static int mrisFreeDefectVertexState(DEFECT_VERTEX_STATE *dvs) ;
static int mrisAddAllDefectFaces(MRI_SURFACE *mris, DEFECT_LIST *dl,
                                 int *vertex_trans) ;
static int mrisFindDefectConvexHull(MRI_SURFACE *mris, DEFECT *defect) ;
static int mrisOrientRetessellatedSurface(MRI_SURFACE *mris, DEFECT_LIST *dl,
    int *vtrans) ;
#if SPHERE_INTERSECTION
static int containsAnotherVertexOnSphere
(MRI_SURFACE *mris, int vno0, int vno1, int vno2,int mode) ;
#else
static int containsAnotherVertex(MRI_SURFACE *mris, int vno0, int vno1,
                                 int vno2, double e0[3], double e1[3],
                                 double origin[3]) ;
#endif
static int       mrisMarkDefect(MRI_SURFACE *mris, DEFECT *defect, int mark) ;
static int       mrisMarkDefectBorder(MRI_SURFACE *mris, DEFECT *defect,
                                      int mark);
static int       mrisMarkDefectConvexHull(MRI_SURFACE *mris, DEFECT *defect,
    int mark);
#if 0

static int mrisAddDefectFaces(MRI_SURFACE *mris, double e0[3], double e1[3],
                              double origin[3], EDGE *et, int nedges);
static int       mrisOrientFaces(MRI_SURFACE *mris,DEFECT *defect,int *vtrans);
static int       mrisRestoreDefectPositions(MRI_SURFACE *mris, DEFECT *defect,
    int which) ;
#endif
FACE_DEFECT_LIST *MRISmarkAmbiguousVertices(MRI_SURFACE *mris, int mark) ;
DEFECT_LIST      *MRISsegmentDefects(MRI_SURFACE *mris, int mark_ambiguous,
                                     int mark_segmented) ;
static int       mrisSegmentDefect(MRI_SURFACE *mris,int vno,DEFECT *defect,
                                   int mark_ambiguous, int mark_segmented);
//#if FIND_ENCLOSING_LOOP
static int mrisSimplyConnectedDefect(MRI_SURFACE *mris, DEFECT *defect,
                                     int mark_ambiguous, int mark_segmented);
static int mrisSegmentConnectedComponents(MRIS *mris);
//#endif
static int       mrisMarkRetainedPartOfDefect(MRI_SURFACE *mris,
    DEFECT *defect,
    FACE_DEFECT_LIST *fdl,
    float area_threshold,
    int mark_retain,
    int mark_discard,
    MHT *mht, int mode) ;
static int       mrisTessellateDefect(MRI_SURFACE *mris,
                                      MRI_SURFACE *mris_corrected,
                                      DEFECT *defect, int *vertex_trans,
                                      MRI *mri,
                                      HISTOGRAM *h_k1,
                                      HISTOGRAM *h_k2,
                                      MRI *mri_k1_k2,
                                      HISTOGRAM *h_white,
                                      HISTOGRAM *h_gray,
                                      HISTOGRAM *h_border,
                                      HISTOGRAM *h_grad,
                                      MRI *mri_gray_white,
                                      HISTOGRAM *h_dot,
                                      TOPOLOGY_PARMS *parms
                                     ) ;
static int      mrisDefectRemoveDegenerateVertices(MRI_SURFACE *mris,
    float min_sphere_dist,
    DEFECT *defect) ;
static int       mrisDefectRemoveProximalVertices(MRI_SURFACE *mris,
    float min_orig_dist,
    DEFECT *defect) ;
static int       mrisDefectRemoveNegativeVertices(MRI_SURFACE *mris,
    DEFECT *defect) ;
static int       intersectDefectEdges(MRI_SURFACE *mris,
                                      DEFECT *defect,
                                      EDGE *e,
                                      int *vertex_trans,int *v1,int *v2);
static int       intersectDefectConvexHullEdges(MRI_SURFACE *mris,
    DEFECT *defect,
    EDGE *e,
    int *vertex_trans,
    int *v1,int *v2);

static MRI *mriDefectVolume(MRIS *mris,
                            EDGE_TABLE *etable,
                            TOPOLOGY_PARMS *parms);
static void defectVolumeLikelihood(MRI *mri,
                                   MRI* mri_defect,
                                   MRI *mri_white,
                                   MRI *mri_gray,
                                   HISTOGRAM *h_white,
                                   HISTOGRAM *h_gray,
                                   float white_mean,
                                   float gray_mean,
                                   int type,
                                   int contrast);
static int       vertexNeighbor(MRI_SURFACE *mris, int vno1, int vno2) ;
static int isVertexInsideFace(MRIS *mris,int vno,int fno);
static int isDiscarded(MRIS *mris,int vno1,int vno2);
static void removeVertex(MRIS *mris,int vno);
static int updateVertexTriangle(MRIS *mris,int vno,int fno);
//static void updateTriangle(MRIS *mris,int fno);
static void findNewTriangles(MRIS *mris,int vno1,int vno2);
static int isEdgeAdded(MRIS *mris,int vno1,int vno2,int mode);
static int retessellateDefect(MRI_SURFACE *mris,
                              MRI_SURFACE *mris_corrected,
                              DVS* dvs,
                              DP* dp);
static int       mrisRetessellateDefect(MRI_SURFACE *mris,
                                        MRI_SURFACE *mris_corrected,
                                        DEFECT *defect,
                                        int *vertex_trans,
                                        EDGE *et,
                                        int nedges,
                                        int *ordering,
                                        EDGE_TABLE *etable) ;
static void defectMatch(MRI *mri,
                        MRI_SURFACE *mris,
                        DP *dp,
                        int smooth,
                        int match);
static void defectSmooth(MRI_SURFACE *mris,
                         DP *dp,
                         int niter,
                         double alpha,
                         int type);
static void defectMaximizeLikelihood(MRI *mri,
                                     MRI_SURFACE *mris,
                                     DP *dp,
                                     int niter,
                                     double alpha);
static void detectDefectFaces(MRIS *mris, DEFECT_PATCH *dp);
static int  computePatchEulerNumber(MRIS *mris,DP *dp);
static void orientDefectFaces(MRIS *mris,DP* dp);
static void computeDefectFaceNormal(MRIS *mris,FACE *face);
static void computeDefectFaceNormals(MRIS *mris,DP *dp);
static void computeDefectVertexNormals(MRIS *mris,DP *dp);
static void computeDefectTangentPlaneAtVertex(MRIS *mris,int vno);
static void computeDefectSecondFundamentalForm(MRIS *mris,TP *tp);
//static void computeDefectMetricProperties(MRIS *mris,TP * tp);
static void printDefectStatistics(DP *dp);
static void computeDisplacement(MRI_SURFACE *mris,DP *dp);
static void updateVertexStatistics(MRIS *mris,
                                   MRIS* mris_corrected,
                                   DVS *dvs,
                                   RP *rp,
                                   DP *dp,
                                   int *vertex_trans,
                                   float fitness);
static int deleteWorstVertices(MRIS *mris,
                               RP *rp,
                               DEFECT *defect,
                               int *vertex_trans,
                               float fraction,
                               int count);
static double mrisDefectPatchFitness(MRI_SURFACE *mris,
                                     MRI_SURFACE *mris_corrected,
                                     MRI *mri,
                                     DEFECT_PATCH *dp,
                                     int *vertex_trans,
                                     DEFECT_VERTEX_STATE *dvs, RP *rp,
                                     HISTOGRAM *h_k1,
                                     HISTOGRAM *h_k2,
                                     MRI *mri_k1_k2,
                                     HISTOGRAM *h_white,
                                     HISTOGRAM *h_gray,
                                     HISTOGRAM *h_border,
                                     HISTOGRAM *h_grad,
                                     MRI *mri_gray_white,
                                     HISTOGRAM *h_dot, TOPOLOGY_PARMS *parms
                                    ) ;
static double mrisComputeDefectLogLikelihood
(MRI_SURFACE *mris,
 MRI *mri, DEFECT_PATCH *dp,HISTOGRAM *h_k1,HISTOGRAM *h_k2,
 MRI *mri_k1_k2,
 HISTOGRAM *h_white,
 HISTOGRAM *h_gray,
 HISTOGRAM *h_border,
 HISTOGRAM *h_grad,
 MRI *mri_gray_white,
 HISTOGRAM *h_dot, TOPOLOGY_PARMS *parms) ;
static float mrisDefectFaceMRILogLikelihood
(MRI_SURFACE *mris, MRI *mri, TP *tp, HISTOGRAM *h_white,
 HISTOGRAM *h_gray, HISTOGRAM *h_grad, MRI *mri_gray_white);
static float mrisDefectVertexMRILogLikelihood
(MRI_SURFACE *mris, MRI *mri, TP *tp, HISTOGRAM *h_white,
 HISTOGRAM *h_gray, HISTOGRAM *h_grad, MRI *mri_gray_white);
static double mrisComputeDefectMRILogLikelihood
(MRI_SURFACE *mris, MRI *mri,TP *tp,HISTOGRAM *h_white,
 HISTOGRAM *h_gray, HISTOGRAM *h_grad, MRI *mri_gray_white) ;
static int findOtherEdgeFace( MRIS *mris , int fno , int vno , int vn1);
static void vertexPseudoNormal
(MRIS *mris1, int vn1, MRIS *mris2, int vn2, float norm[3]);
static void computeVertexPseudoNormal
(MRIS *mris,int vno,float norm[3],int verbose);
static double mrisComputeDefectMRILogUnlikelihood
(MRI_SURFACE *mris, DP *dp,HISTOGRAM *h_border);
static double mrisComputeDefectCurvatureLogLikelihood
(MRI_SURFACE *mris, TP *tp, HISTOGRAM *h_k1, HISTOGRAM *h_k2,MRI *mri_k1_k2) ;
static double mrisComputeDefectNormalDotLogLikelihood
(MRI_SURFACE *mris, TP *tp, HISTOGRAM *h_dot);
static int    mrisMutateDefectPatch
(DEFECT_PATCH *dp, EDGE_TABLE *etable, double pmutation) ;
static int    mrisCrossoverDefectPatches
(DEFECT_PATCH *dp1, DEFECT_PATCH *dp2,
 DEFECT_PATCH *dp_dst, EDGE_TABLE *etable) ;
static int defectPatchRank(DEFECT_PATCH *dps, int index, int npatches) ;
static int mrisCopyDefectPatch(DEFECT_PATCH *dp_src, DEFECT_PATCH *dp_dst) ;
static int    mrisComputeOptimalRetessellation
(MRI_SURFACE *mris, MRI_SURFACE *mris_corrected,
 MRI *mri, DEFECT *defect, int *vertex_trans,
 EDGE *et,
 int nedges, ES *es,int nes, HISTOGRAM *h_k1, HISTOGRAM *h_k2,MRI *mri_k1_k2,
 HISTOGRAM *h_white, HISTOGRAM *h_gray, HISTOGRAM *h_border,
 HISTOGRAM *h_grad,
 MRI *mri_gray_white,
 HISTOGRAM *h_dot, TOPOLOGY_PARMS *parms) ;
static int    mrisComputeRandomRetessellation
(MRI_SURFACE *mris, MRI_SURFACE *mris_corrected,
 MRI *mri, DEFECT *defect, int *vertex_trans,
 EDGE *et,
 int nedges, ES *es,int nes, HISTOGRAM *h_k1, HISTOGRAM *h_k2,MRI *mri_k1_k2,
 HISTOGRAM *h_white, HISTOGRAM *h_gray, HISTOGRAM *h_border,
 HISTOGRAM *h_grad,
 MRI *mri_gray_white,
 HISTOGRAM *h_dot, TOPOLOGY_PARMS *parms) ;
static OPTIMAL_DEFECT_MAPPING* mrisFindOptimalDefectMapping
(MRIS *mris, DEFECT *defect);

#if 0
//old functions
static int mrisComputeDefectVertexNormal(MRI_SURFACE *mris, int vno,
    double *pnx, double *pny, double *pnz) ;
static int mrisFindSecondNeighborhood
(MRI_SURFACE *mris, int vno, int *nbrs, int *num_nbrs) ;
static int       colinearDefectEdges(MRI_SURFACE *mris, DEFECT *defect,
                                     EDGE *e, int *vertex_trans);
static int       mrisCheckDefectEdges(MRI_SURFACE *mris, DEFECT *defect,
                                      int vno, int *vertex_trans) ;
static int       intersectDefectEdges(MRI_SURFACE *mris, DEFECT *defect,
                                      EDGE *e, int *vertex_trans);
static int       intersectDefectConvexHullEdges(MRI_SURFACE *mris,
    DEFECT *defect,
    EDGE *e, int *vertex_trans);
static double    mrisDefectPatchFitness(MRI_SURFACE *mris,
                                        MRI_SURFACE *mris_corrected,
                                        MRI *mri,
                                        DEFECT_PATCH *dp, int *vertex_trans,
                                        DEFECT_VERTEX_STATE *dvs,
                                        HISTOGRAM *h_k1,
                                        HISTOGRAM *h_k2,
                                        HISTOGRAM *h_white,
                                        HISTOGRAM *h_gray,
                                        HISTOGRAM *h_border,
                                        HISTOGRAM *h_grad,
                                        MRI *mri_gray_white,
                                        HISTOGRAM *h_dot, TOPOLOGY_PARMS *parms
                                       ) ;
static double mrisComputeDefectLogLikelihood
(MRI_SURFACE *mris, MRI *mri, DEFECT *defect,
 int *vertex_trans, DEFECT_PATCH *dp,
 HISTOGRAM *h_k1,
 HISTOGRAM *h_k2,
 HISTOGRAM *h_white,
 HISTOGRAM *h_gray,
 HISTOGRAM *h_border,
 HISTOGRAM *h_grad,
 MRI *mri_gray_white,
 HISTOGRAM *h_dot, TOPOLOGY_PARMS *parms) ;
static double mrisComputeDefectEnergy
(MRI_SURFACE *mris, MRI *mri, DEFECT *defect,
 int *vertex_trans) ;
static double mrisComputeDefectQuadraticCurvatureEnergy
(MRI_SURFACE *mris, DEFECT *defect,
 int *vertex_trans) ;
static double mrisComputeDefectCurvatureEnergy
(MRI_SURFACE *mris, DEFECT *defect,
 int *vertex_trans) ;
static double mrisComputeDefectMRIEnergy
(MRI_SURFACE *mris, MRI *mri, DEFECT *defect,
 int *vertex_trans) ;
static double mrisComputeDefectMRILogLikelihood
(MRI_SURFACE *mris, MRI *mri, DEFECT *defect,
 int *vertex_trans, HISTOGRAM *h_white,
 HISTOGRAM *h_gray, HISTOGRAM *h_grad,
 MRI *mri_gray_white) ;
static int       mrisComputeDefectTangentPlanes
(MRI_SURFACE *mris, DEFECT *defect, int *vertex_trans) ;
static double
mrisComputeDefectCurvatureLogLikelihood
(MRI_SURFACE *mris, DEFECT *defect, int *vertex_trans,
 HISTOGRAM *h_k1, HISTOGRAM *h_k2);
static double mrisComputeDefectMRILogUnlikelihood
(MRI_SURFACE *mris, MRI *mri, DEFECT_PATCH *dp,
 int *vertex_trans, HISTOGRAM *h_border) ;
static double
mrisComputeDefectNormalDotLogLikelihood
(MRI_SURFACE *mris, DEFECT *defect, int *vertex_trans,
 HISTOGRAM *h_dot);
#endif


static int mrisComputeJointGrayWhiteBorderDistributions
(MRI_SURFACE *mris,
 MRI *mri,MRI *mri_gray_white, MRI *mri_wm) ;
static int mrisComputeGrayWhiteBorderDistributions
(MRI_SURFACE *mris, MRI *mri, DEFECT *defect,
 HISTOGRAM *h_white, HISTOGRAM *h_gray,
 HISTOGRAM *h_border, HISTOGRAM *h_grad);
static int mrisComputePrincipalCurvatureDistributions
(MRI_SURFACE *mris, HISTOGRAM *h_k1, HISTOGRAM *h_k2,MRI *mri_k1_k2) ;
static int mrisComputeNormalDotDistribution
(MRI_SURFACE *mris, HISTOGRAM *h_dot);

void MRISmapOntoSphere(MRIS *mris)
{
  MRISprojectOntoSphere(mris, mris, 100.0f) ;

  MRISsmoothOnSphere(mris,10000);
}

DEFECT_LIST *
mrisSegmentDefects(MRI_SURFACE *mris, int mark_ambiguous, int mark_segmented)
{
  DEFECT_LIST  *dl ;
  int          vno ,nadded ;
  VERTEX       *v ;
  DEFECT *defect;

  dl = (DEFECT_LIST *)calloc(1, sizeof(DEFECT_LIST)) ;
  if (!dl)
    ErrorExit(ERROR_NO_MEMORY,
              "MRISsegmentDefects: could allocate defect list") ;

  /* uses fixedval to mark border vertices */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].fixedval=0;
  }

  for (nadded = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked != mark_ambiguous)
    {
      continue ;
    }

    defect=&dl->defects[dl->ndefects];
    defect->defect_number=dl->ndefects++;

    /* segment defect #defect->defect_number */
    nadded += mrisSegmentDefect
              (mris, vno, defect, mark_ambiguous, mark_segmented) ;

    /* update the defect so it becomes simply connected */
    mrisSimplyConnectedDefect(mris,defect,mark_ambiguous, mark_segmented);

  }
  if (nadded)
    fprintf
    (stderr,
     "   total of %d vertices have been added to the surface\n",nadded);

  return(dl) ;
}


static int mrisMarkAllDefects(MRI_SURFACE *mris, DEFECT_LIST *dl, int flag) ;


static DEFECT_LIST *mrisRemoveOverlappingDefects(MRIS *mris,DEFECT_LIST *dl )
{
  int i,n,found,removed;
  DEFECT *defect,*removed_defect;
  DEFECT_LIST *new_dl;

  fprintf(stderr,"analyzing defects for overlaps...\n");


  found=1;
  while (found)
  {
    found=0;

    /* initiliaze flags */
    for (n=0; n<mris->nvertices; n++)
    {
      mris->vertices[n].ripflag=0;
      mris->vertices[n].marked=0;
      mris->vertices[n].fixedval=0;
      mris->vertices[n].undefval=0;
      mris->vertices[n].old_undefval=0;
    }

    for (i = 0 ; i < dl->ndefects ; i++)
    {
      if (found)
      {
        break;
      }
      defect = &dl->defects[i] ;
      for (n = 0 ; n < defect->nvertices ; n++)
      {
        if (mris->vertices[defect->vertices[n]].marked)
        {
          /* defect i overlaps defect (marked-1) */
          /* by construction defect (marked-1) is inside defect i */
          /* remove defect (marked-1) */

          fprintf(WHICH_OUTPUT,
                  "  -removing defect %d (overlapping defect %d)\n",
                  mris->vertices[defect->vertices[n]].marked-1,i);
          //fprintf(WHICH_OUTPUT,"defect %d has %d vertices - ",i,defect->nvertices);
          //fprintf(WHICH_OUTPUT,"defect %d has %d vertices : %d\n",mris->vertices[defect->vertices[n]].marked-1,dl->defects[mris->vertices[defect->vertices[n]].marked-1].nvertices,defect->vertices[n]);

          removed=mris->vertices[defect->vertices[n]].marked-1;
          removed_defect=&dl->defects[removed];

          /* free inside vertices */
          free(removed_defect->vertices);
          free(removed_defect->status);
          removed_defect->vertices=NULL;
          removed_defect->status=NULL;
          removed_defect->nvertices=0;
          /* free border */
          free(removed_defect->border);
          removed_defect->border=NULL;
          removed_defect->nborder=0;

          //newflo
          // free edge list!!!

          /* clean defect from empty spaces */
          new_dl=(DEFECT_LIST*)calloc(1,sizeof(DEFECT_LIST));
          for (i=0; i<dl->ndefects; i++)
          {
            if (removed)
            {
              continue;
            }
            defect=&dl->defects[i];
            if (defect->nvertices)
            {
              /* this defect is not empty */
              memmove(&new_dl->defects[new_dl->ndefects++],
                      defect,sizeof(DEFECT));
            }
          }
          free(dl);
          dl=new_dl;

          found=1;
          break;
        }
        mris->vertices[defect->vertices[n]].marked=i+1;
      }
    }
  }

  return dl;
}

static int mrisRipAllDefects(MRI_SURFACE *mris, DEFECT_LIST *dl, int ripflag) ;
static int mrisRipDefect(MRI_SURFACE *mris, DEFECT *defect, int ripflag) ;


int MRISisSurfaceValid(MRIS *mris, int patch,int verbose)
{
  int n,m,p,q,vnop,nfound,mark;
  VERTEX *vn;
  int euler,nedges,nvf,nffm,nffs,cf,nvc;
  FACE *fm;

  //check if every vertex has the same number of vertices and faces
  if (verbose==2)
  {
    fprintf(stderr,"\nchecking for border faces...\n");
  }
  nvf=0;
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    vn=&mris->vertices[n];
    if (vn->vnum!=vn->num)
    {
      nvf++;
      if (verbose==2 && patch==0)
      {
        fprintf(stderr,"vertex %d : vnum = %d num=%d\n",n,vn->vnum,vn->num);
      }
    }
  }

  //check if some faces have more than 2 neighbors
  if (verbose==2)
  {
    fprintf(stderr,"\nchecking for single or multiple faces...\n");
  }
  nffm=nffs=0;
  nedges=0;
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    vn = &mris->vertices[n];
    nedges += vn->vnum;
    for (p = 0 ; p < vn->vnum ; p++)
    {
      vnop=vn->v[p];
      /* counts the # of faces that contain the edge n<-->vnop */
      cf=0;
      for (m = 0 ; m < vn->num ; m++)
      {
        fm = &mris->faces[vn->f[m]];
        // check if fm contains vnop
        for (q=0 ; q < 3 ; q++)
        {
          if (fm->v[q]==vnop)
          {
            cf++;
            break;
          }
        }
      }
      if (cf<2)
      {
        nffs++;
      }
      if (cf>2)
      {
        nffm++;
      }
      if (verbose==2)
      {
        if (cf<2 && patch==0)
        {
          fprintf(stderr,"edge %d <--> %d : single face\n",n,vnop);
        }
        if (cf>2)
        {
          fprintf(stderr,"edge %d <--> %d : multiple face\n",n,vnop);
        }
      }
    }
  }
  nedges /= 2;
  euler = mris->nvertices-nedges+mris->nfaces;

  //finally check the # of connected neighbors of each vertex
  if (verbose==2)
  {
    fprintf(stderr,"\nchecking for corner configurations...\n");
  }
  nvc=0;
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    vn = &mris->vertices[n];
    for (p = 0 ; p < vn->vnum ; p++)
    {
      vnop = vn->v[p];
      mris->vertices[vnop].marked=0;
    }
    //mark first vertex
    vnop=vn->v[0];
    mris->vertices[vnop].marked=1;
    //find connected neighbors
    nfound=1;
    while (nfound)
    {
      nfound=0;
      for (m = 0 ; m < vn->num ; m++)
      {
        fm = &mris->faces[vn->f[m]];
        // check if fm contains a marked vertex
        mark=0;
        for (q=0 ; q < 3 ; q++)
        {
          if (fm->v[q]==n)
          {
            continue;
          }
          if (mris->vertices[fm->v[q]].marked)
          {
            mark=1;
            break;
          }
        }
        if (mark)
        {
          for (q=0 ; q < 3 ; q++)
          {
            if (fm->v[q]==n)
            {
              continue;
            }
            if (mris->vertices[fm->v[q]].marked)
            {
              continue;
            }
            mris->vertices[fm->v[q]].marked=1;
            nfound=1;
            break;
          }
        }
      }
    }
    //now check if there is a remaining vertex that is not marked
    for (p = 0 ; p < vn->vnum ; p++)
    {
      vnop = vn->v[p];
      if (mris->vertices[vnop].marked==0)
      {
        nvc++;
        if (verbose==2)
        {
          fprintf(stderr,"vertex %d : corner configuration\n",n);
        }
        break;
      }
    }
  }
  if (verbose) fprintf(stderr,"Surface Diagnostics:       \n"
                         "   eno=%d (nv=%d, nf=%d, ne=%d)\n"
                         "   # of border vertices [ #v ~ #f ]     %d \n"
                         "   # of edges with single face          %d \n"
                         "   # of edges with more than 2 faces    %d \n"
                         "   # of corner configurations           %d\n",
                         euler,mris->nvertices,
                         mris->nfaces,nedges,nvf,nffs,nffm,nvc);

  if (patch && (nffm || nvc))
  {
    return 0;
  }
  else if (nvf || nffs || nffm || nvc)
  {
    return 0;
  }
  return 1;
}

void MRISidentifyDefects(MRIS *mris, TOPOFIX_PARMS *parms)
{
  int fno;
  FACE_DEFECT_LIST   *fdl ;
  DEFECT_LIST        *dl ;


  /* using CANONICAL_VERTICES */
  MRISrestoreVertexPositions(mris, CANONICAL_VERTICES) ;

  /* marking intersecting edges */
  fdl = MRISmarkAmbiguousVertices(mris, MARK_AMBIGUOUS) ;

  fprintf(WHICH_OUTPUT, "segmenting defects...\n") ;

  dl = mrisSegmentDefects(mris, MARK_AMBIGUOUS, MARK_SEGMENTED) ;

  dl=mrisRemoveOverlappingDefects(mris,dl);

  MRISclearMarks(mris);

  /* free structures */
  for (fno = 0 ; fno < mris->nfaces ; fno++)
    if (fdl->nfaces[fno] > 0)
    {
      free(fdl->faces[fno]) ;
    }
  free(fdl->faces) ;
  free(fdl->nfaces) ;
  free(fdl) ;

  //save structure into parms
  parms->defect_list=(void*)dl;
}

static int detectContrast(MRIS *mris)
{
  int n ,nv;
  double wm,gm;
  VERTEX *v;

  fprintf(WHICH_OUTPUT,"Detecting contrast direction:");
  wm = gm = 0.0;
  nv=0;
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    v=&mris->vertices[n];
    if (v->ripflag)
    {
      continue;
    }
    nv++;
    wm += v->val2;
    gm += v->val2bak;
  }
  wm /= nv;
  gm /= nv;

  if (wm > gm)
  {
    fprintf(WHICH_OUTPUT," right direction [ GM (%3.2f) < WM (%3.2f) ]\n",
            gm,wm);
    return 1;
  }
  else
  {
    fprintf(WHICH_OUTPUT," inverted [ WM (%3.2f) < GM (%3.2f) ]\n",
            wm,gm);
    return -1;
  }
}

void MRISinitTopoFixParameters(MRIS *mris, TOPOFIX_PARMS *parms)
{

#if MATRIX_ALLOCATION
  /* allocation of the transform matrix */
  VoxelFromSRASmatrix=GetSurfaceRASToVoxelMatrix(parms->mri);
  parms->transformation_matrix = VoxelFromSRASmatrix ;
#endif

  //    MRISsmoothSurfaceNormals(mris,10);

  /* v->val = border, v->val2 = white, v->val2bak = gray */
  mrisRipAllDefects(mris, (DEFECT_LIST*)parms->defect_list, 1) ;
  mrisFindGrayWhiteBorderMean(mris, parms->mri) ;

  //find if there is a contrast inversion
  if (parms->contrast == -2)
  {
    parms->contrast = detectContrast(mris);
  }
  mrisRipAllDefects(mris, (DEFECT_LIST*)parms->defect_list, 0) ;


  //computing curvature statistics
  MRISsetNeighborhoodSize(mris,2);
  parms->h_k1 = HISTOalloc(100) ;
  parms->h_k2 = HISTOalloc(100) ;
  parms->mri_k1_k2 = MRIalloc(100, 100, 1, MRI_FLOAT) ;
  parms->h_dot = HISTOalloc(100) ;
  mrisComputePrincipalCurvatureDistributions
  (mris, parms->h_k1, parms->h_k2,parms->mri_k1_k2) ;
  mrisComputeNormalDotDistribution(mris, parms->h_dot) ;
  MRISsetNeighborhoodSize(mris,1);

  //computing mri statistics
  MRIScomputeMetricProperties(mris) ;
  MRISsmoothSurfaceNormals(mris, 10) ;

  parms->h_gray = HISTOalloc(256) ;
  parms->h_white = HISTOalloc(256) ;
  parms->h_border = HISTOalloc(256) ;
  parms->h_grad = HISTOalloc(256) ;
  parms->mri_gray_white = MRIalloc(256, 256, 1, MRI_FLOAT) ;

  mrisMarkAllDefects(mris, (DEFECT_LIST*)parms->defect_list, 1) ;
  mrisComputeJointGrayWhiteBorderDistributions
  (mris, parms->mri,  parms->mri_gray_white,  parms->mri_wm) ;

  /* compute statistics on original */
  mrisComputeSurfaceStatistics
  (mris, parms->mri, parms->h_k1, parms->h_k2,
   parms->mri_k1_k2, parms->mri_gray_white,parms->h_dot);
  mrisMarkAllDefects(mris, (DEFECT_LIST*)parms->defect_list, 0) ;

}

MRI *mriInitDefectVolume(MRIS *mris, TOPOFIX_PARMS *parms)
{
  MRI *mri;
  VERTEX *v;

  int k,l,p,q;
  int width,height,depth;
  float xmin,xmax,ymin,ymax,zmin,zmax,scale;

  if (parms->volume_resolution==-1)
  {
    scale=VOLUME_SCALE;
  }
  else
  {
    scale=parms->volume_resolution;
  }

  /* find dimension of the volume */
  xmin=ymin=zmin=1000.0;
  xmax=ymax=zmax=-1000.0;
  for (k = 0 ; k < mris->nvertices ; k++)
  {
    v=&mris->vertices[k];
    if (v->marked2 != parms->defect_number)
    {
      continue;
    }
    if (v->origx > xmax)
    {
      xmax=v->origx;
    }
    if (v->origy > ymax)
    {
      ymax=v->origy;
    }
    if (v->origz > zmax)
    {
      zmax=v->origz;
    }
    if (v->origx < xmin)
    {
      xmin=v->origx;
    }
    if (v->origy < ymin)
    {
      ymin=v->origy;
    }
    if (v->origz < zmin)
    {
      zmin=v->origz;
    }
  }

  xmin -= 1.0f;
  ymin -= 1.0f;
  zmin -= 1.0f;
  xmax += 1.0f;
  ymax += 1.0f;
  zmax += 1.0f;

  /* allocate the volume */
  width  = ceil(scale*(xmax-xmin)) ;
  height = ceil(scale*(ymax-ymin)) ;
  depth  = ceil(scale*(zmax-zmin)) ;
  mri=MRIalloc(width,height,depth,MRI_UCHAR);

  if (parms->verbose==VERBOSE_MODE_HIGH)
    fprintf(WHICH_OUTPUT,
            "      defect volume : %d by %d by %d (scale = %d)\n",
            width,height,depth,(int)scale);

  mri->xstart=xmin;
  mri->xsize=scale;

  mri->ystart=ymin;
  mri->ysize=scale;

  mri->zstart=zmin;
  mri->zsize=scale;

  for (q = 0 ; q < depth ; q++)
    for (p = 0 ; p < height ; p++)
      for (l = 0 ; l < width ; l++)
      {
        MRIvox(mri,l,p,q)=1;
      }

  return mri;
}

//used for fs_topo_fixer
void MRISsaveLocal(MRIS *mris,  TOPOFIX_PARMS *parms, char *name)
{

  int static n_br=0;
  char fname[512];
  int n ;
  double x,y,z,xv,yv,zv;
  MRI *mri;

  mri = ((DP*)parms->dp)->mri_defect;

  n_br = parms->defect_number;

  MRISsaveVertexPositions(mris,TMP_VERTICES);
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    x = xVOL(mri,mris->vertices[n].x);
    y = yVOL(mri,mris->vertices[n].y);
    z = zVOL(mri,mris->vertices[n].z);
    MRIvoxelToWorld(mri, x, y, z, &xv, &yv, &zv) ;
    mris->vertices[n].x=xv;
    mris->vertices[n].y=yv;
    mris->vertices[n].z=zv;
    mris->vertices[n].curv=mris->vertices[n].H;
  }
  sprintf(fname,"./def_%d.asc",n_br);
  MRISwrite(mris,fname);
  MRISrestoreVertexPositions(mris,TMP_VERTICES);
  sprintf(fname,"./def_o_%d.asc",n_br);
  MRISwrite(mris,fname);

  mris=parms->mrip->mris_source;
  sprintf(fname,"./source_o_%d.asc",n_br);
  MRISwrite(mris,fname);
  MRISsaveVertexPositions(mris,TMP_VERTICES);
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    x = xVOL(mri,mris->vertices[n].x);
    y = yVOL(mri,mris->vertices[n].y);
    z = zVOL(mri,mris->vertices[n].z);
    MRIvoxelToWorld(mri, x, y, z, &xv, &yv, &zv) ;
    mris->vertices[n].x=xv;
    mris->vertices[n].y=yv;
    mris->vertices[n].z=zv;
    mris->vertices[n].curv=mris->vertices[n].H;
  }
  sprintf(fname,"./source_%d.asc",n_br);
  MRISwrite(mris,fname);
  MRISrestoreVertexPositions(mris,TMP_VERTICES);

  sprintf(fname,"./mri_sign_%d.mgz",n_br);
  MRIwrite(((DP*)parms->dp)->mri_defect_sign,fname);
  sprintf(fname,"./mri_sign_init_%d.mgz",n_br);
  MRIwrite(((DP*)parms->dp)->mri_defect_initial_sign,fname);
  // sprintf(fname,"def.curv_%d",n_br++);
  // MRISwriteCurvature(mris,fname);

}

static void defectVolumeWM(MRI *mri, MRI* mri_defect, MRI *mri_wm);

void  mrisInitDefectMRIParameters(MRIS *mris, TOPOFIX_PARMS *parms)
{
  MRI *mri_defect,*mri_defect_white,
      *mri_defect_gray,*mri_defect_sign,*mri_defect_initial_sign,*mri_defect_wm;
  DP *dp;
  DEFECT *defect;

  dp=(DP*)parms->dp;
  defect = dp->defect;

  mri_defect =
    mri_defect_white =
      mri_defect_gray =
        mri_defect_sign =
          mri_defect_initial_sign =
            mri_defect_wm = NULL;

  if (!FZERO(parms->l_unmri))
  {
    //initialization
    mri_defect = mriInitDefectVolume(mris, parms);
    //allocate volumes
    mri_defect_white =
      MRIalloc(mri_defect->width,
               mri_defect->height,
               mri_defect->depth,
               MRI_FLOAT);
    mri_defect_gray =
      MRIalloc(mri_defect->width,
               mri_defect->height,
               mri_defect->depth,
               MRI_FLOAT);
    mri_defect_sign =
      MRIalloc(mri_defect->width,
               mri_defect->height,
               mri_defect->depth,
               MRI_FLOAT);
    mri_defect_initial_sign =
      MRIalloc(mri_defect->width,
               mri_defect->height,
               mri_defect->depth,
               MRI_FLOAT);
    mri_defect_wm =
      MRIalloc(mri_defect->width,
               mri_defect->height,
               mri_defect->depth,
               MRI_FLOAT);
    //compute likelihood
    defectVolumeLikelihood
    (parms->mri, mri_defect, mri_defect_white,
     mri_defect_gray, parms->h_white,
     parms->h_gray,defect->white_mean,defect->gray_mean, 1,parms->contrast);
    defectVolumeWM(parms->mri_wm, mri_defect, mri_defect_wm);
  }
  dp->mri_defect=mri_defect;
  dp->mri_defect_white=mri_defect_white;
  dp->mri_defect_gray=mri_defect_gray;
  dp->mri_defect_sign=mri_defect_sign;
  dp->mri_defect_initial_sign = mri_defect_initial_sign;
  dp->mri_defect_wm=mri_defect_wm;
  dp->mri=parms->mri;
}


void MRISinitDefectParameters(MRIS *mris, TOPOFIX_PARMS *parms)
{
  int n,nvertices, nchull, defect_number;
  DEFECT *defect;
  DP *dp;

#if MATRIX_ALLOCATION
  //  VoxelFromSRASmatrix=parms->transformation_matrix;
#endif

  defect_number = parms->defect_number;
  defect = (DEFECT*)calloc(1,sizeof(DEFECT));
  defect->defect_number = defect_number;

  //reset marks to zero
  MRISclearMarks(mris);
  nvertices=0;
  for (n = 0 ; n < mris->nvertices ; n++)
    if (mris->vertices[n].marked2 == defect_number)
    {
      nvertices++;
      mris->vertices[n].marked = 1 ;
    };
  if (nvertices==0)
  {
    //empty defect!
    free(defect);
    return;
  }
  defect->nvertices=0;
  defect->vertices = (int*)malloc(nvertices*sizeof(int));
  for (n = 0 ; n < mris->nvertices ; n++)
    if (mris->vertices[n].marked)
    {
      defect->vertices[defect->nvertices++]=n;
    }
  //expand marks
  for (n =  0 ; n < 3 ; n++)
  {
    MRISexpandMarked(mris);
  }
  mrisMarkDefect(mris,defect,2);
  nchull=0;
  for (n = 0 ; n < mris->nvertices ; n++)
    if (mris->vertices[n].marked==1)
    {
      nchull++;
    }
  defect->chull = (int*)malloc(nchull*sizeof(int));
  defect->nchull=0;
  for (n = 0 ; n < mris->nvertices ; n++)
    if (mris->vertices[n].marked==1)
    {
      defect->chull[defect->nchull++]=n;
    }

  //computing statistics
  MRISclearMarks(mris);

  mrisMarkAllDefects(mris, (DEFECT_LIST*)parms->defect_list, 1) ;
  mrisComputeGrayWhiteBorderDistributions
  (mris,parms->mri,defect,
   parms->h_white,parms->h_gray,parms->h_border,parms->h_grad);

  computeDefectStatistics
  (parms->mri,mris,defect, parms->h_white,parms->h_gray,
   parms->mri_gray_white,parms->h_k1,
   parms->h_k2,parms->mri_k1_k2,parms->verbose);
  mrisMarkAllDefects(mris, (DEFECT_LIST*)parms->defect_list, 0) ;

  // HISTOplot(parms->h_white,"w.plt") ;
  // HISTOplot(parms->h_gray,"g.plt") ;
  // MRIwrite(parms->mri_k1_k2,"./k1k2.mgz");
  // MRIwrite(parms->mri_gray_white,"gw.mgz");

  //initialize the Defect Patch associated with the current defect
  dp = (DP*)calloc(1,sizeof(DP));
  free(defect->chull);
  defect->chull=NULL;
  defect->nchull=0;
  free(defect->vertices);
  defect->vertices=NULL;
  defect->nvertices=0;
  dp->defect=defect;
  parms->dp=(void*)dp;

  //now initialize the volume associated with the defect
  mrisInitDefectMRIParameters(mris,parms);
}

void TOPOFIXfreeDP(TOPOFIX_PARMS *parms)
{
  DP *dp;
  dp=(DP*)parms->dp;
  if (dp==NULL)
  {
    return;
  }
  if (dp->defect)
  {
    free(dp->defect);
  }
  TPfree(&dp->tp);
  if (dp->mri_defect)
  {
    MRIfree(&dp->mri_defect);
  }
  if (dp->mri_defect_white)
  {
    MRIfree(&dp->mri_defect_white);
  }
  if (dp->mri_defect_gray)
  {
    MRIfree(&dp->mri_defect_gray);
  }
  if (dp->mri_defect_sign)
  {
    MRIfree(&dp->mri_defect_sign);
  }
  if (dp->mri_defect_initial_sign)
  {
    MRIfree(&dp->mri_defect_initial_sign);
  }
  if (dp->mri_defect_wm)
  {
    MRIfree(&dp->mri_defect_wm);
  }

  free(dp);

  parms->dp=NULL;
}

void MRISmarkPatchVertices(MRIS *mris, TOPOFIX_PARMS *parms, int ninitvertices)
{
  int n;
  DP *dp;
  TP *tp;

  dp=(DP*)parms->dp;
  tp=&dp->tp;

  MRISclearMarks(mris);

  for (n = ninitvertices ; n < mris->nvertices ; n++)
  {
    mris->vertices[n].marked=1;
  }
}

void MRISmarkBorderVertices(MRIS *mris, TOPOFIX_PARMS *parms,int mark)
{
  int n;
  DP *dp;
  TP *tp;

  dp=(DP*)parms->dp;
  tp=&dp->tp;

  for (n =  tp->ninside ;  n < tp->nvertices ; n++)
  {
    mris->vertices[tp->vertices[n]].marked=mark;
  }
}


void MRISinitDefectPatch(MRIS *mris, TOPOFIX_PARMS *parms)
{
  int n;
  DP *dp;
  TP *tp;

  dp=(DP*)parms->dp;
  tp=&dp->tp;

  TPfree(tp);
  TPinit(tp);

  tp->nvertices = mris->nvertices;
  tp->vertices = (int*)malloc(tp->nvertices*sizeof(int));
  //first find the inside vertices
  MRISclearMarks(mris);
  tp->ninside=0;
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    VERTEX *v=&mris->vertices[n];
    if (v->vnum == v->num)
    {
      v->marked=1;
      tp->vertices[tp->ninside++]=n;
    }
  }
  //then the remaining ones
  tp->nvertices=tp->ninside;
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    VERTEX *v=&mris->vertices[n];
    if (v->marked==1)
    {
      continue;
    }
    tp->vertices[tp->nvertices++]=n;
  }
  MRISclearMarks(mris);
  //finally the faces
  tp->nfaces = mris->nfaces;
  tp->faces = (int*)malloc(tp->nfaces*sizeof(int));
  for (n = 0 ; n < tp->nfaces ; n++)
  {
    tp->faces[n]=n;
  }
  tp->nedges = 0;

}

void MRIScomputeInitialFitness(MRIS *mris, TOPOFIX_PARMS *parms)
{

  parms->mris_defect=mris;
  MRIScomputeFitness(mris,parms,0);
  parms->initial_fitness = 0.0;
  //save initial sign into mri_defect_initial_sign
  MRIcopy(((DP*)parms->dp)->mri_defect_sign,
          ((DP*)parms->dp)->mri_defect_initial_sign);
  //  fs_topo_fixer_test
  //  MRIwrite(((DP*)parms->dp)->mri_defect_initial_sign,"./mri_init_sign.mgz"); // MRIwrite(((DP*)parms->dp)->mri_defect_wm,"./mri_defect_wm.mgz");
}

static void MRISdefectMaximizeLikelihood
(MRI *mri,MRI_SURFACE *mris,DP *dp, int niter,double alpha, int mode);

void MRISdefectMatch(MRIS *mris, TOPOFIX_PARMS *parms)
{
  // fs_topo_fixer_test
  // defectMatch(parms->mri,mris,(DP*)parms->dp,2,1);//parms->smooth, parms->match);
  MRISdefectMaximizeLikelihood(parms->mri,mris,(DP*)parms->dp,40,0.5,1);
  MRISrestoreVertexPositions(mris,ORIGINAL_VERTICES);
}

double computeSurfaceLikelihood(MRIS *mris, DP *dp,int verbose)
{
  int n;
  double Km, Hm;
  VERTEX *v;

  computeDefectSecondFundamentalForm(mris,&dp->tp);
  Km = Hm = 0.0 ;
  for (n = 0 ; n < dp->tp.ninside; n++)
  {
    v=&mris->vertices[dp->tp.vertices[n]];
    Km += v->K*v->K;
    Hm += v->H*v->H;
  }
  Km /= dp->tp.ninside;
  Hm /= dp->tp.ninside;

  if (verbose)
  {
    fprintf(WHICH_OUTPUT,"CURV: K=%f H=%f\n",Km,Hm);
  }

  return -Hm;

}

double computeVolumeLikelihood(DP *dp, int contrast, int verbose)
{
  double int_g,int_w,val,val2,dval,delta,delta_ll;
  int i,j,k;
  double white_mean,gray_mean,white_vol,gray_vol;
  double scale,valvox,delta_NRG;

  // double sigma,dwhite,dgray,Dw,Dg;

  MRI *mri_defect,*mri_sign,*mri_white,*mri_gray,*mri_init;
  TP *tp;

  tp=&dp->tp;
  mri_defect=dp->mri_defect;
  mri_sign=dp->mri_defect_sign;
  mri_white=dp->mri_defect_white;
  mri_gray=dp->mri_defect_gray;
  mri_init=dp->mri_defect_initial_sign;

  white_mean = dp->defect->white_mean;
  gray_mean = dp->defect->gray_mean;
  // sigma = fabs(white_mean-gray_mean)/2.0;

  scale=mri_defect->xsize;
  scale = 1/(scale*scale*scale);

  white_vol=gray_vol=0.0001;
  int_g = gray_vol*dp->defect->gray_mean;
  int_w = white_vol*dp->defect->white_mean;
  // dwhite = dgray = 0.0;
  // Dw     = Dg    = 0.0;
  delta_NRG = 0.0;
  delta=delta_ll=0.0;

  /* compute differences with mri_defect_initial_sign */
  for ( k = 1 ; k < mri_sign->depth-1 ;  k++ )
    for ( j = 1 ; j <  mri_sign->height-1; j++ )
      for ( i = 1 ; i <  mri_sign->width-1; i++ )
      {
        val = MRIFvox(mri_sign,i,j,k); //new signed volume
        val2 = MRIFvox(mri_init,i,j,k); //old signed volume

        if ((val >= 1.0f && val2 >= 1.0f) ||
            (val <= -1.0f && val2 <= -1.0f))
        {
          continue;  //compute the difference with the orig segmentation only
        }

        dval=fabs(val2-val)/2.0f; //change in volume
        delta_NRG += (val2-val) / 2.0f
                     * ( MRIFvox(mri_white,i,j,k) - MRIFvox(mri_gray,i,j,k) );
        valvox = MRIvox(mri_defect,i,j,k); //intensity at location (i,j,k)

        if (val2 > val)
        {
          white_vol += dval;
          int_w += dval*valvox;
        }
        else
        {
          gray_vol += dval;
          int_g += dval*valvox;
        }

        /*
            if(valvox < white_mean) Dw     += (1-val2)/2.0f   * SQR((valvox - white_mean)/sigma);
            if(valvox > gray_mean)  Dg     += (1.0+val2)/2.0f * SQR((valvox - gray_mean)/sigma);
            if(valvox < white_mean) dwhite += (1.0-val)/2.0f  * SQR((valvox - white_mean)/sigma);
            if(valvox > gray_mean)  dgray  += (1.0+val)/2.0f  * SQR((valvox - gray_mean)/sigma);
            delta_ll += MRIFvox(mri_white,i,j,k)-MRIFvox(mri_gray,i,j,k);
        */
      }
  int_w /= white_vol;
  int_g /= gray_vol;

  /*
   dwhite *= scale;
   dgray *= scale;
   Dw *= scale;
   Dg *= scale;
   delta=(dwhite+dgray-Dw-Dg)/(gray_vol+white_vol);
  */

  delta_NRG *= scale;
  delta_ll = delta_NRG/(white_vol+gray_vol);
  if (verbose)
  {
    if (gray_vol > white_vol)
    {
      fprintf(stderr,"CUTTING HANDLE\n");
    }
    else
    {
      fprintf(stderr,"FILLING HANDLE\n");
    }

    fprintf
    (stderr,
     "Gray [ Vol=%f - Int = %f ]- White [ Vol = %f - Int = %f ] %f (%f)\n",
     gray_vol,int_g,white_vol,int_w,delta_NRG,delta_ll);
  }

  //dp->tp.unmri_ll=(white_ll+gray_ll);
  dp->tp.unmri_ll=delta_ll;
  //return (white_ll+gray_ll);
  return (-delta_NRG);
}



#define DO_NOT_USE_AREA 0


static double  l_mri   = 1.0 ;
static double  l_unmri = 1.0 ;
static double  l_curv  = 1.0 ;
static double  l_qcurv = 1.0 ;

static double l_vol = 1.0;
static double l_surf = 1.0;
static double l_wm = 1.0;

double MRIScomputeFitness(MRIS* mris,TOPOFIX_PARMS *parms,int verbose)
{
  static int first_time = 1 ;
  double fitness,unmri_ll,curv_ll;
  DP *dp;
  TP *tp;

#if 0
  static int now = 0;
  static int def = -1;
  static int when = 0;
#endif

  fitness=unmri_ll=curv_ll=0.0;

  MRIScomputeNormals(mris);
  MRIScomputeTriangleProperties(mris);
  MRISsaveVertexPositions(mris,ORIGINAL_VERTICES);

  dp=(DP*)parms->dp;
  tp=&dp->tp;

  dp->tp.face_ll=0.0f;
  dp->tp.vertex_ll=0.0f;
  dp->tp.curv_ll=0.0f;
  dp->tp.qcurv_ll=0.0f;
  dp->tp.unmri_ll=0.0f;

  if (first_time)
  {
    l_vol = parms->l_unmri ;
    l_surf =  parms->l_curv ;
    l_wm = 0; //parms->l_wm;
    first_time=0;
  }

  //compute the likelihood of the topologically-corrected volume
  if (!FZERO(l_vol) &&
      dp->mri_defect->width >= 5 &&
      dp->mri_defect->height >= 5 &&
      dp->mri_defect->depth >= 5)
  {
    /* compute the signed distance volume */
    MRIScomputeDistanceVolume(parms,2.0);
#if 0
    if (def == parms->defect_number && when == 1)
    {
      now = 1;
    }
    if (def != parms->defect_number)
    {
      def = parms->defect_number;
      when = 1;
    }
    if (now)
    {
      MRISsaveLocal(parms->mris_defect,parms,"./defect");
      now=0;
      when=0;
    }
#endif
    unmri_ll = computeVolumeLikelihood(dp, parms->contrast, 0) ;
    fitness+= l_vol * unmri_ll ;
  }
  //compute the likelihood of the surface
  if (!FZERO(l_surf))
  {
    curv_ll = computeSurfaceLikelihood(mris, dp, 0) ;
    fitness += l_surf * curv_ll ;
  }
  unmri_ll=-unmri_ll;
  curv_ll=-curv_ll;
  dp->tp.unmri_ll = unmri_ll;
  dp->tp.curv_ll = curv_ll;
  dp->tp.qcurv_ll = 2*curv_ll;
  dp->tp.cll = curv_ll;
  dp->tp.qcll = 2*curv_ll;

  return (fitness);
}

void MRISprintInfo(TOPOFIX_PARMS *parms)
{
  TP *tp;
  tp=&((DP*)parms->dp)->tp;
  TPprint(tp);
}


int IsMRISselfIntersecting(MRI_SURFACE *mris)
{
  MRIS_HASH_TABLE  *mht ;
  int fno ;

  mht = MHTfillTable(mris, NULL) ;

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    if (MHTdoesFaceIntersect(mht, mris, fno))
    {
      MHTfree(&mht);
      return 1;
    }
  }

  MHTfree(&mht) ;
  return 0 ;
}


// ------------ Definition of the static functions -------------------- //

static void TPprint(TP *tp)
{
  double mri,curv;
#if DO_NOT_USE_AREA
  mri = (tp->face_ll+tp->vertex_ll)/4.0;
  curv = (tp->qcurv_ll+tp->curv_ll)/3.0;
#else
  mri = (tp->fll+tp->vll)/4.0;
  curv = (tp->qcll+tp->cll)/3.0;
#endif
  fprintf(
    WHICH_OUTPUT,
    "         mri =%3.3f   curv = %3.3f unmri = %3.3f\n",
    mri,curv,tp->unmri_ll);
  fprintf
  (WHICH_OUTPUT,
   "         ( f=%2.2f , v=%2.2f , c=%2.2f , q= %2.2f  ) \n" ,
   tp->face_ll,tp->vertex_ll,tp->curv_ll,tp->qcurv_ll);
  fprintf
  (WHICH_OUTPUT,
   "         ( f=%2.2f , v=%2.2f , c=%2.2f , q= %2.2f ) \n" ,
   tp->fll,tp->vll,tp->cll,tp->qcll);
}

static void TPinit(TP *tp)
{
  tp->vertices=NULL;
  tp->faces=NULL;
  tp->edges=NULL;
}

static void TPfree(TP *tp)
{
  if (tp->vertices)
  {
    free(tp->vertices);
  }
  if (tp->faces)
  {
    free(tp->faces);
  }
  if (tp->edges)
  {
    free(tp->edges);
  }
  TPinit(tp);
}



static SEGMENTATION* SEGMENTATIONalloc(int max_segments, int max_edges)
{
  int n;
  SEGMENTATION *seg;
  SEGMENT *segment;

  seg=(SEGMENTATION*)calloc(1,sizeof(SEGMENTATION));
  seg->segments=(SEGMENT*)calloc(max_segments,sizeof(SEGMENT));
  seg->nsegments=0;
  seg->max_segments=max_segments;

  for ( n = 0 ; n < max_segments ; n++)
  {
    segment=&seg->segments[n];
    segment->edges=(int*)malloc(max_edges*sizeof(int));
    segment->max_edges=max_edges;
    segment->nedges=0;

    segment->xedges=(int*)malloc(max_edges*sizeof(int));
    segment->max_xedges=max_edges;
    segment->nxedges=0;
  }

  return seg;
}

static void SEGMENTATIONfree(SEGMENTATION **segmentation)
{
  int n;
  SEGMENTATION *seg;

  seg=*segmentation;
  *segmentation=NULL;

  for (n=0; n<seg->max_segments; n++)
  {
    if (seg->segments[n].edges)
    {
      free(seg->segments[n].edges);
    }
    if (seg->segments[n].xedges)
    {
      free(seg->segments[n].xedges);
    }
  }
  if (seg->segments)
  {
    free(seg->segments);
  }
  free(seg);
}

static int findSegment(SEGMENTATION *segmentation)
{
  int n;
  SEGMENT *tmp;

  if (segmentation->nsegments==segmentation->max_segments)
  {
    segmentation->max_segments+=10;
    tmp=segmentation->segments;
    segmentation->segments=
      (SEGMENT*)calloc(segmentation->max_segments,sizeof(SEGMENT));
    memmove(segmentation->segments,tmp,segmentation->nsegments*sizeof(SEGMENT));
    free(tmp);
  }
  for ( n = 0 ; n < segmentation->nsegments ; n++)
    if (segmentation->segments[n].nedges==0)
    {
      break;
    }

  return n;
}

static int compatibility(SEGMENTATION *segmentation, int segment_n, int edge_n)
{
  SEGMENT *segment;
  ES *es;
  int n,m;

  if (segment_n<0)
  {
    return 0;
  }

  segment=&segmentation->segments[segment_n];

  for ( n = 0 ; n < segment->nxedges ; n++)
    if (segment->xedges[n]==edge_n)
    {
      return 0;
    }

  es=&segmentation->edges[edge_n];

  for ( m = 0 ; m < es->nxedges ; m++)
    for ( n = 0 ; n < segment->nedges ; n++)
      if (es->xedges[m]==segment->edges[n])
      {
        return 0;
      }

  return 1;
}

/* add edge n into segment n */
static int addEdgeToSegment
(SEGMENTATION *segmentation, int segment_n, int edge_n)
{
  SEGMENT *segment;
  int n,m,inside,val,*tmp,nedges;
  ES *es;

  segment=&segmentation->segments[segment_n];
  /* first add edge */
  if (segment->nedges==segment->max_edges)
  {
    tmp=segment->edges;
    segment->max_edges+=10;
    segment->edges=(int*)malloc(segment->max_edges*sizeof(int));
    memmove(segment->edges,tmp,segment->nedges*sizeof(int));
    free(tmp);
  }
  segment->edges[segment->nedges++]=edge_n;

  /* modify edge */
  es=&segmentation->edges[edge_n];
  es->segment=segment_n;

  /* add excluded edges */
  nedges=segment->nxedges+es->nxedges;
  if (nedges>=segment->max_xedges)
  {
    tmp=segment->xedges;
    segment->max_xedges=nedges+10;
    segment->xedges=(int*)malloc(segment->max_xedges*sizeof(int));
    memmove(segment->xedges,tmp,segment->nxedges*sizeof(int));
    free(tmp);
  }
  for ( n = 0 ; n < es->nxedges ; n++)
  {
    val=es->xedges[n];
    for (inside = m = 0 ; m < segment->nxedges ; m++)
      if (val==segment->xedges[m])
      {
        inside=1;
        break;
      }
    if (inside)
    {
      continue;
    }
    /* add edge */
    segment->xedges[segment->nxedges++]=val;
  }

  return NO_ERROR;
}

/* merge segment 2 into segment 1 */
static int mergeSegmentToSegment
(SEGMENTATION *segmentation, int segment_1, int segment_2)
{
  int n,m,val,inside,nedges,*tmp;
  SEGMENT *segment1,*segment2;

  segment1=&segmentation->segments[segment_1];
  segment2=&segmentation->segments[segment_2];

  /* check compatibility of the two segments */
  for (n = 0 ; n < segment2->nxedges ; n++)
    for (m = 0 ; m < segment1->nedges ; m++)
      if (segment1->edges[m]==segment2->xedges[n])
      {
        return NO_ERROR;
      }

  for (n = 0 ; n < segment1->nxedges ; n++)
    for (m = 0 ; m < segment2->nedges ; m++)
      if (segment2->edges[m]==segment1->xedges[n])
      {
        return NO_ERROR;
      }


  nedges=segment1->nedges+segment2->nedges;
  /* reallocating if necessary */
  if (nedges>=segment1->max_edges)
  {
    tmp=segment1->edges;
    segment1->max_edges=nedges+10;
    segment1->edges=(int*)malloc(segment1->max_edges*sizeof(int));
    memmove(segment1->edges,tmp,segment1->nedges*sizeof(int));
    free(tmp);
  }

  /* copy edges into segment 1 and updating edges */
  for (n = 0 ; n < segment2->nedges ; n++)
  {
    val=segment2->edges[n];
    segment1->edges[n+segment1->nedges]=val;
    segmentation->edges[val].segment=segment_1;
  }
  segment1->nedges=nedges;
  segment2->nedges=0;

  /* overlapping edges */
  nedges=segment1->nxedges+segment2->nxedges;
  if (nedges>=segment1->max_xedges)
  {
    tmp=segment1->xedges;
    segment1->max_xedges=nedges+10;
    segment1->xedges=(int*)malloc(segment1->max_xedges*sizeof(int));
    memmove(segment1->xedges,tmp,segment1->nxedges*sizeof(int));
    free(tmp);
  }
  /* copy edges into segment1 */
  for (n = 0 ; n < segment2->nxedges ; n++)
  {
    val=segment2->xedges[n];
    for ( inside = m = 0 ; m < segment1->nxedges ; m++)
      if (segment1->xedges[m]==val)
      {
        /* already inside segment1 */
        inside=1;
        break;
      }
    if (inside)
    {
      continue;
    }
    segment1->xedges[segment1->nxedges++]=val;
  }
  segment2->nxedges=0;
  segmentation->nsegments--;

  return NO_ERROR;
}

#define MAX_CLUSTERS 40

static void segmentEdge(MRIS *mris, SEGMENTATION *segmentation, int edge_n)
{
  int n,m,vno,stop;
  int clusters[MAX_CLUSTERS],nclusters,segment_n;
  EP *ep;

  /* check if the neighbors are already segmented */
  vno=segmentation->edges[edge_n].vno1;
  ep=(EP*)mris->vertices[vno].vp;
  for ( nclusters = 0 , n = 0 ; n < ep->nedges ; n++)
  {
    if (ep->edges[n]==edge_n)
    {
      continue;
    }
    segment_n=segmentation->edges[ep->edges[n]].segment;
    for (stop=m=0; m<nclusters; m++)
      if (segment_n==clusters[m])
      {
        stop=1;
        break;
      }
    if (stop)
    {
      continue;
    }
    if (compatibility(segmentation,segment_n,edge_n))
    {
      clusters[nclusters++]=segment_n;
    }
  }
  vno=segmentation->edges[edge_n].vno2;
  ep=(EP*)mris->vertices[vno].vp;
  for (n = 0 ; n < ep->nedges ; n++)
  {
    if (ep->edges[n]==edge_n)
    {
      continue;
    }
    segment_n=segmentation->edges[ep->edges[n]].segment;
    for (stop=m=0; m<nclusters; m++)
      if (segment_n==clusters[m])
      {
        stop=1;
        break;
      }
    if (stop)
    {
      continue;
    }
    if (compatibility(segmentation,segment_n,edge_n) )
    {
      clusters[nclusters++]=segment_n;
    }
  }

  /* cluster this edge */
  switch (nclusters)
  {
  case 0: /* create new cluster */
    //fprintf(stderr,",0");
    n=findSegment(segmentation);
    addEdgeToSegment(segmentation,n,edge_n);
    segmentation->nsegments++;
    break;
  case 1: /* add edge to cluster */
    //fprintf(stderr,",1");
    addEdgeToSegment(segmentation,clusters[0],edge_n);
    break;
  default: /* add edge and merge clusters if possible :-) */
    //    fprintf(stderr,",2");
    /* add edge to smallest cluster */
    for (n=1; n<nclusters; n++)
      if (segmentation->segments[clusters[1]].nedges<segmentation->segments[clusters[0]].nedges)
      {
        /* swap */
        m=clusters[0];
        clusters[0]=clusters[1];
        clusters[1]=m;
      }

    addEdgeToSegment(segmentation,clusters[0],edge_n);
    for ( n = 1 ; n < nclusters ; n++)
    {
      mergeSegmentToSegment(segmentation,clusters[0],clusters[n]);
    }
    break;
  }

  //  fprintf(stderr," %d",segmentation->nsegments);

}

static SEGMENTATION* segmentIntersectingEdges
(MRIS *mris, DEFECT *defect, int * vertex_trans,ES *es, int *nedges)
{
  int n,m,vno1,vno2,ndiscarded,nes,vtn;
  int nsegments,*segments,*sizes,changed,tmp;
  EDGE e1,e2;
  SEGMENTATION *segmentation,*new_segmentation ;

  nes=*nedges;

  if (!nes)
  {
    return NULL;
  }

  /* mark the inside vertices */
  for ( n = 0 ; n < defect->nvertices ; n++)
  {
    vtn=vertex_trans[defect->vertices[n]];
    if (vtn < 0 || vtn >= mris->nvertices)
    {
      fprintf(stderr,
              "segmentIntersectingEdges: vertex < 0 : should not happen");
      continue;
    }
    mris->vertices[vtn].marked=1;
  }
  for ( n = 0 ; n < defect->nborder ; n++)
  {
    mris->vertices[vertex_trans[defect->border[n]]].marked=0;
  }

  /* first consider the inside edges */
#if 0

  for ( ndiscarded = n = 0 ; n < nes ; n++ )
  {
    if (mris->vertices[es[n].vno1].marked==0)
    {
      if (n<nes-1)
      {
        memmove(&es[n], &es[n+1], (nes-n-1)*sizeof(ES)) ;
      }
      nes--;
      n--;
      ndiscarded++;
      continue;
    }
    if (mris->vertices[es[n].vno2].marked==0)
    {
      if (n<nes-1)
      {
        memmove(&es[n], &es[n+1], (nes-n-1)*sizeof(ES)) ;
      }
      nes--;
      n--;
      ndiscarded++;
      continue;
    }
  }
  fprintf(WHICH_OUTPUT,
          "%d out of %d edges were discarded \n",ndiscarded,nes+ndiscarded);
#else
  {
    ES *new_es;
    new_es=(ES*)malloc(nes*sizeof(ES));
    for ( m = n = 0 ; n < nes ; n++ )
    {
      if (mris->vertices[es[n].vno1].marked==0)
      {
        continue;
      }
      if (mris->vertices[es[n].vno2].marked==0)
      {
        continue;
      }

      new_es[m].vno1=es[n].vno1;
      new_es[m].vno2=es[n].vno2;
      new_es[m].n=es[n].n;
      new_es[m].segment=es[n].segment;
      new_es[m].xedges=es[n].xedges;
      new_es[m++].nxedges=es[n].nxedges;
    }
    for ( n = 0 ; n < nes ; n++ )
    {
      if (mris->vertices[es[n].vno1].marked && mris->vertices[es[n].vno2].marked)
      {
        continue;
      }

      new_es[m].vno1=es[n].vno1;
      new_es[m].vno2=es[n].vno2;
      new_es[m].n=es[n].n;
      new_es[m].segment=es[n].segment;
      new_es[m].xedges=es[n].xedges;
      new_es[m++].nxedges=es[n].nxedges;
    }
    memmove(es,new_es,nes*sizeof(ES));
    free(new_es);
  }
#endif

  /* unmark the inside vertices */
  for ( n = 0 ; n < defect->nvertices ; n++)
  {
    vtn=vertex_trans[defect->vertices[n]];
    if (vtn < 0 || vtn >= mris->nvertices)
    {
      fprintf(stderr,
              "segmentIntersectingEdges: vertex < 0: should not happen");
      continue;
    }
    mris->vertices[vtn].marked=0;
  }
  for ( n = 0 ; n < defect->nborder ; n++)
  {
    mris->vertices[vertex_trans[defect->border[n]]].marked=0;
  }

  //  fprintf(WHICH_OUTPUT,"update surface\n");

  /* update surface */
  for ( n = 0 ; n < defect->nvertices ; n++ )
  {
    mris->vertices[defect->vertices[n]].vp=NULL;
  }
  for ( n = 0 ; n < defect->nborder; n++ )
  {
    mris->vertices[defect->border[n]].vp=NULL;
  }

  for ( n = 0 ; n < nes ; n++)
  {
    EP *ep;

    vno1=es[n].vno1;


    if (mris->vertices[vno1].vp==NULL)
    {
      mris->vertices[vno1].vp=(void*)calloc(1,sizeof(EP));
    }
    ep=(EP*)mris->vertices[vno1].vp;
    if (ep->nedges==0)
    {
      ep->edges=(int*)malloc((25+mris->vertices[vno1].vnum)*sizeof(int));
    }
    ep->edges[ep->nedges++]=n;

    vno2=es[n].vno2;

    if (mris->vertices[vno2].vp==NULL)
    {
      mris->vertices[vno2].vp=(void*)calloc(1,sizeof(EP));
    }
    ep=(EP*)mris->vertices[vno2].vp;
    if (ep->nedges==0)
    {
      ep->edges=(int*)malloc((25+mris->vertices[vno2].vnum)*sizeof(int));
    }
    ep->edges[ep->nedges++]=n;
  }

  //fprintf(WHICH_OUTPUT,"finding overlapping edges \n");

  /* finding overlapping edges */
  for ( n = 0  ; n < nes ; n++ )
  {
    es[n].nxedges=0;
    es[n].xedges=(int*)malloc((nes-1)*sizeof(int));
    e1.vno1=es[n].vno1;
    e1.vno2=es[n].vno2;
    for ( m = 0  ; m < nes ; m++ )
    {
      if ( n == m )
      {
        continue;
      }
      e2.vno1=es[m].vno1;
      e2.vno2=es[m].vno2;
      if (edgesIntersect(mris, &e1, &e2))
      {
        es[n].xedges[es[n].nxedges++]=m;
      }
    }
#if 0
    fprintf(stdout,"%d and %d:",n,es[n].nxedges);
    if (es[n].nxedges)
      for ( m = 0  ; m <es[n].nxedges ; m++)
      {
        fprintf(stdout," %d",es[n].xedges[m]);
      }
    fprintf(stdout,"\n");
#endif
  }

  /* allocating structure */
  segmentation=SEGMENTATIONalloc(MAX_SEGMENTS,MAX_SEGMENT_EDGES);
  segmentation->edges=es;
  segmentation->nedges=nes;

  *nedges=nes;

  /* ********************************************* */
  /*                 MAIN LOOP                     */

  /* segmenting edges */
  for ( n = 0  ; n < nes ; n++ )
  {
    segmentEdge(mris, segmentation,n);
  }

  /* ********************************************* */

  /* sorting of the segments */
  nsegments=segmentation->nsegments;
  segments=(int*)malloc(nsegments*sizeof(int));
  sizes=(int*)malloc(nsegments*sizeof(int));
  for (nsegments = n = 0 ; n < segmentation->max_segments ; n++)
    if (segmentation->segments[n].nedges>0)
    {
      segments[nsegments]=n;
      sizes[nsegments++]=segmentation->segments[n].nedges;
    }

  changed=1;
  while (changed)
  {
    changed=0;
    for (n = 0 ; n < nsegments-1 ; n++)
      if (sizes[n]<sizes[n+1])
      {
        tmp=sizes[n];
        sizes[n]=sizes[n+1];
        sizes[n+1]=tmp;
        tmp=segments[n];
        segments[n]=segments[n+1];
        segments[n+1]=tmp;
        changed=1;
      }
  }

  free(sizes);

  new_segmentation=(SEGMENTATION*)calloc(1,sizeof(SEGMENTATION));
  new_segmentation->nsegments=nsegments;
  new_segmentation->max_segments=nsegments;
  new_segmentation->segments=(SEGMENT*)calloc(nsegments,sizeof(SEGMENT));
  new_segmentation->edges=segmentation->edges;
  new_segmentation->nedges=segmentation->nedges;
  new_segmentation->mris=segmentation->mris;

  for (n = 0 ; n < nsegments ; n++)
  {
    SEGMENT *sd,*ss;
    sd=&new_segmentation->segments[n];
    ss=&segmentation->segments[segments[n]];

    memmove(sd,ss,sizeof(SEGMENT));

    ss->edges=NULL;
    ss->xedges=NULL;

    for (m = 0 ; m < sd->nedges ; m++)
    {
      new_segmentation->edges[sd->edges[m]].segment=n;
    }
  }

  free(segments);

  SEGMENTATIONfree(&segmentation);
  segmentation=new_segmentation;

  /* remove segments with less than 5 edges -
     keep at least 3 segments , at max 10 */
  for ( ndiscarded = 0 , n = 3 ; n < segmentation->max_segments ; n++)
  {
    if (segmentation->segments[n].nedges<=0)
    {
      continue;
    }
    if ((n>=10) || segmentation->segments[n].nedges<5)
    {

      for ( m = 0 ; m < segmentation->segments[n].nedges ; m++)
      {
        segmentation->edges[segmentation->segments[n].edges[m]].segment=-1;
      }

      segmentation->segments[n].nedges=0;
      segmentation->segments[n].nxedges=0;

      segmentation->nsegments--;

      ndiscarded++;
    }
  }

  if (DIAG_VERBOSE_ON)
    fprintf
    (WHICH_OUTPUT,
     "Edge Clustering: %d segments were found (%d were discarded )\n",
     segmentation->nsegments,ndiscarded);

#if 0
  for ( n = 0 ; n < segmentation->max_segments ; n++)
    if (segmentation->segments[n].nedges>0)
      fprintf(WHICH_OUTPUT,
              "#%d (%d edges) -",n,segmentation->segments[n].nedges);
#endif
  //  fprintf(WHICH_OUTPUT,"\nclustering...\n");

  /* merging edges into the smallest neighboring component */
  changed=1;
  while (changed)
  {
    int vno,nbh,nbh_size;
    EP *ep;
    changed=0;
    for (n = 0 ; n < segmentation->nedges; n++)
    {
      if (segmentation->edges[n].segment>=0)
      {
        continue;
      }
      /* find neighbors of this edge */
      nbh=-1;
      nbh_size=-1;
      vno=segmentation->edges[n].vno1;
      ep=(EP*)mris->vertices[vno].vp;
      for (m=0 ; m < ep->nedges ; m++)
        if ( segmentation->edges[ep->edges[m]].segment>=0 )
        {
          if (nbh_size==-1)
          {
            nbh=segmentation->edges[ep->edges[m]].segment;
            nbh_size=segmentation->segments[nbh].nedges;
          }
          else if (segmentation->segments[segmentation->edges[ep->edges[m]].segment].nedges<nbh_size)
          {
            nbh=segmentation->edges[ep->edges[m]].segment;
            nbh_size=segmentation->segments[nbh].nedges;
          }
        }
      vno=segmentation->edges[n].vno2;
      ep=(EP*)mris->vertices[vno].vp;
      for (m=0 ; m < ep->nedges ; m++)
        if ( segmentation->edges[ep->edges[m]].segment>=0 )
        {
          if (nbh_size==-1)
          {
            nbh=segmentation->edges[ep->edges[m]].segment;
            nbh_size=segmentation->segments[nbh].nedges;
          }
          else if (segmentation->segments[segmentation->edges[ep->edges[m]].segment].nedges<nbh_size)
          {
            nbh=segmentation->edges[ep->edges[m]].segment;
            nbh_size=segmentation->segments[nbh].nedges;
          }
        }
      if (nbh>=0)
      {
        SEGMENT *seg;
        changed=1;
        /* add this edge into the segment nbh */
        segmentation->edges[n].segment=nbh;
        seg=&segmentation->segments[nbh];
        if (seg->nedges==seg->max_edges)
        {
          int *tp;
          tp=seg->edges;
          seg->max_edges+=10;
          seg->edges=(int*)malloc(seg->max_edges*sizeof(int));
          memmove(seg->edges,tp,seg->nedges*sizeof(int));
          free(tp);
        }
        seg->edges[seg->nedges++]=n;
      }
    }
  }
  for ( n = 0 ; n < segmentation->max_segments ; n++)
    if (segmentation->segments[n].nedges>0)
    {
      if (DIAG_VERBOSE_ON)
        fprintf
        (WHICH_OUTPUT,
         "                 cluster %d has %d edges\n",
         n,segmentation->segments[n].nedges);
    }

  for ( n = 0  ; n < nes ; n++ )
    if (es[n].xedges)
    {
      free(es[n].xedges);
    }

  for ( n = 0 ; n < nes ; n++)
  {
    EP *ep;
    vno1=es[n].vno1;

    if (mris->vertices[vno1].vp)
    {
      ep=(EP*)mris->vertices[vno1].vp;
      if (ep->edges)
      {
        free(ep->edges);
      }
      free(mris->vertices[vno1].vp);
      mris->vertices[vno1].vp=NULL;
    }

    vno2=es[n].vno2;

    if (mris->vertices[vno2].vp)
    {
      ep=(EP*)mris->vertices[vno2].vp;
      if (ep->edges)
      {
        free(ep->edges);
      }
      free(mris->vertices[vno2].vp);
      mris->vertices[vno2].vp=NULL;
    }
  }

  return segmentation;
}

static void saveSegmentation
(MRIS *mris, MRIS *mris_corrected,
 DEFECT *defect,int *vertex_trans, ES *es, int nes,char *fname)
{
  int n,val,v_rgb,vtn;
  int r,g,b,rgb[10];
  char name[500];

  MRISRGBToAnnot(0,225,225,rgb[0]);
  MRISRGBToAnnot(205,62,78,rgb[1]);
  MRISRGBToAnnot(120,62,78,rgb[2]);
  MRISRGBToAnnot(196,58,250,rgb[3]);
  MRISRGBToAnnot(0,148,0,rgb[4]);
  MRISRGBToAnnot(220,248,164,rgb[5]);
  MRISRGBToAnnot(230,148,34,rgb[6]);
  MRISRGBToAnnot(0,118,14,rgb[7]);
  MRISRGBToAnnot(12,48,255,rgb[8]);
  MRISRGBToAnnot(122,186,220,rgb[9]);

  for (n = 0 ; n < nes ; n++)
  {
    val=es[n].segment;
    r=100+20*val;
    g=150-20*val;
    b=200-20*val;
    //v_rgb=(int)(((int)((r<<24)+(g<<16)+((b)<<8)))>>8);

    if (val>=0)
    {
      //v_rgb=(int)((int)(rgb[val%5]<<8)>>8);
      v_rgb=rgb[val%10];
      mris_corrected->vertices[es[n].vno1].annotation=v_rgb;
      mris_corrected->vertices[es[n].vno2].annotation=v_rgb;
    }
  }

  MRISclearAnnotations(mris);

  for (n =0 ; n <defect->nvertices ; n++)
  {
    vtn=vertex_trans[defect->vertices[n]];
    if (vtn < 0 || vtn >= mris_corrected->nvertices)
    {
      fprintf(stderr,"saveSegmentation: vertex < 0 : should not happen");
      continue;
    }
    v_rgb=mris_corrected->vertices[vtn].annotation;
    mris->vertices[defect->vertices[n]].annotation=(int)((int)(v_rgb<<8)>>8);
  }
  for (n =0 ; n<defect->nborder ; n++)
  {
    v_rgb=mris_corrected->vertices[vertex_trans[defect->border[n]]].annotation;
    mris->vertices[defect->border[n]].annotation=(int)((int)(v_rgb<<8)>>8);
  }
  sprintf(name,"%s/rh.annotation%d",fname,defect->defect_number);
  fprintf(WHICH_OUTPUT,
          "writting annotation file for edge clustering "
          "segmentation of defect %d\n",
          defect->defect_number);

  MRISwriteAnnotation(mris,name);

}

static void generateOrdering(DP *dp,SEGMENTATION *segmentation, int i)
{
  int n,m,val,r;
  int *ordering,*counter,nedges;
  int *seg_order,nseg;

  /* nothing to be done for the first segment */
  if (i==0)
  {
    return;
  }

  if (segmentation==NULL)
  {
    mrisMutateDefectPatch(dp, dp->etable, MUTATION_PCT_INIT) ;
    return ;
  }

  seg_order=(int*)malloc(sizeof(int)*segmentation->nsegments);
  nseg=segmentation->nsegments;
  for (n=0; n<nseg; n++)
  {
    seg_order[n]=n;
  }

  r=i%segmentation->nsegments+1;

  /* find the nth segment */
  for (n=0 ; n < segmentation->max_segments ; n++)
  {
    if (segmentation->segments[n].nedges>0)
    {
      r--;
    }
    if (r==0)
    {
      break;
    }
  }
  counter=(int*)calloc(dp->nedges,sizeof(int));
  ordering=(int*)calloc(dp->nedges,sizeof(int));

  /* use the nth segment */
  nedges=0;
  for (m=0; m<segmentation->segments[n].nedges; m++)
  {
    val=segmentation->edges[segmentation->segments[n].edges[m]].n;
    ordering[nedges++]=val;
    counter[val]=1;
  }

  /* use all the other segments */
  /* first generate random ordering of the segments */
  for (m=0; m<11; m++)
    for (n=0; n < nseg; n++)
    {
      fflush(stdout); // nicknote: prevents segfault on Linux PowerPC
      // when -O2 optimization is used w/gcc 3.3.3

      r=nint(randomNumber(0.0, (double)nseg-1)) ;

      val=seg_order[n];
      seg_order[n]=seg_order[r];
      seg_order[r]=val;
    }

  for (n=0; n<nseg; n++)
    for (m=0; m<segmentation->segments[seg_order[n]].nedges; m++)
    {
      val=segmentation->edges[segmentation->segments[seg_order[n]].edges[m]].n;
      if (counter[val])
      {
        continue;
      }
      ordering[nedges++]=val;
      counter[val]=1;
    }

  for (m=0; m<dp->nedges; m++)
  {
    val=dp->ordering[m];
    if (counter[val]==0)
    {
      counter[val]=1;
      ordering[nedges++]=val;
    }
  }

  free(dp->ordering);
  dp->ordering=ordering;
  free(seg_order);

  if (r!=i+1)
  {
    mrisMutateDefectPatch(dp, dp->etable, MUTATION_PCT_INIT) ;
  }
}

static MRIS* extractDefect(MRIS *mris,DEFECT *defect)
{
  int n,vno,nvertices,nfaces,*vtrans,*vertex_trans;
  VERTEX *vdst,*vsrc;
  FACE *fdst,*fsrc;
  MRIS *mris_small;

  vertex_trans = defect->vertex_trans;

  /* marking vertices */
  nvertices=0;
  for (n=0; n<defect->nvertices; n++)
  {
    if (defect->status[n]==DISCARD_VERTEX)
    {
      continue;
    }
    vno=vertex_trans[defect->vertices[n]];
    if (vno<0 || vno>=mris->nvertices)
    {
      continue;
    }
    mris->vertices[vno].marked=110;
    nvertices++;
  }
  for (n=0; n<defect->nchull; n++)
  {
    vno=vertex_trans[defect->chull[n]];
    if (vno<0 || vno>=mris->nvertices)
    {
      continue;
    }
    mris->vertices[vno].marked=110;
    nvertices++;
  }

  nfaces=0;
  for (n=0; n<mris->nfaces; n++)
  {
    fsrc=&mris->faces[n];
    if (mris->vertices[fsrc->v[0]].marked==110 &&
        mris->vertices[fsrc->v[1]].marked==110 &&
        mris->vertices[fsrc->v[2]].marked==110)
    {
      nfaces++;
    }
  }


  mris_small=MRISalloc(nvertices,nfaces);
  mris_small->type = MRIS_TRIANGULAR_SURFACE;
  mris_small->useRealRAS=mris->useRealRAS;

  vtrans=(int*)malloc(mris->nvertices*sizeof(int));

  /* vertex positions */
  for ( nvertices = n = 0 ; n < defect->nvertices+defect->nchull ; n++)
  {

    if (n<defect->nvertices)
    {
      if (defect->status[n]==DISCARD_VERTEX)
      {
        continue;
      }
      vno=vertex_trans[defect->vertices[n]];
    }
    else
    {
      vno=vertex_trans[defect->chull[n-defect->nvertices]];
    }

    if (vno<0 || vno>=mris->nvertices)
    {
      continue;
    }

    vdst=&mris_small->vertices[nvertices];
    vsrc=&mris->vertices[vno];
    vdst->x=vsrc->x;
    vdst->y=vsrc->y;
    vdst->z=vsrc->z;
    if (vsrc->old_undefval)
    {
      vdst->curv=1;
    }
    vtrans[vno]=nvertices++;
  }

  /* now the faces */
  nfaces=0;
  for (n=0; n<mris->nfaces; n++)
  {
    fsrc=&mris->faces[n];
    if (mris->vertices[fsrc->v[0]].marked==110 &&
        mris->vertices[fsrc->v[1]].marked==110 &&
        mris->vertices[fsrc->v[2]].marked==110)
    {
      fdst=&mris_small->faces[nfaces];
      fsrc=&mris->faces[n];
      fdst->v[0]=vtrans[fsrc->v[0]];
      fdst->v[1]=vtrans[fsrc->v[1]];
      fdst->v[2]=vtrans[fsrc->v[2]];
      nfaces++;
    }
  }

  /* unmarking vertices */
  for (n=0; n<defect->nvertices; n++)
  {
    if (defect->status[n]==DISCARD_VERTEX)
    {
      continue;
    }
    vno=vertex_trans[defect->vertices[n]];
    if (vno<0 || vno>=mris->nvertices)
    {
      continue;
    }
    mris->vertices[vno].marked=0;
  }

  for (n=0; n<defect->nchull; n++)
  {
    vno=vertex_trans[defect->chull[n]];
    if (vno<0 || vno>=mris->nvertices)
    {
      continue;
    }
    mris->vertices[vno].marked=0;
  }

  free(vtrans);

  return mris_small;
}

#define EXTRACT_SMALL_SURFACE 0

static void savePatch(MRI *mri,
                      MRIS *mris,
                      MRIS *mris_corrected,
                      DVS *dvs,
                      DP *dp,
                      char *fname,
                      TOPOLOGY_PARMS *parms)
{
  int i;
  VERTEX *vsrc,*vdst;
  MRIS *mris_small;

  retessellateDefect(mris, mris_corrected, dvs, dp) ;

  /* detect the new set of faces */
  detectDefectFaces(mris_corrected,dp);

  /* orient the patch faces */
  orientDefectFaces(mris_corrected,dp);

  if (parms->verbose==VERBOSE_MODE_LOW)
    fprintf(WHICH_OUTPUT,
            "(%d , %d , %d ) - %d vertices were discarded \n",
            dp->tp.ninside,dp->tp.nedges,
            dp->tp.nfaces,dp->tp.ndiscarded);

  //before smoothing and after
  MRISrestoreVertexPositions(mris_corrected, ORIGINAL_VERTICES) ;

  if (EXTRACT_SMALL_SURFACE)
  {
    /* extract 'small' surface */
    mris_small=extractDefect(mris_corrected,dp->defect);
    /* save surface */
    MRISwrite(mris_small,fname);
  }
  else
    /* save surface */
  {
    MRISwrite(mris_corrected,fname);
  }

  /* smooth original vertices in the retessellated patch */
  defectMatch(mri,mris_corrected,dp,parms->smooth,0);

  strcat(fname,"s");

  MRISrestoreVertexPositions(mris_corrected, ORIGINAL_VERTICES) ;

  if (EXTRACT_SMALL_SURFACE)
  {
    int nvertices;
    /* transfer current coord to 'small' surface */
    for ( nvertices = i = 0 ;
          i< dp->defect->nvertices+dp->defect->nchull ;
          i++ )
    {
      int vno;
      if (i<dp->defect->nvertices)
      {
        if (dp->defect->status[i]==DISCARD_VERTEX)
        {
          continue;
        }
        vno=dp->defect->vertex_trans[dp->defect->vertices[i]];
      }
      else
        vno=
          dp->defect->vertex_trans[dp->defect->chull[i-dp->defect->nvertices]];
      if (vno<0 || vno>=mris_corrected->nvertices)
      {
        continue;
      }
      vdst=&mris_small->vertices[nvertices++];
      vsrc=&mris_corrected->vertices[vno];
      vdst->x=vsrc->x;
      vdst->y=vsrc->y;
      vdst->z=vsrc->z;
    }
    /* save surface */
    MRISwrite(mris_small,fname);
  }
  else
    /* save surface */
  {
    MRISwrite(mris_corrected,fname);
  }

  /* smooth original vertices in the retessellated patch */
  defectMatch(mri,mris_corrected,dp,0,parms->match);

  strcat(fname,"m");

  MRISrestoreVertexPositions(mris_corrected, ORIGINAL_VERTICES) ;

  if (EXTRACT_SMALL_SURFACE)
  {
    int nvertices;
    /* transfer current coord to 'small' surface */
    for ( nvertices = i = 0 ;
          i< dp->defect->nvertices+dp->defect->nchull ;
          i++ )
    {
      int vno;
      if (i<dp->defect->nvertices)
      {
        if (dp->defect->status[i]==DISCARD_VERTEX)
        {
          continue;
        }
        vno=dp->defect->vertex_trans[dp->defect->vertices[i]];
      }
      else
      {
        vno=dp->defect->vertex_trans[dp->defect->chull[i-dp->defect->nvertices]];
      }
      if (vno<0 || vno>=mris_corrected->nvertices)
      {
        continue;
      }
      vdst=&mris_small->vertices[nvertices++];
      vsrc=&mris_corrected->vertices[vno];
      vdst->x=vsrc->x;
      vdst->y=vsrc->y;
      vdst->z=vsrc->z;
    }
    /* save surface */
    MRISwrite(mris_small,fname);
  }
  else
    /* save surface */
  {
    MRISwrite(mris_corrected,fname);
  }

  if (parms->smooth==3)
  {
    DEFECT *defect;
    int *vtrans,vno;
    VERTEX *v;
    defect=dp->defect;
    vtrans=defect->vertex_trans;
    /* write curv for eliminated vertices */
    MRISclearCurvature(mris_corrected);
    for ( i = 0 ; i < defect->nvertices ; i++)
    {
      if (defect->status[i]==DISCARD_VERTEX)
      {
        continue;
      }
      vno=vtrans[defect->vertices[i]];
      if (vno<0 || vno>= mris_corrected->nvertices)
      {
        continue;
      }
      v=&mris_corrected->vertices[vno];
      if (v->old_undefval)
      {
        v->curv=1;
      }
    }
    strcat(fname,"_c");

    if (EXTRACT_SMALL_SURFACE )
    {
      /* save surface */
      MRISwriteCurvature(mris_small,fname);
      /* free small surface */
      MRISfree(&mris_small);
    }
    else
      /* save curvature  */
    {
      MRISwriteCurvature(mris_corrected,fname);
    }

    MRISclearCurvature(mris_corrected);
  }

  /* restore the vertex state */
  mrisRestoreVertexState(mris_corrected, dvs);

  /* reset the edges to the unused state
     (unless they were in the original tessellation) */
  for (i = 0 ; i < dp->nedges ; i++)
  {
    if (dp->etable->edges[i].used == USED_IN_NEW_TESSELLATION)
    {
      dp->etable->edges[i].used = NOT_USED ;
    }
    if (dp->etable->edges[i].used == USED_IN_BOTH_TESSELLATION)
    {
      dp->etable->edges[i].used = USED_IN_ORIGINAL_TESSELLATION ;
    }
  }

  /* free vertices,edges,faces tables */
  TPfree(&dp->tp);
}

static void updateVertexStatistics(MRIS *mris,
                                   MRIS* mris_corrected,
                                   DVS *dvs,
                                   RP *rp,
                                   DP *dp,
                                   int *vertex_trans,
                                   float fitness)
{
  DEFECT *defect;
  EDGE_TABLE *etable;
  int i,nedges;
  float total_vertex_fitness=0.f,new_fitness;
  VERTEX *v;
  static int first_time=1;

  //TO UPDATE TO BE CHECKED
  if (first_time)
  {
    first_time=0;
  };

  fitness = 1.0f; //to be updated ...

  nedges=dp->nedges;
  etable=dp->etable;
  defect=dp->defect;

  /* first mark the used vertices */
  for (i = 0 ; i < nedges ; i++)
    if (etable->edges[i].used == USED_IN_NEW_TESSELLATION ||
        etable->edges[i].used == USED_IN_BOTH_TESSELLATION)
    {
      mris_corrected->vertices[etable->edges[i].vno1].marked=FINAL_VERTEX ;
      mris_corrected->vertices[etable->edges[i].vno2].marked=FINAL_VERTEX ;
    }

  /* don't need border vertices */
  for (i = 0 ; i < defect->nborder ; i++)
  {
    mris_corrected->vertices[vertex_trans[defect->border[i]]].marked=0;
  }

  /* then compute the total fitness of these used vertices */
  total_vertex_fitness=0.0f;
  for (i = 0 ; i < defect->nvertices ; i++)
  {
    if (defect->status[i]==DISCARD_VERTEX)
    {
      continue;
    }
    v = &mris_corrected->vertices[vertex_trans[defect->vertices[i]]];
    if (v->marked==FINAL_VERTEX)
    {
      total_vertex_fitness+=v->curvbak*fitness;
    }
  }

  if (FZERO(total_vertex_fitness))
  {
    total_vertex_fitness=1.0f;
  }

  total_vertex_fitness/=100.0f;
  total_vertex_fitness=1.0f; //TO BE CHECKED

  /* finally update statistics and reset marks to zero */
  for (i = 0 ; i < defect->nvertices ; i++)
  {
    if (defect->status[i]==DISCARD_VERTEX)
    {
      continue;
    }
    v = &mris_corrected->vertices[vertex_trans[defect->vertices[i]]];
    if (v->marked==FINAL_VERTEX)
    {
      new_fitness=(v->curvbak*fitness/total_vertex_fitness) +
                  (float)rp->nused[i]*rp->vertex_fitness[i];
      rp->vertex_fitness[i]=new_fitness/((float)rp->nused[i]+1.0f);
      rp->nused[i]++;
    }
    v->marked=0;
  }
}

static int deleteWorstVertices(MRIS *mris,
                               RP *rp,
                               DEFECT *defect,
                               int *vertex_trans,
                               float fraction,
                               int count)
{
  int i,nvoxels,niters,init,changed;
  float max;
  int max_i;
  static float threshold=4.0f;
  nvoxels=0;


  if (count<=0)
  {
    fprintf(WHICH_OUTPUT,"error: count (%d) <= 0 \n",count);
    count=1;
  }

  /* first kill the non-used vertices */
  for (niters = 0 , i = 0 ; i < defect->nvertices ; i++)
  {
    if (defect->status[i]==DISCARD_VERTEX)
    {
      continue;
    }
    niters++;
    if (rp->nused[i]==0)
    {
      defect->status[i]=DISCARD_VERTEX;
      mris->vertices[vertex_trans[defect->vertices[i]]].ripflag=count; //TO BE CHECKED
      nvoxels++;
    }
  }

  /* won't kill vertices if less than 10 */
  if (niters<10)
  {
    return 0;
  }

  if (fraction > 0.1)
  {
    threshold /= 2.0f;
  }

  //kill at most 20% of the vertices
  if (niters) //at least one voxel to be killed!
  {
    niters=MAX(1,(int)(fraction*niters));  //FLO
  }

  //if(nvoxels && fraction <= 0.01) //kill only worst voxel
  //    niters=max(1,niters);

  init=niters;

  changed=1;
  while (niters && changed)
  {
    changed=0;
    //find worst voxel
    max=0;
    max_i=-1;
    for (i = 0 ; i < defect->nvertices ; i++)
    {
      if (defect->status[i]==DISCARD_VERTEX)
      {
        continue;
      }
      if (rp->vertex_fitness[i]>max)
      {
        max=rp->vertex_fitness[i];
        max_i=i;
      }
    }

    if (max_i < threshold && (2*niters<init))
    {
      break;
    }

    if (max_i>=0)
    {
      defect->status[max_i]=DISCARD_VERTEX;
      mris->vertices[vertex_trans[defect->vertices[max_i]]].ripflag=count; //TO BE CHECKED
      nvoxels++;
      changed=1;
    }
    niters--;
  }
#if 0
  /* reset vertex statistics */
  for (i = 0 ; i < defect->nvertices ; i++)
  {
    rp->vertex_fitness[i]=0;
    rp->nused[i]=0;
  }
#endif

  return nvoxels;
}

/* static void defectSurfaceToVolume
   (MRI* mri, float x, float y, float z, int *i, int *j , int *k){ */
/*   (*i)=iVOL(mri,x); */
/*   (*j)=jVOL(mri,x); */
/*   (*k)=kVOL(mri,x); */
/* } */

static MRI *mriDefectVolume(MRIS *mris,
                            EDGE_TABLE *etable,
                            TOPOLOGY_PARMS *parms)
{
  MRI *mri;
  VERTEX *v;
#if 0
  int i,j,p,numu,numv,u,w;
  float px0,px1,py0,py1,pz0,pz1,px,py,pz,d0,d1,d2,dmax,x0,y0,z0;
#endif
  int k,vno1,vno2,l,p,q,n,nmax;
  int width,height,depth;
  float len,dx,dy,dz,x,y,z,x1,y1,z1,x2,y2,z2,
        xmin,xmax,ymin,ymax,zmin,zmax,scale;


  if (parms->volume_resolution==-1)
  {
    scale=VOLUME_SCALE;
  }
  else
  {
    scale=parms->volume_resolution;
  }

  /* find dimension of the volume */
  xmin=ymin=zmin=1000.0;
  xmax=ymax=zmax=-1000.0;
  for (k = 0 ; k < etable->nedges ; k++)
  {
    v=&mris->vertices[etable->edges[k].vno1];
    if (v->origx > xmax)
    {
      xmax=v->origx;
    }
    if (v->origy > ymax)
    {
      ymax=v->origy;
    }
    if (v->origz > zmax)
    {
      zmax=v->origz;
    }
    if (v->origx < xmin)
    {
      xmin=v->origx;
    }
    if (v->origy < ymin)
    {
      ymin=v->origy;
    }
    if (v->origz < zmin)
    {
      zmin=v->origz;
    }
    v=&mris->vertices[etable->edges[k].vno2];
    if (v->origx > xmax)
    {
      xmax=v->origx;
    }
    if (v->origy > ymax)
    {
      ymax=v->origy;
    }
    if (v->origz > zmax)
    {
      zmax=v->origz;
    }
    if (v->origx < xmin)
    {
      xmin=v->origx;
    }
    if (v->origy < ymin)
    {
      ymin=v->origy;
    }
    if (v->origz < zmin)
    {
      zmin=v->origz;
    }
  }

  xmin -= 1.0f;
  ymin -= 1.0f;
  zmin -= 1.0f;
  xmax += 1.0f;
  ymax += 1.0f;
  zmax += 1.0f;

  /* allocate the volume */
  width  = ceil(scale*(xmax-xmin)) ;
  height = ceil(scale*(ymax-ymin)) ;
  depth  = ceil(scale*(zmax-zmin)) ;
  mri=MRIalloc(width,height,depth,MRI_UCHAR);

  if (parms->verbose==VERBOSE_MODE_HIGH)
    fprintf(WHICH_OUTPUT,
            "      defect volume : %d by %d by %d (scale = %d)\n",
            width,height,depth,(int)scale);

  mri->xstart=xmin;
  mri->xsize=scale;

  mri->ystart=ymin;
  mri->ysize=scale;

  mri->zstart=zmin;
  mri->zsize=scale;

  /* find all the non-used voxels :
     go through all edges (should be sufficient) */
  for (k = 0 ; k < etable->nedges ; k++)
  {
    vno1=etable->edges[k].vno1;
    vno2=etable->edges[k].vno2;

    /* starting point */
    x1=mris->vertices[vno1].origx;
    y1=mris->vertices[vno1].origy;
    z1=mris->vertices[vno1].origz;

    /* end point */
    x2=mris->vertices[vno2].origx;
    y2=mris->vertices[vno2].origy;
    z2=mris->vertices[vno2].origz;

    if (x2<x1)
    {
      /* switch vertices */
      x=x1;
      x1=x2;
      x2=x;
      y=y1;
      y1=y2;
      y2=y;
      z=z1;
      z1=z2;
      z2=z;
    }

    /* length */
    len=scale*sqrt(SQR(x2-x1)+SQR(y2-y1)+SQR(z2-z1));

    if (!FZERO(len))
    {
      dx = (x2-x1)/(2*len);
      dy = (y2-y1)/(2*len);
      dz = (z2-z1)/(2*len);
      nmax= ceil(2*len+5); /* max number of points */
      for ( x = x1 , y = y1, z = z1 , n = 0
                                          ; (x < x2) && (n < nmax)
            ; x += dx, y += dy, z += dz , n++)
      {
        l=iVOL(mri,x);
        p=jVOL(mri,y);
        q=kVOL(mri,z);
        if ((l<0)||(l>=mri->width)||
            (p<0)||(p>=mri->height)||
            (q<0)||(q>=mri->depth))
        {
          continue;
        }
        MRIvox(mri,l,p,q)=1;
      }
    }
    else
    {
      dx=dy=dz=0.0f;
      l=iVOL(mri,x1);
      p=jVOL(mri,y1);
      q=kVOL(mri,z1);
      if ((l<0)||(l>=mri->width) ||
          (p<0)||(p>=mri->height)||
          (q<0)||(q>=mri->depth))
      {
        continue;
      }
      MRIvox(mri,l,p,q)=1;
    }

    /* last point */
    l=iVOL(mri,x2);
    p=jVOL(mri,y2);
    q=kVOL(mri,z2);
    if ((l<0)||(l>=mri->width) ||
        (p<0)||(p>=mri->height)||
        (q<0)||(q>=mri->depth))
    {
      continue;
    }
    MRIvox(mri,l,p,q)=1;
  }

#if 0
  /* then, mark the correct surface in the volume */
  for ( k = 0 ; k < mris->nfaces ; k++)
  {
    // calculate three vertices
    //fprintf(WHICH_OUTPUT,
    //"\r  %f            ",100.0*(float)k/(float)mris->nfaces);
    x0 =mris->vertices[mris->faces[k].v[0]].origx;
    y0 =mris->vertices[mris->faces[k].v[0]].origy;
    z0 =mris->vertices[mris->faces[k].v[0]].origz;
    x1 =mris->vertices[mris->faces[k].v[1]].origx;
    y1 =mris->vertices[mris->faces[k].v[1]].origy;
    z1 =mris->vertices[mris->faces[k].v[1]].origz;
    x2 =mris->vertices[mris->faces[k].v[2]].origx;
    y2 =mris->vertices[mris->faces[k].v[2]].origy;
    z2 =mris->vertices[mris->faces[k].v[2]].origz;

    i=iVOL(mri,x0);
    j=iVOL(mri,x1);
    p=iVOL(mri,x2);
    if ((i<0) && (j<0) && (p<0))
    {
      continue;
    }
    if ((i>=mri->width) && (j>=mri->width) && (p>=mri->width))
    {
      continue;
    }

    i=jVOL(mri,y0);
    j=jVOL(mri,y1);
    p=jVOL(mri,y2);
    if ((i<0) && (j<0) && (p<0))
    {
      continue;
    }
    if ((i>=mri->height) && (j>=mri->height) && (p>=mri->height))
    {
      continue;
    }

    i=kVOL(mri,z0);
    j=kVOL(mri,z1);
    p=kVOL(mri,z2);
    if ((i<0) && (j<0) && (p<0))
    {
      continue;
    }
    if ((i>=mri->depth) && (j>=mri->depth) && (p>=mri->depth))
    {
      continue;
    }

    // calculate the sides
    d0 = mri->xsize*sqrt(SQR(x1-x0)+SQR(y1-y0)+SQR(z1-z0));
    d1 = mri->ysize*sqrt(SQR(x2-x1)+SQR(y2-y1)+SQR(z2-z1));
    d2 = mri->zsize*sqrt(SQR(x0-x2)+SQR(y0-y2)+SQR(z0-z2));

    //fprintf(WHICH_OUTPUT,
    // "(%f,%f,%f)and (%f,%f,%f)",x0,x1,x2,d0,d1,mri->xsize);

    dmax = (d0>=d1&&d0>=d2)?d0:(d1>=d0&&d1>=d2)?d1:d2;

    numu = (int)(ceil(2*d0));
    numv = (int)(ceil(2*dmax));

    for ( w = 0 ; w <= numv ; w++ )
    {
      px0 = x0 + (x2-x0)*w/numv;
      py0 = y0 + (y2-y0)*w/numv;
      pz0 = z0 + (z2-z0)*w/numv;
      px1 = x1 + (x2-x1)*w/numv;
      py1 = y1 + (y2-y1)*w/numv;
      pz1 = z1 + (z2-z1)*w/numv;

      for ( u = 0 ; u <= numu ; u++ )
      {
        px = px0 + (px1-px0)*u/numu;
        py = py0 + (py1-py0)*u/numu;
        pz = pz0 + (pz1-pz0)*u/numu;

        i=iVOL(mri,px);
        j=jVOL(mri,py);
        p=kVOL(mri,pz);

        if ((i<0)||(i>=mri->width) ||
            (j<0)||(j>=mri->height)||
            (p<0)||(p>=mri->depth))
        {
          continue;
        }

        MRIvox(mri,i,j,p) = 0;
      }
    }
  }
#endif
  return mri;
}


static void defectVolumeWM(MRI *mri, MRI* mri_defect, MRI *mri_wm)
{
  int i,j,k;
  double x, y, z, xv, yv, zv, val;

  if (mri == NULL)
  {
    return;
  }

  for ( k = 0 ; k < mri_defect->depth ; k++)
    for ( j = 0 ; j < mri_defect->height ; j++)
      for ( i = 0 ; i < mri_defect->width ; i++)
      {

        /* corresponding surface coords */
        x=xSURF(mri_defect,i);
        y=ySURF(mri_defect,j);
        z=zSURF(mri_defect,k);

#if MATRIX_ALLOCATION
        mriSurfaceRASToVoxel(x, y, z, &xv, &yv, &zv) ;
#else
        MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xv, &yv, &zv) ;
#endif

        MRIsampleVolume(mri, xv, yv, zv, &val) ;
        MRIFvox(mri_wm,i,j,k) = val;
      }
}

static void defectVolumeLikelihood(MRI *mri,
                                   MRI* mri_defect,
                                   MRI *mri_white,
                                   MRI *mri_gray,
                                   HISTOGRAM *h_white,
                                   HISTOGRAM *h_gray,
                                   float white_mean,
                                   float gray_mean,
                                   int type,
                                   int contrast)
{
  int i,j,k,n;
  double x, y, z, xv, yv, zv, val,sigma;

  sigma = fabs(white_mean-gray_mean)/2.0;

  for ( n  = 0 , k = 0 ; k < mri_defect->depth ; k++)
    for ( j = 0 ; j < mri_defect->height ; j++)
      for ( i = 0 ; i < mri_defect->width ; i++)
      {
        n++;
        /* corresponding surface coords */
        x=xSURF(mri_defect,i);
        y=ySURF(mri_defect,j);
        z=zSURF(mri_defect,k);

#if MATRIX_ALLOCATION
        mriSurfaceRASToVoxel(x, y, z, &xv, &yv, &zv) ;
#else
        MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xv, &yv, &zv) ;
#endif

        MRIsampleVolume(mri, xv, yv, zv, &val) ;
        MRIvox(mri_defect,i,j,k) = val;

        if (type == 0 )
        {

          MRIFvox(mri_white,i,j,k) =
            log(h_white->counts[nint(MIN(val,white_mean))]) ;
          MRIFvox(mri_gray,i,j,k) =
            log(h_gray->counts[nint(MAX(val,gray_mean))]) ;

        }
        else
        {
          //topo_fixer

          //MRIFvox(mri_white,i,j,k) = log(1.0/(1.0+exp(-(val-mu)/sigma)));
          //MRIFvox(mri_gray,i,j,k) = log(1.0/(1.0+exp((val-mu)/sigma)));

          if (contrast == 1)
          {
            if (val > white_mean)
            {
              MRIFvox(mri_white,i,j,k) = 0.0;
            }
            else
            {
              MRIFvox(mri_white,i,j,k) = SQR((val - white_mean)/sigma);
            }
            if (val < gray_mean)
            {
              MRIFvox(mri_gray,i,j,k) = 0.0;
            }
            else
            {
              MRIFvox(mri_gray,i,j,k) = SQR((val - gray_mean)/sigma);
            }
          }
          else if (contrast == -1)
          {
            if (val < white_mean)
            {
              MRIFvox(mri_white,i,j,k) = 0.0;
            }
            else
            {
              MRIFvox(mri_white,i,j,k) = SQR((val-white_mean)/sigma);
            }
            if (val > gray_mean)
            {
              MRIFvox(mri_gray,i,j,k) = 0.0;
            }
            else
            {
              MRIFvox(mri_gray,i,j,k) = SQR((val-gray_mean)/sigma);
            }
          }
          else
          {
            MRIFvox(mri_white,i,j,k) = SQR((val-white_mean)/sigma);
            MRIFvox(mri_gray,i,j,k) = SQR((val-gray_mean)/sigma);
          }

        }
      }

  // HISTOplot(h_white,"w.plt");
  //  HISTOplot(h_gray,"g.plt");
  //  fprintf(stderr,"writing out volume");
  // MRIwrite(mri_white,"./mri_w.mgz");
  // MRIwrite(mri_gray,"./mri_g.mgz");
  //  fprintf(stderr,"done!\n");

  //fprintf(WHICH_OUTPUT,"%d voxels out of %d voxels\n",n,mri_defect->width*mri_defect->height*mri_defect->depth);
}

static void mrisComputeSurfaceStatistics(MRIS *mris,MRI *mri,HISTOGRAM *h_k1,HISTOGRAM *h_k2,MRI*mri_k1_k2,MRI *mri_gray_white,HISTOGRAM *h_dot)
{
  int n,nvertices,nfaces;
  TP tp;
  float total_ll;

  TPinit(&tp);

  fprintf(WHICH_OUTPUT,"Computing Initial Surface Statistics\n");

  MRISsaveVertexPositions(mris,TMP_VERTICES);
  MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
  MRIScomputeMetricProperties(mris);
  MRIScomputeSecondFundamentalForm(mris) ;

  /* initializing the table of vertices */
  nvertices=mris->nvertices;
  tp.vertices=(int*)malloc(nvertices*sizeof(int));
  for ( nvertices = n = 0 ; n < mris->nvertices ; n++)
  {
    if (mris->vertices[n].marked)
    {
      continue;
    }
    tp.vertices[nvertices++]=n;
  }
  tp.nvertices=nvertices;

  /* initializing the table of faces */
  nfaces=mris->nfaces;
  tp.faces=(int*)malloc(nfaces*sizeof(int));
  for ( nfaces = n = 0 ; n < mris->nfaces ; n++)
  {
    if (triangleMarked(mris, n))
    {
      continue ;
    }
    tp.faces[nfaces++]=n;
  }
  tp.nfaces=nfaces;

  mrisComputeDefectCurvatureLogLikelihood(mris, &tp, h_k1, h_k2,mri_k1_k2) ;
  mrisComputeDefectNormalDotLogLikelihood(mris, &tp, h_dot);
  mrisDefectFaceMRILogLikelihood(mris, mri, &tp,
                                 NULL,NULL,NULL, mri_gray_white) ;
  mrisDefectVertexMRILogLikelihood(mris, mri, &tp,
                                   NULL,NULL,NULL, mri_gray_white) ;
  MRISrestoreVertexPositions(mris, CANONICAL_VERTICES) ;

  total_ll=(tp.face_ll+tp.vertex_ll+tp.curv_ll+tp.qcurv_ll);

  fprintf(WHICH_OUTPUT,
          "      -face       loglikelihood: %2.4f  (%2.4f)\n",
          tp.face_ll,tp.face_ll/2.0);
  fprintf(WHICH_OUTPUT,
          "      -vertex     loglikelihood: %2.4f  (%2.4f)\n",
          tp.vertex_ll,tp.vertex_ll/2.0);
  fprintf(WHICH_OUTPUT,
          "      -normal dot loglikelihood: %2.4f  (%2.4f)\n",
          tp.curv_ll,tp.curv_ll);
  fprintf(WHICH_OUTPUT,
          "      -quad curv  loglikelihood: %2.4f  (%2.4f)\n",
          tp.qcurv_ll,tp.qcurv_ll/2.0);
  fprintf(WHICH_OUTPUT,
          "      Total Loglikelihood : %2.4f\n",
          total_ll);

  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  MRIScomputeMetricProperties(mris);

  /* free arrays */
  TPfree(&tp);
}

static void computeDefectStatistics(MRI *mri,
                                    MRIS *mris,
                                    DEFECT *defect,
                                    HISTOGRAM *h_white,
                                    HISTOGRAM *h_gray,
                                    MRI *mri_gw,
                                    HISTOGRAM *h_k1,
                                    HISTOGRAM *h_k2,
                                    MRI *mri_k1_k2,
                                    int verbose)
{
  float val,mean,var,mg,mw,vw,vg,total,max,
        white_val,gray_val,x,y,z,cx,cy,cz,ival,k1,k2,vk1,vk2,wv,gv;
  double xv,yv,zv,int_val;
  int i,j,n;
  HISTOGRAM *h;

  cx=cy=cz=ival=0.0f;
  for (i=0; i<defect->nvertices; i++)
  {
    x=mris->vertices[defect->vertices[i]].origx;
    y=mris->vertices[defect->vertices[i]].origy;
    z=mris->vertices[defect->vertices[i]].origz;

#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x, y, z, &xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xv, &yv, &zv) ;
#endif
    cx+=(float)xv;
    cy+=(float)yv;
    cz+=(float)zv;
    MRIsampleVolume(mri, xv, yv, zv, &int_val) ;
    ival+=(float)int_val;

  }
  cx /= (float)defect->nvertices;
  cy /= (float)defect->nvertices;
  cz /= (float)defect->nvertices;
  ival /= (float)defect->nvertices;

  if (verbose)
    fprintf(WHICH_OUTPUT,
            "   computing statistics for defect %d: %d vertices\n"
            "   location: [ (%d,%d,%d) - average intensity = %3.3f ]\n",
            defect->defect_number,
            defect->nvertices,
            (int)cx,(int)cy,(int)cz,ival);

  /* computing intensity statistics */

  /* white matter */
  h=h_white;

  //first find max value
  max=0.0f;
  for (n=0 ; n < h->nbins ; n++)
  {
    if (h->counts[n]>max)
    {
      max=h->counts[n];
    }
  }

  //then, only consider bins with at least value > 1% of max
  total=0;
  for ( mean=0, var=0, n=0 ; n < h->nbins ; n++)
  {
    val=h->bins[n]-h->bin_size/2.0;
    if (h->counts[n] < max/100.0)
    {
      continue;
    }
    mean += val*h->counts[n];
    var += val*val*h->counts[n];
    total+=h->counts[n];
  }

  mean /= total;
  var /= total;
  var=var-SQR(mean);
  if (var<0)
  {
    var=0;
  }

  white_val=mean;

  wv = var;

  /* white matter */
  h=h_gray;

  //first find max value
  max=0.0f;
  for (n=0 ; n < h->nbins ; n++)
  {
    if (h->counts[n]>max)
    {
      max=h->counts[n];
    }
  }

  //then, only consider bins with at least value > 1% of max
  total=0;
  for ( mean=0, var=0, n=0 ; n < h->nbins ; n++)
  {
    val=h->bins[n]-h->bin_size/2.0;
    if (h->counts[n] < max/100.0)
    {
      continue;
    }
    mean += (val*h->counts[n]);
    var += (SQR(val)*h->counts[n]);
    total+=h->counts[n];
  }

  mean /=total;
  var /= total;

  var=var-SQR(mean);

  if (var<0)
  {
    var=0;
  }

  gray_val=mean;
  gv = var;

  if (verbose)
    fprintf(WHICH_OUTPUT,
            "      -gray ( %2.2f , %2.2f )  -white ( %2.2f , %2.2f )\n",
            gray_val,sqrt(gv),white_val,sqrt(wv));

  for (mw=0,mg=0,vw=0,vg=0,i=0 ; i < 256 ; i++)
    for (j = 0 ; j < 256 ; j++)
    {
      val=(float)i;
      mw+=val*MRIFvox(mri_gw,i,j,0);
      vw+=SQR(val)*MRIFvox(mri_gw,i,j,0);
      val=(float)j;
      mg+=val*MRIFvox(mri_gw,i,j,0);
      vg+=SQR(val)*MRIFvox(mri_gw,i,j,0);
    }

  vw -= SQR(mw);
  vg -= SQR(mg);

  if (verbose)
    fprintf(WHICH_OUTPUT,
            "      -gray ( %2.2f , %2.2f )  -white ( %2.2f , %2.2f ) \n",
            mg,sqrt(vg),mw,sqrt(vw));

  mw=white_val;
  mg=gray_val;

  defect->white_mean=mw;
  defect->gray_mean=mg;

  defect->white_mean_ll =
    log(h_white->counts[MAX(0,MIN(h_white->nbins-1,nint(mw)))]);
  defect->gray_mean_ll =
    log(h_gray->counts[MAX(0,MIN(h_gray->nbins-1,nint(mg)))]);

  if (verbose)
    fprintf(WHICH_OUTPUT,
            "      -intensity (%f [log = %f ]- %f [log = %f ])\n",
            mg,defect->gray_mean_ll,mw,defect->white_mean_ll);

  /* computing curvature statistics */

  /* principal curvature k1 */
  h=h_k1;

  //first find max value
  max=0.0f;
  for (n=0 ; n < h->nbins ; n++)
  {
    if (h->counts[n]>max)
    {
      max=h->counts[n];
    }
  }

  //then, only consider bins with at least value > 1% of max
  total=0;
  for ( mean=0, var=0, n=0 ; n < h->nbins ; n++)
  {
    val=h->bins[n]-h->bin_size/2.0;
    if (h->counts[n] < max/100.0)
    {
      continue;
    }
    mean += val*h->counts[n];
    var += val*val*h->counts[n];
    total+=h->counts[n];
  }

  mean /= total;
  var /= total;

  var=var-SQR(mean);
  if (var<0)
  {
    var=0;
  }
  vk1=var;

  defect->k1_mean=mean;

  /* principal curvature k2 */
  h=h_k2;

  //first find max value
  max=0.0f;
  for (n=0 ; n < h->nbins ; n++)
  {
    if (h->counts[n]>max)
    {
      max=h->counts[n];
    }
  }


  //then, only consider bins with at least value > 1% of max
  total=0;
  for ( mean=0, var=0, n=0 ; n < h->nbins ; n++)
  {
    val=h->bins[n]-h->bin_size/2.0;
    if (h->counts[n] < max/100.0)
    {
      continue;
    }
    mean += val*h->counts[n];
    var += val*val*h->counts[n];
    total+=h->counts[n];
  }

  mean /= total;
  var /= total;

  var=var-SQR(mean);
  if (var<0)
  {
    var=0;
  }
  vk2=var;

  defect->k2_mean=mean;

  if (verbose)
    fprintf(WHICH_OUTPUT,
            "      -curv (k1=%3.3f (%3.3f) , "
            "r1 = %3.3f | k2=%3.3f (%3.3f), r2 = %3.3f )\n",
            defect->k1_mean,sqrt(vk1),-1.0/defect->k1_mean,
            defect->k2_mean,sqrt(vk2),-1.0/defect->k2_mean);

  for (k1=0,vk1=0,k2=0,vk2=0,i=0 ; i < mri_k1_k2->width ; i++)
    for (j = 0 ; j < mri_k1_k2->height ; j++)
    {
      val=mri_k1_k2->xstart+(float)i*mri_k1_k2->xsize;
      k1+=val*MRIFvox(mri_k1_k2,i,j,0);
      vk1+=SQR(val)*MRIFvox(mri_k1_k2,i,j,0);
      val=(float)mri_k1_k2->ystart+(float)j*mri_k1_k2->ysize;
      k2+=val*MRIFvox(mri_k1_k2,i,j,0);
      vk2+=SQR(val)*MRIFvox(mri_k1_k2,i,j,0);
    }
  vk1 -= SQR(k1);
  vk2 -= SQR(k2);

  if (verbose)
    fprintf(WHICH_OUTPUT,
            "      -curv (k1=%3.3f (%3.3f) , r1 = %3.3f "
            "| k2=%3.3f (%3.3f), r2 = %3.3f )\n",
            k1,sqrt(vk1),-1.0/k1,
            k2,sqrt(vk2),-1.0/k2);
}

/* call the right smoothing and matching functions */
static void defectMatch(MRI *mri,
                        MRI_SURFACE *mris,
                        DP *dp,
                        int smooth,
                        int match)
{
  if (smooth)
  {
    defectSmooth(mris,dp,25,0.1,smooth);
  }
  if (match)
  {
    defectMaximizeLikelihood(mri,mris,dp,40,0.5);
  }
}

/* perform a light smoothing of the defect vertices */
static void defectSmooth(MRI_SURFACE *mris,
                         DP *dp,
                         int niter,
                         double alpha,
                         int type)
{
  int i,n;
  VERTEX *v,*vn;
  float x,y,z;
  float r,F,E,rmin,rmax;
  float dx,dy,dz,sx,sy,sz,sd,sxn,syn,szn,sxt,syt,szt,nc,nx,ny,nz,f;
  int *vertices,nvertices,ninside;
  float mean,var;
  int changed,should_be_smoothed,nstrictlyinside;
  float percentage;

  //ninside=dp->tp.nvertices; //TO BE CHECKED
  ninside=dp->tp.ninside; /* smooth only inside vertices, not border ones */
  if (ninside==0)
  {
    return;
  }

  nstrictlyinside=dp->tp.ninside;

  if (type==0)
  {
    return;
  }

  switch (type)
  {
  case 1:
    while (niter--)
    {
      /* using the tmp vertices */
      for (i = 0 ; i < ninside; i++)
      {
        v = &mris->vertices[dp->tp.vertices[i]] ;

        for (x =0,y=0,z=0,n = 0 ; n < v->vnum ; n++)
        {
          vn = &mris->vertices[v->v[n]] ;
          x += vn->origx;
          y  += vn->origy ;
          z += vn->origz;
        }
        if (n)
        {
          x/=(float)n ;
          y/=(float)n;
          z/=(float)n;
        }

        v->tx=v->origx+alpha*(x-v->origx);
        v->ty=v->origy +alpha*(y-v->origy);
        v->tz=v->origz+alpha* (z-v->origz);
      }

      for (i = 0 ; i < ninside; i++)
      {
        v =  &mris->vertices[dp->tp.vertices[i]] ;

        v->origx=v->tx;
        v->origy=v->ty ;
        v->origz=v->tz;
      }
    }
    break;
  case 2:

    rmin=-1/dp->defect->k1_mean;
    rmax=-1/dp->defect->k2_mean;

    E=(1/rmin+1/rmax)/2;
    F=6/(1/rmin-1/rmax);

    while (niter--)
    {
      computeDefectFaceNormals(mris,dp);
      computeDefectVertexNormals(mris,dp);

      /* using the tmp vertices */
      for (i = 0 ; i < ninside; i++)
      {
        v = &mris->vertices[dp->tp.vertices[i]] ;
        x=v->origx;
        y=v->origy;
        z=v->origz;
        nx=v->nx;
        ny=v->ny;
        nz=v->nz;

        sx=sy=sz=sd=0;
        n=0;
        for (n=0; n<v->vnum; n++)
        {
          vn = &mris->vertices[v->v[n]] ;

          sx += dx = vn->origx - x;
          sy += dy = vn->origy - y;
          sz += dz = vn->origz - z;
          sd += sqrt(dx*dx+dy*dy+dz*dz);
          n++;
        }
        // mean distance to the neighbors
        sx = sx/(float)n;
        sy = sy/(float)n;
        sz = sz/(float)n;
        sd = sd/(float)n;

        nc = sx*nx+sy*ny+sz*nz;

        // normal component of the mean distance vector
        sxn = nc*nx;
        syn = nc*ny;
        szn = nc*nz;
        // tangential component of the mean distance vector
        sxt=sx-sxn;
        syt=sy-syn;
        szt=sz-szn;

        r= (nc>0) ? nc : -nc;
        r=SQR(sd)/(2*r);
        f=(1+tanh(F*(1/r-E)))/2;

        v->tx=v->origx+alpha*(sxt+f*sxn);
        v->ty=v->origy+alpha*(syt+f*syn);
        v->tz=v->origz+alpha*(szt+f*szn);
      }
      for (i = 0 ; i < ninside; i++)
      {
        v = &mris->vertices[dp->tp.vertices[i]] ;

        v->origx=v->tx;
        v->origy=v->ty;
        v->origz=v->tz;
      }
    }
    break;
  case 3: /* only smooth the high undefval vertices */
    if (nstrictlyinside==0)
    {
      return;
    }

    for (i = 0 ; i < nstrictlyinside ; i++)
    {
      v = &mris->vertices[dp->tp.vertices[i]] ;
      v->old_undefval=0;
    }

    /* first we need to find which ones need to be smoothed */
    changed=1;
    percentage=0.0f;
    while (changed)
    {
      changed=0;
      for (i = 0 ; i < nstrictlyinside; i++)
      {
        v = &mris->vertices[dp->tp.vertices[i]] ;
        if (v->old_undefval)
        {
          continue;  /* already processed */
        }
        /* check if neighboring values are lower or not */
        should_be_smoothed=1;
        for (n=0; n<v->vnum; n++)
        {
          vn = &mris->vertices[v->v[n]] ;
          if ((!vn->old_undefval) && vn->undefval < v->undefval)
          {
            should_be_smoothed=0;
            break;
          }
        }
        if (should_be_smoothed)
        {
          changed=1;
          v->old_undefval=1;
          percentage += 1.0f;
        }
      }
    }
    percentage=100.0f*percentage/(float)nstrictlyinside;
    // fprintf(stderr,"%2.3f %% vertices are to be smoothed\n",percentage);

    /* then, we smooth these vertices */
    if (percentage>50.0f) /* perform a light smoothing only */
    {
      return defectSmooth(mris,dp,niter,alpha,2);
    }
    niter=20;
    alpha=0.5;
    while (niter--)
    {
      /* using the tmp vertices */
      for (i = 0 ; i < nstrictlyinside ; i++)
      {
        v = &mris->vertices[dp->tp.vertices[i]] ;
        if (v->old_undefval==0)
        {
          continue;
        }

        for (x =0,y=0,z=0,n = 0 ; n < v->vnum ; n++)
        {
          vn = &mris->vertices[v->v[n]] ;
          x += vn->origx;
          y  += vn->origy ;
          z += vn->origz;
        }
        if (n)
        {
          x/=(float)n;
          y/=(float)n;
          z/=(float)n;
        }

        v->tx=v->origx+alpha*(x-v->origx);
        v->ty=v->origy +alpha*(y-v->origy);
        v->tz=v->origz+alpha* (z-v->origz);

      }

      for (i = 0 ; i < nstrictlyinside ; i++)
      {
        v =  &mris->vertices[dp->tp.vertices[i]] ;
        if (v->old_undefval==0)
        {
          continue;
        }

        v->origx=v->tx;
        v->origy=v->ty ;
        v->origz=v->tz;
      }
    }
    /* finally we apply a light smoothing of the whole surface */
    defectSmooth(mris,dp,20,0.1,2);

    break;
  default:
    rmin=-1/dp->defect->k1_mean;
    rmax=-1/dp->defect->k2_mean;

    E=(1/rmin+1/rmax)/2;
    F=6/(1/rmin-1/rmax);

    //detect high curvatures vertices
    computeDefectFaceNormals(mris,dp);
    computeDefectVertexNormals(mris,dp);

    mean=var=0.0;
    for (i = 0 ; i < ninside; i++)
    {
      v = &mris->vertices[dp->tp.vertices[i]] ;
      x=v->origx;
      y=v->origy;
      z=v->origz;
      nx=v->nx;
      ny=v->ny;
      nz=v->nz;

      sx=sy=sz=sd=0;
      n=0;
      for (n=0; n<v->vnum; n++)
      {
        vn = &mris->vertices[v->v[n]] ;

        sx += dx = vn->origx - x;
        sy += dy = vn->origy - y;
        sz += dz = vn->origz - z;
        sd += sqrt(dx*dx+dy*dy+dz*dz);
        n++;
      }
      // mean distance to the neighbors
      sx = sx/(float)n;
      sy = sy/(float)n;
      sz = sz/(float)n;
      sd = sd/(float)n;

      nc = sx*nx+sy*ny+sz*nz;

      //curvature
      //r= (nc>0) ? nc : -nc;
      //r=SQR(sd)/(2*r);
      r=nc;
      r=(2*r)/SQR(sd);

      mean += r;
      var += (r*r);

      v->curv=r;
    }
    mean=mean/dp->tp.nvertices;
    var=var/dp->tp.nvertices-mean*mean;
    if (var<0)
    {
      var=0.0;
    }
    //fprintf(WHICH_OUTPUT,"mean=%f, var=%f \n",mean,sqrt(var));
    vertices=(int*)malloc(dp->tp.nvertices*sizeof(int));
    nvertices=0;
    for (i = 0 ; i < ninside; i++)
    {
      v = &mris->vertices[dp->tp.vertices[i]];
      if (v->curv<mean-1*sqrt(var) || v->curv>mean+1*sqrt(var))
      {
        vertices[nvertices++]=i;
      }
    }

#if 0
    fprintf(WHICH_OUTPUT,"%d (out of %d) vertices with high curvature\n",
            nvertices,dp->tp.ninside);

    MRISclearAnnotations(mris);

    for (i = 0 ; i < nvertices; i++)
    {
      v = &mris->vertices[dp->tp.vertices[vertices[i]]] ;
      v->annotation=100;
    }
#endif

#if 0
    {
      static int counter=0;
      char fname[100];
      sprintf(fname,"./rh.test_%d",counter);
      MRISwriteAnnotation(mris,fname);
      counter++;
    }
#endif
    //smooth these vertices
    while (niter--)
    {
      /* using the tmp vertices */
      for (i = 0 ; i < nvertices; i++)
      {
        v = &mris->vertices[dp->tp.vertices[vertices[i]]] ;

        for (x =0,y=0,z=0,n = 0 ; n < v->vnum ; n++)
        {
          vn = &mris->vertices[v->v[n]] ;
          x += vn->origx;
          y  += vn->origy ;
          z += vn->origz;
        }
        if (n)
        {
          x/=(float)n ;
          y/=(float)n;
          z/=(float)n;
        }

        v->tx=v->origx+alpha*(x-v->origx);
        v->ty=v->origy +alpha*(y-v->origy);
        v->tz=v->origz+alpha* (z-v->origz);
      }

      for (i = 0 ; i < nvertices; i++)
      {
        v =  &mris->vertices[dp->tp.vertices[vertices[i]]] ;

        v->origx=v->tx;
        v->origy=v->ty ;
        v->origz=v->tz;
      }
    }
    free(vertices);

    break;
  }
  computeDefectFaceNormals(mris,dp);
  computeDefectVertexNormals(mris,dp);
}

static void MRISdefectMaximizeLikelihood(MRI *mri,
    MRI_SURFACE *mris,
    DP *dp,
    int niter,
    double alpha,
    int mode)
{
  float wm,gm,mean;
  int i,n,nvertices,*vertices;
  VERTEX *v,*vn;
  double x,y,z,xm,ym,zm,nx,ny,nz,dx,dy,dz,g,NRG;
  double xv,yv,zv,white_val,gray_val,val;

  if (mode==0)
  {
    return defectMaximizeLikelihood(mri,mris,dp,niter,alpha);
  }

  // matching marked vertices only !

  wm=dp->defect->white_mean;
  gm=dp->defect->gray_mean;

  mean=(wm+gm)/2.0;

  //find marked vertices
  nvertices=0;
  for (n = 0 ; n < mris->nvertices ; n++)
    if (mris->vertices[n].marked)
    {
      nvertices++;
    }
  vertices=(int*)malloc(nvertices*sizeof(int));
  if (nvertices==0)
  {
    return;
  }
  nvertices=0;
  for (n = 0 ; n < mris->nvertices ; n++)
    if (mris->vertices[n].marked)
    {
      vertices[nvertices++]=n;
    }

  while (niter--)
  {
    /* using the tmp vertices */
    for (NRG=0,i = 0 ; i < nvertices; i++)
    {
      v = &mris->vertices[vertices[i]] ;
      x=v->origx;
      y=v->origy;
      z=v->origz;

      /* smoothness term */
      for (xm=0,ym=0,zm=0,n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        xm += vn->origx;
        ym += vn->origy ;
        zm += vn->origz;
      }
      if (n)
      {
        xm/=(double)n;
        ym/=(double)n;
        zm/=(double)n;
      }

      /* image gradient */
      nx=v->nx;
      ny=v->ny;
      nz=v->nz;

#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x-0.5*nx, y-0.5*ny, z-0.5*nz, &xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x-0.5*nx, y-0.5*ny, z-0.5*nz, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &white_val) ;

#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x, y, z, &xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &val) ;

#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x+0.5*nx, y+0.5*ny, z+0.5*nz, &xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x+0.5*nx, y+0.5*ny, z+0.5*nz, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;

      g=(white_val-gray_val)*(val-mean);

      if (fabs(g)>0.1)
      {
        g=0.1*g/fabs(g);
      }

      dx=0.5*(xm-x)+g*nx;
      dy=0.5*(ym-y)+g*ny;
      dz=0.5*(zm-z)+g*nz;

      NRG+=SQR(val-mean);

      v->tx=x+alpha*dx;
      v->ty=y+alpha*dy;
      v->tz=z+alpha*dz;

    }
    NRG=sqrt(NRG/nvertices);

    //    fprintf(WHICH_OUTPUT,"-  NRG = %f  -",NRG);

    /* update orig vertices */
    for (i = 0 ; i < nvertices; i++)
    {
      v = &mris->vertices[vertices[i]] ;
      v->origx=v->tx;
      v->origy=v->ty;
      v->origz=v->tz;
    }

    /* recompute normals */
    computeDefectFaceNormals(mris,dp);
    computeDefectVertexNormals(mris,dp);

  }
  if (vertices)
  {
    free(vertices);
  }

}



static void defectMaximizeLikelihood(MRI *mri,MRI_SURFACE *mris,DP *dp, int niter,double alpha)
{
  float wm,gm,mean;
  int i,n,nvertices;
  VERTEX *v,*vn;
  double x,y,z,xm,ym,zm,nx,ny,nz,dx,dy,dz,g,NRG;
  double xv,yv,zv,white_val,gray_val,val;

  wm=dp->defect->white_mean;
  gm=dp->defect->gray_mean;

  mean=(wm+gm)/2.0;

  nvertices=dp->tp.nvertices;
  nvertices=dp->tp.ninside; /* matching only for inside vertices */

  while (niter--)
  {
    /* using the tmp vertices */
    for (NRG=0,i = 0 ; i < nvertices; i++)
    {
      v = &mris->vertices[dp->tp.vertices[i]] ;
      x=v->origx;
      y=v->origy;
      z=v->origz;

      /* smoothness term */
      for (xm=0,ym=0,zm=0,n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        xm += vn->origx;
        ym += vn->origy ;
        zm += vn->origz;
      }
      if (n)
      {
        xm/=(double)n;
        ym/=(double)n;
        zm/=(double)n;
      }

      /* image gradient */
      nx=v->nx;
      ny=v->ny;
      nz=v->nz;

#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x-0.5*nx, y-0.5*ny, z-0.5*nz, &xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x-0.5*nx, y-0.5*ny, z-0.5*nz, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &white_val) ;

#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x, y, z, &xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &val) ;

#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x+0.5*nx, y+0.5*ny, z+0.5*nz, &xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x+0.5*nx, y+0.5*ny, z+0.5*nz, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;

      g=(white_val-gray_val)*(val-mean);

      if (fabs(g)>0.2)
      {
        g=0.2*g/fabs(g);
      }

      dx=0.5*(xm-x)+g*nx;
      dy=0.5*(ym-y)+g*ny;
      dz=0.5*(zm-z)+g*nz;

      NRG+=SQR(val-mean);

      v->tx=x+alpha*dx;
      v->ty=y+alpha*dy;
      v->tz=z+alpha*dz;

    }
    NRG=sqrt(NRG/nvertices);

    //    fprintf(WHICH_OUTPUT,"-  %f  -",NRG);

    /* update orig vertices */
    for (i = 0 ; i < nvertices; i++)
    {
      v = &mris->vertices[dp->tp.vertices[i]] ;
      v->origx=v->tx;
      v->origy=v->ty;
      v->origz=v->tz;
    }

    /* recompute normals */
    computeDefectFaceNormals(mris,dp);
    computeDefectVertexNormals(mris,dp);

  }

}


static void detectDefectFaces(MRIS *mris, DEFECT_PATCH *dp)
{
  int i,n,m,vno,vn1,vn2,nvertices,nthings,*things,nfaces;
  int optimal=dp->defect->optimal_mapping;
  VERTEX *v;
  TP *tp;

  /* the tessellated patch */
  tp=&dp->tp;

  /* in 'theory', the euler number of the patch is one */
  nfaces=tp->nedges-dp->tp.ninside+101; /* add 100 just to make sure */
  things=(int*)malloc(nfaces*sizeof(nfaces));

  /* will use the border flag to mark modified vertices */
  nvertices=tp->nvertices;
#if 0
  for (nthings = i = 0 ; i < nvertices ; i++)
  {
    vno=tp->vertices[i];
    v = &mris->vertices[vno] ;
    v->border=1;
  }
#endif
  /* detect faces only for modified vertices */
  for (nthings = i = 0 ; i < nvertices ; i++)
  {
    vno=tp->vertices[i];
    v = &mris->vertices[vno] ;

    for ( n = 0 ; n <  v->vnum ; n++)
    {
      vn1=v->v[n];

      //                        if(!mris->vertices[vn1].border) continue; /* only modified vertices */

      if (optimal && mris->vertices[vn1].fixedval==0)
      {
        continue;  //experimental
      }

      for (m=0; m < v->vnum ; m++)
      {
        vn2 = v->v[m];
        if (vn1 == vn2)
        {
          continue;
        }

        //if(!mris->vertices[vn2].border) continue; /* only modified vertices */
        if (optimal && mris->vertices[vn2].fixedval==0)
        {
          continue;  //experimental
        }

        /* check if this set of vertices could constitue a face */
        if (!vertexNeighbor(mris, vn1, vn2))
        {
          continue;
        }

        /* check if this triangle already in the tessellation */
        if (isFace(mris,vno,vn1,vn2))
        {
          continue;
        }

        /* check if this potential face contains other vertices */
        if (containsAnotherVertexOnSphere(mris,vno,vn1,vn2,optimal))
        {
          continue;
        }

        /* add this new face to the defect faces */
        mrisAddFace(mris,vno,vn1,vn2);
        if (nthings==nfaces)
        {
          continue;
        }
        things[nthings++]=mris->nfaces-1;
      }
    }
  }

#if 0
  /* reset border flag */
  for (nthings = i = 0 ; i < nvertices ; i++)
  {
    vno=tp->vertices[i];
    v = &mris->vertices[vno] ;
    v->border=0;
  }
#endif

  /* save the list of new faces */
  if (nthings==nfaces)
  {
    fprintf(WHICH_OUTPUT,"error in the retessellation \n");
  }
  tp->faces=(int*)malloc(nthings*sizeof(int));
  tp->nfaces=nthings;
  memmove(tp->faces,things,nthings*sizeof(int));
  free(things);
}

#define DEBUG_INFO 0

static int computePatchEulerNumber(MRIS *mris,DP *dp)
{
  int nfaces,nedges,nvertices,euler;

  /* everything has already been computed */
  nfaces=dp->tp.nfaces;
  nedges=dp->tp.nedges;
  nvertices=dp->tp.ninside;
  euler=nvertices-nedges+nfaces;

#if DEBUG_INFO
  fprintf(WHICH_OUTPUT,"euler=%d : (%d,%d,%d)\n",euler,nvertices,nedges,nfaces);
  if (euler!=1)
  {
    fprintf(WHICH_OUTPUT,"\n\nXXXXXXXXXXXXXXXXXXXXXXXX\n\n");
  }

  if (euler!=1)
    fprintf(WHICH_OUTPUT,"\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n"
            "euler=%d : (%d,%d,%d)\n"
            "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n",euler,nvertices,nedges,nfaces);
#endif
  return euler;
}

static void orientDefectFaces(MRIS *mris,DP* dp)
{
  int n,m,vno0,vno1,fno;
  float dot,cx,cy,cz,a[3],b[3],norm[3];
  TP *tp;
  FACE *face;
  VERTEX *v,*v1,*v2,*v3;

  tp=&dp->tp;

  for ( n = 0 ; n < tp->nfaces ; n++ )
  {
    fno=tp->faces[n]; /* face index in mris_corrected */

    face=&mris->faces[fno];

    v1=&mris->vertices[face->v[0]];
    v2=&mris->vertices[face->v[1]];
    v3=&mris->vertices[face->v[2]];

    /* compute centroid direction on sphere */
    cx=v1->cx+v2->cx+v3->cx;
    cy=v1->cy+v2->cy+v3->cy;
    cz=v1->cz+v2->cz+v3->cz;

    /* compute normal of face onto sphere*/
    a[0]=v2->cx-v1->cx;
    b[0]=v3->cx-v1->cx;
    a[1]=v2->cy-v1->cy;
    b[1]=v3->cy-v1->cy;
    a[2]=v2->cz-v1->cz;
    b[2]=v3->cz-v1->cz;

    F_CROSS(a,b,norm);
    dot = norm[0]*cx + norm[1]*cy + norm[2]*cz ;

    if (dot < 0)
    {
      /* they disagree - change order of vertices 1 & 2 in face n */
      vno0 = face->v[1] ;
      vno1 = face->v[2] ;
      face->v[1] = vno1 ;
      face->v[2] = vno0 ;

      /* set vertex face index */
      v=&mris->vertices[vno0] ; /* vno0 is now in 2 */
      for (m = 0 ; m < v->num ; m++)
        if (v->f[m]==fno)
        {
          v->n[m] = 2 ;
          break;
        }

      v=&mris->vertices[vno1] ; /* vno1 is now in 1 */
      for (m = 0 ; m < v->num ; m++)
        if (v->f[m]==fno)
        {
          v->n[m] = 1 ;
          break;
        }
    }
  }
}

static void computeDefectFaceNormal(MRIS *mris,FACE *face)
{
  VERTEX *v1,*v2,*v3;
  float a[3],b[3],norm[3],len,nx,ny,nz;

  v1=&mris->vertices[face->v[0]];
  v2=&mris->vertices[face->v[1]];
  v3=&mris->vertices[face->v[2]];

  /* compute the face normal on the original configuration */
  a[0]=v2->origx-v1->origx;
  b[0]=v3->origx-v1->origx;
  a[1]=v2->origy-v1->origy;
  b[1]=v3->origy-v1->origy;
  a[2]=v2->origz-v1->origz;
  b[2]=v3->origz-v1->origz;

  F_CROSS(a,b,norm);
  nx=norm[0];
  ny=norm[1];
  nz=norm[2];

  /* normalize */
  len = sqrt(nx*nx + ny*ny + nz*nz) ;
  if (FZERO(len))
  {
    //TO BE CHECKED
    //          fprintf(WHICH_OUTPUT,"face with a null normal (%f,%f,%f) - (%f,%f,%f) - (%f,%f,%f)",v1->origx,v1->origy,v1->origz,v2->origx,v2->origy,v2->origz,v3->origx,v3->origy,v3->origz);
    /* try another dot product */
    a[0]=100.0*(v3->origx-v2->origx);
    b[0]=100.0*(v1->origx-v2->origx);
    a[1]=100.0*(v3->origy-v2->origy);
    b[1]=100.0*(v1->origy-v2->origy);
    a[2]=100.0*(v3->origz-v2->origz);
    b[2]=100.0*(v1->origz-v2->origz);
    F_CROSS(a,b,norm);
    nx=norm[0];
    ny=norm[1];
    nz=norm[2];
    /* normalize */
    len = sqrt(nx*nx + ny*ny + nz*nz) ;
    if (FZERO(len))
    {
      //fprintf(WHICH_OUTPUT,".");
      len = 1.0;
    }
    //fprintf(WHICH_OUTPUT,"\n");
  }
  face->nx = nx / len ;
  face->ny = ny / len ;
  face->nz = nz / len ;
  face->orig_area=len/2.0f;
}

/* used to temporary rip the faces of the defect so we don't proceed them many times */
//FLO TO BE CHECKED
#define TEMPORARY_RIPPED_FACE 2

static void computeDefectFaceNormals(MRIS *mris,DP *dp)
{
  int i,n;
  VERTEX *v;
  FACE *face;
  TP *tp;

  /* the tessellated patch */
  tp=&dp->tp;

  /* compute faces only for modified vertices */
  for (i = 0 ; i < tp->nvertices ; i++)
  {
    v = &mris->vertices[tp->vertices[i]] ;
    for ( n = 0 ; n < v->num ; n++ )
    {
      face=&mris->faces[v->f[n]];
      if (face->ripflag)
      {
        continue;  /* don't process a face twice */
      }
      computeDefectFaceNormal(mris,face);
      face->ripflag=TEMPORARY_RIPPED_FACE;
    }
  }
  /* unrip faces */
  for (i = 0 ; i < tp->nvertices ; i++)
  {
    v = &mris->vertices[tp->vertices[i]] ;
    for ( n = 0 ; n < v->num ; n++ )
    {
      face=&mris->faces[v->f[n]];
      if (face->ripflag==TEMPORARY_RIPPED_FACE) /* unrip face */
      {
        face->ripflag=0;
      }
    }
  }
}


static void computeDefectVertexNormals(MRIS *mris,DP *dp)
{
  int n,m;
  float nx,ny,nz,len;
  TP *tp;
  FACE *face;
  VERTEX *v;

  tp=&dp->tp;
  /* compute vertex normals only for modified vertices */
  for (n = 0 ; n < tp->nvertices ; n++)
  {
    v = &mris->vertices[tp->vertices[n]] ;

    /* compute normal at vertex */
    nx=ny=nz=0.0f;
    for (m = 0 ; m < v->num ; m++)
    {
      face=&mris->faces[v->f[m]];

      nx+=face->nx;
      ny+=face->ny;
      nz+=face->nz;
    }
    /* normalize */
    len = sqrt(nx*nx + ny*ny + nz*nz) ;
    if (FZERO(len))
    {
      fprintf(WHICH_OUTPUT,"normal vector of length zero at vertex %d with %d faces\n",tp->vertices[n],(int)v->num);  //TO BE CHECKED
      if ((int)v->num==0)
      {
        ErrorExit(ERROR_BADPARM,"vertex %d has 0 face",tp->vertices[n]);
      }
      len = 1 ;
    }
    v->nx = nx / len ;
    v->ny = ny / len ;
    v->nz = nz / len ;
  }
}

static void computeDefectTangentPlaneAtVertex(MRIS *mris,int vno)
{
  float a[3],b[3],c[3],len;

  VERTEX  *v ;

  v = &mris->vertices[vno] ;

  a[0]=v->nx;
  a[1]=v->ny;
  a[2]=v->nz;

  /* pick one random vector */
  b[0]=1.0f;
  b[1]=0.0f;
  b[2]=0.0f;

  F_CROSS(a,b,c);
  len = SQR(c[0])+SQR(c[1])+SQR(c[2]);

  if (FZERO(len))
  {
    /* the vector b was parallel to a */
    b[0]=0.0f;
    b[1]=1.0f;
    b[2]=0.0f;
    F_CROSS(a,b,c);
    len = SQR(c[0])+SQR(c[1])+SQR(c[2]);
  }
  /* normalize */
  len=sqrt(len);

  if (FZERO(len))
  {
    fprintf(WHICH_OUTPUT,"first tangent vector of length zero at vertex %d\n",vno);
    len = 1 ;
  }
  v->e1x = c[0] / len ;
  v->e1y = c[1] / len ;
  v->e1z = c[2] / len ;

  F_CROSS(a,c,b);

  /* normalize */
  len=sqrt(SQR(b[0])+SQR(b[1])+SQR(b[2]));
  if (FZERO(len))
  {
    fprintf(WHICH_OUTPUT,"second tangent vector of length zero at vertex %d\n",vno);
    len = 1 ;
  }
  v->e2x = b[0] / len ;
  v->e2y = b[1] / len ;
  v->e2z = b[2] / len ;
}

static void computeDefectSecondFundamentalForm(MRIS *mris,TP *tp)
{
  int    p,vno, i, n, nbad = 0 ;
  VERTEX *vertex, *vnb ;
  MATRIX *m_U, *m_Ut, *m_tmp1, *m_tmp2, *m_inverse, *m_eigen, *m_Q ;
  VECTOR *v_c, *v_z, *v_n, *v_e1, *v_e2, *v_yi ;
  float  k1, k2, evalues[3], a11, a12, a21, a22, cond_no, kmax, kmin, rsq, k ;
  double ui, vi;


  /* allocation of diverse vectors matrices*/
  v_c = VectorAlloc(3, MATRIX_REAL) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_e1 = VectorAlloc(3, MATRIX_REAL) ;
  v_e2 = VectorAlloc(3, MATRIX_REAL) ;
  v_yi = VectorAlloc(3, MATRIX_REAL) ;
  m_Q = MatrixAlloc(2, 2, MATRIX_REAL) ;    /* the quadratic form */
  m_eigen = MatrixAlloc(2, 2, MATRIX_REAL) ;

  /* compute faces only for modified vertices */
  for (p = 0 ; p < tp->nvertices ; p++)
  {
    vno=tp->vertices[p];

    vertex = &mris->vertices[vno] ;

    /* compute tangent plane */
    computeDefectTangentPlaneAtVertex(mris,vno);

    //FLO TO BE CHECKED !!!
#if 0
    mrisFindSecondNeighborhood(mris, vno, nbrs, &num_nbrs) ;
    if (num_nbrs < 3)
    {
      continue ;
    }
    nvertices++;

    /* need ex,ey,ez */
    MRIScomputeSecondFundamentalFormAtVertex(mris, vno, nbrs, num_nbrs) ;
#endif


    VECTOR_LOAD(v_n, vertex->nx, vertex->ny, vertex->nz) ;
    VECTOR_LOAD(v_e1, vertex->e1x, vertex->e1y, vertex->e1z) ;
    VECTOR_LOAD(v_e2, vertex->e2x, vertex->e2y, vertex->e2z) ;

    if (vertex->vtotal <= 0)
    {
      continue ;
    }

    m_U = MatrixAlloc(vertex->vtotal, 3, MATRIX_REAL) ;
    v_z = VectorAlloc(vertex->vtotal, MATRIX_REAL) ;

    /* fit a quadratic form to the surface at this vertex */
    kmin = 10000.0f ;
    kmax = -kmin ;
    for (n = i = 0 ; i < vertex->vtotal ; i++)
    {
      vnb = &mris->vertices[vertex->v[i]] ;

      /* calculate the projection of this vertex onto the local tangent plane */
      VECTOR_LOAD(v_yi, vnb->origx-vertex->origx, vnb->origy-vertex->origy,vnb->origz-vertex->origz);
      ui = V3_DOT(v_yi, v_e1) ;
      vi = V3_DOT(v_yi, v_e2) ;
      *MATRIX_RELT(m_U, n+1, 1) = ui*ui ;
      *MATRIX_RELT(m_U, n+1, 2) = 2*ui*vi ;
      *MATRIX_RELT(m_U, n+1, 3) = vi*vi ;
      VECTOR_ELT(v_z, n+1) = V3_DOT(v_n, v_yi) ;  /* height above TpS */
      rsq = ui*ui + vi*vi ;

      if (!FZERO(rsq))
      {
        k = VECTOR_ELT(v_z, n+1) / rsq ;
        if (k > kmax)
        {
          kmax = k ;
        }
        if (k < kmin)
        {
          kmin = k ;
        }
      }
      n++ ;
    }
    m_Ut = MatrixTranspose(m_U, NULL) ;          /* Ut */
    m_tmp2 = MatrixMultiply(m_Ut, m_U, NULL) ;   /* Ut U */
    cond_no = MatrixConditionNumber(m_tmp2) ;

    m_inverse = MatrixSVDInverse(m_tmp2, NULL) ;    /* (Ut U)^-1 */

    if (!m_inverse)
    {
      /* singular matrix - must be planar?? */
      nbad++ ;
      evalues[0] = evalues[1] = 0.0 ;
    }
    else
    {
      m_tmp1 = MatrixMultiply(m_Ut, v_z, NULL) ;   /* Ut z */
      MatrixMultiply(m_inverse, m_tmp1, v_c) ;     /* (Ut U)^-1 Ut z */

      /* now build Hessian matrix */
      *MATRIX_RELT(m_Q,1,1) = 2*VECTOR_ELT(v_c, 1) ;
      *MATRIX_RELT(m_Q,1,2) = *MATRIX_RELT(m_Q,2,1) = 2*VECTOR_ELT(v_c, 2) ;
      *MATRIX_RELT(m_Q,2,2) = 2*VECTOR_ELT(v_c, 3) ;

      if (cond_no >= ILL_CONDITIONED)
      {

        vertex->k1 = k1 = kmax ;
        vertex->k2 = k2 = kmin ;

        vertex->K = k1*k2 ;
        vertex->H = (k1+k2)/2 ;
        MatrixFree(&m_Ut) ;
        MatrixFree(&m_tmp2) ;
        MatrixFree(&m_U) ;
        VectorFree(&v_z) ;
        MatrixFree(&m_tmp1) ;
        MatrixFree(&m_inverse) ;
        continue ;
      }

      /* the columns of m_eigen will be the eigenvectors of m_Q */
      if (MatrixEigenSystem(m_Q, evalues, m_eigen) == NULL)
      {
        nbad++ ;
        MatrixSVDEigenValues(m_Q, evalues) ;
        vertex->k1 = k1 = evalues[0] ;
        vertex->k2 = k2 = evalues[1] ;
        vertex->K = k1*k2 ;
        vertex->H = (k1+k2)/2 ;
        MatrixFree(&m_Ut) ;
        MatrixFree(&m_tmp2) ;
        MatrixFree(&m_U) ;
        VectorFree(&v_z) ;
        MatrixFree(&m_tmp1) ;
        MatrixFree(&m_inverse) ;
        continue ;
      }

      MatrixFree(&m_tmp1) ;
      MatrixFree(&m_inverse) ;
    }
    k1 = evalues[0] ;
    k2 = evalues[1] ;
    vertex->k1 = k1 ;
    vertex->k2 = k2 ;
    vertex->K = k1 * k2 ;
    vertex->H = (k1 + k2) / 2 ;

    /* now update the basis vectors to be the principal directions */
    a11 = *MATRIX_RELT(m_eigen,1,1) ;
    a12 = *MATRIX_RELT(m_eigen,1,2) ;
    a21 = *MATRIX_RELT(m_eigen,2,1) ;
    a22 = *MATRIX_RELT(m_eigen,2,2) ;
    vertex->e1x = V3_X(v_e1) * a11 + V3_X(v_e2) * a21 ;
    vertex->e1y = V3_Y(v_e1) * a11 + V3_Y(v_e2) * a21 ;
    vertex->e1z = V3_Z(v_e1) * a11 + V3_Z(v_e2) * a21 ;
    vertex->e2x = V3_X(v_e1) * a12 + V3_X(v_e2) * a22 ;
    vertex->e2y = V3_Y(v_e1) * a12 + V3_Y(v_e2) * a22 ;
    vertex->e2z = V3_Z(v_e1) * a12 + V3_Z(v_e2) * a22 ;

    MatrixFree(&m_Ut) ;
    MatrixFree(&m_tmp2) ;
    MatrixFree(&m_U) ;
    VectorFree(&v_z) ;
  }

  MatrixFree(&m_eigen) ;
  VectorFree(&v_e1) ;
  VectorFree(&v_e2) ;
  VectorFree(&v_c) ;
  VectorFree(&v_n) ;
  VectorFree(&v_yi) ;
  MatrixFree(&m_Q) ;
}

/* static void computeDefectMetricProperties(MRIS *mris,TP * tp){ */

/*   /\* the normals are supposed to be already computed*\/ */
/*   /\* computeDefectNormals(mris,dp); *\/ */

/*   /\* second fondamental form with principal curvatures *\/ */
/*   computeDefectSecondFundamentalForm(mris,tp); */
/* } */

static void printDefectStatistics(DP *dp)
{
  //fprintf(WHICH_OUTPUT,"fitness=%2.4f\n",dp->fitness);
  fprintf(WHICH_OUTPUT,"X=%d (v=%d,e=%d,f=%d): %d vertices were discarded\n",dp->tp.ninside+dp->tp.nfaces-dp->tp.nedges,
          dp->tp.ninside,dp->tp.nedges,dp->tp.nfaces,dp->tp.ndiscarded);
  fprintf(WHICH_OUTPUT,"fll=%2.4f (%2.4f), vll=%2.4f (%2.4f),cll=%2.4f (%2.4f),qcll=%2.4f (%2.4f) umll=%2.4f (%2.4f)\n",
          dp->tp.face_ll,(dp->tp.face_ll-dp->defect->initial_face_ll),
          dp->tp.vertex_ll,(dp->tp.vertex_ll-dp->defect->initial_vertex_ll),
          dp->tp.curv_ll,(dp->tp.curv_ll-dp->defect->initial_curv_ll),
          dp->tp.qcurv_ll,(dp->tp.qcurv_ll-dp->defect->initial_qcurv_ll),
          dp->tp.unmri_ll,(dp->tp.unmri_ll-dp->defect->initial_unmri_ll));
}

#define OUTSIDE_VERTEX   0
#define INSIDE_VERTEX    1 /* not yet used */
#define EDGE_VERTEX      2 /* part of an edge */
#define TRIANGLE_VERTEX  3 /* part of a triangle */
#define DISCARDED_VERTEX 4 /* excluded from the current tessellation */
#define BORDER_VERTEX    TRIANGLE_VERTEX /* part of a triangle! */
#define USED_VERTEX      5 /* used in the final tessellation */

static int isVertexInsideFace(MRIS *mris,int vno,int fno)
{
  int i;
  VERTEX  *V0,*V1,*V2,*V,*Vn;
  double sign,test,normal[3], orgn[3],tangent[3];

  /* the vertices constituting the triangle fno */
  V0=&mris->vertices[mris->faces[fno].v[0]];
  V1=&mris->vertices[mris->faces[fno].v[1]];
  V2=&mris->vertices[mris->faces[fno].v[2]];

  /* if one of the vertices is outside of the defect, then vno is outside of fno*/
  if (V0->marked==OUTSIDE_VERTEX || V1->marked==OUTSIDE_VERTEX || V2->marked==OUTSIDE_VERTEX)
  {
    return 0;
  }


  /* the vertex to be tested */
  Vn=&mris->vertices[vno];

  for (i = 0; i<3 ; i++)
  {
    if (i)
    {
      //circular rotation
      V=V0;
      V0=V1;
      V1=V2;
      V2=V;
    }

    //compute normal for edge V1<-->V2
    orgn[0]=(V1->cx+V2->cx)/2.0;
    orgn[1]=(V1->cy+V2->cy)/2.0;
    orgn[2]=(V1->cz+V2->cz)/2.0;

    tangent[0]=V2->cx-V1->cx;
    tangent[1]=V2->cy-V1->cy;
    tangent[2]=V2->cz-V1->cz;

    //normal to edge in the planar basis
    F_CROSS(orgn,tangent,normal);

    tangent[0]=V0->cx-orgn[0];
    tangent[1]=V0->cy-orgn[1];
    tangent[2]=V0->cz-orgn[2];

    sign=F_DOT(tangent,normal);

    tangent[0]=Vn->cx-orgn[0];
    tangent[1]=Vn->cy-orgn[1];
    tangent[2]=Vn->cz-orgn[2];

    test=F_DOT(tangent,normal);

    if (sign*test<0)
    {
      return 0;  /* outside */
    }
  }
  return 1;
}

/* check if the vertex vno1 is contained in one of the faces of vno2 */
static int isDiscarded(MRIS *mris,int vno1,int vno2)
{
  int n;
  VERTEX *v;


  v=&mris->vertices[vno2];

  for ( n = 0 ; n < v->num ; n++)
    if (isVertexInsideFace(mris,vno1,v->f[n])) /* vno1 is inside face v->f[n]! */
    {
      return 1;
    }

  return 0;
}

static void removeVertex(MRIS *mris,int vno)
{
  int n,m,vnum,*oldlist;
  VERTEX *v,*vn;

  v=&mris->vertices[vno];

  //to be checked when the ADD_SOME_VERTICES mode is on
  //could be a good "outside" vertex

  if (v->marked==0)
  {

    /*          if(parms->verbose>=VERBOSE_MODE_MEDIUM)
                fprintf(stderr,"removeVertex: the vertex %d was not marked - SHOULD NOT HAPPEN\n",vno);
                if(parms->verbose==VERBOSE_MODE_HIGH)*/
    ErrorExit(ERROR_BADPARM, "removeVertex: the vertex %d was not marked - SHOULD NOT HAPPEN\n",vno);
    return;
  }


  for (n = 0 ; n < v->vnum ; n++)
  {
    /* remove vno from the list of v->v[n] */
    vn=&mris->vertices[v->v[n]];
    oldlist=vn->v;
    vnum=vn->vnum-1; /* the new # of neighbors */
    if (vnum)
    {
      vn->v=(int*)malloc(vnum*sizeof(int));
      for ( vnum = m = 0 ; m < vn->vnum ; m++ )
      {
        if (oldlist[m]==vno)
        {
          continue;
        }
        vn->v[vnum++]=oldlist[m];
      }
      free(oldlist);
    }
    else
    {
      vn->v=NULL;
    }
    vn->vnum=vnum;
    vn->vtotal=vnum;
    /* check if the vertex became singled out */
    if (vn->vnum==0)
    {
      vn->marked=INSIDE_VERTEX;
    }
  }
  v->marked=DISCARDED_VERTEX;
  free(v->v);
  v->v=NULL;
  v->vnum=0;
  v->vtotal=0;
}

static int updateVertexTriangle(MRIS *mris,int vno,int fno)
{
  int n,m,vn;
  VERTEX *v;

  v=&mris->vertices[vno];

  for ( m = n = 0 ; n < v->vnum ; n++)
  {
    /* work with the vertex v->v[n] */
    vn=v->v[n];
    if (mris->vertices[vn].marked==TRIANGLE_VERTEX)
    {
      continue;
    }
    if (isVertexInsideFace(mris,vn,fno))
    {
      /* vertex is inside the new face, so we have to remove it */
      removeVertex(mris,vn);
      n--;
      m++;
    }
  }

  /* we have removed m vertices from vno->vnum */
  return m;
}

/* static void updateTriangle(MRIS *mris,int fno){ */
/*   int n,m,vn; */
/*   VERTEX *v; */

/*   /\* update type *\/ */
/*   for( m = 0 ; m < 3; m++) */
/*     mris->vertices[mris->faces[fno].v[m]].marked=TRIANGLE_VERTEX; */

/*   for( m = 0 ; m < 3; m++){ */
/*     v=&mris->vertices[mris->faces[fno].v[m]]; */
/*     for( n = 0 ; n < v->vnum ; n++){ */
/*       /\* work with the vertex v->v[n] *\/ */
/*       vn=v->v[n]; */
/*       if(mris->vertices[vn].marked==TRIANGLE_VERTEX) continue; */
/*       if(isVertexInsideFace(mris,vn,fno)){ */
/*      /\* vertex is inside the new face, so we have to remove it *\/ */
/*      removeVertex(mris,vn); */
/*      n--; */
/*       } */
/*     } */
/*   } */
/* } */

/* check if the edge vno1 <--> vno2 is the edge of a triangle */
static void findNewTriangles(MRIS *mris,int vno1,int vno2)
{
  int n,m,vn,fno;
  VERTEX *v;

  /* only exterior triangles */

  v=&mris->vertices[vno1];
  for ( n = 0 ; n < v->vnum ; n++)
  {
    if (v->v[n]==vno2)
    {
      continue;
    }
    if (vertexNeighbor(mris, vno2, v->v[n]))
    {
      /* there is a triangle */
      vn=v->v[n];
      /* make sure this vertex is not outside : could happen if border <-> border edge */
      if (mris->vertices[vn].marked==OUTSIDE_VERTEX)
      {
        continue;  /* outside vertex */
      }

      /* check if face already exists : could happen with border <-> border <-> border triangles */
      if (isFace(mris,vno1,vno2,vn))
      {
        continue;
      }

      mrisAddFace(mris,vno1,vno2,vn);
      fno=mris->nfaces-1;
      /* update type */
      mris->vertices[vno1].marked=TRIANGLE_VERTEX;
      mris->vertices[vno2].marked=TRIANGLE_VERTEX;
      mris->vertices[vn].marked=TRIANGLE_VERTEX;

      m=updateVertexTriangle(mris,vno1,fno);
      updateVertexTriangle(mris,vn,fno);
      updateVertexTriangle(mris,vno2,fno);

      /* we have removed m vertices from the vertex vno1 */
      n-=m;
    }
  }
}

static int isEdgeAdded(MRIS *mris,int vno1,int vno2,int mode)
{
  int mark1,mark2,tmp;
  VERTEX *v1,*v2;


  if (mode==USE_ALL_VERTICES)
  {
    mrisAddEdge(mris, vno1, vno2);
    mris->vertices[vno1].marked=TRIANGLE_VERTEX;
    mris->vertices[vno2].marked=TRIANGLE_VERTEX;
    return 1;
  };

  /* the initial marks */
  mark1=mris->vertices[vno1].marked;
  mark2=mris->vertices[vno2].marked;

  /* swap vertices if necessary */
  if (mark2 < mark1)
  {
    tmp=vno1;
    vno1=vno2;
    vno2=tmp;
    tmp=mark1;
    mark1=mark2;
    mark2=tmp;
  }

  v1=&mris->vertices[vno1];
  v2=&mris->vertices[vno2];

  switch (mark1)
  {
  case INSIDE_VERTEX:
    if (mark2==TRIANGLE_VERTEX)
    {
      /* is the first vertex inside or outside the faces of vno2*/
      if (isDiscarded(mris,vno1,vno2))
      {
        /* inside one of the faces of vno2 */
        /* remove this vertex that is not connected to anyone */
        v1->marked=DISCARDED_VERTEX;
        return 0;
      }
      else
      {
        /* outside the faces */
        mrisAddEdge(mris, vno1, vno2) ;
        /* the first vertex becomes EDGE */
        v1->marked=EDGE_VERTEX;
        return 1;
      }
    }
    else
    {
      /* the second vertex is either of type INSIDE or EDGE */
      mrisAddEdge(mris, vno1, vno2) ;
      /* they both become EDGE */
      v1->marked=EDGE_VERTEX;
      v2->marked=EDGE_VERTEX;
      return 1;
    }
    break;
  case EDGE_VERTEX:
    if (mark2==EDGE_VERTEX)
    {
      /* add this edge */
      mrisAddEdge(mris, vno1, vno2) ;
      /* look for new triangles */
      findNewTriangles(mris,vno1, vno2);
      return 1;
    }
    else
    {
      /* vno2 is of type TRIANGLE_VERTEX */
      /* is the first vertex inside or outside the faces of vno2 */
      if (isDiscarded(mris,vno1,vno2))
      {
        /* inside one of the faces */
        /* remove this vertex and its connexions */
        removeVertex(mris,vno1);
        return 0;
      }
      else
      {
        /* outside */
        mrisAddEdge(mris, vno1, vno2) ;
        /* check if some new triangles have been formed : if yes, update type*/
        findNewTriangles(mris,vno1, vno2);
        return 1;
      }
    }
    break;
  case TRIANGLE_VERTEX:
    /* both vertices have the type TRIANGLE_VERTEX */
    mrisAddEdge(mris, vno1, vno2) ;
    /* check if some new triangles have been formed */
    findNewTriangles(mris,vno1, vno2);
    return 1;
    break;
  }

  return 0;
};

typedef struct
{
  int intersected;
  int vno1,vno2;
}
INTERSECTION_TABLE , IT;

static int retessellateDefect(MRI_SURFACE *mris,
                              MRI_SURFACE *mris_corrected,
                              DVS* dvs,
                              DP* dp)
{
  double max_len;
  int     i, j, max_i, max_added, nadded, index,ndiscarded;
  int     (*intersection_function)(MRI_SURFACE *mris, DEFECT *defect, EDGE *e, int *vertex_trans,int *v1,int *v2) ;
  int *vertex_trans;
  DEFECT *defect;
  EDGE *et;
  EDGE_TABLE *etable;
  int nedges,*ordering,n,vno;
  int nthings,*things;
  int modified;
  IT *it;
  VERTEX *vertex1,*vertex2;
  int counting;

  /* initialize arrays of tessellated patch to null pointer*/
  TPinit(&dp->tp);

  etable=dp->etable;
  defect=dvs->defect;
  vertex_trans=dvs->vertex_trans;
  et=dp->etable->edges;
  nedges= dp->nedges;
  ordering=dp->ordering;


  /* for the ordering the vertices - using undefval*/
  // useful only if dp->retessellation_mode==USE_ALL_VERTICES
  for (counting=0 , n = 0 ; n < defect->nvertices ; n++)
  {
    if (defect->status[n]==DISCARD_VERTEX)
    {
      continue;
    }
    vno=vertex_trans[defect->vertices[n]];
    vertex1=&mris_corrected->vertices[vno];
    vertex1->undefval=0;
    if (vertex1->vnum)
    {
      vertex1->undefval = 1;
      counting=1;
    }
  }

  max_len = 0 ;
  max_i = 0 ;
  max_added  = 0 ;
  intersection_function = intersectDefectEdges ;

  /* first mark the defective vertices */
  for (ndiscarded = n = 0 ; n < defect->nvertices ; n++)
  {
    if (defect->status[n]==DISCARD_VERTEX)
    {
      ndiscarded++;
      continue;
    }
    vno=vertex_trans[defect->vertices[n]];
    mris_corrected->vertices[vno].marked=INSIDE_VERTEX;
  }
  for (n = 0 ; n < defect->nborder ; n++)
  {
    vno=vertex_trans[defect->border[n]];
    mris_corrected->vertices[vno].marked=BORDER_VERTEX;
  }

  /* count the number of potentially added edges */
  nthings = nadded = 0;

  /* allocate the table of potentially intersected edges */
  it=(IT*)calloc(nedges,sizeof(IT));

  modified=1;
  while (modified)
  {
    modified=0;

    /* start building the retessellation */
    for (index = 0 ; index < nedges ; index++)
    {
      if (ordering)
      {
        i = ordering[index] ;
      }
      else
      {
        i = index ;
      }

      if (it[i].intersected)
      {
        continue;
      }

      if (et[i].used &&
          et[i].used!=USED_IN_ORIGINAL_TESSELLATION) /* already exists in
                                                        tessellation - don't
                                                        add it again */
      {
        continue;  /* edge status must be USED_IN_TESSELLATION */
      }

      /* check if this edge really exists */
      if (mris_corrected->vertices[et[i].vno1].marked==DISCARDED_VERTEX)
      {
        continue;
      }
      if (mris_corrected->vertices[et[i].vno2].marked==DISCARDED_VERTEX)
      {
        continue;
      }

      //TO BE CHECKED (used in RandomRetessellation)
      if (mris_corrected->vertices[et[i].vno1].ripflag)
      {
        continue;
      }
      if (mris_corrected->vertices[et[i].vno2].ripflag)
      {
        continue;
      }

      if (etable &&
          etable->use_overlap==USE_OVERLAP)   /* use pre-computed
                                                 intersection table */
      {
        int intersects = 0 ;

        for (j = 0 ; j < etable->noverlap[i] ; j++)
          if (et[etable->overlapping_edges[i][j]].used &&
              et[etable->overlapping_edges[i][j]].used!=
              USED_IN_ORIGINAL_TESSELLATION)
          {
            intersects = 1 ;
            /* the edge i was refused because of the edge
               etable->overlapping_edges[i][j] */
            it[i].intersected=2;
            it[i].vno1=et[etable->overlapping_edges[i][j]].vno1;
            it[i].vno2=et[etable->overlapping_edges[i][j]].vno2;
            break ;
          }
        if (intersects)
        {
          continue ;
        }
        if (etable->flags[i] & ET_OVERLAP_LIST_INCOMPLETE)
        {
          intersection_function = intersectDefectEdges ;
        }
        else
        {
          intersection_function = intersectDefectConvexHullEdges ;
        }
      }
      if ((*intersection_function)(mris_corrected, defect, &et[i], vertex_trans,&it[i].vno1,&it[i].vno2) == 0)
      {

        /* this edge could potentially be added : no sphere intersection */
        nadded++;
        if (isEdgeAdded(mris_corrected,et[i].vno1, et[i].vno2,dp->retessellation_mode))
        {
          nthings++;
          if (et[i].used) /* used in original tessellation */
          {
            et[i].used=USED_IN_BOTH_TEMPORARY_TESSELLATION;
          }
          else
          {
            et[i].used=USED_IN_NEW_TEMPORARY_TESSELLATION;
          }
          /* useful only if mode = USE_ALL_VERTICES */
          vertex1=&mris_corrected->vertices[et[i].vno1];
          vertex2=&mris_corrected->vertices[et[i].vno2];
          if (vertex1->undefval==0 || vertex2->undefval==0)
          {
            counting++;
            if (vertex1->undefval==0)
            {
              vertex1->undefval=counting;
            }
            if (vertex2->undefval==0)
            {
              vertex2->undefval=counting;
            }
          }
        }
      }
      else /* intersecting edge with edge e1<-->e2 */
      {
        it[i].intersected=2;
      }
    }
    /* now update the edges */
    for (index = 0 ; index < nedges ; index++)
    {
      /* keep the same order (not necessary) */
      if (ordering)
      {
        i = ordering[index] ;
      }
      else
      {
        i = index ;
      }

      /* already exists in tessellation - don't add it again */
      if (et[i].used==USED_IN_NEW_TEMPORARY_TESSELLATION)
      {
        et[i].used=NOT_USED;
        if (mris_corrected->vertices[et[i].vno1].marked!=TRIANGLE_VERTEX)
        {
          continue;
        }
        if (mris_corrected->vertices[et[i].vno2].marked!=TRIANGLE_VERTEX)
        {
          continue;
        }
        et[i].used=USED_IN_NEW_TESSELLATION;
      };
      if (et[i].used==USED_IN_BOTH_TEMPORARY_TESSELLATION)
      {
        et[i].used=USED_IN_ORIGINAL_TESSELLATION;
        if (mris_corrected->vertices[et[i].vno1].marked!=TRIANGLE_VERTEX)
        {
          continue;
        }
        if (mris_corrected->vertices[et[i].vno2].marked!=TRIANGLE_VERTEX)
        {
          continue;
        }
        et[i].used=USED_IN_BOTH_TESSELLATION;
      };

      if (it[i].intersected==2)
      {
        if (mris_corrected->vertices[it[i].vno1].marked==DISCARDED_VERTEX ||
            mris_corrected->vertices[it[i].vno2].marked==DISCARDED_VERTEX)
        {
          modified=1;
          it[i].intersected=0;
        }
        else
        {
          it[i].intersected=1;
        }
      }
      else
      {
        it[i].intersected=1;
      }
    }
  }

  /* in this retessellation we have added, at most, nthings edges */
  things=(int*)malloc(nthings*sizeof(int));
  /* then, note the used edges */
  for (nthings = index = 0 ; index < nedges ; index++)
  {
    /* keep the same order (not necessary) */
    if (ordering)
    {
      i = ordering[index] ;
    }
    else
    {
      i = index ;
    }

    /* already exists in tessellation - don't add it again */
    if (et[i].used!=USED_IN_NEW_TESSELLATION && et[i].used!=USED_IN_BOTH_TESSELLATION)
    {
      continue ;
    }

    things[nthings++]=i;
    if (et[i].len > max_len)
    {
      max_len = et[i].len ;
      max_added = nadded-1 ;
      max_i = i ;
    }
  }

  /* store list of used edges */
  dp->tp.nedges=nthings;
  dp->tp.edges=(int*)malloc(nthings*sizeof(int));
  memmove(dp->tp.edges,things,nthings*sizeof(int));
  free(things);

#if DEBUG_INFO
  fprintf(WHICH_OUTPUT,"%d added edges out of %d potential edges\n",nthings,nadded);
#endif

  /* mark the used vertices */
  for (n = 0 ; n < dp->tp.nedges ; n++)
  {
    i=dp->tp.edges[n];
    mris_corrected->vertices[et[i].vno1].marked=USED_VERTEX;
    mris_corrected->vertices[et[i].vno2].marked=USED_VERTEX;
  }

  /* in this retessellation we have added, at most, nthings vertices */
  nthings=defect->nvertices+defect->nborder;
  things=(int*)malloc(nthings*sizeof(int));

  /* count the number of added vertices and reset marks to zero*/
  for (nthings = n = 0 ; n < defect->nvertices ; n++)
  {
    if (defect->status[n]==DISCARD_VERTEX)
    {
      continue;
    }
    vno=vertex_trans[defect->vertices[n]];
    if (mris_corrected->vertices[vno].marked==USED_VERTEX)
    {
      things[nthings++]=vno;
    }
    mris_corrected->vertices[vno].marked=0;
  }
  dp->tp.ninside=nthings; /* we have ninside new vertices */
  for (n = 0 ; n < defect->nborder ; n++)
  {
    /* every border voxel counts !!!*/
    vno=vertex_trans[defect->border[n]];
    things[nthings++]=vno;
    mris_corrected->vertices[vno].marked=0;
  }
  dp->tp.nvertices=nthings;
  dp->tp.vertices=(int*)malloc(nthings*sizeof(int));
  memmove(dp->tp.vertices,things,nthings*sizeof(int));
  free(things);

  /* number of discarded vertices */
  dp->tp.ndiscarded=defect->nvertices-ndiscarded-dp->tp.ninside;

#if DEBUG_INFO
  fprintf(WHICH_OUTPUT,"%d vertices have been used out of %d(%d): %d were discarded,\n"
          "%d out of %d(%d) are new vertices: %d were discarded,\n"
          "%d out of %d are border vertices : %d were discarded\n",
          dp->tp.nvertices,defect->nvertices+defect->nborder-ndiscarded,defect->nvertices+defect->nborder,
          defect->nvertices+defect->nborder-ndiscarded-dp->tp.nvertices,
          dp->tp.ninside,defect->nvertices-ndiscarded,defect->nvertices,defect->nvertices-ndiscarded-dp->tp.ninside,
          dp->tp.nvertices-dp->tp.ninside,defect->nborder,defect->nborder-dp->tp.nvertices+dp->tp.ninside);
#endif

  /* reset the number of original faces in the surface before the retessellation */
  if (dp->retessellation_mode==USE_SOME_VERTICES)
  {
    mrisRestoreFaceVertexState(mris_corrected, dvs) ;
  }

  /* free the allocated memory for the intersection_table */
  free(it);

  return(NO_ERROR) ;
}

static void computeDisplacement(MRI_SURFACE *mris,DP *dp)
{
  DEFECT *defect;
  int p,vno;
  float val;
  VERTEX *vertex;

  defect=dp->defect;
  for (p = 0 ; p < defect->nvertices ; p++)
  {
    if (defect->status[p]==DISCARD_VERTEX)
    {
      continue;
    }
    vno=defect->vertex_trans[defect->vertices[p]];
    vertex = &mris->vertices[vno] ;
    val=(SQR(vertex->fx-vertex->origx)+SQR(vertex->fy-vertex->origy)+SQR(vertex->fz-vertex->origz));
    vertex->curvbak = sqrt(val);
  }
}

static double
mrisDefectPatchFitness(MRI_SURFACE *mris, MRI_SURFACE *mris_corrected, MRI *mri,
                       DEFECT_PATCH *dp, int *vertex_trans, DEFECT_VERTEX_STATE *dvs, RP *rp,
                       HISTOGRAM *h_k1, HISTOGRAM *h_k2, MRI *mri_k1_k2,HISTOGRAM *h_white, HISTOGRAM *h_gray,
                       HISTOGRAM *h_border, HISTOGRAM *h_grad, MRI *mri_gray_white,
                       HISTOGRAM *h_dot, TOPOLOGY_PARMS *parms)
{
  int i,euler ;
  VERTEX *v;
  DEFECT *defect=dp->defect;

  defect->vertex_trans=vertex_trans;
  dp->verbose_mode=parms->verbose;

  while (1)
  {

    /* set the arrays to NULL in dp->tp */
    TPinit(&dp->tp);

    retessellateDefect(mris, mris_corrected, dvs, dp) ;

    /* detect the new set of faces */
    detectDefectFaces(mris_corrected,dp);

    /* compute the euler number of the patch */
    euler=computePatchEulerNumber(mris_corrected,dp);

    break;

    /* the following lines in the while loop are incorrect */
    /* It was assuming that the patch euler number was equal to one */

    if (euler==1)
    {
      break;
    }

    /* we have a surface patch with an euler number
       different from 1 : this is a bug!*/
    /* restore the vertex state */
    mrisRestoreVertexState(mris_corrected, dvs);

    /* reset the edges to the unused state
       (unless they were in the original tessellation) */
    for (i = 0 ; i < dp->nedges ; i++)
    {
      if (dp->etable->edges[i].used == USED_IN_NEW_TESSELLATION)
      {
        dp->etable->edges[i].used = NOT_USED ;
      }
      if (dp->etable->edges[i].used == USED_IN_BOTH_TESSELLATION)
      {
        dp->etable->edges[i].used = USED_IN_ORIGINAL_TESSELLATION;
      }
    }

    /* free vertices,edges,faces tables */
    TPfree(&dp->tp);

    /* generate random ordering */
    {
      int p,m,tp;
      for (m=0; m<11; m++)
        for (i=0; i < dp->nedges ; i++)
        {
          p=nint(randomNumber(0.0, (double)dp->nedges-1)) ;

          tp=dp->ordering[i];
          dp->ordering[i]=dp->ordering[p];
          dp->ordering[p]=tp;
        }
    }
  }

  /* orient the patch faces */
  orientDefectFaces(mris_corrected,dp);

  /* save original coord into flattened coordinates */
  for (i = 0 ; i < defect->nvertices ; i++)
  {
    if (defect->status[i]==DISCARD_VERTEX)
    {
      continue;
    }
    v = &mris_corrected->vertices[vertex_trans[defect->vertices[i]]];
    //          fprintf(WHICH_OUTPUT,"%d-",vertex_trans[defect->vertices[i]]);
    v->fx=v->origx;
    v->fy=v->origy;
    v->fz=v->origz;
  }

  /* smooth and match original vertices in the retessellated patch */
  defectMatch(mri,mris_corrected,dp,parms->smooth,parms->match);

  computeDisplacement(mris_corrected,dp);

  /* compute the face normals on the surface*/
  computeDefectFaceNormals(mris_corrected,dp);

  /* compute vertex normals on original surface */
  // computeDefectVertexNormals(mris_corrected,dp);

  /* compute the patch fitness */
  dp->fitness = mrisComputeDefectLogLikelihood(mris_corrected, mri, dp, h_k1, h_k2, mri_k1_k2,h_white, h_gray, h_border, h_grad, mri_gray_white, h_dot, parms) ;

  /* update statistics */
  updateVertexStatistics(mris,mris_corrected,dvs,rp,dp,vertex_trans,dp->fitness);

  /* restore the vertex state */
  mrisRestoreVertexState(mris_corrected, dvs);

  /* reset the edges to the unused state (unless they were in the original tessellation) */
  for (i = 0 ; i < dp->nedges ; i++)
  {
    if (dp->etable->edges[i].used == USED_IN_NEW_TESSELLATION)
    {
      dp->etable->edges[i].used = NOT_USED ;
    }
    if (dp->etable->edges[i].used == USED_IN_BOTH_TESSELLATION)
    {
      dp->etable->edges[i].used = USED_IN_ORIGINAL_TESSELLATION;
    }
  }
  /* free vertices,edges,faces tables */
  TPfree(&dp->tp);

  return(dp->fitness) ;
}

static int
mrisFreeDefectVertexState(DEFECT_VERTEX_STATE *dvs)
{
  int  i ;

  for (i = 0 ; i < dvs->nvertices ; i++)
  {
    free(dvs->vs[i].v) ;
    if (dvs->vs[i].f)
    {
      free(dvs->vs[i].f);
    }
    if (dvs->vs[i].n)
    {
      free(dvs->vs[i].n);
    }
  }

  free(dvs->vs) ;
  free(dvs) ;
  return(NO_ERROR) ;
}

static DEFECT_VERTEX_STATE *
mrisRecordVertexState(MRI_SURFACE *mris, DEFECT *defect, int *vertex_trans)
{
  DEFECT_VERTEX_STATE *dvs ;
  int                 i, n, vno ;
  VERTEX              *v ;
  VERTEX_STATE        *vs ;

  dvs = calloc(1, sizeof(DVS)) ;
  if (!dvs)
  {
    ErrorExit(ERROR_NOMEMORY, "mrisRecordVertexState: could not allocate dvs") ;
  }

  dvs->defect = defect ;
  dvs->vertex_trans = vertex_trans ;

  /* in theory, the convex hull vertices should not be changed */
  /* however, numerical errors might generate some unexpected 'bugs' */
  /* including the convex hull vertices in DVS  limits these errors */
#if MRIS_FIX_TOPOLOGY_ERROR_MODE
  dvs->nvertices = defect->nvertices+defect->nchull ;
  dvs->vs = (VS *)calloc(dvs->nvertices, sizeof(VS)) ;
#else
  dvs->nvertices = defect->nvertices+defect->nborder ;
  dvs->vs = (VS *)calloc(dvs->nvertices, sizeof(VS)) ;
#endif
  if (!dvs->vs)
    ErrorExit(ERROR_NOMEMORY, "mrisRecordVertexState: could not allocate %d dvs->vs",
              dvs->nvertices) ;

  /* keep the # of faces before retessellation */
  dvs->nfaces=mris->nfaces;

  for (n = 0 ; n < defect->nvertices ; n++)
  {
    dvs->vs[n].vno = vertex_trans[defect->vertices[n]] ;
  }
#if MRIS_FIX_TOPOLOGY_ERROR_MODE
  for (n = 0 ; n < defect->nchull ; n++)
  {
    dvs->vs[defect->nvertices+n].vno = vertex_trans[defect->chull[n]] ;
  }
#else
  for (n = 0 ; n < defect->nborder ; n++)
  {
    dvs->vs[defect->nvertices+n].vno = vertex_trans[defect->border[n]] ;
  }
#endif

  for (i = 0 ; i < dvs->nvertices ; i++)
  {
    vs = &dvs->vs[i] ;
    vno = vs->vno ;

    if (vno < 0)
    {
      continue ;
    }
    v = &mris->vertices[vno] ;

#if 1
    vs->origx=v->origx;
    vs->origy=v->origy;
    vs->origz=v->origz;
    vs->nx=v->nx;
    vs->ny=v->ny;
    vs->nz=v->nz;
#endif

    vs->vtotal = v->vtotal ;
    vs->vnum = v->vnum ;
    if (v->vtotal)
    {

      vs->v = (int *)calloc(vs->vtotal, sizeof(int)) ;
      if (!vs->v)
      {
        ErrorExit(ERROR_NOMEMORY, "mrisRecordVertexState: could not allocate %dth array of %d elts", i, vs->vtotal) ;
      }
      for (n = 0 ; n < v->vtotal ; n++)
      {
        vs->v[n] = v->v[n] ;
      }
    }
#if 1
    if (v->num>0)
    {
      vs->num=v->num;
      vs->f=(int*)calloc(v->num, sizeof(int)) ;
      vs->n=(unsigned char*)calloc(v->num, sizeof(unsigned char)) ;
      for (n = 0 ; n < v->num ; n++)
      {
        vs->f[n] = v->f[n] ;
        vs->n[n] = v->n[n] ;
      }
    }
    else
    {
      vs->num=0;
      vs->f=NULL;
      vs->n=NULL;
    }
#endif
  }

  return(dvs) ;
}


static int
mrisRestoreFaceVertexState(MRI_SURFACE *mris, DEFECT_VERTEX_STATE *dvs)
{
  int                 i, n, vno ;
  VERTEX              *v ;
  VERTEX_STATE        *vs ;

  /* restore the original number of faces */
  mris->nfaces=dvs->nfaces;

  for (i = 0 ; i < dvs->nvertices ; i++)
  {
    vs = &dvs->vs[i] ;
    vno = vs->vno ;
    if (vno < 0)
    {
      continue ;
    }

    v = &mris->vertices[vno] ;

    free(v->f);
    v->f=NULL;
    free(v->n);
    v->n=NULL;
    v->num=vs->num;

    if (vs->num)
    {
      v->f= (int *)calloc(vs->num, sizeof(int)) ;
      if (!v->f) ErrorExit(ERROR_NOMEMORY,
                             "mrisRestoreFaceState: could not allocate first %dth array of %d elts",
                             i, vs->num) ;
      v->n= (unsigned char *)calloc(vs->num, sizeof(unsigned char)) ;
      if (!v->n) ErrorExit(ERROR_NOMEMORY,
                             "mrisRestoreFaceState: could not allocate second %dth array of %d elts",
                             i, vs->num) ;
      for (n = 0 ; n < v->num ; n++)
      {
        v->f[n] = vs->f[n] ;
        v->n[n] = vs->n[n] ;
      }
    }
  }

  return(NO_ERROR) ;
}

static int
mrisRestoreVertexState(MRI_SURFACE *mris, DEFECT_VERTEX_STATE *dvs)
{
  int                 i, n, vno ;
  VERTEX              *v ;
  VERTEX_STATE        *vs ;

  /* restore the original number of faces */
  mris->nfaces=dvs->nfaces;

  for (i = 0 ; i < dvs->nvertices ; i++)
  {
    vs = &dvs->vs[i] ;
    vno = vs->vno ;
    if (vno < 0)
    {
      continue ;
    }
    v = &mris->vertices[vno] ;
#if 1
    v->origx=vs->origx;
    v->origy=vs->origy;
    v->origz=vs->origz;
    v->nx=vs->nx;
    v->ny=vs->ny;
    v->nz=vs->nz;
#endif
    free(v->v) ;
    v->v = NULL ;
    v->vtotal = vs->vtotal ;
    v->vnum = vs->vnum ;

#if 1
    free(v->f);
    v->f=NULL;
    free(v->n);
    v->n=NULL;
    v->num=vs->num;

    if (vs->num)
    {
      v->f= (int *)calloc(vs->num, sizeof(int)) ;
      if (!v->f) ErrorExit(ERROR_NOMEMORY,
                             "mrisRestoreVertexState: could not allocate first %dth array of %d elts",
                             i, vs->num) ;
      v->n= (unsigned char *)calloc(vs->num, sizeof(unsigned char)) ;
      if (!v->n) ErrorExit(ERROR_NOMEMORY,
                             "mrisRestoreVertexState: could not allocate second %dth array of %d elts",
                             i, vs->num) ;
      for (n = 0 ; n < v->num ; n++)
      {
        v->f[n] = vs->f[n] ;
        v->n[n] = vs->n[n] ;
      }
    }
#endif
    if (!v->vtotal)
    {
      continue ;
    }
    v->v = (int *)calloc(vs->vtotal, sizeof(int)) ;
    if (!v->v)
      ErrorExit(ERROR_NOMEMORY,
                "mrisRestoreVertexState: could not allocate %dth array of %d elts",
                i, vs->vtotal) ;
    for (n = 0 ; n < v->vtotal ; n++)
    {
      v->v[n] = vs->v[n] ;
    }
  }

  return(NO_ERROR) ;
}

static int
mrisComputeNormalDotDistribution(MRI_SURFACE *mris, HISTOGRAM *h_dot)
{
  int    vno, bin, n, num ;
  VERTEX *v, *vn ;
  float  bin_size, min_dot, max_dot, bin_val, dot, dx, dy, dz, nx, ny, nz, x, y, z ;
  HISTOGRAM *h_raw;

  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;
  min_dot = 100000 ;
  max_dot = -100000 ;

  /* first compute min and max */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dx = vn->x - x ;
      dy = vn->y - y ;
      dz = vn->z - z ;
      dot = dx*nx + dy*ny * dz*nz ;
      if (dot < min_dot)
      {
        min_dot = dot ;
      }
      if (dot > max_dot)
      {
        max_dot = dot ;
      }
    }
  }

  /* add one bin at either end for almost zero probability events */
  bin_size = (max_dot - min_dot) / (h_dot->nbins-2) ;
  h_dot->bin_size = bin_size ;
  for (bin_val = min_dot-bin_size, bin = 0 ; bin < h_dot->nbins ; bin++, bin_val += bin_size)
  {
    h_dot->bins[bin] = bin_val ;
  }

  min_dot = h_dot->bins[0] ;

  /* now fill in distribution */
  for (num = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      num++ ;
      vn = &mris->vertices[v->v[n]] ;
      dx = vn->x - x ;
      dy = vn->y - y ;
      dz = vn->z - z ;
      dot = dx*nx + dy*ny * dz*nz ;
      bin = (int)((dot - min_dot) / bin_size) ;
      if (bin == 0)
      {
        DiagBreak() ;
      }

      bin=MIN(h_dot->nbins,MAX(0,bin));
      h_dot->counts[bin]++ ;
    }
  }

  for (bin = 0 ; bin < h_dot->nbins ; bin++)
  {
    if (h_dot->counts[bin] == 0)
    {
      h_dot->counts[bin] = 0.01 ;
    }
    h_dot->counts[bin] /= (float)num ;
  }
  h_raw = HISTOcopy(h_dot, NULL) ;
  //to correct the bug in HISTOcopy..
  h_raw->bin_size=h_dot->bin_size;
  HISTOsmooth(h_raw, h_dot, 2.0) ;

  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    HISTOplot(h_dot, "ndot.plt") ;
    HISTOplot(h_raw, "rdot.plt") ;
  }
  HISTOfree(&h_raw) ;
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;
  return(NO_ERROR) ;
}
static int
mrisComputePrincipalCurvatureDistributions(MRI_SURFACE *mris, HISTOGRAM *h_k1, HISTOGRAM *h_k2,MRI *mri_k1_k2)
{
  int    vno, bin ,bink1,bink2,nvertices,x,y;
  VERTEX *v ;
  float  k1_bin_size, k2_bin_size, min_k1, max_k1, min_k2, max_k2, bin_val, norm ;

#if 0
  HISTOGRAM *h_k1_raw, *h_k2_raw ;
#endif

  MRIScomputeSecondFundamentalForm(mris) ;
  min_k1 = min_k2 = 100000 ;
  max_k1 = max_k2 = -100000 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (v->k1 < min_k1)
    {
      min_k1 = v->k1 ;
    }
    if (v->k2 < min_k2)
    {
      min_k2 = v->k2 ;
    }
    if (v->k1 > max_k1)
    {
      max_k1 = v->k1 ;
    }
    if (v->k2 > max_k2)
    {
      max_k2 = v->k2 ;
    }
  }

  //    fprintf(stderr,"     k1: (min,max)=(%f,%f)\n",min_k1,max_k1);
  //    fprintf(stderr,"     k2: (min,max)=(%f,%f)\n",min_k2,max_k2);

#if 1  /* we limit the span  */
  min_k1=MAX(-3,min_k1);
  max_k1=MIN(3,max_k1);
  min_k2=MAX(-3,min_k2);
  max_k2=MIN(3,max_k2);
#endif

  k1_bin_size = (max_k1 - min_k1) / h_k1->nbins ;
  k2_bin_size = (max_k2 - min_k2) / h_k2->nbins ;

  mri_k1_k2->xsize=(max_k1 - min_k1) / (float)mri_k1_k2->width;
  mri_k1_k2->ysize=(max_k2 - min_k2) / (float)mri_k1_k2->height;
  mri_k1_k2->xstart=min_k1;
  mri_k1_k2->ystart=min_k2;

  h_k1->bin_size = k1_bin_size ;
  h_k2->bin_size = k2_bin_size ;

  for (bin_val = min_k1, bin = 0 ; bin < h_k1->nbins ; bin++, bin_val += k1_bin_size)
  {
    h_k1->bins[bin] = bin_val ;
  }
  for (bin_val = min_k2, bin = 0 ; bin < h_k2->nbins ; bin++, bin_val += k2_bin_size)
  {
    h_k2->bins[bin] = bin_val ;
  }

  nvertices=0;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    nvertices++;
    bin = MIN(h_k1->nbins-1,MAX(0,(int)((v->k1 - min_k1) / k1_bin_size))) ;
    h_k1->counts[bin]++ ;
    bin = MIN(h_k2->nbins-1,MAX(0,(int)((v->k2 - min_k2) / k2_bin_size))) ;
    h_k2->counts[bin]++ ;

    bink1=MIN(mri_k1_k2->width-1,MAX(0,(int)((v->k1 - mri_k1_k2->xstart) / mri_k1_k2->xsize))) ;

    bink2=MIN(mri_k1_k2->height-1,MAX(0,(int)((v->k2 - mri_k1_k2->ystart) / mri_k1_k2->ysize))) ;

    MRIFvox(mri_k1_k2,bink1,bink2,0) += 1.0f;
  }

  for (bin = 0 ; bin < h_k1->nbins ; bin++)
  {
    if (h_k1->counts[bin] == 0)
    {
      h_k1->counts[bin] = 0.01 ;
    }
    h_k1->counts[bin] /= (float)nvertices ;
    ;
  }
  for (bin = 0 ; bin < h_k2->nbins ; bin++)
  {
    if (h_k2->counts[bin] == 0)
    {
      h_k2->counts[bin] = 0.01 ;
    }
    h_k2->counts[bin] /= (float)nvertices ;
    ;
  }

  for (x = 0 ; x < 100; x++)
    for (y = 0 ; y < 100 ; y++)
    {
      if (FZERO(MRIFvox(mri_k1_k2, x, y, 0)))
      {
        MRIFvox(mri_k1_k2, x, y, 0) = 0.1 ;
      }
    }
  for (norm = 0.0, x = 0 ; x < 100 ; x++)
    for (y = 0 ; y < 100 ; y++)
    {
      norm += MRIFvox(mri_k1_k2, x, y, 0) ;
    }

  for (x = 0 ; x < 100; x++)
    for (y = 0 ; y < 100 ; y++)
    {
      MRIFvox(mri_k1_k2, x, y, 0) = MRIFvox(mri_k1_k2, x, y, 0) / norm ;
    }

#if 0
  h_k1_raw = HISTOcopy(h_k1, NULL) ;
  h_k2_raw = HISTOcopy(h_k2, NULL) ;
  // to correct the bug in HISTOcopy
  h_k1_raw->bin_size=h_k1->bin_size;
  h_k2_raw->bin_size=h_k2->bin_size;
  HISTOsmooth(h_k1_raw, h_k1, 2.0) ;
  HISTOsmooth(h_k2_raw, h_k2, 2.0) ;
  HISTOplot(h_k1_raw, "k1r.plt") ;
  HISTOplot(h_k2_raw, "k2r.plt") ;
#endif

  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    HISTOplot(h_k1, "k1.plt") ;
    HISTOplot(h_k2, "k2.plt") ;
    MRIwrite(mri_k1_k2,"mri_k1_k2.mgh");
  }
  return(NO_ERROR) ;
}


/* this set of functions centers the surface mris,
   assuming that its vertices
   (using ORIGINAL_VERTICES) are sampled onto a
   sphere of radius R to be determined */

static double estimateNRG(MRIS *mris,
                          double cx, double cy ,double cz, double R2);
static double estimateSquaredRadius(MRIS *mris,
                                    double cx, double cy, double cz);
static void computeGradient(MRIS *mris,
                            double cx, double cy ,double cz, double R2,
                            double *gx,double *gy, double *gz);

/* compute the NRG associated with the center
   (cx,cy,cz) and the squared radius R2
   NRG = sum((x-cx)^2+(y-cy)^2+(z-cz)^2-R2)^2 */
static double estimateNRG(MRIS *mris ,
                          double cx, double cy ,double cz, double R2)
{
  int n;
  double NRG;
  for (NRG = 0, n = 0 ; n < mris->nvertices ; n++)
  {
    NRG+=SQR(SQR(mris->vertices[n].x-cx)+SQR(mris->vertices[n].y-cy)
             +SQR(mris->vertices[n].z-cz)-R2);
  }
  return NRG;
}

/* estimate the squared radius that
   minimizes the energy defined above for a given
   center (cx,cy,cz) */
static double estimateSquaredRadius(MRIS *mris,
                                    double cx, double cy, double cz)
{
  int n;
  double R2;

  for (R2 = 0.0, n = 0; n < mris->nvertices ; n++)
  {
    R2+=SQR(mris->vertices[n].x-cx)+
        SQR(mris->vertices[n].y-cy)+
        SQR(mris->vertices[n].z-cz);
    if (!finite(R2))
    {
      DiagBreak() ;
    }
  }
  return (R2/(double)mris->nvertices);
}

/* compute the gradient of the energy
   defined above at location (cx,cy,cz,R2) */
static void computeGradient(MRIS *mris,
                            double cx, double cy ,double cz, double R2,
                            double *gx,double *gy, double *gz)
{
  int n;
  double tx,ty,tz;
  tx=0.0;
  ty=0.0;
  tz=0.0;
  for (tx = 0 , ty = 0 , tz = 0 , n = 0 ; n < mris->nvertices ; n++)
  {
    tx += (SQR(mris->vertices[n].x-cx)+SQR(mris->vertices[n].y-cy)
           +SQR(mris->vertices[n].z-cz)-R2)*(mris->vertices[n].x-cx);
    ty += (SQR(mris->vertices[n].x-cx)+SQR(mris->vertices[n].y-cy)
           +SQR(mris->vertices[n].z-cz)-R2)*(mris->vertices[n].y-cy);
    tz += (SQR(mris->vertices[n].x-cx)+SQR(mris->vertices[n].y-cy)
           +SQR(mris->vertices[n].z-cz)-R2)*(mris->vertices[n].z-cz);
  }
  (*gx)=tx/(double)mris->nvertices;
  (*gy)=ty/(double)mris->nvertices;
  (*gz)=tz/(double)mris->nvertices;
}

#define DEBUG_CENTER_SURFACE 0

/* Center the surface mris at location (cx,cy,cz) with a radius r
   such the energy sum((x-cx)^2+(y-cy)^2+(z-cz)^2-r^2)^2 is minimized */
int MRIScenterSphere(MRI_SURFACE *mris)
{
  VERTEX *vertex;
  int n,niters;
  /* sphere parameters */
  double x,y,z,R2,xhi,xlo,yhi,ylo,zhi,zlo,cx,cy,cz,radius,scale;
  /* NRG parameters */
  double NRG,last_NRG;
  /* gradient parameters */
  double dx,dy,dz,d,epsilon;

  fprintf(WHICH_OUTPUT,
          "Finding true center and radius of Spherical Surface...");

  /* compute an initial estimate of the the center (x,y,z) */
  xhi=yhi=zhi= -10000;
  xlo=ylo=zlo= 10000;
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    vertex = &mris->vertices[n] ;
    x = (double)vertex->x ;
    y = (double)vertex->y ;
    z = (double)vertex->z ;

    if (x>xhi)
    {
      xhi=x;
    }
    if (x<xlo)
    {
      xlo=x;
    }
    if (y>yhi)
    {
      yhi=y;
    }
    if (y<ylo)
    {
      ylo=y;
    }
    if (z>zhi)
    {
      zhi=z;
    }
    if (z<zlo)
    {
      zlo=z;
    }
  }
  x = (xlo+xhi)/2.0f ;
  y = (ylo+yhi)/2.0f ;
  z = (zlo+zhi)/2.0f ;

  /* estimate the corresponding squared radius */
  R2=estimateSquaredRadius(mris,x,y,z);

  /* compute the initial NRG */
  NRG=estimateNRG(mris,x,y,z,R2);

  /* verify if the center (0,0,0) with radius 100.0 is a better candidate */
  if (estimateNRG(mris,0.0,0.0,0.0,10000.0)<NRG)
  {
    x=0.0;
    y=0.0;
    z=0.0;
    R2=10000.0;
    NRG=estimateNRG(mris,x,y,z,R2);
  }

  if (estimateNRG(mris,0,0,0,estimateSquaredRadius(mris,0,0,0))<NRG)
  {
    x=y=z=0.0;
    R2=estimateSquaredRadius(mris,x,y,z);
    NRG=estimateNRG(mris,x,y,z,R2);
  }

#if DEBUG_CENTER_SURFACE
  fprintf(WHICH_OUTPUT,"\nInitial Configuration: NRG=%lf, R=%f and ( %f , %f , %f )"
          ,100000.0*NRG,sqrt(R2), x, y, z);
#endif


  /* iteratively minize the NRG */
  last_NRG=NRG+1.0;
  niters=0;
  while (NRG<last_NRG)
  {
    niters++;
    if (niters>100)
    {
      break;
    }
    last_NRG=NRG;

    /* compute the gradient */
    computeGradient(mris,x,y,z,R2,&dx,&dy,&dz);

    /* bound gradient by displacement of 1.0 mm */
    d=sqrt(SQR(dx)+SQR(dy)+SQR(dz));
    if (d>1.0)
    {
      dx/=d;
      dy/=d;
      dz/=d;
    }

    /*   fprintf(WHICH_OUTPUT,"\n gradient:(%f,%f,%f)",dx,dy,dz); */

    epsilon=2.0;
    while (NRG>=last_NRG)
    {
      epsilon/=2.0;
      NRG=estimateNRG(mris,x+epsilon*dx,y+epsilon*dy,z+epsilon*dz
                      ,estimateSquaredRadius(mris,x+epsilon*dx,y+epsilon*dy,z+epsilon*dz));
      d=sqrt(SQR(dx)+SQR(dy)+SQR(dz));
      if (epsilon*d<0.00000000001) //FZERO(epsilon*(SQR(dx)+SQR(dy)+SQR(dz))))
      {
        break;
      }
    }

    if (NRG<last_NRG)
    {
      x=x+epsilon*dx;
      y=y+epsilon*dy;
      z=z+epsilon*dz;

      R2=estimateSquaredRadius(mris,x,y,z);

#if DEBUG_CENTER_SURFACE
      fprintf(WHICH_OUTPUT,"\nNew Minimum found: NRG=%lf, R=%f and ( %f , %f , %f )"
              ,100000.0*NRG , sqrt(R2), 10000.*x, 10000.*y,10000.*z);
#endif
    }
    else
    {
      NRG=estimateNRG(mris,x,y,z,R2);
    }
  }

  /* now centering the surface at position (0,0,0) with radius 100.0 */
  cx=0.0;
  cy=0.0;
  cz=0.0;
  radius=100.0;
  scale=sqrt(SQR(radius)/R2);
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    vertex = &mris->vertices[n] ;
    vertex->x=cx+scale*(vertex->x-x);
    vertex->y=cy+scale*(vertex->y-y);
    vertex->z=cz+scale*(vertex->z-z);
  }

  //scaling onto sphere with the exact right radius DEFAULT_RADIUS
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    vertex = &mris->vertices[n] ;
    R2=SQR(vertex->x)+SQR(vertex->y)+SQR(vertex->z);
    scale=DEFAULT_RADIUS/sqrt(R2);
    vertex->x *= scale;
    vertex->y *= scale;
    vertex->z *= scale;
    R2=SQR(vertex->x)+SQR(vertex->y)+SQR(vertex->z);
    scale=DEFAULT_RADIUS/sqrt(R2);
    vertex->x *= scale;
    vertex->y *= scale;
    vertex->z *= scale;
  }

#if DEBUG_CENTER_SURFACE
  fprintf(WHICH_OUTPUT,"\nFinal Minimum found: NRG=%lf, R=%f and ( %f , %f , %f )\n"
          , 100000.0*estimateNRG(mris,cx,cy,cz,10000.0)
          , sqrt(estimateSquaredRadius(mris,cx,cy,cz)), 10000.*cx, 10000.*cy,10000.*cz);
#endif

  fprintf(WHICH_OUTPUT,"done\nSurface centered at (0,0,0) with radius 100.0 in %d iterations\n", niters);
  return NO_ERROR;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description: apply gradient to the sphere, so that the
  topology of the border is preserved
  (check mrisFindOptimalDefectMapping)

  ------------------------------------------------------*/

#define VERTEX_INTERIOR 1
#define VERTEX_BORDER 2
#define VERTEX_CHULL 3

#if 0
static float computeAngleSign(MRIS *mris, int v,int v2, int v3)
{
  float v0[3],v1[3],d1,d2,d3,dot;

  v0[0] = mris->vertices[v2].x - mris->vertices[v].x;
  v0[1] = mris->vertices[v2].y - mris->vertices[v].y;
  v0[2] = mris->vertices[v2].z - mris->vertices[v].z;
  v1[0] = mris->vertices[v3].x - mris->vertices[v].x;
  v1[1] = mris->vertices[v3].y - mris->vertices[v].y;
  v1[2] = mris->vertices[v3].z - mris->vertices[v].z;
  d1 = -v1[1]*v0[2] + v0[1]*v1[2];
  d2 = v1[0]*v0[2] - v0[0]*v1[2];
  d3 = -v1[0]*v0[1] + v0[0]*v1[1];

  dot =  mris->vertices[v].x * d1
         + mris->vertices[v].y * d2
         + mris->vertices[v].z * d3 ;

  return dot;
}
#endif


typedef struct
{
  EDGE *inside_edges,*border_edges;
  int n_inside_edges,n_border_edges;
}
EDGE_LIST_INFO;

#define DEBUG_PRESERVING_GRADIENT 0
#if DEBUG_PRESERVING_GRADIENT
/* for debugging purposes */
static int ver1=-1,ver2=-1,ver3=-1,ver4=-1;
#endif

int mrisApplyTopologyPreservingGradient(MRI_SURFACE *mris,
                                        double dt,int which_gradient)
{
  int     vno, nvertices , n , m ;
  VERTEX  *v , *vn ;//,*vm;
  EDGE e1,*e2;
  FACE *face;
#if DEBUG_PRESERVING_GRADIENT
  EDGE e3,e4;
#endif
  double x,y,z,dx,dy,dz;
  float orig_area,area;
  int v1,v2,v3;

#if 1
  int last_step = 5;
  double epsilon[6]= {1.0,0.8,0.6,0.4,0.2,0.0};
#else
  int last_step = 2;
  double epsilon[3]= {1.0,0.5,0.0};
#endif
  int step ;

  int intersect,ninside,nborder;
  EDGE *inside,*border;

  EDGE_LIST_INFO* eli=(EDGE_LIST_INFO*)mris->vp;
  ninside=eli->n_inside_edges;
  inside=eli->inside_edges;
  nborder=eli->n_border_edges;
  border=eli->border_edges;

  nvertices = mris->nvertices ;
  MRISstoreCurrentPositions(mris) ;

  /* just making sure */
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->cx=v->x;
    v->cy=v->y;
    v->cz=v->z;
  }

  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    if (!finite(v->x) || !finite(v->y) || !finite(v->z))
    {
      ErrorPrintf(ERROR_BADPARM, "vertex %d position is not finite!\n",vno) ;
    }

    x = v->x;
    y = v->y;
    z = v->z;

    if (which_gradient)
    {
      if (!finite(v->odx) || !finite(v->ody) || !finite(v->odz))
      {
        ErrorPrintf(ERROR_BADPARM, "vertex %d position is not finite!\n",vno) ;
      }

      dx = v->odx;
      dy = v->ody;
      dz = v->odz;

    }
    else
    {
      if (!finite(v->dx) || !finite(v->dy) || !finite(v->dz))
      {
        ErrorPrintf(ERROR_BADPARM, "vertex %d position is not finite!\n",vno) ;
      }

      dx = dt*v->dx;
      dy = dt*v->dy;
      dz = dt*v->dz;
    }


#if DEBUG_PRESERVING_GRADIENT
    if (vno == ver1 || vno == ver2 || vno == ver3 || vno == ver4)
    {
      fprintf(stderr,"\nbf %d : %f %f %f - %f %f %f  ",vno,v->x,v->y,v->z,v->cx,v->cy,v->cz);

      /* test */
      e3.vno1=ver1;
      e3.vno2=ver2;
      e4.vno1=ver3;
      e4.vno2=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"\nXXX intersection %d !\n",vno);
      }
      /* test */
      e3.vno1=ver1;
      e3.vno2=ver2;
      e4.vno2=ver3;
      e4.vno1=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"YYY intersection %d !\n",vno);
      }
      /* test */
      e3.vno2=ver1;
      e3.vno1=ver2;
      e4.vno2=ver3;
      e4.vno1=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"ZZZ intersection %d !\n",vno);
      }
      /* test */
      e3.vno2=ver1;
      e3.vno1=ver2;
      e4.vno1=ver3;
      e4.vno2=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"UUU intersection %d !\n",vno);
      }
      /* test */
      e4.vno1=ver1;
      e4.vno2=ver2;
      e3.vno1=ver3;
      e3.vno2=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"AAA intersection %d !\n",vno);
      }
      /* test */
      e4.vno1=ver1;
      e4.vno2=ver2;
      e3.vno2=ver3;
      e3.vno1=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"BBB intersection %d !\n",vno);
      }
      /* test */
      e4.vno2=ver1;
      e4.vno1=ver2;
      e3.vno2=ver3;
      e3.vno1=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"CCC intersection %d !\n",vno);
      }
      /* test */
      e4.vno2=ver1;
      e4.vno1=ver2;
      e3.vno1=ver3;
      e3.vno2=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"DDD intersection %d !\n",vno);
      }
    }
#endif

    switch (v->flags)
    {
    case VERTEX_CHULL:
      step = 0 ;
      /* preserve triangle area */
      for ( n = 0 ; n < v->num && step < last_step ; n++)
      {
        sphericalProjection(x,y,z,&v->x,&v->y,&v->z);
        v->cx=v->x;
        v->cy=v->y;
        v->cz=v->z;
        orig_area = computeArea(mris,v->f[n],(int)v->n[n]);
        if ((orig_area <= 0))
        {
          //&&(parms->verbose>=VERBOSE_MODE_MEDIUM)) {

          fprintf(stderr,"negative area : this should never happen!\n");
          fprintf(stderr,"face %d (%d,%d,%d) at vertex %d\n",v->f[n],mris->faces[v->f[n]].v[0],mris->faces[v->f[n]].v[1],mris->faces[v->f[n]].v[2],vno);
          v1=mris->faces[v->f[n]].v[0];
          v2=mris->faces[v->f[n]].v[1];
          v3=mris->faces[v->f[n]].v[2];
          fprintf(stderr,"cur: vertex %d (%f,%f,%f)\n",
                  v1,mris->vertices[v1].x,mris->vertices[v1].y
                  ,mris->vertices[v1].z);
          fprintf(stderr,"cur: vertex %d (%f,%f,%f)\n",
                  v2,mris->vertices[v2].x,mris->vertices[v2].y
                  ,mris->vertices[v2].z);
          fprintf(stderr,"cur: vertex %d (%f,%f,%f)\n",
                  v3,mris->vertices[v3].x,mris->vertices[v3].y
                  ,mris->vertices[v3].z);
          //if(parms->verbose==VERBOSE_MODE_HIGH)
          ErrorExit(ERROR_BADPARM, "mrisApplyTopologyPreservingGradient:SHOULD NOT HAPPEN\n");
        }
        while (step<last_step)
        {
          sphericalProjection(x+epsilon[step]*dx,y+epsilon[step]*dy,z+epsilon[step]*dz,&v->x,&v->y,&v->z);
          v->cx=v->x;
          v->cy=v->y;
          v->cz=v->z;
          area = computeArea(mris,v->f[n],(int)v->n[n]);
          if (area > 0)
          {
            break;  /* we can stop here */
          }
          step++;
        }
      }

      /* apply gradient */
#if DEBUG_PRESERVING_GRADIENT
      //step=5;
      if (step!=0 && step!=5)
      {
        fprintf(stderr,"%d+",step);
      }
      else
      {
        fprintf(stderr,".");
      }
#endif
      sphericalProjection(x+epsilon[step]*dx,y+epsilon[step]*dy,z+epsilon[step]*dz,&v->x,&v->y,&v->z);
      v->cx=v->x;
      v->cy=v->y;
      v->cz=v->z;
      break;


    case VERTEX_BORDER:
      step=0;
      /* preserve triangle area for border/chull vertices */
      for ( n = 0 ; n < v->num && step < last_step ; n++)
      {
        face=&mris->faces[v->f[n]];
        if (mris->vertices[face->v[0]].flags==VERTEX_INTERIOR ||
            mris->vertices[face->v[1]].flags==VERTEX_INTERIOR ||
            mris->vertices[face->v[2]].flags==VERTEX_INTERIOR)
        {
          continue;
        }
        /* test : could be removed */
        sphericalProjection(x,y,z,&v->x,&v->y,&v->z);
        v->cx=v->x;
        v->cy=v->y;
        v->cz=v->z;
        orig_area = computeArea(mris,v->f[n],(int)v->n[n]);
        if ((orig_area <= 0))
        {
          //&&(parms->verbose>=VERBOSE_MODE_MEDIUM)) {
          fprintf(stderr,"negative area : should not happen!\n");
          fprintf(stderr,"face %d (%d,%d,%d) at vertex %d\n",v->f[n],mris->faces[v->f[n]].v[0],mris->faces[v->f[n]].v[1],mris->faces[v->f[n]].v[2],vno);
          v1=mris->faces[v->f[n]].v[0];
          v2=mris->faces[v->f[n]].v[1];
          v3=mris->faces[v->f[n]].v[2];
          fprintf(stderr,"cur: vertex %d (%f,%f,%f)\n",
                  v1,mris->vertices[v1].x,mris->vertices[v1].y
                  ,mris->vertices[v1].z);
          fprintf(stderr,"cur: vertex %d (%f,%f,%f)\n",
                  v2,mris->vertices[v2].x,mris->vertices[v2].y
                  ,mris->vertices[v2].z);
          fprintf(stderr,"cur: vertex %d (%f,%f,%f)\n",
                  v3,mris->vertices[v3].x,mris->vertices[v3].y
                  ,mris->vertices[v3].z);
          //if(parms->verbose==VERBOSE_MODE_HIGH)
          ErrorExit(ERROR_BADPARM, "mrisApplyTopologyPreservingGradient:SHOULD NOT HAPPEN\n");
        }
        /* end of test */
        while (step<last_step)
        {
          sphericalProjection(x+epsilon[step]*dx,y+epsilon[step]*dy,z+epsilon[step]*dz,&v->x,&v->y,&v->z);
          v->cx=v->x;
          v->cy=v->y;
          v->cz=v->z;
          area = computeArea(mris,v->f[n],(int)v->n[n]);
          if (area > 0)
          {
            break;  /* we can stop here */
          }
          step++;
        }
      }

      /* check intersection/inversion with all the border edges
         For EVERY time step, all edges should not intersect anything
         This is because the border does not have to be convex!!
      */
      /* test : could be removed */
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn=&mris->vertices[v->v[n]];
#if DEBUG_PRESERVING_GRADIENT
        //if(vno==412)
        //fprintf(stderr,"\n%d(%d) and %d(%d)\n",vno,v->flags,v->v[n],vn->flags);
#endif
        if (vn->flags != VERTEX_BORDER)
        {
          continue;
        }
        e1.vno1=vno;
        e1.vno2=v->v[n];
        sphericalProjection(x,y,z,&v->x,&v->y,&v->z);
        v->cx=v->x;
        v->cy=v->y;
        v->cz=v->z;
        for ( m = 0 ; m < ninside ; m++)
        {
          e2=&inside[m];
          /* intersection */
          if (edgesIntersect(mris, &e1, e2))
          {
            {
              //if(parms->verbose>=VERBOSE_MODE_MEDIUM){
              fprintf(stderr,"edge intersection : should not happen\n");
              fprintf(stderr,"edge %d-%d with edge %d %d \n",e1.vno1,e1.vno2,e2->vno1,e2->vno2);
              vno=e1.vno1;
              v=&mris->vertices[vno];
              fprintf(stderr,"%d : %f %f %f  - %f %f %f \n",vno,v->x,v->y,v->z,v->cx,v->cy,v->cz);
              vno=e1.vno2;
              v=&mris->vertices[vno];
              fprintf(stderr,"%d : %f %f %f - %f %f %f \n",vno,v->x,v->y,v->z,v->cx,v->cy,v->cz);
              vno=e2->vno1;
              v=&mris->vertices[vno];
              fprintf(stderr,"%d : %f %f %f - %f %f %f \n",vno,v->x,v->y,v->z,v->cx,v->cy,v->cz);
              vno=e2->vno2;
              v=&mris->vertices[vno];
              fprintf(stderr,"%d : %f %f %f - %f %f %f \n",vno,v->x,v->y,v->z,v->cx,v->cy,v->cz);
              //                                      if(parms->verbose==VERBOSE_MODE_HIGH)
              ErrorExit(ERROR_BADPARM, "mrisApplyTopologyPreservingGradient:SHOULD NOT HAPPEN\n");
            }
            break;
          }
        }
      }
      /* end of test */
      while (step < last_step)
      {
        intersect=0;
        /* new coordinates */
        sphericalProjection(x+epsilon[step]*dx,y+epsilon[step]*dy,z+epsilon[step]*dz,&v->x,&v->y,&v->z);
        v->cx=v->x;
        v->cy=v->y;
        v->cz=v->z;

        /* check for all edges */
        for ( n = 0 ; (n < v->vnum) && (!intersect) ; n++)
        {
          vn=&mris->vertices[v->v[n]];
          if (vn->flags != VERTEX_BORDER)
          {
            continue;
          }
          e1.vno1=vno;
          e1.vno2=v->v[n];

          for ( m = 0 ; m < ninside ; m++)
          {
            e2=&inside[m];
            /* intersection */
            if (edgesIntersect(mris, &e1, e2))
            {
              intersect=1;
              break;
            }
          }
        }
        if (!intersect)
        {
          break;
        }
        step++;
      }

      /* apply gradient */
#if DEBUG_PRESERVING_GRADIENT
      //step=5;
      if (step!=0 && step!=5)
      {
        fprintf(stderr,"%d_",step);
      }
      else
      {
        fprintf(stderr,":");
      }
#endif
      sphericalProjection(x+epsilon[step]*dx,y+epsilon[step]*dy,z+epsilon[step]*dz,&v->x,&v->y,&v->z);
      v->cx=v->x;
      v->cy=v->y;
      v->cz=v->z;
      break;

    case VERTEX_INTERIOR: /* preserve edge-edge intersection and angle inversion */
      step=0;
      /* check intersection/inversion with all the border edges
         For EVERY time step, all edges should not intersect anything
         This is because the border does not have to be convex!!
      */
      /* test : could be removed */
      for ( n = 0 ; n < v->vnum  ; n++)
      {
        vn=&mris->vertices[v->v[n]];
#if DEBUG_PRESERVING_GRADIENT
        //if(vno==412)
        //fprintf(stderr,"\n%d(%d) and %d(%d)\n",vno,v->flags,v->v[n],vn->flags);
#endif
        if (vn->flags != VERTEX_INTERIOR)
        {
          continue;
        }
        e1.vno1=vno;
        e1.vno2=v->v[n];
        sphericalProjection(x,y,z,&v->x,&v->y,&v->z);
        v->cx=v->x;
        v->cy=v->y;
        v->cz=v->z;
        for ( m = 0 ; m < nborder ; m++)
        {
          e2=&border[m];
          /* intersection */
          if (edgesIntersect(mris, &e1, e2))
          {
            {
              //if(parms->verbose>=VERBOSE_MODE_MEDIUM){
              fprintf(stderr,"Error; edge intersection : should not happen\n");
              fprintf(stderr,"edge %d-%d with edge %d %d \n",e1.vno1,e1.vno2,e2->vno1,e2->vno2);
              //if(parms->verbose==VERBOSE_MODE_HIGH)
              ErrorExit(ERROR_BADPARM, "mrisApplyTopologyPreservingGradient:SHOULD NOT HAPPEN\n");
            }
            break;
          }
        }
      }
      /* end of test */

      while (step < last_step)
      {
        intersect=0;
        /* new coordinates */
        sphericalProjection(x+epsilon[step]*dx,y+epsilon[step]*dy,z+epsilon[step]*dz,&v->x,&v->y,&v->z);
        v->cx=v->x;
        v->cy=v->y;
        v->cz=v->z;

        /* check for all edges */
        for ( n = 0 ; n < v->vnum && (!intersect) ; n++)
        {
          vn=&mris->vertices[v->v[n]];
          if (vn->flags != VERTEX_INTERIOR)
          {
            continue;
          }
          e1.vno1=vno;
          e1.vno2=v->v[n];

          for ( m = 0 ; m < nborder ; m++)
          {
            e2=&border[m];
            /* intersection */
            if (edgesIntersect(mris, &e1, e2))
            {
              intersect=1;
              break;
            }
          }
        }
        if (!intersect)
        {
          break;
        }
        step++;
      }

      /* apply gradient */
#if DEBUG_PRESERVING_GRADIENT
      //step=5;
      if (step!=0 && step!=5)
      {
        fprintf(stderr,"%d-",step);
      }
      else
      {
        fprintf(stderr,",");
      }
#endif
      sphericalProjection(x+epsilon[step]*dx,y+epsilon[step]*dy,z+epsilon[step]*dz,&v->x,&v->y,&v->z);
      v->cx=v->x;
      v->cy=v->y;
      v->cz=v->z;
      break;
    }
#if DEBUG_PRESERVING_GRADIENT
    if (vno == ver1 || vno == ver2 || vno == ver3 || vno == ver4)
    {
      fprintf(stderr,"\naf %d : %f %f %f - %f %f %f  ",vno,v->x,v->y,v->z,v->cx,v->cy,v->cz);

      /* test */
      e4.vno1=ver1;
      e4.vno2=ver2;
      e3.vno1=ver3;
      e3.vno2=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"\nAAA intersection %d !\n",vno);
      }
      /* test */
      e4.vno1=ver1;
      e4.vno2=ver2;
      e3.vno2=ver3;
      e3.vno1=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"BBB intersection %d !\n",vno);
      }
      /* test */
      e4.vno2=ver1;
      e4.vno1=ver2;
      e3.vno2=ver3;
      e3.vno1=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"CCC intersection %d !\n",vno);
      }
      /* test */
      e4.vno2=ver1;
      e4.vno1=ver2;
      e3.vno1=ver3;
      e3.vno2=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"DDD intersection %d !\n",vno);
      }
      /* test */
      e3.vno1=ver1;
      e3.vno2=ver2;
      e4.vno1=ver3;
      e4.vno2=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"XXX intersection %d !\n",vno);
      }
      /* test */
      e3.vno1=ver1;
      e3.vno2=ver2;
      e4.vno2=ver3;
      e4.vno1=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"YYY intersection %d !\n",vno);
      }
      /* test */
      e3.vno2=ver1;
      e3.vno1=ver2;
      e4.vno2=ver3;
      e4.vno1=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"ZZZ intersection %d !\n",vno);
      }
      /* test */
      e3.vno2=ver1;
      e3.vno1=ver2;
      e4.vno1=ver3;
      e4.vno2=ver4;
      if (edgesIntersect(mris, &e3, &e4))
      {
        fprintf(stderr,"UUU intersection %d !\n",vno);
      }
    }
#endif
  }
  //    fprintf(stderr,"\n\n\n");
  return(NO_ERROR) ;
}


static long ncross = 0 ;
static long nmut = 0 ;
static long nkilled = 0;

static DEFECT_LIST *mrisMergeNeighboringDefects(MRIS *mris,DEFECT_LIST *dl);

static DEFECT_LIST *mrisMergeNeighboringDefects(MRIS *mris,DEFECT_LIST *dl)
{
  int i,j,n,m,*nd,ndefects,merged;
  int  vlist[200000],nadded;
  float len;
  VERTEX *v,*nv;
  DEFECT *defect;
  DEFECT_LIST *new_dl;

  fprintf(WHICH_OUTPUT,"analyzing neighboring defects...\n");

  ndefects=dl->ndefects;
  nd=(int*)malloc((ndefects+1)*sizeof(int));

  /* mark inside vertices */
  for (i=0; i<ndefects; i++)
  {
    defect=&dl->defects[i];
    for (n = 0; n < defect->nvertices ; n++)
    {
      mris->vertices[defect->vertices[n]].marked=i+1;
    }
  }

  /* iteratively find neighboring defects and merge them */
  for ( i = 0 ; i < ndefects ; i++)
  {
    memset(nd,0,(ndefects+1)*sizeof(int));
    defect=&dl->defects[i];
    for (n=0; n<defect->nborder; n++)
    {
      v=&mris->vertices[defect->border[n]];
      for (m=0; m<v->vnum; m++)
      {
        nv=&mris->vertices[v->v[m]];
        if (nv->marked && nv->marked!=i+1) // belong to another defect
        {
          nd[nv->marked]++;
        }
      }
    }

    /* find if this segment should be merged with other ones */
    merged=0;
    for (j=1; j < ndefects+1 ; j++)
    {
      if (nd[j]>=2)
      {
        merged=1;
        fprintf(WHICH_OUTPUT,"      -merging segment %d into %d\n",j-1,i);
        /* merging of two segments */

        defect->area = -1;
        /* update inside vertices */
        memmove(vlist,defect->vertices,defect->nvertices*sizeof(int));
        nadded=defect->nvertices;
        memmove(&vlist[nadded],dl->defects[j-1].vertices,dl->defects[j-1].nvertices*sizeof(int));
        nadded += dl->defects[j-1].nvertices;

        free(defect->vertices);
        defect->vertices=(int*)malloc(nadded*sizeof(int));
        memmove(defect->vertices,vlist,nadded*sizeof(int));
        defect->nvertices=nadded;

        free(defect->status);
        defect->status=(char *)malloc(nadded*sizeof(char));
        for (n=0; n<defect->nvertices; n++)
        {
          defect->status[n]=KEEP_VERTEX;  //TO BE CHECKED
        }

        /* free inside vertices */
        free(dl->defects[j-1].vertices);
        free(dl->defects[j-1].status);
        dl->defects[j-1].vertices=NULL;
        dl->defects[j-1].status=NULL;
        dl->defects[j-1].nvertices=0;


        /* free border */
        free(dl->defects[j-1].border);
        dl->defects[j-1].border=NULL;
        dl->defects[j-1].nborder=0;

        /* update defect parameters */
        defect->nx = 0;
        defect->ny = 0 ;
        defect->nz=0;
        defect->cx = 0;
        defect->cy = 0 ;
        defect->cz = 0 ;
        defect->area = 0 ;
        for (n = 0; n < defect->nvertices ; n++)
        {
          defect->nx += mris->vertices[defect->vertices[n]].nx;
          defect->ny += mris->vertices[defect->vertices[n]].ny;
          defect->nz += mris->vertices[defect->vertices[n]].nz;
          defect->cx += mris->vertices[defect->vertices[n]].x;
          defect->cy += mris->vertices[defect->vertices[n]].y;
          defect->cz += mris->vertices[defect->vertices[n]].z;
          defect->area += mris->vertices[defect->vertices[n]].origarea ;
        }
        defect->nx /= (float)defect->nvertices;
        defect->ny /= (float)defect->nvertices;
        defect->nz /= (float)defect->nvertices;
        defect->cx /= (float)defect->nvertices;
        defect->cy /= (float)defect->nvertices;
        defect->cz /= (float)defect->nvertices;
        defect->area /= (float)defect->nvertices;
      }
    }

    /* update the border vertices and the mark for the inside ones */
    if (merged)
    {
      /* update marks inside */
      for (n=0; n<defect->nvertices; n++)
      {
        mris->vertices[defect->vertices[n]].marked=i+1;
      }

      /* update border vertices */
      nadded=0;
      for (n=0; n<defect->nvertices; n++)
      {
        v=&mris->vertices[defect->vertices[n]];
        for (m=0; m<v->vnum; m++)
        {
          nv=&mris->vertices[v->v[m]];
          if (nv->marked)
          {
            continue;
          }
          nv->marked=-1; /* border vertex */
          vlist[nadded++]=v->v[m];
        }
      }

      free(defect->border);
      defect->border=(int*)malloc(nadded*sizeof(int));
      memmove(defect->border,vlist,nadded*sizeof(int));
      defect->nborder=nadded;
      /* set marks to zero */
      for (n=0; n<defect->nborder; n++)
      {
        mris->vertices[defect->border[n]].marked=0;
        ;
      }
      //if merged, we evaluate the defect again...
      i--;
    }
  }

  free(nd);

  /* clean defect from empty spaces */
  new_dl=(DEFECT_LIST*)calloc(1,sizeof(DEFECT_LIST));
  for (i=0; i<ndefects; i++)
  {
    defect=&dl->defects[i];
    if (defect->nvertices)
    {
      /* this defect is not empty */
      memmove(&new_dl->defects[new_dl->ndefects++],defect,sizeof(DEFECT));
    }
  }

  free(dl);

  /* update defect statistics */
  for (i=0; i<ndefects; i++)
  {
    defect=&new_dl->defects[i];
    if (defect->area >= 0)
    {
      continue;
    }
    defect->area=0;
    defect->cx = 0 ;
    defect->cy = 0 ;
    defect->cz = 0;
    for ( n = 0 ; n < defect->nvertices ; n++)
    {
      v=&mris->vertices[defect->vertices[n]];
      defect->cx += v->x ;
      defect->cy += v->y ;
      defect->cz += v->z ;
      defect->area += v->origarea ;
    }

    defect->cx /= (float)defect->nvertices ;
    defect->cy /= (float)defect->nvertices ;
    defect->cz /= (float)defect->nvertices ;

    defect->nx = defect->ny = defect->nz = 0;
    for (n = 0 ; n < defect->nborder ; n++)
    {
      v = &mris->vertices[defect->border[n]] ;
      defect->nx += v->nx ;
      defect->ny += v->ny ;
      defect->nz += v->nz ;
    }
    len = sqrt(defect->nx*defect->nx + defect->ny*defect->ny + defect->nz*defect->nz) ;
    if (FZERO(len))
    {
      len = 1.0f ;
    }
    defect->nx = defect->nx/len ;
    defect->ny = defect->ny/len ;
    defect->nz = defect->nz/len ;
  }

  fprintf(stderr,"%d defects to be corrected \n",new_dl->ndefects);
  return new_dl;
}

MRIS* MRISremoveRippedSurfaceElements(MRIS *mris)
{
  int *vertex_trans,*face_trans;
  int vno,fno,i,n,nrippedfaces,nrippedvertices,kept_vertices,kept_faces;
  MRIS *mris_corrected;
  VERTEX *v,*vdst;
  FACE *f,*fdst;

  fprintf(WHICH_OUTPUT,"building final representation...\n");

  vertex_trans=(int*)malloc(mris->nvertices*sizeof(int));
  face_trans=(int*)malloc(mris->nfaces*sizeof(int));

  memset(vertex_trans, -1, mris->nvertices*sizeof(int)) ;
  memset(face_trans, -1, mris->nfaces*sizeof(int)) ;

  //cout the number of faces and vertices
  for (kept_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue;
    }
    kept_vertices++;
  }
  for (kept_faces = fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno];
    if (f->ripflag)
    {
      continue;
    }
    kept_faces++;
  }

  // create a new surface
  mris_corrected = MRISalloc(kept_vertices,kept_faces) ;
  // keep the extra info into the new one
  mris_corrected->useRealRAS = mris->useRealRAS;
  copyVolGeom(&mris->vg, &mris_corrected->vg);

  mris_corrected->type = MRIS_TRIANGULAR_SURFACE ;

  for (nrippedvertices = mris_corrected->nvertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    /* ignore the ripped vertices */
    if (v->ripflag)
    {
      nrippedvertices++;
      continue ;
    }
    /* save vertex information */
    vdst = &mris_corrected->vertices[mris_corrected->nvertices] ;
    vdst->nsize = v->nsize ;
    vdst->x = v->x ;
    vdst->y = v->y ;
    vdst->z = v->z ;
    vdst->origx = v->origx ;
    vdst->origy = v->origy ;
    vdst->origz = v->origz ;
    vdst->tx = v->tx ;
    vdst->ty = v->ty ;
    vdst->tz = v->tz ;
    vdst->nx = v->nx ;
    vdst->ny = v->ny ;
    vdst->nz = v->nz ;
    vdst->cx = v->cx ;
    vdst->cy = v->cy ;
    vdst->cz = v->cz ;
    vdst->val = v->val ;
    vdst->val2 = v->val2 ;
    vdst->valbak = v->valbak ;
    vdst->val2bak = v->val2bak ;
    vdst->imag_val = v->imag_val ;
    vdst->curv = v->curv ;
    vdst->curvbak = v->curvbak ;
    vdst->stat = v->stat ;
    vdst->mean = v->mean ;
    vdst->mean_imag = v->mean_imag ;
    vdst->std_error = v->std_error;
    vdst->H = v->H ;
    vdst->K = v->K ;
    vdst->k1 = v->k1 ;
    vdst->k2 = v->k2 ;
    vertex_trans[vno] = mris_corrected->nvertices++ ;
  }

  for (nrippedfaces = mris_corrected->nfaces = fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    /* don't update triangle with marked vertices */
    if (f->ripflag)
    {
      nrippedfaces++;
      continue ;
    }
    /* save face information */
    fdst = &mris_corrected->faces[mris_corrected->nfaces] ;
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      fdst->v[n] = vertex_trans[f->v[n]] ;
      if (mris->vertices[f->v[n]].ripflag)
      {
        fprintf(stderr,"Error with face %d (%d): vertex %d (%d) is ripped\n",fno,mris_corrected->nfaces,f->v[n],fdst->v[n]);
      }
    }
    face_trans[fno] = mris_corrected->nfaces++ ;
  }
  /* now allocate face and neighbor stuff in mris_corrected */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue;
    }

    vdst = &mris_corrected->vertices[vertex_trans[vno]] ;

    /* count # of good triangles attached to this vertex */
    for (vdst->num = n = 0 ; n < v->num ; n++)
      if (mris->faces[v->f[n]].ripflag == 0)
      {
        vdst->num++ ;
      }
    vdst->f = (int *)calloc(vdst->num, sizeof(int)) ;
    vdst->n = (uchar *)calloc(vdst->num, sizeof(uchar)) ;
    for (i = n = 0 ; n < v->num ; n++)
    {
      if (mris->faces[v->f[n]].ripflag)
      {
        continue;
      }
      vdst->n[i] = v->n[n] ;
      vdst->f[i] = face_trans[v->f[n]] ;
      i++ ;
    }
    /* count # of valid neighbors */
    for (n = vdst->vnum = 0 ; n < v->vnum ; n++)
      if (mris->vertices[v->v[n]].ripflag == 0)
      {
        vdst->vnum++ ;
      }
    vdst->vtotal = vdst->vnum ;
    vdst->v = (int *)calloc(vdst->vnum, sizeof(int)) ;
    for (i = n = 0 ; n < v->vnum ; n++)
      if (mris->vertices[v->v[n]].ripflag == 0)
      {
        vdst->v[i++] = vertex_trans[v->v[n]] ;
      }
  }

  free(vertex_trans);
  free(face_trans);

  fprintf(stderr,"%d vertices and %d faces have been removed from triangulation\n",nrippedvertices,nrippedfaces);

  return mris_corrected;
}

static int defectIdentifyDefectiveVertices(MRI_SURFACE *mris, DEFECT *defect,
    FACE_DEFECT_LIST *fdl,
    float area_threshold,
    int mark_retained,
    int mark_discard,
    MHT *mht, int mode)
{
  int counting,n,p;
  VERTEX *v,*v0, *v1, *v2;
  FACE *f;
  VECTOR  *v_a, *v_b, *v_n ;
  float dot,area;

  v_a = VectorAlloc(3, MATRIX_REAL) ;
  v_b = VectorAlloc(3, MATRIX_REAL) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;       /* normal vector */

  /* set marks to zero */
  for (n = 0 ; n < defect->nvertices ; n++)
  {
    v=&mris->vertices[defect->vertices[n]];
    for ( p = 0 ; p < v->num ; p++)
    {
      f=&mris->faces[v->f[p]];
      f->ripflag=0;
      /* store information */
      f->orig_area = f->area;
    }
  }

  /* store areas and compute spherical area */
  for (n = 0 ; n < defect->nvertices ; n++)
  {
    v=&mris->vertices[defect->vertices[n]];
    for ( p = 0 ; p < v->num ; p++)
    {
      f=&mris->faces[v->f[p]];
      if (f->ripflag)
      {
        continue;
      }
      f->ripflag=1;
      /* compute new area with new coord systems */
      v0 = &mris->vertices[f->v[0]] ;
      v1 = &mris->vertices[f->v[1]] ;
      v2 = &mris->vertices[f->v[2]] ;

      VERTEX_CANONICAL_EDGE(v_a, v0, v1) ;
      VERTEX_CANONICAL_EDGE(v_b, v0, v2) ;

      /* compute metric properties of first triangle */
      V3_CROSS_PRODUCT(v_a, v_b, v_n) ;
      area = V3_LEN(v_n) * 0.5f ;
      dot = v->cx * V3_X(v_n) + v->cy * V3_Y(v_n) + v->cz * V3_Z(v_n);
      if (dot < 0.0f)   /* not in same direction, area < 0 and reverse n */
      {
        f->area = -area ;
      }
      else
      {
        f->area = area ;
      }
    }
  }
  /* unrip */
  for (n = 0 ; n < defect->nvertices ; n++)
  {
    v=&mris->vertices[defect->vertices[n]];
    for ( p = 0 ; p < v->num ; p++)
    {
      f=&mris->faces[v->f[p]];
      f->ripflag=0;
    }
  }

  for (n = 0 ; n < defect->nvertices ; n++)
  {
    defect->status[n]=0;
  }

  mrisMarkRetainedPartOfDefect(mris, defect, fdl, area_threshold,
                               mark_retained, mark_discard, mht , mode) ;

  /* setting back old areas */
  for (n = 0 ; n < defect->nvertices ; n++)
  {
    v=&mris->vertices[defect->vertices[n]];
    for ( p = 0 ; p < v->num ; p++)
    {
      f=&mris->faces[v->f[p]];
      f->area=f->orig_area;
    }
  }

  for (counting = n = 0 ; n < defect->nvertices ; n++)
    if (defect->status[n]==DISCARD_VERTEX)
    {
      counting++;
    }

  VectorFree(&v_a);
  VectorFree(&v_b);
  VectorFree(&v_n);

  return counting;
}
#if ADD_EXTRA_VERTICES
/* verify if some defects are not overlapping : to be implemented */
static DEFECT_LIST *mrisDefectAnalysis(MRIS *mris,DEFECT_LIST *dl )
{
  int i,n;
  DEFECT *defect;

  fprintf(stderr,"analyzing defects...\n");
  /* initiliaze flags */
  for (n=0; n<mris->nvertices; n++)
  {
    mris->vertices[n].ripflag=0;
    mris->vertices[n].marked=0;
    mris->vertices[n].fixedval=0;
    mris->vertices[n].undefval=0;
    mris->vertices[n].old_undefval=0;
  }

  for (i = 0 ; i < dl->ndefects ; i++)
  {
    defect = &dl->defects[i] ;
    //fprintf(stderr,"\n%d  : ",i);
    for (n = 0 ; n < defect->nvertices ; n++)
    {
      //fprintf(stderr,"%d ",defect->vertices[n]);
      if (mris->vertices[defect->vertices[n]].marked)
      {
        ErrorExit(ERROR_BADPARM,"mrisDefectAnalysis : defect %d overlap defect %d",i,mris->vertices[defect->vertices[n]].marked-1);
      }
      mris->vertices[defect->vertices[n]].marked=i+1;
    }
  }
  for (i = 0 ; i < dl->ndefects ; i++)
  {
    defect = &dl->defects[i] ;
    for (n = 0 ; n < defect->nborder ; n++)
    {
      if (mris->vertices[defect->border[n]].marked)
      {
        ErrorExit(ERROR_BADPARM,"mrisDefectAnalysis : defect border %d overlap inside defect %d",i,mris->vertices[defect->border[n]].marked-1);
      }
    }
  }
  for (i = 0 ; i < dl->ndefects ; i++)
  {
    defect = &dl->defects[i] ;
    for (n = 0 ; n < defect->nborder ; n++)
    {
      if (mris->vertices[defect->border[n]].marked)
      {
        ErrorExit(ERROR_BADPARM,"mrisDefectAnalysis : defect border %d overlap border defect %d",i,mris->vertices[defect->border[n]].marked-1);
      }
      mris->vertices[defect->border[n]].marked=i+1;
    }
  }

  //fprintf(stderr,"\nend analysis\n");
  return dl;
}
#endif

#if ADD_EXTRA_VERTICES
static int pushApartDefects(MRIS *mris,DEFECT_LIST *dl)
{
  int i,n,p,m,vnop,total_nadded,nadded;
  DEFECT *defect;
  VERTEX *v,*vp,*vadded;

  fprintf(stderr,"separating defects...\n");
  for ( n = 0 ; n < mris->nvertices ; n++ )
  {
    v=&mris->vertices[n];
    v->fixedval=0;
    v->marked=0;
  }
  for (total_nadded=i=0 ; i < dl->ndefects; i++)
  {
    defect=&dl->defects[i];

    for ( nadded=n = 0 ; n < defect->nborder ; n++)
    {
      v=&mris->vertices[defect->border[n]];
      for ( p = 0 ; p < v->vnum ; p++)
      {
        vnop=v->v[p];
        vp=&mris->vertices[vnop];
        if (vp->fixedval && vp->fixedval!=i+1)
        {
          /* border vertex from another defect : add one vertex */
          if (mris->nvertices==mris->max_vertices)
          {
            ErrorExit(ERROR_BADPARM,"pushApartDefect : could not allocate extra vertex\n");
          }
          /* just making sure */
          for ( m = 0 ; m < mris->nvertices ; m++)
          {
            mris->vertices[m].marked=0;
          }
          mrisDivideEdge(mris,defect->border[n], vnop);
          vadded=&mris->vertices[mris->nvertices-1];
          //fprintf(stderr,"adding vertex %d(%d)\n",mris->nvertices-1,vn->fixedval);
          vadded->fixedval=0;

          /* spherical projection */
          sphericalProjection(vadded->cx,vadded->cy,vadded->cz,&vadded->cx,&vadded->cy,&vadded->cz);
          vadded->x=vadded->cx;
          vadded->y=vadded->cy;
          vadded->z=vadded->cz;
          nadded++;
        }
      }
      mris->vertices[defect->border[n]].fixedval=i+1;
    }
    //          if(nadded) fprintf(stderr,"defect %d : %d vertices have been added to the surface\n",defect->defect_number,nadded);
    total_nadded += nadded;
  }
  fprintf(stderr,"   total of %d vertices have been added to the surface\n",total_nadded);
  for ( n = 0 ; n < mris->nvertices ; n++ )
  {
    v=&mris->vertices[n];
    v->fixedval=0;
    v->marked=0;
  }
  return NO_ERROR;
}
#endif

////////////////////////////////////////////////////////////////////////
//
//
//    This program will generate a topologically
//    correct surface mris_corrected from mris
//
//    canonical vertices = spherical vertices
//    original vertices = original vertices
//    tmp vertices = inflated vertices
//
//    CAREFUL: the fiedls v->curvbak, v->val, v->val2,
//             v->valbak are used by some functions
//
//////////////////////////////////////////////////////////////////////

MRI_SURFACE *MRIScorrectTopology(MRI_SURFACE *mris,
                                 MRI_SURFACE *mris_corrected,
                                 MRI *mri, MRI *mri_wm,
                                 int nsmooth, TOPOLOGY_PARMS *parms)
{
  FACE_DEFECT_LIST   *fdl ;
  DEFECT_LIST        *dl ;
  DEFECT             *defect ;
  int                fno, i, n, p, vno, kept_vertices, *face_trans,*vertex_trans,counter=0,ninitialfaces;
  MHT                *mht ;
  VERTEX             *v, *vdst ;
  FACE               *f, *fdst ;
  HISTOGRAM          *h_k1, *h_k2, *h_gray, *h_white, *h_dot, *h_border, *h_grad ;
  MRI                *mri_gray_white, *mri_k1_k2 ;
  MRIS               *mris_corrected_final;
#if 0
  float              max_len ;
#endif

#if ADD_EXTRA_VERTICES
  int retessellation_error=-1;
#endif

  OPTIMAL_DEFECT_MAPPING *o_d_m;

  fprintf(WHICH_OUTPUT,"\nCorrection of the Topology\n");

  //    canonical = spherical vertices
  //  original  = original vertices
  //  tmp       = inflated vertices
  //  current   = canonical vertices

  /* saving additional information */
  MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
  //MRISwrite(mris,"orig_uncorrected");
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  //MRISwrite(mris,"inflated_uncorrected");
  // current = inflated

#if MATRIX_ALLOCATION
  /* allocation of the transform matrix */
  VoxelFromSRASmatrix=GetSurfaceRASToVoxelMatrix(mri);
#endif

  /* centering the surface using CANONICAL_VERTICES */
  MRISrestoreVertexPositions(mris, CANONICAL_VERTICES) ;
  //    canonical = spherical vertices
  //  original  = original vertices
  //  tmp       = inflated vertices
  //  current   = spherical vertices
  MRIScenterSphere(mris);

  /* saving into CANONICAL_VERTICES */
  MRISsaveVertexPositions(mris, CANONICAL_VERTICES) ;
  /* at this point : current = canonical vertices */

  /* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
     for now on, should avoid reprojecting vertices onto the sphere
     and even more recentering the canonical sphere
     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  */

  /* marking intersecting edges */
  fdl = MRISmarkAmbiguousVertices(mris, MARK_AMBIGUOUS) ;
  ninitialfaces=mris->nfaces;
  //if (Gdiag & DIAG_SHOW)
  fprintf(WHICH_OUTPUT, "segmenting defects...\n") ;
  dl = MRISsegmentDefects(mris, MARK_AMBIGUOUS, MARK_SEGMENTED) ;

#if ADD_EXTRA_VERTICES
  /* analyze if the segmentation into connected defects is correct */
  dl = mrisDefectAnalysis(mris,dl);
  pushApartDefects(mris,dl);
#endif

  MRISsetVals(mris, 0.0f) ;
  for (i = 0 ; i < dl->ndefects ; i++)
  {
    defect = &dl->defects[i] ;
    defect->defect_number=i;
    for (n = 0 ; n < defect->nvertices ; n++)
    {
      mris->vertices[defect->vertices[n]].val = defect->area ;
    }
  }
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    MRISwriteValues(mris, "defect_area") ;
  }
  //if (Gdiag & DIAG_SHOW)
  fprintf(WHICH_OUTPUT, "%d defects found, arbitrating ambiguous regions...\n",
          dl->ndefects) ;

  /* at this point : canonical vertices */
  MRIScomputeMetricProperties(mris) ;
#if 0
  /* should not modify anything about canonical vertices */
  mrisScaleMaxDimension(mris, FIELD_OF_VIEW*.9f) ;
#endif
  MRISclearMarks(mris) ;
  MRISclearCurvature(mris) ;

  /* at this point : canonical vertices */
#if MERGE_NEIGHBORING_DEFECTS
  /* to avoid subtle topological errors
     became obsolet with ADD_EXTRA_VERTICES */
  dl = mrisMergeNeighboringDefects(mris,dl);
  MRISclearMarks(mris) ;
#endif

  mht = MHTfillTable(mris, NULL) ;

  for (i = 0 ; i < dl->ndefects ; i++)
  {
    defect = &dl->defects[i] ;
    defect->defect_number=i;

    /* Identify some defective vertices */
    mrisMarkRetainedPartOfDefect
    (mris, defect, fdl, AREA_THRESHOLD,
     MARK_RETAIN, MARK_DISCARD, mht , parms->keep) ;
    /* The convex hull is now constituted of the first neighbors only */
    mrisFindDefectConvexHull(mris, defect) ;
  }

  /* for diagnostic purposes */
  for (i = 0 ; i < dl->ndefects ; i++)
  {
    int    vno2, n2 ;
    VERTEX *vn ;

    defect = &dl->defects[i] ;
    defect->defect_number=i;
    for (n = 0 ; n < defect->nvertices+defect->nborder ; n++)
    {
      if (n < defect->nvertices)
      {
        if (defect->status[n] == DISCARD_VERTEX)
        {
          continue ;
        }
        vno = defect->vertices[n] ;
      }
      else
      {
        vno = defect->border[n-defect->nvertices] ;
      }
      v = &mris->vertices[vno] ;
      for (n2 = n+1 ; n2 < defect->nvertices+defect->nborder ; n2++)
      {
        if (n2 < defect->nvertices)
        {
          if (defect->status[n2] == DISCARD_VERTEX)
          {
            continue ;
          }
          vno2 = defect->vertices[n2] ;
        }
        else
        {
          vno2 = defect->border[n2-defect->nvertices] ;
        }
        if (vno == vno2)
        {
          continue ;
        }
        vn = &mris->vertices[vno2] ;
        if (FEQUAL(vn->x,v->x) &&
            FEQUAL(vn->y,v->y) &&
            FEQUAL(vn->z,v->z))
        {
          counter++;
          if (Gdiag & DIAG_SHOW)
            fprintf(WHICH_OUTPUT,
                    "defect %d, vertices %d and %d coincident!\n",
                    i, vno, vno2) ;
        }
      }
    }
  }
  fprintf(WHICH_OUTPUT, "%d vertices coincident\n",counter) ;
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(WHICH_OUTPUT, "\n") ;
  }
  MHTfree(&mht) ;

  MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
  /* at this point : current = original vertices */

  /* v->val = border, v->val2 = white, v->val2bak = gray */
  mrisRipAllDefects(mris, dl, 1) ;
  mrisFindGrayWhiteBorderMean(mris, mri) ;
  mrisRipAllDefects(mris, dl, 0) ;

#if 1
  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  /* at this point : tmp becomes original vertices */
  MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
  MRISaverageVertexPositions(mris, 2) ;
  MRISsaveVertexPositions(mris, ORIGINAL_VERTICES) ;
  /* at this point : original vertices become smoothed original vertices */
  //saving out additional information
  //MRISwrite(mris,"orig_smooth_uncorrected");

  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  /* at this point : back to original vertices */
#endif

  /* vertex information :
     canonical - canonical
     tmp - original
     original = smoothed
     current = original (non smoothed)
  */

  MRISsetNeighborhoodSize(mris, 2) ;
  h_k1 = HISTOalloc(100) ;
  h_k2 = HISTOalloc(100) ;
  mri_k1_k2 = MRIalloc(100, 100, 1, MRI_FLOAT) ;
  h_dot = HISTOalloc(100) ;
  mrisComputePrincipalCurvatureDistributions(mris, h_k1, h_k2,mri_k1_k2) ;
  mrisComputeNormalDotDistribution(mris, h_dot) ;

  /* now knit each defect together by retessellating the surface,
     using the spherical space for topology (i.e. edge intersection),
     and the original space for geometry (i.e. edge length).
  */
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  /* at this point : 'non-smoothed' original vertices */

  for (i = 0 ; i < dl->ndefects ; i++)
  {
    defect = &dl->defects[i] ;
    for (n = 0 ; n < defect->nvertices ; n++)
    {
      mris->vertices[defect->vertices[n]].curv =
        defect->status[n] == DISCARD_VERTEX ? -1 : 1 ;
    }
  }

  if (((Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)) || (Gdiag & DIAG_SAVE_DIAGS))
  {
    MRISwriteCurvature(mris, "defect_status");
  }

  /*  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;*/
  MRIScomputeMetricProperties(mris) ;
  MRISclearCurvature(mris) ;
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    for (i = 0 ; i < dl->ndefects ; i++)
    {
      int   total_defective_vertices ;
      float total_defective_area ;
      FILE *fp ;
      char fname[STRLEN] ;

      sprintf(fname, "%s.%s.defect%d.log",
              mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh",
              mris->subject_name,i) ;
      fp = fopen(fname, "wb") ;
      fprintf(fp, "%d %2.3f\n",
              dl->defects[i].nvertices,dl->defects[i].area);
      for (n = 0 ; n < dl->defects[i].nvertices ; n++)
      {
        fprintf(fp, "%d\n", dl->defects[i].vertices[n]) ;
        mris->vertices[dl->defects[i].vertices[n]].curv = (float)i+1 ;
        if (dl->defects[i].vertices[n] == Gdiag_no)
        {
          DiagBreak() ;
        }
      }
      fprintf(fp, "\nborder (%d)\n", dl->defects[i].nborder) ;
      for (n = 0 ; n < dl->defects[i].nborder ; n++)
      {
        fprintf(fp, "%d\n", dl->defects[i].border[n]) ;
        if (dl->defects[i].border[n] == Gdiag_no)
        {
          DiagBreak() ;
        }
      }
#if 0
      if (i != Gdiag_no)
      {
        continue ;
      }
#endif
      fprintf(fp, "\nconvex hull (%d)\n", dl->defects[i].nchull) ;
      for (n = 0 ; n < dl->defects[i].nchull ; n++)
      {
        fprintf(fp, "%d\n", dl->defects[i].chull[n]) ;
        if (dl->defects[i].chull[n] == Gdiag_no)
        {
          DiagBreak() ;
        }
      }
      fclose(fp) ;

      sprintf(fname, "%s.%s.defects.log",
              mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh",
              mris->subject_name) ;
      fp = fopen(fname, "wb") ;
      for (total_defective_area = 0.0f, total_defective_vertices = i = 0 ;
           i < dl->ndefects ; i++)
      {
        total_defective_vertices += dl->defects[i].nvertices ;
        total_defective_area += dl->defects[i].area ;
      }
      fprintf(fp, "%d %2.3f\n",
              total_defective_vertices,total_defective_area);
      for (i = 0 ; i < dl->ndefects ; i++)
      {
        for (n = 0 ; n < dl->defects[i].nvertices ; n++)
        {
          fprintf(fp, "%d\n", dl->defects[i].vertices[n]) ;
        }
      }
      fclose(fp) ;
    }
  }

  //always writing out additional information
  //if(Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
    {
      MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
      MRISwrite(mris,"new_orig_uncorrected");
      MRISrestoreVertexPositions(mris, CANONICAL_VERTICES) ;
      MRISwrite(mris,"new_qsphere_uncorrected");
      MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
    }
    MRISclearCurvature(mris) ;

    for (i = 0 ; i < dl->ndefects ; i++)
    {
      defect = &dl->defects[i] ;
      for (n = 0 ; n < defect->nvertices ; n++)
      {
        mris->vertices[defect->vertices[n]].curv = i+1 ;
      }
    }
    //if (DIAG_VERBOSE_ON || (Gdiag & DIAG_SAVE_DIAGS))
    MRISwriteCurvature(mris, "defect_labels") ;
    for (i = 0 ; i < dl->ndefects ; i++)
    {
      defect = &dl->defects[i] ;
      for (n = 0 ; n < defect->nborder ; n++)
      {
        fflush(stdout); // nicknote: prevents segfault on Linux PowerPC
        // when -O2 optimization is used w/gcc 3.3.3

        mris->vertices[defect->border[n]].curv = i+1;
      }
    }
    //if (DIAG_VERBOSE_ON || (Gdiag & DIAG_SAVE_DIAGS))
    MRISwriteCurvature(mris, "defect_borders") ;
    for (i = 0 ; i < dl->ndefects ; i++)
    {
      defect = &dl->defects[i] ;
      for (n = 0 ; n < defect->nchull ; n++)
      {
        mris->vertices[defect->chull[n]].curv = 2;
      }
      for (n = 0 ; n < defect->nborder ; n++)
      {
        mris->vertices[defect->border[n]].curv = -1;
      }
      for (n = 0 ; n < defect->nvertices ; n++)
      {
        fflush(stdout); // nicknote: prevents segfault on Linux PowerPC
        // when -O2 optimization is used w/gcc 3.3.3

        mris->vertices[defect->vertices[n]].curv = i+1 ;
      }
    }
    //if (DIAG_VERBOSE_ON || (Gdiag & DIAG_SAVE_DIAGS))
    MRISwriteCurvature(mris, "defect_chull") ;
  }
  if (topology_fixing_exit_after_diag)
  {
    return(NULL) ;
  }

  /* now start building the target surface */
  MRISclearMarks(mris) ;
  kept_vertices = mris->nvertices ;
  /* mark the defect with the value 1 (only inside vertices not border !) */
  for (i = 0 ; i < dl->ndefects ; i++)
  {
    mrisMarkDefect(mris, &dl->defects[i], 1) ;
  }
  if (parms->search_mode==GREEDY_SEARCH)
  {
    /* don't keep all vertices */
    for (n = 0 ; n < dl->defects[i].nvertices ; n++)
      if (dl->defects[i].status[n] == DISCARD_VERTEX)
      {
        kept_vertices-- ;
      }
  }

  face_trans  =(int *)calloc(mris->nfaces, sizeof(int)) ;
  vertex_trans = (int *)calloc(mris->nvertices, sizeof(int)) ;
  memset(vertex_trans, -1, mris->nvertices*sizeof(int)) ;
  memset(face_trans, -1, mris->nfaces*sizeof(int)) ;
  // create a new surface
  mris_corrected = MRISoverAlloc(mris->nvertices+10, 2*mris->nfaces,
                                 kept_vertices, 2*mris->nfaces) ;
  // keep the extra info into the new one
  mris_corrected->useRealRAS = mris->useRealRAS;
  mris_corrected->hemisphere = mris->hemisphere ;
  copyVolGeom(&mris->vg, &mris_corrected->vg);

  mris_corrected->type = MRIS_TRIANGULAR_SURFACE ;
#if 0
  MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
#endif
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;  /* inflated */
  MRIScomputeMetricProperties(mris) ;

  for (mris_corrected->nvertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    /* ignore the inside defect vertices but not the bordering ones */
    if (v->marked)
    {
      continue ;
    }
    vdst = &mris_corrected->vertices[mris_corrected->nvertices] ;
    if (mris_corrected->nvertices == Gdiag_no)
    {
      DiagBreak() ;
    }

    vdst->nsize = v->nsize ;
    /* original vertices */
    vdst->x = v->x ;
    vdst->y = v->y ;
    vdst->z = v->z ;
    /* smoothed vertices */
    vdst->origx = v->origx ;
    vdst->origy = v->origy ;
    vdst->origz = v->origz ;
    vdst->tx = v->tx ;
    vdst->ty = v->ty ;
    vdst->tz = v->tz ;
    vdst->nx = v->nx ;
    vdst->ny = v->ny ;
    vdst->nz = v->nz ;
    /* canonical vertices */
    vdst->cx = v->cx ;
    vdst->cy = v->cy ;
    vdst->cz = v->cz ;
    vdst->num = v->num ;
    vdst->val = v->val ;
    vdst->val2 = v->val2 ;
    vdst->valbak = v->valbak ;
    vdst->val2bak = v->val2bak ;
    vdst->imag_val = v->imag_val ;
    vdst->curv = v->curv ;
    vdst->curvbak = v->curvbak ;
    vdst->stat = v->stat ;
    vdst->mean = v->mean ;
    vdst->mean_imag = v->mean_imag ;
    vdst->std_error = v->std_error;
    vdst->H = v->H ;
    vdst->K = v->K ;
    vdst->k1 = v->k1 ;
    vdst->k2 = v->k2 ;
    vdst->border=0;
    vertex_trans[vno] = mris_corrected->nvertices++ ;
  }
  /* now add all the retained vertices in the defects */
  for (i = 0 ; i < dl->ndefects ; i++)
  {
    defect = &dl->defects[i] ;
    for (n = 0 ; n < defect->nvertices ; n++)
    {
      if (defect->vertices[n] == Gdiag_no)
      {
        DiagBreak() ;
      }
      /* only add the kept vertices in greedy_search mode */
      if (parms->search_mode!=GREEDY_SEARCH ||
          defect->status[n] == KEEP_VERTEX)
      {
        vno = defect->vertices[n] ;
        v = &mris->vertices[vno] ;
        if (vno == Gdiag_no)
        {
          DiagBreak() ;
        }
        vdst = &mris_corrected->vertices[mris_corrected->nvertices] ;
        if (mris_corrected->nvertices == Gdiag_no)
        {
          DiagBreak() ;
        }

        vdst->nsize = v->nsize ;
        vdst->x = v->x ;
        vdst->y = v->y ;
        vdst->z = v->z ;
        vdst->origx = v->origx;
        vdst->origy = v->origy;
        vdst->origz = v->origz;
        vdst->tx = v->tx ;
        vdst->ty = v->ty ;
        vdst->tz = v->tz ;
        vdst->cx = v->cx ;
        vdst->cy = v->cy ;
        vdst->cz = v->cz ;
        vdst->nx = v->nx ;
        vdst->ny = v->ny ;
        vdst->nz = v->nz ;
        /* no num*/
        vdst->val = v->val ;
        vdst->val2 = v->val2 ;
        vdst->valbak = v->valbak ;
        vdst->val2bak = v->val2bak ;
        vdst->imag_val = v->imag_val ;
        vdst->curv = v->curv ;
        vdst->curvbak = v->curvbak ;
        vdst->stat = v->stat ;
        vdst->mean = v->mean ;
        vdst->mean_imag = v->mean_imag ;
        vdst->std_error = v->std_error;
        vdst->H = v->H ;
        vdst->K = v->K ;
        vdst->k1 = v->k1 ;
        vdst->k2 = v->k2 ;
        vdst->num = vdst->vnum = 0 ;
        if (parms->search_mode!=GREEDY_SEARCH &&
            defect->status[n] == DISCARD_VERTEX)
        {
          vdst->ripflag=1;
        }
        vertex_trans[vno] = mris_corrected->nvertices++ ;
      }
    }
  }

  for (mris_corrected->nfaces = fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    /* don't update triangle with marked vertices */
    if (triangleMarked(mris, fno))
    {
      continue ;
    }
    /* initialize face */
    fdst = &mris_corrected->faces[mris_corrected->nfaces] ;
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      fdst->v[n] = vertex_trans[f->v[n]] ;
    }
    face_trans[fno] = mris_corrected->nfaces++ ;
  }

  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    FILE  *fp ;
    char  fname[STRLEN] ;
    sprintf(fname, "%s.%s.vtrans.log",
            mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh",
            mris->subject_name) ;
    fp = fopen(fname, "wb") ;
    if (!fp)
    {
      DiagBreak() ;
    }

    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      fprintf(fp, "%6d --> %6d\n", vno, vertex_trans[vno]) ;
    }
    fclose(fp);
    sprintf(fname, "%s.%s.ftrans.log",
            mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh",
            mris->subject_name) ;
    fp = fopen(fname, "wb") ;

    for (vno = 0 ; vno < mris->nfaces ; vno++)
    {
      fprintf(fp, "%6d --> %6d\n", vno, face_trans[vno]) ;
    }
    fclose(fp);
  }

  /* now allocate face and neighbor stuff in mris_corrected */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked)
    {
      continue ;
    }
    if (vertex_trans[vno]<0 ||
        vertex_trans[vno] >= mris_corrected->nvertices)
    {
      continue ;
    }
    vdst = &mris_corrected->vertices[vertex_trans[vno]] ;

    /* count # of good triangles attached to this vertex */
    for (vdst->num = n = 0 ; n < v->num ; n++)
      if (triangleMarked(mris, v->f[n]) == 0)
      {
        vdst->num++ ;
      }
    vdst->f = (int *)calloc(vdst->num, sizeof(int)) ;
    vdst->n = (uchar *)calloc(vdst->num, sizeof(uchar)) ;
    for (i = n = 0 ; n < v->num ; n++)
    {
      if (triangleMarked(mris, v->f[n]))
      {
        continue ;
      }
      vdst->n[i] = v->n[n] ;
      vdst->f[i] = face_trans[v->f[n]] ;
      i++ ;
    }

    /* count # of valid neighbors */
    for (n = vdst->vnum = 0 ; n < v->vnum ; n++)
      if (mris->vertices[v->v[n]].marked == 0)
      {
        vdst->vnum++ ;
      }
    vdst->vtotal = vdst->vnum ;
    vdst->v = (int *)calloc(vdst->vnum, sizeof(int)) ;
    for (i = n = 0 ; n < v->vnum ; n++)
      if (mris->vertices[v->v[n]].marked == 0)
      {
        vdst->v[i++] = vertex_trans[v->v[n]] ;
      }
  }

  MRISclearMarks(mris) ;
  MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
  /* at this point : back to smoothed original vertices for mris */
  /*                 but still original (non smoothed)
                     vertices for mris_corrected */
  MRIScomputeMetricProperties(mris) ;
  MRISsmoothSurfaceNormals(mris, 10) ;

  //////////////// watch out ///////////////////////////////////////////
  h_gray = HISTOalloc(256) ;
  h_white = HISTOalloc(256) ;
  h_border = HISTOalloc(256) ;
  h_grad = HISTOalloc(256) ;
  mri_gray_white = MRIalloc(256, 256, 1, MRI_FLOAT) ;

  mrisMarkAllDefects(mris, dl, 1) ;
  //TO BE CHECKED IF MGH PROCESSED BRAIN (T1==110)
  mrisComputeJointGrayWhiteBorderDistributions
  (mris, mri, mri_gray_white, mri_wm) ;

  /* compute statistics on original */
  if (parms->search_mode!=GREEDY_SEARCH)
    mrisComputeSurfaceStatistics
    (mris,mri,h_k1,h_k2,mri_k1_k2,mri_gray_white,h_dot);

  mrisMarkAllDefects(mris, dl, 0) ;
  for (i = 0 ; i < dl->ndefects ; i++)
  {

    if (parms->correct_defect>=0 && i!=parms->correct_defect)
    {
      continue;
    }

    defect = &dl->defects[i] ;
    if (i == Gdiag_no)
    {
      DiagBreak() ;
    }
#if 0
    fprintf(WHICH_OUTPUT,
            "\rretessellating defect %d with %d vertices (chull=%d).    ",
            i, defect->nvertices+defect->nborder, defect->nchull) ;
#endif
    mrisMarkAllDefects(mris, dl, 1) ;
    mrisComputeGrayWhiteBorderDistributions
    (mris, mri, defect, h_white,h_gray, h_border, h_grad) ;
    mrisMarkAllDefects(mris, dl, 0) ;

#if 0
    MRIwrite(mri_gray_white,"mri_gw.mgh");
    MRIwrite(mri_k1_k2,"mri_k1_k2.mgh");
    HISTOplot(h_k1, "k1.plt") ;
    HISTOplot(h_k2, "k2.plt") ;
    HISTOplot(h_white, "hw.plt") ;
    HISTOplot(h_gray, "hg.plt") ;
#endif

#define TESTING_OPTIMAL 1

    if (parms->search_mode!=GREEDY_SEARCH && parms->optimal_mapping)
    {
      //char fname[500];
      int  validate, counting;
      MAPPING *mapping;
      FS_VERTEX_INFO *vinfo;
      DVS *dvs;
      //MRIS *mris_small;

      /* in optimal mode, check for self-intersection */
      parms->check_surface_intersection=1;

      fprintf(stderr,"\nINITIAL MAPPING with %d vertices\n",defect->nvertices);

#if TESTING_OPTIMAL
      /* record vertex state before correction */
      dvs = mrisRecordVertexState(mris_corrected, defect, vertex_trans) ;

      /* first retessellate using spherical mapping */

      /* identify negative/defective vertices and ignore them */
      counting=defectIdentifyDefectiveVertices
               (mris, defect, fdl,
                AREA_THRESHOLD, MARK_RETAIN, MARK_DISCARD, mht , parms->keep) ;

      fprintf(stderr,"%d out of %d vertices were eliminated",
              counting,defect->nvertices);

      /* retessellate defect */
      mrisTessellateDefect(mris, mris_corrected, defect, vertex_trans, mri,
                           h_k1,h_k2,mri_k1_k2,h_white,h_gray,
                           h_border, h_grad, mri_gray_white, h_dot, parms) ;

#if 1
      {
        int ne,nv,nf,tt,theoric_euler,euler_nb;
        nf=mris_corrected->nfaces;
        ne=nv=0;
        for (tt = 0 ; tt < mris_corrected->nvertices ; tt++)
        {
          if (mris_corrected->vertices[tt].ripflag)
          {
            continue;
          }
          if (mris_corrected->vertices[tt].vnum==0)
          {
            continue;
          }
          ne+=mris_corrected->vertices[tt].vnum;
          nv++;
        }
        ne/=2;
        euler_nb=nv+nf-ne;
        theoric_euler=3+defect->defect_number-dl->ndefects;
        fprintf(WHICH_OUTPUT,
                "After retessellation of defect %d, "
                "euler #=%d (%d,%d,%d) : difference with theory (%d) = %d \n",
                i,euler_nb,nv,ne,nf,theoric_euler,theoric_euler-euler_nb);

#if ADD_EXTRA_VERTICES
        if (theoric_euler-euler_nb && retessellation_error<0)
        {
          retessellation_error=i;
        }
#endif

      }
#endif

      /* validation : no self-intersection and good retessellation */
      //... to be implemented
      validate=0;

      if (!validate)
      {
        /* restore the vertex state */
        mrisRestoreVertexState(mris_corrected, dvs);
#else  // #if TESTING_OPTIMAL
      {
#endif // #if TESTING_OPTIMAL
        /* generation of optimal mappings */
        defect->optimal_mapping=1;

        /* modify chull : chull becomes useless */
        free(defect->chull);
        defect->nchull=defect->nborder;
        defect->chull=(int*)malloc(defect->nchull*sizeof(int));
        memmove(defect->chull,defect->border,defect->nchull*sizeof(int));

        /* save border positions */
        for ( n = 0 ; n < defect->nborder ; n++)
        {
          vdst=&mris_corrected->vertices[vertex_trans[defect->border[n]]];
          vdst->tx2=vdst->cx;
          vdst->ty2=vdst->cy;
          vdst->tz2=vdst->cz;
        }
        /* save inside positions */
        for ( n = 0 ; n < defect->nvertices ; n++)
        {
          vdst=&mris_corrected->vertices[vertex_trans[defect->vertices[n]]];
          vdst->tx2=vdst->cx;
          vdst->ty2=vdst->cy;
          vdst->tz2=vdst->cz;
        }

        /* generate different mappings (max 10) */
        o_d_m=mrisFindOptimalDefectMapping(mris, defect);

        for (p = 0 ; p < o_d_m->nmappings ; p++)
        {
          fprintf(stderr,"MAPPING %d\n",p);

          /* select mapping */
          mapping=&o_d_m->mappings[p];

          /* use fixedval to identify good vertices */
          for (vno=0; vno<mris_corrected->nvertices; vno++)
          {
            mris_corrected->vertices[vno].fixedval=0;
          }

          /* use new coordinates */
          for ( n = 0 ; n < defect->nchull ; n++)
          {
            vinfo =
              &mapping->vertices[o_d_m->vertex_trans[defect->chull[n]]];
            vdst=&mris_corrected->vertices[vertex_trans[defect->chull[n]]];
            v=&mris->vertices[defect->chull[n]];
            vdst->cx=vinfo->c_x;
            vdst->cy=vinfo->c_y;
            vdst->cz=vinfo->c_z;
            v->cx=vinfo->c_x;
            v->cy=vinfo->c_y;
            v->cz=vinfo->c_z;
            vdst->ripflag=0;
            vdst->fixedval=1;
          }
          for ( n = 0 ; n < defect->nvertices ; n++)
          {
            vinfo =
              &mapping->vertices[o_d_m->vertex_trans[defect->vertices[n]]];
            vdst=
              &mris_corrected->vertices[vertex_trans[defect->vertices[n]]];
            v=&mris->vertices[defect->vertices[n]];
            vdst->cx=vinfo->c_x;
            vdst->cy=vinfo->c_y;
            vdst->cz=vinfo->c_z;
            v->cx=vinfo->c_x;
            v->cy=vinfo->c_y;
            v->cz=vinfo->c_z;
            vdst->ripflag=0;
            vdst->fixedval=1;
            defect->status[n]=0;
          }
          /* identify negative/defective vertices and ignore them */
          counting=defectIdentifyDefectiveVertices
                   (mris, defect, fdl, AREA_THRESHOLD,
                    MARK_RETAIN, MARK_DISCARD, mht , parms->keep) ;
          fprintf(stderr,"%d out of %d vertices were eliminated",
                  counting,defect->nvertices);


          /* retessellate defect */
          mrisTessellateDefect(mris, mris_corrected, defect,
                               vertex_trans, mri,
                               h_k1,h_k2,mri_k1_k2,h_white,
                               h_gray, h_border, h_grad,
                               mri_gray_white, h_dot, parms) ;


#if 1
          {
            int ne,nv,nf,tt,theoric_euler,euler_nb;
            nf=mris_corrected->nfaces;
            ne=nv=0;
            for (tt = 0 ; tt < mris_corrected->nvertices ; tt++)
            {
              if (mris_corrected->vertices[tt].ripflag)
              {
                continue;
              }
              if (mris_corrected->vertices[tt].vnum==0)
              {
                continue;
              }
              ne+=mris_corrected->vertices[tt].vnum;
              nv++;
            }
            ne/=2;
            euler_nb=nv+nf-ne;
            theoric_euler=3+defect->defect_number-dl->ndefects;
            fprintf(WHICH_OUTPUT,"After retessellation of defect %d, euler #=%d (%d,%d,%d) : difference with theory (%d) = %d \n",i,euler_nb,nv,ne,nf,theoric_euler,theoric_euler-euler_nb);


#if ADD_EXTRA_VERTICES
            if (theoric_euler-euler_nb && retessellation_error<0)
            {
              retessellation_error=i;
            }
#endif

          }
#endif
#if 0
          /* save solution */
          sprintf(fname,"./lh.final_%d",p);
          fprintf(stderr,"writting solution into %s",fname);
          MRISrestoreVertexPositions(mris_corrected,ORIGINAL_VERTICES);
#if 0

          MRISwrite(mris_corrected,fname);
#else
          mris_small=extractDefect(mris_corrected,defect);
          MRISwrite(mris_small,fname);
          MRISfree(&mris_small);
#endif
          MRISrestoreVertexPositions(mris_corrected,TMP_VERTICES);
#endif

          /* restore border positions */
          for ( n = 0 ; n < defect->nborder ; n++)
          {
            vdst=&mris_corrected->vertices[vertex_trans[defect->border[n]]];
            vdst->cx=vdst->tx2;
            vdst->cy=vdst->ty2;
            vdst->cz=vdst->tz2;
          }
          /* save inside positions */
          for ( n = 0 ; n < defect->nvertices ; n++)
          {
            vdst=
              &mris_corrected->vertices[vertex_trans[defect->vertices[n]]];
            vdst->cx=vdst->tx2;
            vdst->cy=vdst->ty2;
            vdst->cz=vdst->tz2;
          }
          break;

          fprintf(stderr,"restore\n");
          /* restore the vertex state */
          mrisRestoreVertexState(mris_corrected, dvs);
        }
        /* free the structure o_d_m */
        MRISfree(&o_d_m->mris);
        free(o_d_m->vertex_trans);
        free(o_d_m->face_trans);
        free(o_d_m->orig_mapping.vertices);
        for ( n = 0 ; n < 10 ; n++)
        {
          free(o_d_m->mappings[n].vertices);
        }
        free(o_d_m);
      }
      /* free the structure dvs */
#if TESTING_OPTIMAL
      mrisFreeDefectVertexState(dvs) ;
#endif
    }
    else
    {
      // main part of the routine: retessellation of the defect
      mrisTessellateDefect
      (mris, mris_corrected, defect, vertex_trans, mri,
       h_k1,h_k2,mri_k1_k2,h_white,h_gray,
       h_border, h_grad, mri_gray_white, h_dot, parms) ;
    }

    /* compute Euler number of surface */
    if (parms->search_mode!=GREEDY_SEARCH)
    {
      int ne,nv,nf,tt,theoric_euler,euler_nb;
      nf=mris_corrected->nfaces;
      ne=nv=0;
      for (tt = 0 ; tt < mris_corrected->nvertices ; tt++)
      {
        if (mris_corrected->vertices[tt].ripflag)
        {
          continue;
        }
        if (mris_corrected->vertices[tt].vnum==0)
        {
          continue;
        }
        ne+=mris_corrected->vertices[tt].vnum;
        nv++;
      }
      ne/=2;
      euler_nb=nv+nf-ne;
      theoric_euler=3+defect->defect_number-dl->ndefects;
      fprintf(WHICH_OUTPUT,"After retessellation of defect %d, "
              "euler #=%d (%d,%d,%d) : "
              "difference with theory (%d) = %d \n",
              i,euler_nb,nv,ne,nf,theoric_euler,theoric_euler-euler_nb);
#if ADD_EXTRA_VERTICES
      if (theoric_euler-euler_nb && retessellation_error<0)
      {
        retessellation_error=i;
      }
#endif
    }

    if (parms->correct_defect>=0 && i==parms->correct_defect)
      ErrorExit(ERROR_BADPARM,
                "TERMINATING PROGRAM AFTER CORRECTED DEFECT\n");
  }
#if ADD_EXTRA_VERTICES
  if (retessellation_error>=0)
  {
    fprintf(WHICH_OUTPUT,"\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nThe first retessellation error happened for defect %d\n\n",retessellation_error);
  }
#endif

  if (Gdiag & DIAG_SAVE_DIAGS)
  {
    char fname[STRLEN], path[STRLEN] ;

    MRISclearCurvature(mris_corrected) ;
    for (i = 0 ; i < dl->ndefects ; i++)
    {
      defect = &dl->defects[i] ;
      for ( n = 0 ; n < defect->nvertices ; n++)
      {
        vdst=&mris_corrected->vertices[vertex_trans[defect->vertices[n]]];
        if (vdst->ripflag == 0)
        {
          vdst->curv = (i+1) ;  // for diagnostics
        }
      }
    }
    FileNamePath(mris->fname, path) ;
    sprintf(fname, "%s/%s.fixed.defect_labels.mgz", path, mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh") ;
    printf("writing corrected defect labels to %s\n", fname) ;
    MRISwriteCurvature(mris_corrected, fname) ;
  }
  HISTOfree(&h_white) ;
  HISTOfree(&h_gray) ;
  HISTOfree(&h_border) ;
  HISTOfree(&h_dot) ;
  HISTOfree(&h_k1) ;
  HISTOfree(&h_k2) ;
  HISTOfree(&h_grad) ;
  MRIfree(&mri_gray_white) ;
  MRIfree(&mri_k1_k2);

  if (parms->search_mode==GREEDY_SEARCH)
  {
    mrisAddAllDefectFaces(mris_corrected, dl, vertex_trans) ;
  }

  mrisCheckSurface(mris_corrected) ;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    MHT *mht ;

    fprintf(WHICH_OUTPUT,
            "checking corrected surface for self-intersection...\n") ;
    MRISsaveVertexPositions(mris_corrected, TMP_VERTICES) ;
    MRISrestoreVertexPositions(mris_corrected, ORIG_VERTICES) ;
    mht = MHTfillTable(mris_corrected, NULL) ;
    MHTcheckSurface(mris_corrected, mht) ;
    MHTfree(&mht) ;
    MRISrestoreVertexPositions(mris_corrected, TMP_VERTICES) ;
  }

#if 0
  for (i = 0 ; i < dl->ndefects ; i++)
  {
    defect = &dl->defects[i] ;
    for (n = 0 ; n < defect->nvertices ; n++)
    {
      vno = vertex_trans[defect->vertices[n]] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (vno < 0)
      {
        continue ;
      }
      v = &mris_corrected->vertices[vno] ;
      if (v->vnum < 2)
      {
        fprintf(WHICH_OUTPUT,
                "Warning: vertex %d has only %d neighbors!\n",
                vno, v->vnum) ;
        DiagBreak() ;
      }
    }
  }
  if (Gdiag & DIAG_SHOW)
  {
    fprintf(WHICH_OUTPUT, "\n") ;
  }
#endif
  for (vno = 0 ; vno < mris_corrected->nvertices ; vno++)
  {
    VERTEX *v ;

    v = &mris_corrected->vertices[vno] ;
    if (v->dist)
    {
      free(v->dist) ;
    }
    if (v->dist_orig)
    {
      free(v->dist_orig) ;
    }
    v->vtotal = v->vnum ;
    v->dist = (float *)calloc(v->vtotal, sizeof(float)) ;
    if (!v->dist )
      ErrorExit(ERROR_NO_MEMORY,
                "MRISclone: could not allocate %d num",v->vtotal) ;
    v->dist_orig = (float *)calloc(v->vtotal, sizeof(float)) ;
    if (!v->dist_orig )
      ErrorExit(ERROR_NO_MEMORY,
                "MRISclone: could not allocate %d num",v->vtotal) ;
  }

  fprintf(WHICH_OUTPUT,
          "computing original vertex metric properties...\n") ;
  MRISrestoreVertexPositions(mris_corrected, ORIGINAL_VERTICES) ;
  /* at this point : smoothed corrected orig vertices */
  MRIScomputeMetricProperties(mris_corrected) ;
  fprintf(WHICH_OUTPUT, "storing new metric properties...\n") ;
  /*  MRISstoreMetricProperties(mris_corrected) ;*/
  fprintf(WHICH_OUTPUT, "computing tessellation statistics...\n") ;
  MRISprintTessellationStats(mris_corrected, stderr) ;

  // mark everything not in a defect with 1
  MRISsetMarks(mris_corrected, 1) ;
  for (i = 0 ; i < dl->ndefects ; i++)
  {
    defect = &dl->defects[i] ;
    for (n = 0 ; n < defect->nvertices ; n++)
    {
      vno = vertex_trans[defect->vertices[n]] ;
      if (vno < 0 || vno >= mris_corrected->nvertices)
      {
        continue ;
      }
      v = &mris_corrected->vertices[vno] ;
      v->marked = 0 ;
    }
    for (n = 0 ; n < defect->nborder ; n++)
    {
      vno = vertex_trans[defect->border[n]] ;
      if (vno < 0 || vno >= mris_corrected->nvertices)
      {
        continue ;
      }
      v = &mris_corrected->vertices[vno] ;
      v->marked = 0 ;
    }
  }
  fprintf(WHICH_OUTPUT,
          "performing soap bubble on retessellated vertices for %d "
          "iterations...\n", nsmooth) ;
  /* at this point : smoothed corrected orig vertices */

  MRISsoapBubbleVertexPositions(mris_corrected, nsmooth) ;
  MRISsaveVertexPositions(mris_corrected, ORIGINAL_VERTICES) ;
  MRISclearMarks(mris_corrected) ;

  MRISprintTessellationStats(mris_corrected, stderr) ;
  MRISrestoreVertexPositions(mris_corrected, TMP_VERTICES) ;
  /* at this point : back to original vertices */
  fprintf(WHICH_OUTPUT,
          "tessellation finished, orienting corrected surface...\n") ;

  if (parms->search_mode==GREEDY_SEARCH)
  {
    mrisOrientRetessellatedSurface(mris_corrected, dl, vertex_trans) ;
  }

  if (parms->save_fname)
  {
    char fname[500];
    if (MRISmarkOrientationChanges(mris_corrected))
    {
      MRISclearCurvature(mris);
      for (i = 0 ; i < mris->nvertices ; i++)
      {
        vno = vertex_trans[i] ;
        if (vno>=0 && vno<mris_corrected->nvertices)
        {
          mris->vertices[i].curv=mris_corrected->vertices[vno].curv;
        }
      }
      sprintf(fname,"%s/orientation_changes",parms->save_fname);
      MRISwriteCurvature(mris,fname);
      MRISrestoreVertexPositions(mris_corrected,CANONICAL_VERTICES);
      sprintf(fname,"%s/new_sphere",parms->save_fname);
      MRISwrite(mris_corrected,fname);
      sprintf(fname,"%s/orientation_changes2",parms->save_fname);
      MRISwriteCurvature(mris_corrected,fname);
      MRISrestoreVertexPositions(mris_corrected,ORIGINAL_VERTICES);
      MRISclearCurvature(mris_corrected);
      for (i = 0 ; i < dl->ndefects ; i++)
      {
        defect = &dl->defects[i] ;
        for (n = 0 ; n < defect->nborder ; n++)
        {
          vno = vertex_trans[defect->border[n]] ;
          if (vno < 0 || vno >= mris_corrected->nvertices)
          {
            continue ;
          }
          v = &mris_corrected->vertices[vno] ;
          v->curv=-1;
        }
      }
      sprintf(fname,"%s/borders",parms->save_fname);
      MRISwriteCurvature(mris_corrected,fname);
    }
  }

  free(face_trans) ;
  free(vertex_trans) ;
  /* free structures */
  for (fno = 0 ; fno < ninitialfaces ; fno++)
    if (fdl->nfaces[fno] > 0)
    {
      free(fdl->faces[fno]) ;
    }

  free(fdl->faces) ;
  free(fdl->nfaces) ;
  free(fdl) ;
  for (i = 0 ; i < dl->ndefects ; i++)
  {
    if (dl->defects[i].vertices)
    {
      free(dl->defects[i].vertices) ;
    }
    if (dl->defects[i].status)
    {
      free(dl->defects[i].status) ;
    }
    if (dl->defects[i].border)
    {
      free(dl->defects[i].border) ;
    }
    if (dl->defects[i].edges)
    {
      free(dl->defects[i].edges);
    }
  }
  free(dl) ;

#if MATRIX_ALLOCATION
  if (VoxelFromSRASmatrix)
  {
    MatrixFree(&VoxelFromSRASmatrix);
  }
#endif

  if (nmut+ncross>0)
    fprintf(
      WHICH_OUTPUT,
      "%ld mutations (%2.1f%%), %ld crossovers (%2.1f%%), "
      "%ld vertices were eliminated\n",
      nmut, (float)nmut*100/(nmut+ncross), ncross,
      (float)ncross*100/(nmut+ncross),nkilled) ;
  else
  {
    fprintf(WHICH_OUTPUT,"%ld vertices were eliminated\n",nkilled) ;
  }

  mris_corrected_final=MRISremoveRippedSurfaceElements(mris_corrected);
  mris_corrected_final->hemisphere = mris->hemisphere ;
  strcpy(mris_corrected_final->fname, mris->fname) ;

  MRISfree(&mris_corrected);
  /* current = orig vertices
     tmp = originial vertices
     orig = smoothed correct vertices = true solution
     canonical = canonical vertices
  */
  return(mris_corrected_final) ;

}


static int mrisMarkAllDefects(MRI_SURFACE *mris, DEFECT_LIST *dl, int flag)
{
  int j ;

  for (j = 0 ; j < dl->ndefects ; j++)
  {
    mrisMarkDefect(mris, &dl->defects[j], flag) ;
  }
  return(NO_ERROR) ;
}

static int mrisRipAllDefects(MRI_SURFACE *mris, DEFECT_LIST *dl, int flag)
{
  int j ;

  for (j = 0 ; j < dl->ndefects ; j++)
  {
    mrisRipDefect(mris, &dl->defects[j], flag) ;
  }
  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Mark all the vertices in the tessellation that are part
  of faces whose centroid intersects other faces. These are
  regions in which the topology is broken as the spherical
  homeomorphism is non-invertible.
  ------------------------------------------------------*/
FACE_DEFECT_LIST *
MRISmarkAmbiguousVertices(MRI_SURFACE *mris, int mark)
{
  FACE   *f ;
  VERTEX *v ;
  int    fno, flist[1000], i, nfaces, nmarked, n /*, vno, neg*/ ;
  double area_scale ;
#if 0
  double r;
#endif
  MHT    *mht ;
  FILE   *fp = NULL ;
  FDL    *fdl ;

  fdl = (FACE_DEFECT_LIST *)calloc(1, sizeof(FDL)) ;
  if (!fdl)
    ErrorExit(ERROR_NO_MEMORY,
              "MRISmarkAmbiguousFaces: could allocate face defect list") ;
  fdl->nfaces = (int *)calloc(mris->nfaces, sizeof(int)) ;
  if (!fdl->nfaces)
    ErrorExit(ERROR_NO_MEMORY,
              "MRISmarkAmbiguousFaces: could allocate face defect list") ;
  fdl->faces = (int **)calloc(mris->nfaces, sizeof(int *)) ;
  if (!fdl->faces)
    ErrorExit(ERROR_NO_MEMORY,
              "MRISmarkAmbiguousFaces: could allocate face defect list") ;
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    char fname[STRLEN] ;
    sprintf(fname, "%s.%s.topology.log",
            mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh",
            mris->subject_name) ;
    fp = fopen(fname, "w") ;
  }

  /* the curvature is for diagnostic purposes so I can write it out */
  MRISclearMarks(mris) ;
  MRISclearCurvature(mris) ;
  mrisMarkBadEdgeVertices(mris, mark) ;


#if 0
  /*
    should not reproject vertices on to sphere
    should not recenter the canonical sphere !
  */
  r = MRISaverageRadius(mris) ;
  MRISscaleBrain(mris, mris, 100.0/r) ;
#endif

  mht = MHTfillTable(mris, NULL) ;

  area_scale = mris->orig_area / mris->total_area ;
  //if (Gdiag & DIAG_SHOW)
  fprintf(WHICH_OUTPUT, "marking ambiguous vertices...\n") ;

  for (nmarked = fno = 0 ; fno < mris->nfaces ; fno++)
  {
    if (Gdiag & DIAG_SHOW && !(fno % 25000) && fno)
      fprintf(WHICH_OUTPUT, "%d of %d faces processed, %d ambiguous\n",
              fno, mris->nfaces-1, nmarked) ;
    f = &mris->faces[fno] ;
    if (fno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (f->ripflag)
    {
      continue ;
    }

    /* only edge-intersection to identify overlapping faces */
    nfaces = mrisFindAllOverlappingFaces(mris, mht, fno, flist) ;

    /* make sure fno is in list, and add it if it isn't (it should be) */
    for (i = 0 ; i < nfaces ; i++)
      if (flist[i] == fno)
      {
        break ;
      }
    if (i >= nfaces)
    {
      if (nfaces == 1000)
      {
        ErrorExit(ERROR_BADPARM, "Too many faces");
      }
      flist[nfaces++] = fno ;
    }
#if 1
    if (nfaces>1)
#else
    if ((nfaces > 1 ||
         area_scale*f->area < 0.001) ||
        ((fno <= 5) && Gdiag & DIAG_SAVE_DIAGS))  /* part of a defect */
#endif
    {
      nmarked++ ;
#if 0
      if (Gdiag & DIAG_SHOW)
        fprintf(WHICH_OUTPUT, "\r%d of %d faces processed, %d ambiguous",
                fno, mris->nfaces-1, nmarked) ;
#endif


      if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      {
        fprintf(WHICH_OUTPUT, "%d faces @ fno %d\n", nfaces, fno) ;
        for (i = 0 ; i < nfaces ; i++)
        {
          f = &mris->faces[flist[i]] ;
          fprintf
          (WHICH_OUTPUT,
           "\tface %d area %2.4f (%d, %d, %d)\n",
           flist[i], f->area, f->v[0], f->v[1], f->v[2]) ;
        }
        fprintf(WHICH_OUTPUT, "\n") ;
      }
      if (Gdiag & DIAG_WRITE && fp != NULL && DIAG_VERBOSE_ON)
      {
        fprintf(fp, "%d faces @ fno %d\n", nfaces, fno) ;
        for (i = 0 ; i < nfaces ; i++)
        {
          f = &mris->faces[flist[i]] ;
          fprintf(fp, "\tface %d area %2.4f (%d, %d, %d)\n",
                  flist[i], f->area, f->v[0], f->v[1], f->v[2]) ;
        }
        fprintf(fp, "\n") ;
        fflush(fp) ;
      }

      fdl->nfaces[fno] = nfaces ;
      fdl->faces[fno] = (int *)calloc(nfaces, sizeof(int)) ;
      if (!fdl->faces[fno])
        ErrorExit
        (ERROR_NO_MEMORY,
         "MRISmarkAmbiguousFaces: could allocate %d defect list",
         fno) ;
      for (i = 0 ; i < nfaces ; i++)
      {
        fdl->faces[fno][i] = flist[i] ;
        f = &mris->faces[flist[i]] ;
        for (n = 0 ; n < VERTICES_PER_FACE ; n++)
        {
          v = &mris->vertices[f->v[n]] ;
          if (f->v[n] == Gdiag_no)
          {
            DiagBreak() ;
          }
          v->marked = mark ;
        }
      }
    }
  }
  //TO BE CHECKED : ... pbm when "#if 1...
#if 0
  /* expand defective vertices outwards by one */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked == mark)
    {
      for (n = 0 ; n < v->vnum ; n++)
      {
        mris->vertices[v->v[n]].marked = mark+1 ;
      }
    }
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked == mark+1)
    {
      v->marked = mark ;
    }
  }
#endif

  if (Gdiag & DIAG_SHOW)
  {
    fprintf(WHICH_OUTPUT, "\n") ;
  }
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON && fp)
  {
    fclose(fp) ;
  }


#if 0
  /* should not reproject vertices on to sphere */
  MRISscaleBrain(mris, mris, r/100.0) ;
#endif

  fprintf(WHICH_OUTPUT,
          "%d ambiguous faces found in tessellation\n", nmarked) ;
  MHTfree(&mht) ;
  return(fdl) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Find all connected components of a defect.
  use undefval,old_undefval, curv and fixedval during segmentation
  into connected components:
  - fixedval is used to mark border vertices
  - curv is used to save the marked flags during divideedge.
  - undefval and old_undefval are used to find the enclosing loop
  ------------------------------------------------------*/
DEFECT_LIST *
MRISsegmentDefects(MRI_SURFACE *mris, int mark_ambiguous, int mark_segmented)
{
  DEFECT_LIST  *dl ;
  int          vno ,nadded ;
  VERTEX       *v ;
  FILE         *fp = NULL ;
  DEFECT *defect;

  dl = (DEFECT_LIST *)calloc(1, sizeof(DEFECT_LIST)) ;
  if (!dl)
    ErrorExit(ERROR_NO_MEMORY,
              "MRISsegmentDefects: could allocate defect list") ;

  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;
    sprintf(fname, "%s.%s.topology.log",
            mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh",
            mris->subject_name) ;
    fp = fopen(fname, "a") ;
  }

#if ADD_EXTRA_VERTICES /* uses fixedval to mark border vertices */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].fixedval=0;
  }
#endif

  for (nadded = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked != mark_ambiguous)
    {
      continue ;
    }
    if (dl->ndefects == Gdiag_no)
    {
      DiagBreak() ;
    }

    defect=&dl->defects[dl->ndefects];
    defect->defect_number=dl->ndefects++;
    //                fprintf(stderr,"DEFECT %d\n",defect->defect_number);

    /* segment defect #defect->defect_number */
    nadded += mrisSegmentDefect
              (mris, vno, defect, mark_ambiguous, mark_segmented) ;

#if FIND_ENCLOSING_LOOP
    /* update the defect so it becomes simply connected */
    mrisSimplyConnectedDefect(mris,defect,mark_ambiguous, mark_segmented);
#endif

    if (Gdiag & DIAG_WRITE && fp)
    {
      int n ;
      DEFECT *defect = &dl->defects[dl->ndefects-1] ;
      fprintf(fp, "defect %d found with %d vertices, area %2.2f\n"
              "\tcentroid (%2.1f,%2.1f,%2.1f)\n",
              dl->ndefects, defect->nvertices, defect->area,
              defect->cx, defect->cy, defect->cz) ;
      for (n = 0 ; n < defect->nvertices ; n++)
      {
        fprintf(fp, "\t%d\n", defect->vertices[n]) ;
      }
    }
  }
  if (nadded)
    fprintf
    (stderr,
     "   total of %d vertices have been added to the surface\n",nadded);
  //if (Gdiag & DIAG_SHOW) fprintf(WHICH_OUTPUT, "\n") ;
  if (Gdiag & DIAG_WRITE && fp)
  {
    fclose(fp) ;
  }
  return(dl) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Segment the connected region of a defect, starting with vno
  and spreading outwards.
  ------------------------------------------------------*/
static int
mrisSegmentDefect
(MRI_SURFACE *mris, int vno, DEFECT *defect,
 int mark_ambiguous, int mark_segmented)
{
  int    vlist[200000], i, j,n, nfilled ,nadded,vno1,m;
  VERTEX *v, *vn,*vadded ;
  float  len, nx, ny, nz ;

  vno1=nadded=m=j=0; /* to avoid compilator warnings */
  vadded=NULL;

  vlist[defect->nvertices++] = vno ;  /* start the list */

  v = &mris->vertices[vno] ;
  v->marked = mark_segmented ;
  defect->cx = v->x ;
  defect->cy = v->y ;
  defect->cz = v->z ;
  defect->area = v->origarea ;

  do
  {
    nfilled = 0 ;

    for (i = 0 ; i < defect->nvertices ; i++)
    {
      v = &mris->vertices[vlist[i]] ;
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        if (v->v[n] == Gdiag_no)
        {
          DiagBreak() ;
        }
        if (vn->marked == mark_ambiguous)
        {
          vlist[defect->nvertices++] = v->v[n] ;  /* add it to list */

          vn->marked = mark_segmented ;
          defect->cx += vn->x ;
          defect->cy += vn->y ;
          defect->cz += vn->z ;
          defect->area += vn->origarea ;
          nfilled++ ;
        }
      }
    }
  }
  while (nfilled > 0) ;

  defect->cx /= (float)defect->nvertices ;
  defect->cy /= (float)defect->nvertices ;
  defect->cz /= (float)defect->nvertices ;
  defect->vertices = (int *)calloc(defect->nvertices, sizeof(int)) ;
  if (!defect->vertices)
    ErrorExit(ERROR_NO_MEMORY,
              "mrisSegmentDefect: could allocate defect vertex list") ;
  defect->status = (char *)calloc(defect->nvertices, sizeof(char)) ;
  if (!defect->status)
    ErrorExit(ERROR_NO_MEMORY,
              "mrisSegmentDefect: could allocate defect status list") ;
  memmove(defect->vertices, vlist, defect->nvertices*sizeof(int)) ;


  /* analyze if some extra vertices should be added to the surface */
#if ADD_EXTRA_VERTICES
  for (nadded = i = 0 ; i < defect->nvertices ; i++)
  {
    v = &mris->vertices[defect->vertices[i]] ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      vno1=v->v[n];
      vn=&mris->vertices[vno1];
      if (vn->marked==0)
      {
        /* border vertex */
        /* check if this border vertex is already part of one defect */
        if (vn->fixedval)
        {
          /* needs to add one extra vertex */
          if (mris->nvertices==mris->max_vertices)
          {
            ErrorExit
            (ERROR_BADPARM,
             "ADD_EXTRA_VERTICES : could not allocate extra vertex\n");
          }
          /* hack to avoid errors : using curv to save marked vertices */
          for (j=0 ; j < mris->nvertices ; j++)
          {
            VERTEX *vj;
            vj = &mris->vertices[j] ;
            vj->curv=vj->marked;
            vj->marked=0;
          }
          mrisDivideEdge(mris,defect->vertices[i], vno1);
          for (j=0 ; j < mris->nvertices-1 ; j++)
          {
            /* reset marks */
            VERTEX *vj;
            vj = &mris->vertices[j] ;
            vj->marked=(int)vj->curv;
          }

          vadded=&mris->vertices[mris->nvertices-1];
          //fprintf(stderr,"adding vertex %d(%d)\n",
          // mris->nvertices-1,vn->fixedval);
          vadded->marked=0; /* border vertex  */
          vadded->fixedval=0;

          /* spherical projection */
          sphericalProjection
          (vadded->cx,vadded->cy,vadded->cz,
           &vadded->cx,&vadded->cy,&vadded->cz);
          vadded->x=vadded->cx;
          vadded->y=vadded->cy;
          vadded->z=vadded->cz;
          nadded++;
        }

      }
    }
  }
  if (nadded)
    fprintf(stderr,
            "   defect %d : %d vertices have been added to the surface\n",
            defect->defect_number,nadded);

#endif

  for (nfilled = i = 0 ; i < defect->nvertices ; i++)
  {
    v = &mris->vertices[defect->vertices[i]] ;
    if (defect->vertices[i] == Gdiag_no)
    {
      DiagBreak() ;
    }
    v->val = defect->area ;
    defect->status[i] = KEEP_VERTEX ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      if (v->v[n] == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (mris->vertices[v->v[n]].marked == 0) /* border vertex */
      {
        mris->vertices[v->v[n]].marked = 2 ;
        vlist[nfilled++] = v->v[n] ;
      }
    }
  }

  defect->border = (int *)calloc(nfilled, sizeof(int)) ;
  defect->nborder = nfilled ;
  memmove(defect->border, vlist, defect->nborder*sizeof(int)) ;
  mrisMarkDefectBorder(mris, defect, 0) ;

  nx = ny = nz = 0.0f ;
  for (n = 0 ; n < defect->nborder ; n++)
  {
    v = &mris->vertices[defect->border[n]] ;
    nx += v->nx ;
    ny += v->ny ;
    nz += v->nz ;
  }
  len = sqrt(nx*nx + ny*ny + nz*nz) ;
  if (FZERO(len))
  {
    len = 1.0f ;
  }
  defect->nx = nx/len ;
  defect->ny = ny/len ;
  defect->nz = nz/len ;
  return(nadded) ;
}
//#if FIND_ENCLOSING_LOOP
/* segment a surface into connected components using undefval to mark
   the different components and avoiding old_undefval */
static int mrisSegmentConnectedComponents(MRIS *mris)
{
  int n,p,vno=0,seed,found;
  int *vlist,nvertices;
  int *next_vlist,next_nvertices,total_vertices,maxn,maxv;
  VERTEX *v,*vp;

  vlist=(int*)malloc(mris->nvertices*sizeof(int));
  next_vlist=(int*)malloc(mris->nvertices*sizeof(int));

  for (n=0; n<mris->nvertices; n++)
  {
    mris->vertices[n].undefval=0;
  }

  seed=1; /* first seed */
  maxv=0;
  maxn=0;
  while (1)
  {
    found=0;
    for (n=0; n<mris->nvertices; n++)
    {
      v=&mris->vertices[n];
      if (v->old_undefval)
      {
        continue;
      }
      if (v->undefval==0)
      {
        v->undefval=seed;
        vno=n;
        found=1;
        break;
      }
    }
    if (found==0)
    {
      break;
    }

    /* grow seed point */
    vlist[0]=vno;
    nvertices=1;
    total_vertices=1;

    while (nvertices)
    {
      for (next_nvertices = n = 0 ; n < nvertices ; n++)
      {
        v = &mris->vertices[vlist[n]] ;

        for (p = 0 ; p < v->vnum ; p++)
        {
          vp = &mris->vertices[v->v[p]] ;
          if (vp->old_undefval)
          {
            continue;
          }
          if (vp->undefval)
          {
            continue;
          }

          /* new point to be added */
          next_vlist[next_nvertices++]=v->v[p];
          vp->undefval=seed;
        }
      }
      nvertices=next_nvertices;
      memmove(vlist,next_vlist,mris->nvertices*sizeof(int));
      total_vertices += nvertices;
    }
    if (maxv < total_vertices)
    {
      maxn=seed;
      maxv=total_vertices;
    }
    //fprintf(stderr,"seed %d has %d vertices \n",seed,total_vertices);

    seed++;
  }
  free(vlist);
  free(next_vlist);

  if (maxn==0)
  {
    ErrorExit
    (ERROR_BADPARM,"0 labels found in mrisSegmentConnectedComponents\n");
  }
  return maxn;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Making sure the defect is simply connected
  region growing method (the largest component is the good one)
  use undefval,old_undefval during the segmentation process
  - old_undefval are forbidden points (borders, inside)
  - undefval are flags for the segmentation into connected components
  ------------------------------------------------------*/
static int mrisSimplyConnectedDefect
(MRI_SURFACE *mris, DEFECT *defect,
 int mark_ambiguous, int mark_segmented)
{
  int n,p,l,label,j,w;
  int nvertices,nedges,inside_face,outside_face;
  int add_vertex,add_edges;
  VERTEX *v,*v1,*v2,*vin,*vout;
  FACE *f;
  EDGE *edges,*edge,*new_edges;
  int added_edges,vno1,vno2,vno_in,vno_out,isedge;
  int *varray,*barray,vnb,bnb;
  float len,dot,cx,cy,cz;
  VECTOR  *v_a, *v_b, *v_n ;

  //fprintf(stderr,"\nDEFECT %d\n",defect->defect_number);
  //fprintf(stderr,"before analysis: %d inside vertices, %d border vertices (total=%d)\n",defect->nvertices,defect->nborder,defect->nvertices+defect->nborder);

  v_a = VectorAlloc(3, MATRIX_REAL) ;
  v_b = VectorAlloc(3, MATRIX_REAL) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;

  /* setting flags to zero */
  for ( n = 0 ; n < mris->nvertices ; n++)
  {
    mris->vertices[n].undefval=0;
    mris->vertices[n].old_undefval=0;
  }

  for (n=0; n<defect->nborder; n++)
  {
    v=&mris->vertices[defect->border[n]];
    v->old_undefval=1; /* forbidden border point */
  }
  for (n=0; n<defect->nvertices; n++)
  {
    v=&mris->vertices[defect->vertices[n]];
    v->old_undefval=1; /* forbidden inside point */
  }

  /* segment the surface into connected components
     label is the largest component */
  label=mrisSegmentConnectedComponents(mris);

  /* everything not label becomes defective (old_undefval=1)*/
  /* first count them */
  vnb=0;
  for (n=0; n<mris->nvertices; n++)
  {
    /* these first vertices are new ones */
    v=&mris->vertices[n];
    if (v->old_undefval)
    {
      continue;
    }
    if (v->undefval!=label)
    {
      vnb++;  /* only counting for now */
    }
  }
  /* allocate the new list of defective vertices
     max size is vnb+defect->nvertices+defect->nborder */
  varray=(int*)malloc((vnb+defect->nvertices+defect->nborder)*sizeof(int));
  /* then add them */
  vnb=0;
  for (n=0; n<mris->nvertices; n++)
  {
    /* this first vertices are new ones */
    v=&mris->vertices[n];
    if (v->old_undefval)
    {
      continue;
    }
    if (v->undefval!=label)
    {
      varray[vnb++]=n;
      v->undefval=1;
    }
    else
    {
      v->undefval=0;
    }
  }

  for (n=0; n<defect->nvertices; n++)
  {
    v=&mris->vertices[defect->vertices[n]];
    v->old_undefval=0;
    v->undefval=1;
  }

  for (n=0; n<defect->nborder; n++)
  {
    /* border vertices become 2 */
    v=&mris->vertices[defect->border[n]];
    v->old_undefval=0;
    v->undefval=2;
  }

  /* max number of edges */
  nedges = defect->nborder*(defect->nborder-1)/2;
  edges=(EDGE*)malloc(nedges*sizeof(EDGE));
  added_edges=0;

  /* now need to find the right border vertices to keep (border = 2)
     right vertices = forms good edge in between inside (1 or 2) and outside 0
     this subtlety is important : the closed loop must be "convexified"
     the right border vertices are marked as 3 */

  for (nvertices = nedges = n = 0 ; n < defect->nborder ; n++)
  {
    v=&mris->vertices[defect->border[n]];
    add_vertex=add_edges=0;
    /* count # of neighbors */
    for ( p = 0 ; p < v->vnum ; p++)
    {
      if (mris->vertices[v->v[p]].undefval==2 ||
          mris->vertices[v->v[p]].undefval==3)
      {
        /* potential edge */
        /* is there an inside and outside triangle in common with this vertex */
        inside_face=0;
        outside_face=0;
        vno_in=vno_out=-1;
        for (l = 0 ; l < v->num ; l++)
        {
          f=&mris->faces[v->f[l]];
          /* check if this face has v->v[p] */
          for (j=0; j<3; j++)
          {
            if (f->v[j]==v->v[p])
            {
              /* check if the last vertex is outside */
              for (w=0; w<3; w++)
              {
                if (mris->vertices[f->v[w]].undefval==0)
                {
                  /* outside */
                  outside_face=1;
                  vno_out=f->v[w];
                  break;
                }
              }
              for (w=0; w<3; w++)
              {
                if (mris->vertices[f->v[w]].undefval==1 /* inside vertex */
                    || ((mris->vertices[f->v[w]].undefval==2 || mris->vertices[f->v[w]].undefval==3) && f->v[w]!=defect->border[n] && f->v[w]!=v->v[p]))
                {
                  /* border vertex */
                  inside_face=1;
                  vno_in=f->v[w];
                  break;
                }
              }
            }
          }
        }
        if (inside_face && outside_face)
        {
          /* good edge -> good vertex */
          add_edges++;
          add_vertex=1;
          v->undefval=3;

          /* vertices constituting the edge to be potentially added */
          vno1=defect->border[n];
          vno2=v->v[p];

          /* check is edge already exists */
          for (isedge=w=0; w<added_edges; w++)
          {
            edge=&edges[w];
            if ((edge->vno1==vno1 && edge->vno2==vno2) ||
                (edge->vno1==vno2 && edge->vno2==vno1))
            {
              isedge=1;
              break;
            }
          }
          if (isedge==0)
          {
            /* add edge to list */
            /* orient edge first */
            v1=&mris->vertices[vno1];
            v2=&mris->vertices[vno2];
            vout=&mris->vertices[vno_out];
            vin=&mris->vertices[vno_in];
            VECTOR_LOAD(v_a,v2->cx-v1->cx,v2->cy-v1->cy,v2->cz-v1->cz);
            VECTOR_LOAD(v_b,vin->cx-vout->cx,vin->cy-vout->cy,vin->cz-vout->cz);
            V3_CROSS_PRODUCT(v_a, v_b, v_n) ;
            cx=v1->cx+v2->cx;
            cy=v1->cy+v2->cy;
            cz=v1->cz+v2->cz;
            dot = cx * V3_X(v_n) + cy * V3_Y(v_n) + cz * V3_Z(v_n);

            if (dot < 0.0f)
            {
              /* not in same direction, reverse vno1, vno2 */
              w=vno1;
              vno1=vno2;
              vno2=w;
            }

            /* add edge */
            edge=&edges[added_edges++];
            edge->vno1=vno1;
            edge->vno2=vno2;
          }
        }
      }
    }
    nedges += add_edges;
    if (add_vertex)
    {
      nvertices++;
    }
  }
  nedges /= 2;

  VectorFree(&v_a);
  VectorFree(&v_b);
  VectorFree(&v_n);

  //    fprintf(stderr,"Defect %d : Euler Number = %d [ %d , %d  ] \n",defect->defect_number,nvertices-nedges,nvertices,nedges);

  if (nvertices-nedges)
  {
    ErrorExit(ERROR_BADPARM,"mrisSimplyConnectedDefect : euler number of loop is not 0!\n");
  }


  /* now update defect */
  /* first list good enclosing edges */
  defect->edges=(EDGE*)malloc(added_edges*sizeof(EDGE));
  defect->nedges=added_edges;
  memmove(defect->edges,edges,added_edges*sizeof(EDGE));
  free(edges);

  /* then keep updating inside and border vertices */
  bnb=0;
  barray=(int*)malloc((defect->nvertices+defect->nborder)*sizeof(int));
  for (n=0; n<defect->nvertices; n++)
  {
    varray[vnb++]=defect->vertices[n];
  }
  for (n=0; n<defect->nborder; n++)
  {
    v=&mris->vertices[defect->border[n]];
    if (v->undefval==3) /* good border vertex */
    {
      barray[bnb++]=defect->border[n];
    }
    else /* becomes inside vertex */
    {
      varray[vnb++]=defect->border[n];
    }
  }
  free(defect->vertices);
  free(defect->status);
  free(defect->border);
  defect->nvertices=vnb;
  defect->vertices=(int*)malloc(vnb*sizeof(int));
  defect->status=(char*)calloc(vnb,sizeof(char));
  memmove(defect->vertices,varray,vnb*sizeof(int));
  defect->nborder=bnb;
  defect->border=(int*)malloc(bnb*sizeof(int));
  memmove(defect->border,barray,bnb*sizeof(int));
  free(varray);
  free(barray);

  /* analyze the closed loop and correctly order the edges */
  {
    int init,final,cur,next;
    int *tab,nb=0;
    tab=(int*)malloc(defect->nedges*sizeof(int));

    new_edges=(EDGE*)malloc(defect->nedges*sizeof(EDGE));

    //fprintf(stderr,"analyze closed loop\n");

    init=defect->edges[0].vno2;
    final=defect->edges[0].vno1;
    /* find other vertex */
    cur=-1;
    for (n=1; n<defect->nedges; n++)
    {
      edge=&defect->edges[n];
      if (edge->vno1==init)
      {
        //fprintf(stderr,"*");
        cur=edge->vno2;
        break;
      }
      if (edge->vno2==init)
      {
        cur=edge->vno1;
        //fprintf(stderr,"!");
        break;
      }
    }
    //          fprintf(stderr,"%d->%d->%d",final,init,cur);
    if (cur<0)
    {
      ErrorExit(ERROR_BADPARM,"mrisSimplyConnectedDefect : initialization of the closed loop\n");
    }
    tab[nb++]=init;
    tab[nb++]=cur;
    add_edges=0;
    new_edges[add_edges].vno1=final;
    new_edges[add_edges++].vno2=init;
    new_edges[add_edges].vno1=init;
    new_edges[add_edges++].vno2=cur;
    while (cur!=final)
    {
      /*find next vertex */
      next=-1;
      for (n=0; n<defect->nedges; n++)
      {
        edge=&defect->edges[n];
        if (edge->vno1==cur && edge->vno2!=init)
        {
          //fprintf(stderr,"*");
          next=edge->vno2;
          break;
        }
        if (edge->vno2==cur && edge->vno1!=init)
        {
          //fprintf(stderr,".");
          next=edge->vno1;
          break;
        }
      }
      //                        fprintf(stderr,"->%d",next);
      if (next<0)
      {
        ErrorExit(ERROR_BADPARM,"mrisSimplyConnectedDefect : propagation of the closed loop\n");
      }
      /* make sure next is not in the loop already */
      for (n=0; n<nb; n++)
      {
        if (tab[n]==next)
        {
          ErrorExit(ERROR_BADPARM,"mrisSimplyConnectedDefect : loop self-intersecting\n");
        }
      }
      tab[nb++]=next;

      init=cur;
      cur=next;
      new_edges[add_edges].vno1=init;
      new_edges[add_edges++].vno2=cur;
    }
    free(tab);

    free(defect->edges);
    defect->edges=new_edges;

    for (n=0; n<defect->nedges; n++)
    {
      edge=&defect->edges[n];
      //fprintf(stderr,"%d->%d:",edge->vno1,edge->vno2);
    }

    //          fprintf(stderr,"loop of %d=%d vertices\n",nb,defect->nborder);
    if (nb!=defect->nborder)
    {
      ErrorExit(ERROR_BADPARM,"mrisSimplyConnectedDefect : loop smaller than border\n");
    }
  }
  //fprintf(stderr,"\n");

  /* now update defect statistics */
  defect->cx=0;
  defect->cy=0;
  defect->cz=0;
  defect->area=0;
  for (n=0; n<defect->nvertices; n++)
  {
    v=&mris->vertices[defect->vertices[n]];
    defect->status[n]=KEEP_VERTEX;
    v->marked=mark_segmented;
    defect->cx += v->x ;
    defect->cy += v->y ;
    defect->cz += v->z ;
    defect->area += v->origarea ;
  }
  defect->cx /= (float)defect->nvertices ;
  defect->cy /= (float)defect->nvertices ;
  defect->cz /= (float)defect->nvertices ;

  defect->nx = defect->ny = defect->nz = 0.0f ;
  for (n = 0 ; n < defect->nborder ; n++)
  {
    v = &mris->vertices[defect->border[n]] ;
    v->marked=0;
    defect->nx += v->nx ;
    defect->ny += v->ny ;
    defect->nz += v->nz ;
  }
  len = sqrt(defect->nx*defect->nx + defect->ny*defect->ny + defect->nz*defect->nz) ;
  if (FZERO(len))
  {
    len = 1.0f ;
  }
  defect->nx /= len ;
  defect->ny /= len ;
  defect->nz /= len ;

  //fprintf(stderr,"after analysis: %d inside vertices, %d border vertices (total=%d)\n",defect->nvertices,defect->nborder,defect->nvertices+defect->nborder);

#if ADD_EXTRA_VERTICES
  /* mark the border vertices */
  for (n = 0 ; n < defect->nborder ; n++)
  {
    v = &mris->vertices[defect->border[n]] ;
    v->fixedval = defect->defect_number+1;
  }
#endif

  return NO_ERROR;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Mark the vertices in a defect as either retained or
  discarded. The decision will be made based on the surface
  area in the defect. If it is above some threshold, then
  fill it by marking the "outside" faces as kept and all others
  as discarded. Otherwise cut it by marking the "inside" face
  as kept and all others as discarded. The inside/outside
  decision will be made by using the dot product of the average
  inflated surface normal with the inflated face centroid.

  By default (genetic search), MRIScorrectTopology will now keep most vertices
  ------------------------------------------------------*/
#define MIN_SPHERE_DIST   .01
#define MIN_ORIG_DIST     .75

#if 1
int
mrisMarkRetainedPartOfDefect
(MRI_SURFACE *mris, DEFECT *defect,
 FACE_DEFECT_LIST *fdl, float area_threshold,
 int mark_retain, int mark_discard, MHT *mht, int mode)
{
#if 0
  int      n, i, j, nfaces, fno, flist[100000], n2, vno, retain;
  FACE     *f ;
  VERTEX   *v, *vn ;
  float    dot, x0, y0, z0, x, y, z, dx, dy, dz, dist, fn, dot0, len ;
#endif

  mrisMarkDefect(mris, defect, 0) ;

  if (!mode)
  {
    mrisDefectRemoveDegenerateVertices(mris, MIN_SPHERE_DIST, defect) ;
    mrisDefectRemoveProximalVertices(mris, MIN_ORIG_DIST, defect) ;
    mrisDefectRemoveNegativeVertices(mris, defect) ;
  }
  else
  {
    int i;
    for (i = 0 ; i < defect->nvertices ; i++)
    {
      defect->status[i]=KEEP_VERTEX;
    }
    mrisDefectRemoveDegenerateVertices(mris, MIN_SPHERE_DIST, defect) ;
  }

#if 0
  /* throw out anything in a negative face */
  for (i = 0 ; i < defect->nvertices ; i++)
  {
    if (defect->status[i] == DISCARD_VERTEX)
    {
      continue ;
    }
    v = &mris->vertices[defect->vertices[i]] ;
    for (n = 0 ; n < v->num ; n++)
      if (mris->faces[v->f[n]].area < 0.05)
      {
        defect->status[i] = DISCARD_VERTEX ;
      }
  }

  /* compute centroid and average normal of defect using border vertices */
  defect->cx = defect->cy = defect->cz = 0.0f ;
  defect->nx = defect->ny = defect->nz = 0.0f ;
  for (fn = 0.0f, i = 0 ; i < defect->nborder ; i++, fn += 1.0f)
  {
    v = &mris->vertices[defect->border[i]] ;
    defect->nx += v->nx ;
    defect->ny += v->ny ;
    defect->nz += v->nz ;
    defect->cx += v->x  ;
    defect->cy += v->y  ;
    defect->cz += v->z ;
  }
  len = sqrt(SQR(defect->nx) + SQR(defect->ny) + SQR(defect->nz)) ;
  defect->nx /= len ;
  defect->ny /= len ;
  defect->nz /= len ;
  defect->cx /= fn  ;
  defect->cy /= fn  ;
  defect->cz /= fn  ;

  /* discard vertices that are too close to another vertex */
  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    float  dx, dy, dz ;

    if (i < defect->nvertices)
    {
      if (defect->status[i] == DISCARD_VERTEX)
      {
        continue ;
      }
      v = &mris->vertices[defect->vertices[i]] ;
    }
    else
    {
      v = &mris->vertices[defect->border[i-defect->nvertices]] ;
    }
    for (j = i+1 ; j < defect->nvertices ; j++)
    {
      if (defect->status[j] == DISCARD_VERTEX)
      {
        continue ;
      }
      vn = &mris->vertices[defect->vertices[j]] ;
      dx = vn->origx-v->origx ;
      dy = vn->origy-v->origy ;
      dz = vn->origz-v->origz ;
      dist = sqrt(dx*dx+dy*dy+dz*dz) ;
      if (dist <= 0.75)
      {
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
          fprintf(WHICH_OUTPUT, "discarding proximal vertex %d\n",
                  defect->vertices[j]);
        defect->status[j] = DISCARD_VERTEX ;
        vn->imag_val = -1.0f ;
      }
    }
  }

  /* build a list of all faces in this defect */
  for (nfaces = n = 0 ; n < defect->nvertices ; n++)
  {
    if (defect->status[n] == DISCARD_VERTEX)
    {
      continue ;
    }

    vno = defect->vertices[n] ;
    v = &mris->vertices[vno] ;

    /* build a list of faces */
    for (n2 = 0 ; n2 < v->num ; n2++)
    {
      if (mris->faces[v->f[n2]].ripflag == 0)
      {
        if (nfaces == 7127)
        {
          DiagBreak() ;
        }
        if (nfaces == 100000)
        {
          ErrorExit(ERROR_BADPARM, "Too many faces");
        }
        flist[nfaces++] = v->f[n2] ;
        mris->faces[v->f[n2]].ripflag = 1 ;  /* temporary */
      }
    }
  }

  /* for really big defects throw out 'inside' vertices */
  for (n = 0 ; n < nfaces ; n++)
  {
    fno = flist[n] ;
    f = &mris->faces[fno] ;
    mrisCalculateFaceCentroid(mris, fno, &x0, &y0, &z0) ;
    dx = x0 - defect->cx ;
    dy = y0 - defect->cy ;
    dz = z0 - defect->cz ;
    dot0 = dx*defect->nx + dy*defect->ny + dz*defect->nz ;

    /* see if there are any faces inside (outside) of this one */
    retain = 1 ;
    for (n2 = 0 ; n2 < fdl->nfaces[fno] ; n2++)
    {
      if (triangleNeighbors(mris, fno, fdl->faces[fno][n2]) >= 1)
      {
        continue ;
      }
      mrisCalculateFaceCentroid(mris, fdl->faces[fno][n2], &x, &y, &z);
      dx = x - defect->cx ;
      dy = y - defect->cy ;
      dz = z - defect->cz ;
      dot = dx*defect->nx + dy*defect->ny + dz*defect->nz ;
#define HUGE_DEFECT 10000
#define BIG_DEFECT   5000
      if ((defect->nvertices > HUGE_DEFECT) && (dot > dot0))
      {
        retain = 0 ;
        break ;   /* found a face outside of this one - discard it */
      }
      if (defect->nvertices > BIG_DEFECT &&
          defect->nvertices < HUGE_DEFECT)
      {
        if (dot < dot0)  /* found a face inside this one - keep it */
        {
          retain = 1 ;
          break ;
        }
        else
        {
          retain =  0 ;
        }
      }
    }
    if (!retain)  /* no faces outside of this one */
    {
      for (n2 = 0 ; n2 < VERTICES_PER_FACE ; n2++)
      {
        if (f->v[n2] == 1245 || f->v[n2] == Gdiag_no)
        {
          DiagBreak() ;
        }
        mris->vertices[f->v[n2]].marked = 1 ;
        mris->vertices[f->v[n2]].imag_val = -1 ;
      }
    }
  }

  /* discard all marked vertices */
  for (i = 0 ; i < defect->nvertices ; i++)
  {
    if (defect->status[i] == DISCARD_VERTEX)
    {
      continue ;
    }
    v = &mris->vertices[defect->vertices[i]] ;
    if (v->marked)
    {
      v->marked = 0 ;
      defect->status[i] = DISCARD_VERTEX ;
    }
  }

  /* unmark the faces */
  for (n = 0 ; n < nfaces ; n++)
  {
    fno = flist[n] ;
    f = &mris->faces[fno] ;
    f->ripflag = 0 ;
  }

  /* discard vertices that are too close to another vertex */
  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    float  dx, dy, dz ;

    if (i < defect->nvertices)
    {
      if (defect->status[i] == DISCARD_VERTEX)
      {
        continue ;
      }
      v = &mris->vertices[defect->vertices[i]] ;
    }
    else
    {
      v = &mris->vertices[defect->border[i-defect->nvertices]] ;
    }
    for (j = i+1 ; j < defect->nvertices ; j++)
    {
      if (defect->status[j] == DISCARD_VERTEX)
      {
        continue ;
      }
      vn = &mris->vertices[defect->vertices[j]] ;
      dx = vn->cx-v->cx ;
      dy = vn->cy-v->cy ;
      dz = vn->cz-v->cz ;
      dist = (dx*dx+dy*dy+dz*dz) ;  /* no sqrt */
      if (dist < MIN_SPHERE_DIST)
      {
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
          fprintf(WHICH_OUTPUT, "discarding proximal vertex %d\n",
                  defect->vertices[j]);
        defect->status[j] = DISCARD_VERTEX ;
        vn->imag_val = -1.0f ;
      }
    }
  }
#endif
  return(NO_ERROR) ;
}
#else
static int
mrisMarkRetainedPartOfDefect(MRI_SURFACE *mris, DEFECT *defect,
                             FACE_DEFECT_LIST *fdl, float area_threshold,
                             int mark_retain, int mark_discard, MHT *mht)
{
#define USING_CUBE 0
#if USING_CUBE || 1
  /* based on faces */
  int     n, n2, inside, vno, flist[100000], nfaces, fno, i, j ;
  VERTEX  *v, *vn ;
  FACE    *f ;
  float   dot, x0, y0, z0, x, y, z, dx, dy, dz, fn, len, dist ;

  defect->cx = defect->cy = defect->cz = 0.0f ;
  inside = defect->area < area_threshold ;
  mrisMarkDefect(mris, defect, 1) ;
  for (fn = 0.0, nfaces = n = 0 ; n < defect->nvertices ; n++)
  {
    vno = defect->vertices[n] ;
    v = &mris->vertices[vno] ;

    /* build a list of faces */
    for (n2 = 0 ; n2 < v->num ; n2++)
    {
      if (mris->faces[v->f[n2]].ripflag == 0)
      {
        if (nfaces == 100000)
        {
          ErrroExit(ERROR_BADPARM, "Too many faces");
        }
        flist[nfaces++] = v->f[n2] ;
        mris->faces[v->f[n2]].ripflag = 1 ;  /* temporary */
      }
    }
    v->val = inside ? -1.0f : 1.0 ;
    v->imag_val = 1.0f ;  /* assume kept until found otherwise */
    defect->cx += v->x ;
    defect->cy += v->y ;
    defect->cz += v->z ;

  }
  defect->nx = defect->ny = defect->nz = 0.0f ;
  for (n = 0 ; n < defect->nborder ; n++)
  {
    vno = defect->border[n] ;
    v = &mris->vertices[vno] ;
    defect->nx += v->nx ;
    defect->ny += v->ny ;
    defect->nz += v->nz ;
  }
  mrisMarkDefect(mris, defect, 0) ;
  len =sqrt(defect->nx*defect->nx+defect->ny*defect->ny+defect->nz*defect->nz);
  if (FZERO(len))
  {
    len = 1.0f ;
  }
  defect->nx /= len ;
  defect->ny /= len ;
  defect->nz /= len ;
  fn = (float)defect->nvertices ;
  defect->cx /= fn ;
  defect->cy /= fn ;
  defect->cz /= fn ;

  /* unrip the faces (used really as a mark, but don't want to add to
  face struct).
  */
  for (n = 0 ; n < defect->nvertices ; n++)
  {
    v = &mris->vertices[defect->vertices[n]] ;

    for (n2 = 0 ; n2 < v->num ; n2++)
    {
      mris->faces[v->f[n2]].ripflag = 0 ;
    }
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(WHICH_OUTPUT, "%d faces found in defect\n", nfaces) ;
  }
#if USING_CUBE
  for (n = 0 ; n < nfaces ; n++)
  {
    fno = flist[n] ;
    f = &mris->faces[fno] ;
    mrisCalculateFaceCentroid(mris, fno, &x0, &y0, &z0) ;

    /* see if there are any faces inside (outside) of this one */
    for (dot = 0.0f, n2 = 0 ; n2 < fdl->nfaces[fno] ; n2++)
    {
      if (triangleNeighbors(mris, fno, fdl->faces[fno][n2]) >= 1)
      {
        continue ;
      }
      mrisCalculateFaceCentroid(mris, fdl->faces[fno][n2], &x, &y, &z);
      dx = -15.5 - x ;
      dot = dx*dx ;
      if (dot < ((-15.5-x0)*(-15.5-x0)))
      {
        break ;
      }
    }
    if (n2 < fdl->nfaces[fno])  /* found a face inside
      (outside) of this one */
    {
      for (n2 = 0 ; n2 < VERTICES_PER_FACE ; n2++)
      {
        if (f->v[n2] == 1245 || f->v[n2] == Gdiag_no)
        {
          DiagBreak() ;
        }
        mris->vertices[f->v[n2]].marked = 1 ;
        mris->vertices[f->v[n2]].imag_val = -1 ;
      }
    }
  }
#else
  for (n = 0 ; n < nfaces ; n++)
  {
    fno = flist[n] ;
    f = &mris->faces[fno] ;
    mrisCalculateFaceCentroid(mris, fno, &x0, &y0, &z0) ;

    /* see if there are any faces inside (outside) of this one */
    for (dot = 0.0f, n2 = 0 ; n2 < fdl->nfaces[fno] ; n2++)
    {
      if (triangleNeighbors(mris, fno, fdl->faces[fno][n2]) >= 1)
      {
        continue ;
      }
      mrisCalculateFaceCentroid(mris, fdl->faces[fno][n2], &x, &y, &z);
      dx = x - x0 ;
      dy = y - y0 ;
      dz = z - z0 ;
      dot = dx*defect->nx + dy*defect->ny + dz*defect->nz ;
      if ((inside && dot < 0) || (!inside && dot > 0))
      {
        break ;
      }
    }
    if (n2 < fdl->nfaces[fno])  /* found a face inside
    (outside) of this one */
    {
      for (n2 = 0 ; n2 < VERTICES_PER_FACE ; n2++)
      {
        if (f->v[n2] == 1245 || f->v[n2] == Gdiag_no)
        {
          DiagBreak() ;
        }
        mris->vertices[f->v[n2]].marked = 1 ;
        mris->vertices[f->v[n2]].imag_val = -1 ;
      }
    }
  }
#endif
  for (n = 0 ; n < defect->nvertices ; n++)
  {
    vno = defect->vertices[n] ;
    v = &mris->vertices[vno] ;
    defect->status[n] = v->marked ? DISCARD_VERTEX : KEEP_VERTEX ;
  }
  mrisMarkDefect(mris, defect, 0) ;
#else
  int     n, n2, inside, vno ;
  VERTEX  *v, *v2 ;
  float   fn, len ;

  defect->cx=defect->cy=defect->cz=defect->nx=defect->ny=defect->nz = 0.0 ;
  inside = defect->area < area_threshold ;
  mrisMarkDefect(mris, defect, 1) ;
  for (fn = 0.0, n = 0 ; n < defect->nvertices ; n++)
  {
    vno = defect->vertices[n] ;
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (inside)
    {
      v->val = -1.0f ;
    }
    else
    {
      v->val = 1.0f ;
    }
    defect->cx += v->x ;
    defect->cy += v->y ;
    defect->cz += v->z ;

    /* use surrounding unmarked vertices as estimate of local normal */
    for (n2 = 0 ; n2 < v->vnum ; n2++)
    {
      v2 = &mris->vertices[v->v[n2]] ;
      if (!v2->marked)
      {
        defect->nx += v2->nx ;
        defect->ny += v2->ny ;
        defect->nz += v2->nz ;
        fn += 1.0 ;
      }
    }
  }
  mrisMarkDefect(mris, defect, 0) ;
  defect->nx /= fn ;
  defect->ny /= fn ;
  defect->nz /= fn ;
  len =sqrt(defect->nx*defect->nx+defect->ny*defect->ny+defect->nz*defect->nz);
  if (FZERO(len))
  {
    len = 1.0f ;
  }
  defect->nx /= len ;
  defect->ny /= len ;
  defect->nz /= len ;
  fn = (float)defect->nvertices ;
  defect->cx /= fn ;
  defect->cy /= fn ;
  defect->cz /= fn ;

  for (n = 0 ; n < defect->nvertices ; n++)  /* for each vertex in defect */
  {
    vno = defect->vertices[n] ;
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    defect->status[n] = KEEP_VERTEX ;
    v->imag_val = 1.0 ;
    v->nx = defect->nx ;
    v->ny = defect->ny ;
    v->nz = defect->nz ;
    if (inside)
    {
      if (mrisFindNextInwardFace(mris, mht, vno, 20.0f) >= 0)
      {
        defect->status[n] = DISCARD_VERTEX ;
        defect->status[n] = KEEP_VERTEX ;
        v->imag_val = -1.0 ;
      }
    }
    else
    {
      if (mrisFindNextOutwardFace(mris, mht, vno, 20.0f) >= 0)
      {
        defect->status[n] = DISCARD_VERTEX ;
        v->imag_val = -1.0 ;
      }
    }
  }
#endif

  /* throw out anything in a negative face */
  for (i = 0 ; i < defect->nvertices ; i++)
  {
    if (defect->status[i] == DISCARD_VERTEX)
    {
      continue ;
    }
    v = &mris->vertices[defect->vertices[i]] ;
    for (n = 0 ; n < v->num ; n++)
      if (mris->faces[v->f[n]].area < 0)
      {
        defect->status[i] = DISCARD_VERTEX ;
      }
  }

  /* discard vertices that are too close to another vertex */
  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    float  dx, dy, dz ;

    if (i < defect->nvertices)
    {
      if (defect->status[i] == DISCARD_VERTEX)
      {
        continue ;
      }
      v = &mris->vertices[defect->vertices[i]] ;
    }
    else
    {
      v = &mris->vertices[defect->border[i-defect->nvertices]] ;
    }
    for (j = i+1 ; j < defect->nvertices ; j++)
    {
      if (defect->status[j] == DISCARD_VERTEX)
      {
        continue ;
      }
      vn = &mris->vertices[defect->vertices[j]] ;
      dx = vn->origx-v->origx ;
      dy = vn->origy-v->origy ;
      dz = vn->origz-v->origz ;
      dist = sqrt(dx*dx+dy*dy+dz*dz) ;
      if (dist <= 0.5)
      {
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
          fprintf(WHICH_OUTPUT, "discarding proximal vertex %d\n",
                  defect->vertices[j]);
        defect->status[j] = DISCARD_VERTEX ;
        vn->imag_val = -1.0f ;
      }
    }
  }
  /* discard vertices that are too close to another vertex on sphere */
  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    float  dx, dy, dz ;

    if (i < defect->nvertices)
    {
      if (defect->status[i] == DISCARD_VERTEX)
      {
        continue ;
      }
      v = &mris->vertices[defect->vertices[i]] ;
    }
    else
    {
      v = &mris->vertices[defect->border[i-defect->nvertices]] ;
    }
    for (j = i+1 ; j < defect->nvertices ; j++)
    {
      if (defect->status[j] == DISCARD_VERTEX)
      {
        continue ;
      }
      vn = &mris->vertices[defect->vertices[j]] ;
      dx = vn->cx-v->cx ;
      dy = vn->cy-v->cy ;
      dz = vn->cz-v->cz ;
      dist = (dx*dx+dy*dy+dz*dz) ;  /* no sqrt */
      if (dist < MIN_SPHERE_DIST)
      {
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
          fprintf(WHICH_OUTPUT, "discarding proximal vertex %d\n",
                  defect->vertices[j]);
        defect->status[j] = DISCARD_VERTEX ;
        vn->imag_val = -1.0f ;
      }
    }
  }
  return(NO_ERROR) ;
}
#endif
#if 0

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Is vno a vertex of face fno?
  ------------------------------------------------------*/
static int
vertexInFace(MRI_SURFACE *mris, int vno, int fno)
{
  VERTEX   *v ;
  int      n ;

  v = &mris->vertices[vno] ;
  for (n = 0 ; n < v->num ; n++)
    if (v->f[n] == fno)
    {
      return(1) ;
    }
  return(0) ;
}
#endif
static int
mrisRipDefect(MRI_SURFACE *mris, DEFECT *defect, int ripflag)
{
  int   n ;

  for (n = 0 ; n < defect->nvertices ; n++)
  {
    mris->vertices[defect->vertices[n]].ripflag = ripflag ;
  }

  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Mark all the vertices in the given defect.
  ------------------------------------------------------*/
static int
mrisMarkDefect(MRI_SURFACE *mris, DEFECT *defect, int mark)
{
  int   n ;

  for (n = 0 ; n < defect->nvertices ; n++)
  {
    mris->vertices[defect->vertices[n]].marked = mark ;
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Mark all the border vertices in the given defect.
  ------------------------------------------------------*/
static int
mrisMarkDefectConvexHull(MRI_SURFACE *mris, DEFECT *defect, int mark)
{
  int   n ;

  for (n = 0 ; n < defect->nchull ; n++)
  {
    mris->vertices[defect->chull[n]].marked = mark ;
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Mark all the border vertices in the given defect.
  ------------------------------------------------------*/
static int
mrisMarkDefectBorder(MRI_SURFACE *mris, DEFECT *defect,int mark)
{
  int   n ;

  for (n = 0 ; n < defect->nborder ; n++)
  {
    mris->vertices[defect->border[n]].marked = mark ;
  }

  return(NO_ERROR) ;
}
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Scale the surface so that it's max dimension has length maxr
  ------------------------------------------------------*/
static int
mrisScaleMaxDimension(MRI_SURFACE *mris, float maxr)
{
  maxr /= 2.0 ;
  mrisComputeSurfaceDimensions(mris) ;
  if (mris->xhi >= maxr)
  {
    MRISscaleBrain(mris, mris, maxr / mris->xhi) ;
  }
  if (mris->yhi >= maxr)
  {
    MRISscaleBrain(mris, mris, maxr / mris->yhi) ;
  }
  if (mris->yhi >= maxr)
  {
    MRISscaleBrain(mris, mris, maxr / mris->yhi) ;
  }
  if (fabs(mris->xlo) >= maxr)
  {
    MRISscaleBrain(mris, mris, maxr / fabs(mris->xlo)) ;
  }
  if (fabs(mris->ylo) >= maxr)
  {
    MRISscaleBrain(mris, mris, maxr / fabs(mris->ylo)) ;
  }
  if (fabs(mris->zlo) >= maxr)
  {
    MRISscaleBrain(mris, mris, maxr / fabs(mris->zlo)) ;
  }
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  See if any of the vertices in a triangle are marked
  ------------------------------------------------------*/
static int
triangleMarked(MRI_SURFACE *mris, int fno)
{
  int  n ;
  FACE *f ;

  f = &mris->faces[fno] ;
  for (n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    if (mris->vertices[f->v[n]].marked != 0)
    {
      return(1) ;
    }
  }
  return(0) ;
}
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Return count of # of vertices shared by 2 triangles
  ------------------------------------------------------*/
static int
triangleNeighbors(MRI_SURFACE *mris, int fno1, int fno2)
{
  int  n1, n2, num ;
  FACE *f1, *f2 ;

  f1 = &mris->faces[fno1] ;
  f2 = &mris->faces[fno2] ;
  for (num = n1 = 0 ; n1 < VERTICES_PER_FACE ; n1++)
  {
    for (n2 = 0 ; n2 < VERTICES_PER_FACE ; n2++)
      if (f1->v[n1] == f2->v[n2])
      {
        num++ ;
      }
  }
  return(num) ;
}
#endif


#define NOT_PROCESSED_YET 1000
#define NPY NOT_PROCESSED_YET

//////////////////////////////////////////////////////////////
// Find inside and outside voxels of a surface mris
//////////////////////////////////////////////////////////////
MRI *MRISbinarizeVolume
(MRI_SURFACE *mris, MRI_REGION *region,
 float resolution, float distance_from_surface)
{
  int k,i,j,p,width,height,depth;
  float x0,x1,x2,y0,y1,y2,z0,z1,z2;
  float x,y,z;

  int fno,fn1;
  int delta;
  FACE *face;
  int imin,imax,jmin,jmax,kmin,kmax;
  float distance,sign;
  float n_f[3],n_e0[3],n_e1[3],n_e2[3],n_v0[3],n_v1[3],n_v2[3];
  float vec[3],vec0[3],vec1[3],vec2[3],e0[3],e1[3],e2[3],n0[3],n1[3],n2[3];
  float val,valu,val0,val1,val2;
  MRI *mri_distance;

  /* resolution*/
  if ( resolution < 1.0f )
  {
    resolution=1.0f;
  }
  /* distance */
  if ( distance_from_surface < 2.0f )
  {
    distance_from_surface=2.0f;
  }
  /* look at approximately +/- dist mm */
  delta=(int)(distance_from_surface/resolution);
  if (delta < 2 )
  {
    delta=2;
  }


  //find the region of interest in this coordinate system

  /* allocate the volume */
  width  = ceil(resolution*(region->dx)) ;
  height = ceil(resolution*(region->dy)) ;
  depth  = ceil(resolution*(region->dz)) ;
  mri_distance=MRIalloc(width,height,depth,MRI_FLOAT);

  fprintf(WHICH_OUTPUT,"mri volume size : %d by %d by %d (resolution = %d)\n",width,height,depth,(int)resolution);

  mri_distance->xstart=region->x;
  mri_distance->xsize=resolution;

  mri_distance->ystart=region->y;
  mri_distance->ysize=resolution;

  mri_distance->zstart=region->z;
  mri_distance->zsize=resolution;

  /* optimize by listing the concerned faces */

  for (k=0; k<mri_distance->depth; k++)
    for (j=0; j<mri_distance->height; j++)
      for (i=0; i<mri_distance->width; i++)
      {
        MRIFvox(mri_distance,i,j,k)=NPY;
      }

  for ( p = 0 ; p < mris->nfaces ; p++)
  {
    computeDefectFaceNormal(mris,&mris->faces[p]);
  }

  /* find the distance to each surface voxels */
  for ( p = 0 ; p < mris->nfaces ; p++)
  {
    fno=p;//tp->faces[p];
    face=&mris->faces[fno];

    // calculate three vertices
    x0 =mris->vertices[face->v[0]].x;
    y0 =mris->vertices[face->v[0]].y;
    z0 =mris->vertices[face->v[0]].z;
    x1 =mris->vertices[face->v[1]].x;
    y1 =mris->vertices[face->v[1]].y;
    z1 =mris->vertices[face->v[1]].z;
    x2 =mris->vertices[face->v[2]].x;
    y2 =mris->vertices[face->v[2]].y;
    z2 =mris->vertices[face->v[2]].z;

    /* find the bounding box */
    imin=iVOL(mri_distance,MIN3(x0,x1,x2))-delta;
    imax=iVOL(mri_distance,MAX3(x0,x1,x2))+delta;

    jmin=jVOL(mri_distance,MIN3(y0,y1,y2))-delta;
    jmax=jVOL(mri_distance,MAX3(y0,y1,y2))+delta;

    kmin=kVOL(mri_distance,MIN3(z0,z1,z2))-delta;
    kmax=kVOL(mri_distance,MAX3(z0,z1,z2))+delta;

#if 0
    /* we don't count faces that are outside the volume - should not change the sign */ //TO BE CHECKED it some defects are close from each other!
    if (imin > mri_distance->width-1 || jmin > mri_distance->height-1 || kmin > mri_distance->depth-1 || imax < 0 || jmax < 0 || kmax < 0)
    {
      continue;
    }
#endif

    imin=MAX(imin,0);
    imax=MIN(imax,mri_distance->width-1);

    jmin=MAX(jmin,0);
    jmax=MIN(jmax,mri_distance->height-1);

    kmin=MAX(kmin,0);
    kmax=MIN(kmax,mri_distance->depth-1);

    /* generating the pseudo-normals for edges and vertices */
    n_f[0]=face->nx;
    n_f[1]=face->ny;
    n_f[2]=face->nz;

    /* edge0: x0 <--> x1 */
    e0[0]=x1-x0;
    e0[1]=y1-y0;
    e0[2]=z1-z0;
    F_CROSS(n_f,e0,n0);
    fn1=findOtherEdgeFace(mris,fno,face->v[0],face->v[1]);
    n_e0[0]=face->nx+mris->faces[fn1].nx;
    n_e0[1]=face->ny+mris->faces[fn1].ny;
    n_e0[2]=face->nz+mris->faces[fn1].nz;

    /* edge1: x1 <--> x2 */
    e1[0]=x2-x1;
    e1[1]=y2-y1;
    e1[2]=z2-z1;
    F_CROSS(n_f,e1,n1);
    fn1=findOtherEdgeFace(mris,fno,face->v[1],face->v[2]);
    n_e1[0]=face->nx+mris->faces[fn1].nx;
    n_e1[1]=face->ny+mris->faces[fn1].ny;
    n_e1[2]=face->nz+mris->faces[fn1].nz;

    /* edge2: x2 <--> x0 */
    e2[0]=x0-x2;
    e2[1]=y0-y2;
    e2[2]=z0-z2;
    F_CROSS(n_f,e2,n2);
    fn1=findOtherEdgeFace(mris,fno,face->v[2],face->v[0]);
    n_e2[0]=face->nx+mris->faces[fn1].nx;
    n_e2[1]=face->ny+mris->faces[fn1].ny;
    n_e2[2]=face->nz+mris->faces[fn1].nz;

    /* vertex pseudo-normals */
    computeVertexPseudoNormal(mris,face->v[0],n_v0,0);
    computeVertexPseudoNormal(mris,face->v[1],n_v1,0);
    computeVertexPseudoNormal(mris,face->v[2],n_v2,0);

    /* finding distance to surface */
#if 1
    for ( k = kmin ; k <= kmax ;  k++ )
      for ( j = jmin ; j <= jmax ; j++ )
        for ( i = imin ; i <= imax ; i++ )
#else
    for ( k = 0 ; k <= mri_distance->depth-1 ;  k++ )
      for ( j = 0 ; j <=  mri_distance->height-1; j++ )
        for ( i = 0 ; i <=  mri_distance->width-1; i++ )
#endif
        {
          x=xSURF(mri_distance,i);
          y=ySURF(mri_distance,j);
          z=zSURF(mri_distance,k);

          vec0[0]=x-x0;
          vec0[1]=y-y0;
          vec0[2]=z-z0;
          vec1[0]=x-x1;
          vec1[1]=y-y1;
          vec1[2]=z-z1;
          vec2[0]=x-x2;
          vec2[1]=y-y2;
          vec2[2]=z-z2;
          vec[0]=(vec0[0]+vec1[0]+vec2[0])/3.0;
          vec[1]=(vec0[1]+vec1[1]+vec2[1])/3.0;
          vec[2]=(vec0[2]+vec1[2]+vec2[2])/3.0;

          /* compute distance to face */
          /* where is the point */
          val0=F_DOT(vec0,n0);
          val1=F_DOT(vec1,n1);
          val2=F_DOT(vec2,n2);

          if ((val0>=0) && (val1>=0) && (val2>=0))
          {
            /* the projection of the vertex is inside */
            val=F_DOT(n_f,vec);
            valu=1;
            sign=val;
            distance=val; /* n_f is already normalized */
          }
          else
          {
            distance=NPY;
            sign=0;
            valu=0;

            if (val0<=0)
            {
              /* compute distance to edge0 */
              val=F_DOT(vec0,e0);
              if (val<0)
              {
                /* closer to x0 */
                sign=F_DOT(n_v0,vec0);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec0));
              }
              else if (val<SQR3(e0))
              {
                /* closer to edge0 */
                sign=F_DOT(n_e0,vec0);
                valu=3;
                distance=SIGN(sign)*MIN(fabs(distance),sqrt(MAX(0,SQR3(vec0)-SQR(val)/SQR3(e0))));
              }
              else
              {
                /* closer to x1 */
                sign=F_DOT(n_v1,vec1);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec1));
              }
            };
            if (val1<=0)
            {
              val=F_DOT(vec1,e1);
              if (val<0)
              {
                /* closer to x1 */
                sign=F_DOT(n_v1,vec1);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec1));
              }
              else if (val<SQR3(e1))
              {
                /* closer to edge1 */
                sign=F_DOT(n_e1,vec1);
                valu=3;
                distance=SIGN(sign)*MIN(fabs(distance),sqrt(MAX(0,SQR3(vec1)-SQR(val)/SQR3(e1))));
              }
              else
              {
                /* closer to x2 */
                sign=F_DOT(n_v2,vec2);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec2));
              }
            };
            if (val2<=0)
            {
              val=F_DOT(vec2,e2);
              if (val<0)
              {
                /* closer to x2 */
                sign=F_DOT(n_v2,vec2);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec2));
              }
              else if (val<SQR3(e2))
              {
                /* closer to edge2 */
                sign=F_DOT(n_e2,vec2);
                valu=3;
                distance=SIGN(sign)*MIN(fabs(distance),sqrt(MAX(0,SQR3(vec2)-SQR(val)/SQR3(e2))));
              }
              else
              {
                /* closer to x0 */
                sign=F_DOT(n_v0,vec0);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec0));
              }
            };
          }

          /* update distance map */
          if (fabs(distance)<fabs(MRIFvox(mri_distance,i,j,k)))
          {
            MRIFvox(mri_distance,i,j,k)=distance;

          }
        }
  }

#if 0 //debugging
  for ( p = 0 ; p < mris->nvertices ; p++)
  {
    VERTEX *v;
    v=&mris->vertices[p];

    v->x=iVOL(mri_distance,v->x);
    v->y=jVOL(mri_distance,v->y);
    v->z=kVOL(mri_distance,v->z);
  }
#endif

  return mri_distance;
}



/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Tessellate a defect using the spherical space to compute
  edge intersection, and the original space to compute edge length.
  ------------------------------------------------------*/
static int defect_no = 0 ;

static int compare_edge_length(const void *pe1, const void *pe2) ;
static int edgeExists(MRI_SURFACE *mris, int vno1, int vno2) ;

static int
edgeExists(MRI_SURFACE *mris, int vno1, int vno2)
{
  int    n ;
  VERTEX *v ;

  v = &mris->vertices[vno1] ;
  for (n = 0 ; n < v->vnum ; n++)
    if (v->v[n] == vno2)
    {
      return(1) ;
    }
  return(0) ;
}

#if MATRIX_ALLOCATION
#ifndef V4_LOAD
#define V4_LOAD(v, x, y, z, r)  (VECTOR_ELT(v,1)=x, VECTOR_ELT(v,2)=y,  \
                                 VECTOR_ELT(v,3)=z, VECTOR_ELT(v,4)=r) ;
#endif

int mriSurfaceRASToVoxel(double xr, double yr, double zr,
                         double *xv, double *yv, double *zv)
{

  VECTOR *sr, *vv;

  sr = VectorAlloc(4, MATRIX_REAL);

  V4_LOAD(sr, xr, yr, zr, 1.);

  vv = MatrixMultiply(VoxelFromSRASmatrix, sr, NULL);

  *xv = V3_X(vv);
  *yv = V3_Y(vv);
  *zv = V3_Z(vv);

  VectorFree(&sr);
  VectorFree(&vv);

  return (NO_ERROR);
}

#endif

static float
mrisDefectFaceMRILogLikelihood
(MRI_SURFACE *mris, MRI *mri, TP *tp, HISTOGRAM *h_white,
 HISTOGRAM *h_gray, HISTOGRAM *h_grad, MRI *mri_gray_white)
{
  int n,vno0,vno1,vno2;
  double x,y,z,nx,ny,nz,xv,yv,zv,white_val,gray_val,val;
  double int_w,int_g;
  double fll,t_area,tf_area;
  FACE *face;
  VERTEX *v0, *v1, *v2 ;

#if 1

  t_area = tf_area=0.0;

  fll = 0.0;
  int_w = int_g = 0.0;
  for (n = 0 ; n < tp->nfaces ; n++)
  {
    face=&mris->faces[tp->faces[n]];

    vno0=face->v[0];
    vno1=face->v[1];
    vno2=face->v[2];

    v0 = &mris->vertices[vno0] ;
    v1 = &mris->vertices[vno1] ;
    v2 = &mris->vertices[vno2] ;

    /* find face centroid */
    x=(v0->origx+v1->origx+v2->origx)/3.0f;
    y=(v0->origy+v1->origy+v2->origy)/3.0f;
    z=(v0->origz+v1->origz+v2->origz)/3.0f;

    /* face normal */
    nx=face->nx;
    ny=face->ny;
    nz=face->nz;

#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &white_val) ;

    int_w += white_val;

#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;

    int_g += gray_val;

    MRIsampleVolume(mri_gray_white, white_val, gray_val, 0, &val) ;
    fll += log(val) ;

    t_area += face->area;
    tf_area += log(val)*face->area;

  }

  if (tp->nfaces)
  {
    tp->face_ll=(float)fll/(float)tp->nfaces;
    tp->fll = tf_area / t_area;
    int_w /= (double)tp->nfaces;
    int_g /= (double)tp->nfaces;
    // fs_topo_fixer_test
    //  fprintf(stderr,"face : gray = %f and white = %f\n",int_g,int_w);
  }
  else
  {
    tp->fll = 0.0;
    tp->face_ll=0.0;
  }

  return tp->face_ll;

#else
  double x,y z, xa, ya, za, xc, yc, zc, t0, t1, adx, ady, adz, dx, dy, dz, grad,
         cdx, cdy, cdz, alen, clen, delta_t0, delta_t1, len, nx, ny, nz, xv, yv, zv,
         white_val, gray_val, cnx, cny, cnz, dot, val ;
  double ll = 0.0, jll = 0.0 ;

  adx = v1->x - v0->x ;
  ady = v1->y - v0->y ;
  adz = v1->z - v0->z ;
  alen = sqrt(SQR(adx)+SQR(ady)+SQR(adz)) ;
  cdx = v2->x - v0->x ;
  cdy = v2->y - v0->y ;
  cdz = v2->z - v0->z ;
  clen = sqrt(SQR(cdx)+SQR(cdy)+SQR(cdz)) ;

  /*
  sample along legs of the triangle making sure the maximum spacing
  between samples (along the longer leg) is SAMPLE_DIST.
  */

  /*
  move along v0->v1 and v3->v2 lines and draw in crossing line to fill face
  t0 parameterizes lines from v0->v1 and v0->v2
  */
  if (FZERO(alen) && FZERO(clen))
  {
    delta_t0 = 0.99 ;
  }
  else
  {
    delta_t0 = (alen > clen) ? (SAMPLE_DIST / alen) : (SAMPLE_DIST / clen ) ;
  }
  if (FZERO(delta_t0))
    ErrorReturn
    (ERROR_BADPARM,
     (ERROR_BADPARM,
      "mrisDefectFaceMRILogLikelihood: face has infinite leg (%d, %d)\n",
      alen, clen)) ;

  if (delta_t0 >= 1.0)
  {
    delta_t0 = 0.99 ;
  }

  /* delta_t0 is % of alen or clen (whichever is bigger) of SAMPLE_DIST */
  for (nsamples = 0, ll = 0.0f, t0 = 0 ; t0 <= 1.0f ; t0 += delta_t0)
  {
    /* compute points (xa,ya,za) and (xc,yc,zc) on the a and c lines resp. */
    xa = v0->x + t0*adx ;
    ya = v0->y + t0*ady ;
    za = v0->z + t0*adz ;
    xc = v0->x + t0*cdx ;
    yc = v0->y + t0*cdy ;
    zc = v0->z + t0*cdz ;
    dx = xc-xa ;
    dy = yc-ya ;
    dz = zc-za ;
    len = sqrt(SQR(dx)+SQR(dy)+SQR(dz)) ;
    if (FZERO(len))
    {
      delta_t1 = 0.99 ;
    }
    else
    {
      delta_t1 = SAMPLE_DIST / len ;  /* sample at SAMPLE_DIST intervals */
      if (delta_t1 >= 1.0f)
      {
        delta_t1 = 0.99 ;
      }
    }

    /* now draw a line from (xa,ya,za) to (xc, yc, zc) */
    for (t1 = 0 ; t1 <= 1.0f ; t1 += delta_t1, nsamples++)
    {
      /* compute a point on the line connecting a and c */
      x = xa + t1*dx ;
      y = ya + t1*dy ;
      z = za + t1*dz ;
      // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif

      MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;
      ll += log(h_gray->counts[nint(gray_val)]) ;
      // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &white_val) ;
      ll += log(h_white->counts[nint(white_val)]) ;
      grad = white_val - gray_val ;
      bin = nint((grad-h_grad->bins[0]) / h_grad->bin_size) ;
      if (bin < 0)
      {
        bin = 0 ;
      }
      else if (bin >= h_grad->nbins)
      {
        bin = h_grad->nbins-1 ;
      }
      ll += log(h_grad->counts[bin]) ;
      MRIsampleVolume(mri_gray_white, white_val, gray_val, 0, &val) ;
      jll += log(val) ;
    }
    /* compute last point on line */
    t1 = 1.0f ;
    x = xa + t1*dx ;
    y = ya + t1*dy ;
    z = za + t1*dz ;
    // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;
    ll += log(h_gray->counts[nint(gray_val)]) ;
    // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &white_val) ;
    ll += log(h_white->counts[nint(white_val)]) ;
    grad = white_val - gray_val ;
    bin = nint((grad-h_grad->bins[0]) / h_grad->bin_size) ;
    if (bin < 0)
    {
      bin = 0 ;
    }
    else if (bin >= h_grad->nbins)
    {
      bin = h_grad->nbins-1 ;
    }
    ll += log(h_grad->counts[bin]) ;
    nsamples++ ;
    MRIsampleVolume(mri_gray_white, white_val, gray_val, 0, &val) ;
    jll += log(val) ;
  }

  /* compute last line on the a and c lines resp. */
  t0 = 1.0f ;
  xa = v0->x + t0*adx ;
  ya = v0->y + t0*ady ;
  za = v0->z + t0*adz ;
  xc = v0->x + t0*cdx ;
  yc = v0->y + t0*cdy ;
  zc = v0->z + t0*cdz ;
  dx = xc-xa ;
  dy = yc-ya ;
  dz = zc-za ;
  len = sqrt(SQR(dx)+SQR(dy)+SQR(dz)) ;
  if (FZERO(len))
  {
    delta_t1 = 0.99 ;
  }
  else
  {
    delta_t1 = SAMPLE_DIST / len ;  /* sample at SAMPLE_DIST intervals */
    if (delta_t1 >= 1.0f)
    {
      delta_t1 = 0.99 ;
    }
  }

  /* now draw a line from (xa,ya,za) to (xc, yc, zc) */
  for (t1 = 0 ; t1 <= 1.0f ; t1 += delta_t1, nsamples++)
  {
    /* compute a point on the line connecting a and c */
    x = xa + t1*dx ;
    y = ya + t1*dy ;
    z = za + t1*dz ;
    // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;
    ll += log(h_gray->counts[nint(gray_val)]) ;
    // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &white_val) ;
    ll += log(h_white->counts[nint(white_val)]) ;
    grad = white_val - gray_val ;
    bin = nint((grad-h_grad->bins[0]) / h_grad->bin_size) ;
    if (bin < 0)
    {
      bin = 0 ;
    }
    else if (bin >= h_grad->nbins)
    {
      bin = h_grad->nbins-1 ;
    }
    ll += log(h_grad->counts[bin]) ;
    MRIsampleVolume(mri_gray_white, white_val, gray_val, 0, &val) ;
    jll += log(val) ;
  }
  /* compute last point on line */
  t1 = 1.0f ;
  x = xa + t1*dx ;
  y = ya + t1*dy ;
  z = za + t1*dz ;
  // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
  mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
  MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
  MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;
  ll += log(h_gray->counts[nint(gray_val)]) ;
  // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
  mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
  MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
  MRIsampleVolume(mri, xv, yv, zv, &white_val) ;
  ll += log(h_white->counts[nint(white_val)]) ;
  grad = white_val - gray_val ;
  bin = nint((grad-h_grad->bins[0]) / h_grad->bin_size) ;
  if (bin < 0)
  {
    bin = 0 ;
  }
  else if (bin >= h_grad->nbins)
  {
    bin = h_grad->nbins-1 ;
  }
  ll += log(h_grad->counts[bin]) ;
  MRIsampleVolume(mri_gray_white, white_val, gray_val, 0, &val) ;
  jll += log(val) ;
  nsamples++ ;

#if 0
  return(ll/nsamples) ;
#else
  return(jll/nsamples) ;
#endif
#endif

}

static float
mrisDefectVertexMRILogLikelihood
(MRI_SURFACE *mris, MRI *mri, TP *tp, HISTOGRAM *h_white,
 HISTOGRAM *h_gray, HISTOGRAM *h_grad, MRI *mri_gray_white)
{
  int  n;
  double x,y,z,nx,ny,nz,xv,yv,zv,white_val,gray_val,val;
  double int_w,int_g;
  double v_ll,total_ll,t_area,tv_area;
  VERTEX *v;

  total_ll = 0.0;
  t_area = tv_area = 0.0;
  int_w = int_g = 0.0;

  for (n = 0 ; n < tp->nvertices ; n++)
  {
    v=&mris->vertices[tp->vertices[n]];

    x=v->origx;
    y=v->origy;
    z=v->origz;

    nx=v->nx;
    ny=v->ny;
    nz=v->nz;

#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &white_val) ;

    int_w += white_val;

#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;

    int_g +=gray_val;

    MRIsampleVolume(mri_gray_white, white_val, gray_val, 0, &val) ;

    v_ll = log(val) ;
    total_ll += v_ll;
    tv_area += v_ll * v->area;
    t_area += v->area;
  }

  if (tp->nvertices)
  {
    tp->vertex_ll=total_ll/(double)tp->nvertices;
    tp->vll = tv_area / t_area;
    int_w /= (double)tp->nvertices;
    int_g /= (double)tp->nvertices;
    // fs_topo_fixer_test
    //  fprintf(stderr,"vertex : gray = %f and white = %f\n",int_g,int_w);
  }
  else
  {
    tp->vll = 0.0;
    tp->vertex_ll=0.0;
  }

  return tp->vertex_ll;
}


static double
mrisComputeDefectMRILogLikelihood
(MRI_SURFACE *mris, MRI *mri, TP *tp,
 HISTOGRAM *h_white, HISTOGRAM *h_gray, HISTOGRAM *h_grad, MRI *mri_gray_white)
{
  double mll;

  mll=mrisDefectVertexMRILogLikelihood
      (mris,mri,tp,h_white,h_gray,h_grad,mri_gray_white);
  mll+=mrisDefectFaceMRILogLikelihood
       (mris,mri,tp,h_white,h_gray,h_grad,mri_gray_white);
  return mll;
}


static int findOtherEdgeFace
(MRIS *mris , int fno , int vno , int vn1)
{
  int n,m;

  VERTEX *v1,*v2;
  v1=&mris->vertices[vno];
  v2=&mris->vertices[vn1];
  for ( n = 0 ; n < v1->num ; n++ )
  {
    if (v1->f[n] == fno)
    {
      continue;
    }
    for ( m = 0 ; m < v2->num ; m++)
      if (v1->f[n] == v2->f[m])
      {
        return (v1->f[n]);
      }
  }

  //fprintf(WHICH_OUTPUT,"edge (%d<-->%d) does not have two faces\n",vno,vn1);

  return fno;
}

static void vertexPseudoNormal(MRIS *mris1, int vn1, MRIS *mris2, int vn2, float norm[3])
{
  int n,n0,n1,n2;
  float v1[3],v2[3],alpha;
  VERTEX *v;
  FACE *face;


  // fprintf(stderr,"-vpn: %d and %d - ",vn1,vn2);

  norm[0]=norm[1]=norm[2]=0;

  v=&mris1->vertices[vn1];
  for ( n = 0 ; n < v->num ; n++)
  {
    face=&mris1->faces[v->f[n]];
    if (face->marked)
    {
      continue;  //defect
    }

    n0=v->n[n];
    n1=(n0==2)?0:n0+1;
    n2=(n0==0)?2:n0-1;

#if 1
    if ((face->v[n0]!=vn1) || (face->v[n1]==vn1) || (face->v[n2]==vn1) || (face->v[n2]==face->v[n1]))
    {
      if (1)
      {
        //verbose>=VERBOSE_MODE_MEDIUM){
        if (face->v[n0]!=vn1)
        {
          fprintf(WHICH_OUTPUT,"error for vno in face %d",v->f[n]);
        }
        if (face->v[n1]==vn1)
        {
          fprintf(WHICH_OUTPUT,"error for vn1 in face %d",v->f[n]);
        }
        if (face->v[n2]==vn1)
        {
          fprintf(WHICH_OUTPUT,"error for vn2 in face %d",v->f[n]);
        }
        if (face->v[n2]==face->v[n1])
        {
          fprintf(WHICH_OUTPUT,"error for vn in face %d",v->f[n]);
        }

        fprintf(WHICH_OUTPUT,"face %d (%d,%d,%d) != (%d)\n",v->f[n],face->v[n0],face->v[n1],face->v[n2],vn1);

        if (1)//verbose==VERBOSE_MODE_MEDIUM)
        {
          fprintf(stderr,"vertexPseudoNormal: SHOULD NOT HAPPEN\n");
        }

        //                      MRISwrite(mris,"rh.testdebug1");
        //MRISrestoreVertexPositions(mris,CANONICAL_VERTICES);
        //MRISwrite(mris,"rh.testdebug2");
        if (1)//verbose==VERBOSE_MODE_HIGH)
        {
          ErrorExit(ERROR_BADPARM, "vertexPseudoNormal: SHOULD NOT HAPPEN\n");
        }
      }
    }
#endif
    v1[0]=mris1->vertices[face->v[n1]].origx-v->origx;
    v1[1]=mris1->vertices[face->v[n1]].origy-v->origy;
    v1[2]=mris1->vertices[face->v[n1]].origz-v->origz;

    v2[0]=mris1->vertices[face->v[n2]].origx-v->origx;
    v2[1]=mris1->vertices[face->v[n2]].origy-v->origy;
    v2[2]=mris1->vertices[face->v[n2]].origz-v->origz;

    alpha=MAX(0.0,MIN(1.0,F_DOT(v1,v2)/NORM3(v1)/NORM3(v2)));
    alpha=acos(alpha);

    norm[0]+=alpha*face->nx;
    norm[1]+=alpha*face->ny;
    norm[2]+=alpha*face->nz;
  }

  v = &mris2->vertices[vn2];
  for ( n = 0 ; n < v->num ; n++)
  {
    face=&mris2->faces[v->f[n]];
    n0=v->n[n];
    n1=(n0==2)?0:n0+1;
    n2=(n0==0)?2:n0-1;
#if 1
    if ((face->v[n0]!=vn2) || (face->v[n1]==vn2) || (face->v[n2]==vn2) || (face->v[n2]==face->v[n1]))
    {
      if (1)
      {
        //verbose>=VERBOSE_MODE_MEDIUM){
        if (face->v[n0]!=vn2)
        {
          fprintf(WHICH_OUTPUT,"error for vno in face %d",v->f[n]);
        }
        if (face->v[n1]==vn2)
        {
          fprintf(WHICH_OUTPUT,"error for vn1 in face %d",v->f[n]);
        }
        if (face->v[n2]==vn2)
        {
          fprintf(WHICH_OUTPUT,"error for vn2 in face %d",v->f[n]);
        }
        if (face->v[n2]==face->v[n1])
        {
          fprintf(WHICH_OUTPUT,"error for vn in face %d",v->f[n]);
        }

        fprintf(WHICH_OUTPUT,"face %d (%d,%d,%d) != (%d)\n",v->f[n],face->v[n0],face->v[n1],face->v[n2],vn2);

        if (1)//verbose==VERBOSE_MODE_MEDIUM)
        {
          fprintf(stderr,"vertexPseudoNormal: SHOULD NOT HAPPEN\n");
        }

        //                      MRISwrite(mris,"rh.testdebug1");
        //MRISrestoreVertexPositions(mris,CANONICAL_VERTICES);
        //MRISwrite(mris,"rh.testdebug2");
        if (1)//verbose==VERBOSE_MODE_HIGH)
        {
          ErrorExit(ERROR_BADPARM, "computeVertexPseudoNormal: SHOULD NOT HAPPEN\n");
        }
      }
    }
#endif
    v1[0]=mris2->vertices[face->v[n1]].origx-v->origx;
    v1[1]=mris2->vertices[face->v[n1]].origy-v->origy;
    v1[2]=mris2->vertices[face->v[n1]].origz-v->origz;

    v2[0]=mris2->vertices[face->v[n2]].origx-v->origx;
    v2[1]=mris2->vertices[face->v[n2]].origy-v->origy;
    v2[2]=mris2->vertices[face->v[n2]].origz-v->origz;

    alpha=MAX(0.0,MIN(1.0,F_DOT(v1,v2)/NORM3(v1)/NORM3(v2)));
    alpha=acos(alpha);

    norm[0]+=alpha*face->nx;
    norm[1]+=alpha*face->ny;
    norm[2]+=alpha*face->nz;
  }

}


static void computeVertexPseudoNormal(MRIS *mris,int vno,float norm[3],int verbose)
{
  int n,n0,n1,n2;
  float v1[3],v2[3],alpha;
  VERTEX *v;
  FACE *face;
  v=&mris->vertices[vno];

  norm[0]=norm[1]=norm[2]=0;

  for ( n = 0 ; n < v->num ; n++)
  {
    face=&mris->faces[v->f[n]];

    n0=v->n[n];
    n1=(n0==2)?0:n0+1;
    n2=(n0==0)?2:n0-1;

    if ((face->v[n0]!=vno) || (face->v[n1]==vno) || (face->v[n2]==vno) || (face->v[n2]==face->v[n1]))
    {
      if (verbose>=VERBOSE_MODE_MEDIUM)
      {
        if (face->v[n0]!=vno)
        {
          fprintf(WHICH_OUTPUT,"error for vno in face %d",v->f[n]);
        }
        if (face->v[n1]==vno)
        {
          fprintf(WHICH_OUTPUT,"error for vn1 in face %d",v->f[n]);
        }
        if (face->v[n2]==vno)
        {
          fprintf(WHICH_OUTPUT,"error for vn2 in face %d",v->f[n]);
        }
        if (face->v[n2]==face->v[n1])
        {
          fprintf(WHICH_OUTPUT,"error for vn in face %d",v->f[n]);
        }

        fprintf(WHICH_OUTPUT,"face %d (%d,%d,%d) != (%d)\n",v->f[n],face->v[n0],face->v[n1],face->v[n2],vno);

        if (verbose==VERBOSE_MODE_MEDIUM)
        {
          fprintf(stderr,"computeVertexPseudoNormal: SHOULD NOT HAPPEN\n");
        }

        //                      MRISwrite(mris,"rh.testdebug1");
        //MRISrestoreVertexPositions(mris,CANONICAL_VERTICES);
        //MRISwrite(mris,"rh.testdebug2");
        if (verbose==VERBOSE_MODE_HIGH)
        {
          ErrorExit(ERROR_BADPARM, "computeVertexPseudoNormal: SHOULD NOT HAPPEN\n");
        }
      }
    }

    v1[0]=mris->vertices[face->v[n1]].origx-v->origx;
    v1[1]=mris->vertices[face->v[n1]].origy-v->origy;
    v1[2]=mris->vertices[face->v[n1]].origz-v->origz;

    v2[0]=mris->vertices[face->v[n2]].origx-v->origx;
    v2[1]=mris->vertices[face->v[n2]].origy-v->origy;
    v2[2]=mris->vertices[face->v[n2]].origz-v->origz;

    alpha=MAX(0.0,MIN(1.0,F_DOT(v1,v2)/NORM3(v1)/NORM3(v2)));
    alpha=acos(alpha);

    norm[0]+=alpha*face->nx;
    norm[1]+=alpha*face->ny;
    norm[2]+=alpha*face->nz;

  }
}


static int findNonMarkedFace(MRIS *mris, int vno, int vn1)
{
  int i,nf;
  int fn;
  VERTEX *v;
  FACE *f;

  //test
  if (vno < 0 || vno >= mris->nfaces || vn1 < 0 || vn1 >= mris->nfaces)
  {
    fprintf(stderr,"error in findNonmarkedFace\n");
    return -1;
  }
  v=&mris->vertices[vno];
  for ( nf = 0 ; nf < v->num ; nf++)
  {
    fn = v->f[nf];
    f = &mris->faces[fn];
    if (f->marked)
    {
      continue;
    }
    //check if correct face
    for (i = 0 ; i < 3 ; i++)
    {
      if (f->v[i]==vno)
      {
        continue;
      }
      if (f->v[i]==vn1)
      {
        return fn;
      }
    }
  }
  fprintf(stderr,"could not find other face in findNonMarkedFace\n");
  return -1;
}

static int _DX[6]=
{
  -1,1,0,0,0,0
};
static int _DY[6]=
{
  0,0,-1,1,0,0
};
static int _DZ[6]=
{
  0,0,0,0,-1,1
};

// compute a signed distance volume from two surfaces ( the original ones + a corrected defect )
void MRIScomputeDistanceVolume(TOPOFIX_PARMS *parms, float distance_to_surface)
{

  int k,i,j,p;
  float x0,x1,x2,y0,y1,y2,z0,z1,z2;
  float x,y,z;

  int fno,fn1;
  int delta;
  FACE *face,*oface;
  int imin,imax,jmin,jmax,kmin,kmax;
  float distance,sign,scale;
  float n_f[3],n_e0[3],n_e1[3],n_e2[3],n_v0[3],n_v1[3],n_v2[3];
  float vec[3],vec0[3],vec1[3],vec2[3],e0[3],e1[3],e2[3],n0[3],n1[3],n2[3];
  float val,valu,val0,val1,val2;


  MRIP *mrip;
  MRIS *mris_defect,*mris_source,*mris;
  MRI *mri_defect,*mri_distance;
  int wsurf;
  int n,n_faces,n_vertices;
  int *ffrom, *fto,*vfrom, *vto;

  int found;

  mrip=parms->mrip;
  mris_defect=parms->mris_defect; //the defect surface
  mris_source=mrip->mris_source; //the source surface

  // fprintf(stderr,"INFO:{%d %d} {%d (%d) %d (%d)} \n",mris_defect->nfaces,mris_defect->nvertices,mris_source->nfaces,mris_source->max_faces,mris_source->nvertices,mris_source->max_vertices);

  n_faces = mrip->n_faces;
  n_vertices = mrip->n_vertices;
  ffrom = mrip->ftrans_from;
  fto = mrip->ftrans_to;
  vfrom = mrip->vtrans_from;
  vto = mrip->vtrans_to;

  mri_defect = ((DP*)parms->dp)->mri_defect;
  mri_distance = ((DP*)parms->dp)->mri_defect_sign;

  //marking defect faces of source surface, i.e. mris_source
  //MRISclearFaceMarks(mris_source); //useless
  for (n = 0 ; n < n_faces ; n++)
  {
    mris_source->faces[fto[n]].marked=1;
  }
  //marking defect vertices of source surface, i.e. mris_source
  //MRISclearMarks(mris_source); //useless
  for (n = 0 ; n < n_vertices ; n++)
  {
    mris_source->vertices[vto[n]].marked=1;
  }
  //unmarking defect faces for defect surface, i.e. mris_defect
  MRISclearFaceMarks(mris_defect);

  /* look at approximately +/- 2mm */
  distance_to_surface = MAX(2.0,distance_to_surface);
  delta=distance_to_surface*mri_defect->xsize;
  delta = 3.0 ; //for now, distance_to_surface = 2 * volume_resolution
  scale = mri_defect->xsize;

  /* initialize the signed image */
  for (k=0; k<mri_distance->depth; k++)
    for (j=0; j<mri_distance->height; j++)
      for (i=0; i<mri_distance->width; i++)
      {
        MRIFvox(mri_distance,i,j,k)=NPY;
      }

  // compute face normals for the defect surface
  //for ( p = 0 ; p < mris_source->nfaces ; p++) computeDefectFaceNormal(mris_source,&mris_source->faces[p]); //useless
  //for ( p = 0 ; p < mris_defect->nfaces ; p++) computeDefectFaceNormal(mris_defect,&mris_defect->faces[p]); //useless

  /* find the distance to each surface voxels */
  for ( p = 0 ; p < mris_defect->nfaces +mris_source->nfaces; p++)
  {
    if ( p >= mris_defect->nfaces )
    {
      mris=mris_source;
      fno=p-mris_defect->nfaces;
      wsurf=1; //using source surface
      if (mris->faces[fno].marked)
      {
        continue;
      }
    }
    else
    {
      fno=p;
      mris=mris_defect;
      wsurf=0; //using defect surface
    }
    face=&mris->faces[fno];

    // calculate three vertices
    x0 =mris->vertices[face->v[0]].origx;
    y0 =mris->vertices[face->v[0]].origy;
    z0 =mris->vertices[face->v[0]].origz;
    x1 =mris->vertices[face->v[1]].origx;
    y1 =mris->vertices[face->v[1]].origy;
    z1 =mris->vertices[face->v[1]].origz;
    x2 =mris->vertices[face->v[2]].origx;
    y2 =mris->vertices[face->v[2]].origy;
    z2 =mris->vertices[face->v[2]].origz;

    /* find the bounding box */
    imin=iVOL(mri_defect,MIN3(x0,x1,x2))-delta;
    imax=iVOL(mri_defect,MAX3(x0,x1,x2))+delta;

    jmin=jVOL(mri_defect,MIN3(y0,y1,y2))-delta;
    jmax=jVOL(mri_defect,MAX3(y0,y1,y2))+delta;

    kmin=kVOL(mri_defect,MIN3(z0,z1,z2))-delta;
    kmax=kVOL(mri_defect,MAX3(z0,z1,z2))+delta;


    /* we don't count faces that are outside
       the volume - will not change the sign */
    if (imin > mri_defect->width-1 ||
        jmin > mri_defect->height-1 ||
        kmin > mri_defect->depth-1 ||
        imax < 0 || jmax < 0 || kmax < 0)
    {
      continue;
    }

    imin=MAX(imin,0);
    imax=MIN(imax,mri_defect->width-1);

    jmin=MAX(jmin,0);
    jmax=MIN(jmax,mri_defect->height-1);

    kmin=MAX(kmin,0);
    kmax=MIN(kmax,mri_defect->depth-1);

    //////////////////////////////////////////////////////////////
    /* generating the pseudo-normals for edges and vertices */
    // normal for the current face
    n_f[0]=face->nx;
    n_f[1]=face->ny;
    n_f[2]=face->nz;

    /* edge0: x0 <--> x1 */
    e0[0]=x1-x0;
    e0[1]=y1-y0;
    e0[2]=z1-z0;
    F_CROSS(n_f,e0,n0);
    fn1=findOtherEdgeFace(mris,fno,face->v[0],face->v[1]);
    if (wsurf)
    {
      //source surface
      if (mris->faces[fn1].marked)
      {
        //border face
        //find face in mris_defect
        fn1 = findNonMarkedFace
              (mris_defect,vfrom[face->v[0]],vfrom[face->v[1]]);
        if (fn1==-1)
        {
          //sanity check
          fprintf(stderr,"fn1=-1 in defect- should not happen\n");
          fn1 = fno;
        }
        oface = &mris_defect->faces[fn1];
      }
      else
      {
        oface = &mris->faces[fn1];
      }
    }
    else
    {
      //defect surface
      if (fn1 == fno)
      {
        // border face
        //find face in mris_source
        fn1 = findNonMarkedFace(mris_source , vto[face->v[0]],vto[face->v[1]]);
        if (fn1 == -1)
        {
          fprintf(stderr,"fn1=-1 in source- should not happen\n");
          fn1 = fno; //sanity check
        }
        oface = &mris_source->faces[fn1];
      }
      else
      {
        oface = &mris->faces[fn1];
      }
    }
    n_e0[0]=face->nx+oface->nx;
    n_e0[1]=face->ny+oface->ny;
    n_e0[2]=face->nz+oface->nz;

    /* edge1: x1 <--> x2 */
    e1[0]=x2-x1;
    e1[1]=y2-y1;
    e1[2]=z2-z1;
    F_CROSS(n_f,e1,n1);
    fn1=findOtherEdgeFace(mris,fno,face->v[1],face->v[2]);
    if (wsurf)
    {
      //source surface
      if (mris->faces[fn1].marked)
      {
        //border face
        //find face in mris_defect
        fn1 = findNonMarkedFace
              (mris_defect,vfrom[face->v[1]],vfrom[face->v[2]]);
        if (fn1==-1)
        {
          //sanity check
          fprintf(stderr,"fn1=-1 in defect- should not happen\n");
          fn1 = fno;
        }
        oface = &mris_defect->faces[fn1];
      }
      else
      {
        oface = &mris->faces[fn1];
      }
    }
    else
    {
      //defect surface
      if (fn1 == fno)
      {
        // border face
        //find face in mris_source
        fn1 = findNonMarkedFace(mris_source , vto[face->v[1]],vto[face->v[2]]);
        if (fn1 == -1)
        {
          fprintf(stderr,"fn1=-1 in source- should not happen\n");
          fn1 = fno; //sanity check
        }
        oface = &mris_source->faces[fn1];
      }
      else
      {
        oface = &mris->faces[fn1];
      }
    }
    n_e1[0]=face->nx+oface->nx;
    n_e1[1]=face->ny+oface->ny;
    n_e1[2]=face->nz+oface->nz;

    /* edge2: x2 <--> x0 */
    e2[0]=x0-x2;
    e2[1]=y0-y2;
    e2[2]=z0-z2;
    F_CROSS(n_f,e2,n2);
    fn1=findOtherEdgeFace(mris,fno,face->v[2],face->v[0]);
    if (wsurf)
    {
      //source surface
      if (mris->faces[fn1].marked)
      {
        //border face
        //find face in mris_defect
        fn1 = findNonMarkedFace
              (mris_defect,vfrom[face->v[2]],vfrom[face->v[0]]);
        if (fn1==-1)
        {
          //sanity check
          fprintf(stderr,"fn1=-1 in defect- should not happen\n");
          fn1 = fno;
        }
        oface = &mris_defect->faces[fn1];
      }
      else
      {
        oface = &mris->faces[fn1];
      }
    }
    else
    {
      //defect surface
      if (fn1 == fno)
      {
        // border face
        //find face in mris_source
        fn1 = findNonMarkedFace(mris_source , vto[face->v[2]],vto[face->v[0]]);
        if (fn1 == -1)
        {
          fprintf(stderr,"fn1=-1 in source- should not happen\n");
          fn1 = fno; //sanity check
        }
        oface = &mris_source->faces[fn1];
      }
      else
      {
        oface = &mris->faces[fn1];
      }
    }
    n_e2[0]=face->nx+oface->nx;
    n_e2[1]=face->ny+oface->ny;
    n_e2[2]=face->nz+oface->nz;

    /* vertex pseudo-normals */
    if (wsurf)
    {
      int vn;
      vn = face->v[0];
      if (mris->vertices[vn].marked)
      {
        //border
        //test
        if (vfrom[vn]<0 || vfrom[vn]>=n_vertices)
        {
          fprintf(stderr,"problem with vfrom vn0\n");
        }
        //fprintf(stderr,"to0(%d-",vn);
        //fprintf(stderr,"%d),",vfrom[vn]);
        vertexPseudoNormal(mris_source,vn,mris_defect,vfrom[vn],n_v0);
      }
      else
      {
        computeVertexPseudoNormal(mris,vn,n_v0,0);
      }
      vn = face->v[1];
      if (mris->vertices[vn].marked)
      {
        //border
        //test
        if (vfrom[vn]<0 || vfrom[vn]>=n_vertices)
        {
          fprintf(stderr,"problem with vfrom vn1\n");
        }
        //fprintf(stderr,"to1(%d-",vn);
        //fprintf(stderr,"%d),",vfrom[vn]);
        vertexPseudoNormal(mris_source,vn,mris_defect,vfrom[vn],n_v1);
      }
      else
      {
        computeVertexPseudoNormal(mris,vn,n_v1,0);
      }
      vn = face->v[2];
      if (mris->vertices[vn].marked)
      {
        //border
        //test
        if (vfrom[vn]<0 ||
            vfrom[vn]>=n_vertices)
        {
          fprintf(stderr,"problem with vfrom vn2\n");
        }
        //fprintf(stderr,"to2(%d-",vn);
        //fprintf(stderr,"%d),",vfrom[vn]);
        vertexPseudoNormal(mris_source,vn,mris_defect,vfrom[vn],n_v2);
      }
      else
      {
        computeVertexPseudoNormal(mris,vn,n_v2,0);
      }
    }
    else
    {
      int vn = face->v[0];
      //fprintf(stderr,"we have %d and %d \n", mris->vertices[vn].vnum,mris->vertices[vn].num);
      if (mris->vertices[vn].vnum != mris->vertices[vn].num)
      {
        //border
        //test
        if (vn >= n_vertices)
        {
          fprintf(stderr,"problem with vto vn0\n");
        }
        //fprintf(stderr,"fo0(%d-",vn);
        //fprintf(stderr,"%d),",vto[vn]);
        vertexPseudoNormal(mris_source,vto[vn],mris_defect,vn,n_v0);
      }
      else
      {
        computeVertexPseudoNormal(mris,vn,n_v0,0);
      }
      vn = face->v[1];
      if (mris->vertices[vn].vnum != mris->vertices[vn].num)
      {
        //border
        //test
        if (vn >= n_vertices)
        {
          fprintf(stderr,"problem with vto vn1\n");
        }
        //fprintf(stderr,"fo1(%d-",vn);
        //fprintf(stderr,"%d),",vto[vn]);
        vertexPseudoNormal(mris_source,vto[vn],mris_defect,vn,n_v1);
      }
      else
      {
        computeVertexPseudoNormal(mris,vn,n_v1,0);
      }
      vn = face->v[2];
      if (mris->vertices[vn].vnum != mris->vertices[vn].num)
      {
        //border
        //test
        if (vn >= n_vertices)
        {
          fprintf(stderr,"problem with vto vn2\n");
        }
        //fprintf(stderr,"fo2(%d-",vn);
        //fprintf(stderr,"%d),",vto[vn]);
        vertexPseudoNormal(mris_source,vto[vn],mris_defect,vn,n_v2);
      }
      else
      {
        computeVertexPseudoNormal(mris,vn,n_v2,0);
      }
    }
    if (isnan(n_v0[0]) || isnan(n_v1[0]) || isnan(n_v2[0]))
    {
      fprintf(stderr, ".%d & %d[%d(%d) %d(%d) %d(%d)][%f %f %f]\n",
              wsurf,fno,face->v[0],mris->vertices[face->v[0]].marked,
              face->v[1],mris->vertices[face->v[1]].marked,face->v[2],
              mris->vertices[face->v[2]].marked,n_v0[0],n_v1[0],n_v2[0]);
      exit(-1);
    }
    //////////////////////////////////////////////////////////////

    /* finding distance to surface */
    for ( k = kmin ; k <= kmax ;  k++ )
      for ( j = jmin ; j <= jmax ; j++ )
        for ( i = imin ; i <= imax ; i++ )
        {

          x=xSURF(mri_defect,i);
          y=ySURF(mri_defect,j);
          z=zSURF(mri_defect,k);

          vec0[0]=x-x0;
          vec0[1]=y-y0;
          vec0[2]=z-z0;
          vec1[0]=x-x1;
          vec1[1]=y-y1;
          vec1[2]=z-z1;
          vec2[0]=x-x2;
          vec2[1]=y-y2;
          vec2[2]=z-z2;
          vec[0]=(vec0[0]+vec1[0]+vec2[0])/3.0;
          vec[1]=(vec0[1]+vec1[1]+vec2[1])/3.0;
          vec[2]=(vec0[2]+vec1[2]+vec2[2])/3.0;

          /* compute distance to face */
          /* where is the point */
          val0=F_DOT(vec0,n0);
          val1=F_DOT(vec1,n1);
          val2=F_DOT(vec2,n2);

          if ((val0>=0) && (val1>=0) && (val2>=0))
          {
            /* the projection of the vertex is inside */
            val=F_DOT(n_f,vec);
            valu=1;
            sign=val;
            distance=val; /* n_f is already normalized */
          }
          else
          {
            distance=NPY;
            sign=0;
            valu=0;

            if (val0<=0)
            {
              /* compute distance to edge0 */
              val=F_DOT(vec0,e0);
              if (val<0)
              {
                /* closer to x0 */
                sign=F_DOT(n_v0,vec0);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec0));
              }
              else if (val<SQR3(e0))
              {
                /* closer to edge0 */
                sign=F_DOT(n_e0,vec0);
                valu=3;
                distance=
                  SIGN(sign)*MIN(fabs(distance),
                                 sqrt(MAX(0,SQR3(vec0)-SQR(val)/SQR3(e0))));
              }
              else
              {
                /* closer to x1 */
                sign=F_DOT(n_v1,vec1);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec1));
              }
            };
            if (val1<=0)
            {
              val=F_DOT(vec1,e1);
              if (val<0)
              {
                /* closer to x1 */
                sign=F_DOT(n_v1,vec1);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec1));
              }
              else if (val<SQR3(e1))
              {
                /* closer to edge1 */
                sign=F_DOT(n_e1,vec1);
                valu=3;
                distance=
                  SIGN(sign)*MIN(fabs(distance),
                                 sqrt(MAX(0,SQR3(vec1)-SQR(val)/SQR3(e1))));
              }
              else
              {
                /* closer to x2 */
                sign=F_DOT(n_v2,vec2);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec2));
              }
            };
            if (val2<=0)
            {
              val=F_DOT(vec2,e2);
              if (val<0)
              {
                /* closer to x2 */
                sign=F_DOT(n_v2,vec2);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec2));
              }
              else if (val<SQR3(e2))
              {
                /* closer to edge2 */
                sign=F_DOT(n_e2,vec2);
                valu=3;
                distance=
                  SIGN(sign)*MIN(fabs(distance),
                                 sqrt(MAX(0,SQR3(vec2)-SQR(val)/SQR3(e2))));
              }
              else
              {
                /* closer to x0 */
                sign=F_DOT(n_v0,vec0);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec0));
              }
            };
          }

          /* update distance map */
          if (fabs(distance)<fabs(MRIFvox(mri_distance,i,j,k)))
          {
            MRIFvox(mri_distance,i,j,k)=distance;
          }
        }
  }
  for (n = 0 ; n < n_faces ; n++)
  {
    mris_source->faces[fto[n]].marked=0;
  }
  for (n = 0 ; n < n_vertices ; n++)
  {
    mris_source->vertices[vto[n]].marked=0;
  }

  //update the volume
  //only keep the points close to the surface (we only care about the sign)
  for (k=0; k<mri_distance->depth; k++)
    for (j=0; j<mri_distance->height; j++)
      for (i=0; i<mri_distance->width; i++)
      {
        if (i == 0 || j == 0 || k == 0 ||
            i == mri_distance->width-1 ||
            j == mri_distance->height-1 ||
            k == mri_distance->depth-1)
        {
          MRIFvox(mri_distance,i,j,k)=NPY;
          continue;
        }
        distance = MRIFvox(mri_distance,i,j,k);
        if (distance==NPY)
        {
          continue;
        }
        if (fabs(distance)*scale > 1.5)
        {
          MRIFvox(mri_distance,i,j,k) = NPY;
        }
        else if (distance>0.0)
        {
          MRIFvox(mri_distance,i,j,k)=MIN(distance*scale,1.0f);
        }
        else
        {
          MRIFvox(mri_distance,i,j,k)=MAX(distance*scale,-1.0f);
        }
      }

  found = 1 ;
  while (found)
  {
    found = 0 ;
    for (k=1; k<mri_distance->depth-1; k++)
      for (j=1; j<mri_distance->height-1; j++)
        for (i=1; i<mri_distance->width-1; i++)
        {
          if (MRIFvox(mri_distance,i,j,k) < NPY )
          {
            continue;
          }
          for ( n = 0 ; n < 6 ; n++)
          {
            float sign;
            sign = MRIFvox(mri_distance,i+_DX[n],j+_DY[n],k+_DZ[n]);
            if (fabs(sign) < NPY)
            {
              if (sign>0)
              {
                MRIFvox(mri_distance,i,j,k)=1.0f;
              }
              else
              {
                MRIFvox(mri_distance,i,j,k)=-1.0f;
              }
              found=1;
              break;
            }
          }
        }
  }
  //making sure
  for (k=0; k<mri_distance->depth-0; k++)
    for (j=0; j<mri_distance->height-0; j++)
      for (i=0; i<mri_distance->width-0; i++)
      {
        sign = MRIFvox(mri_distance,i,j,k);
        if (sign > 0.0)
        {
          MRIFvox(mri_distance,i,j,k)=MIN(1.0f,sign);
        }
        else
        {
          MRIFvox(mri_distance,i,j,k)=MAX(-1.0f,sign);
        }
      }
}


#define DEBUG_UL 0

static double mrisComputeDefectMRILogUnlikelihood
(MRI_SURFACE *mris, DEFECT_PATCH *dp, HISTOGRAM *h_border)
{
#if 0
  int u,v,numu,numv;
  float d0,d1,d2,dmax,px,px0,px1,py,py0,py1,pz,pz0,pz1,nx,ny,nz;
  int noutside,ninside,nambiguous;
  MRI_SEGMENTATION *segment;
  int changed,signp,signm;
#endif

  int k,i,j,p;
  float x0,x1,x2,y0,y1,y2,z0,z1,z2;
  float x,y,z;

  TP *tp;
  MRI *mri_defect,*mri_distance,*mri_white,*mri_gray;

#if DEBUG_UL
  double xv,yv,zv,ival;
  MRI *mri_intensity;
  MRI *mri_debug1,*mri_debug2,*mri_debug3;
#endif
  int fno,fn1;
  int delta;
  FACE *face;
  int imin,imax,jmin,jmax,kmin,kmax;
  float distance,sign;
  float n_f[3],n_e0[3],n_e1[3],n_e2[3],n_v0[3],n_v1[3],n_v2[3];
  float vec[3],vec0[3],vec1[3],vec2[3],e0[3],e1[3],e2[3],n0[3],n1[3],n2[3];
  float val,valu,val0,val1,val2;
  int nwhite,ngray;
  float white_ll,gray_ll;
  float max_distance;
  float int_w,int_g;

  tp=&dp->tp;
  mri_defect=dp->mri_defect;
  mri_distance=dp->mri_defect_sign;
  mri_white=dp->mri_defect_white;
  mri_gray=dp->mri_defect_gray;

  /* look at approximately +/- 2mm */
  delta=2.0*mri_defect->xsize;

  /* optimize by listing the concerned faces */

#if DEBUG_UL
  mri_intensity=MRIclone(mri_distance,NULL);
  mri_debug1=MRIclone(mri_distance,NULL);
  mri_debug2=MRIclone(mri_distance,NULL);
  mri_debug3=MRIclone(mri_distance,NULL);
#endif

  for (k=0; k<mri_distance->depth; k++)
    for (j=0; j<mri_distance->height; j++)
      for (i=0; i<mri_distance->width; i++)
      {
        MRIFvox(mri_distance,i,j,k)=NPY;

#if DEBUG_UL
        mriSurfaceRASToVoxel
        (xSURF(mri_defect,i),
         ySURF(mri_defect,j),
         zSURF(mri_defect,k),
         &xv, &yv, &zv) ;

        MRIsampleVolume(dp->mri, xv, yv, zv, &ival) ;
        MRIFvox(mri_intensity,i,j,k)
        = ival;//log(h_white->counts[nint(white_val)]) ;
        MRIFvox(mri_debug1,i,j,k)=0;
        MRIFvox(mri_debug2,i,j,k)=0;
        MRIFvox(mri_debug3,i,j,k)=0;
#endif
      }

  //    MRISmarkOrientationChanges(mris,0);
  //FLO NOT HERE: TO BE CHECKED
  for ( p = 0 ; p < mris->nfaces ; p++)
  {
    computeDefectFaceNormal(mris,&mris->faces[p]);
  }

  /* find the distance to each surface voxels */
  for ( p = 0 ; p < mris->nfaces ; p++)
  {
    //tp->nfaces ; p++){
    fno=p;//tp->faces[p];
    face=&mris->faces[fno];

#if DEBUG_UL
    fprintf(WHICH_OUTPUT,"\r %3.2f     ",100.*(float)p/(float)mris->nfaces);
#endif

    // calculate three vertices
    x0 =mris->vertices[face->v[0]].origx;
    y0 =mris->vertices[face->v[0]].origy;
    z0 =mris->vertices[face->v[0]].origz;
    x1 =mris->vertices[face->v[1]].origx;
    y1 =mris->vertices[face->v[1]].origy;
    z1 =mris->vertices[face->v[1]].origz;
    x2 =mris->vertices[face->v[2]].origx;
    y2 =mris->vertices[face->v[2]].origy;
    z2 =mris->vertices[face->v[2]].origz;

    /* find the bounding box */
    imin=iVOL(mri_defect,MIN3(x0,x1,x2))-delta;
    imax=iVOL(mri_defect,MAX3(x0,x1,x2))+delta;

    jmin=jVOL(mri_defect,MIN3(y0,y1,y2))-delta;
    jmax=jVOL(mri_defect,MAX3(y0,y1,y2))+delta;

    kmin=kVOL(mri_defect,MIN3(z0,z1,z2))-delta;
    kmax=kVOL(mri_defect,MAX3(z0,z1,z2))+delta;

    //TO BE CHECKED
    /* we don't count faces that are outside the volume -
       should not change the sign */
    //TO BE CHECKED it some defects are close from each other!
    if (imin > mri_defect->width-1 ||
        jmin > mri_defect->height-1 ||
        kmin > mri_defect->depth-1 ||
        imax < 0 ||
        jmax < 0 ||
        kmax < 0)
    {
      continue;
    }

    imin=MAX(imin,0);
    imax=MIN(imax,mri_defect->width-1);

    jmin=MAX(jmin,0);
    jmax=MIN(jmax,mri_defect->height-1);

    kmin=MAX(kmin,0);
    kmax=MIN(kmax,mri_defect->depth-1);

    /* generating the pseudo-normals for edges and vertices */
    n_f[0]=face->nx;
    n_f[1]=face->ny;
    n_f[2]=face->nz;

    /* edge0: x0 <--> x1 */
    e0[0]=x1-x0;
    e0[1]=y1-y0;
    e0[2]=z1-z0;
    F_CROSS(n_f,e0,n0);
    fn1=findOtherEdgeFace(mris,fno,face->v[0],face->v[1]);
    n_e0[0]=face->nx+mris->faces[fn1].nx;
    n_e0[1]=face->ny+mris->faces[fn1].ny;
    n_e0[2]=face->nz+mris->faces[fn1].nz;

    /* edge1: x1 <--> x2 */
    e1[0]=x2-x1;
    e1[1]=y2-y1;
    e1[2]=z2-z1;
    F_CROSS(n_f,e1,n1);
    fn1=findOtherEdgeFace(mris,fno,face->v[1],face->v[2]);
    n_e1[0]=face->nx+mris->faces[fn1].nx;
    n_e1[1]=face->ny+mris->faces[fn1].ny;
    n_e1[2]=face->nz+mris->faces[fn1].nz;

    /* edge2: x2 <--> x0 */
    e2[0]=x0-x2;
    e2[1]=y0-y2;
    e2[2]=z0-z2;
    F_CROSS(n_f,e2,n2);
    fn1=findOtherEdgeFace(mris,fno,face->v[2],face->v[0]);
    n_e2[0]=face->nx+mris->faces[fn1].nx;
    n_e2[1]=face->ny+mris->faces[fn1].ny;
    n_e2[2]=face->nz+mris->faces[fn1].nz;

    /* vertex pseudo-normals */
    computeVertexPseudoNormal(mris,face->v[0],n_v0,dp->verbose_mode);
    computeVertexPseudoNormal(mris,face->v[1],n_v1,dp->verbose_mode);
    computeVertexPseudoNormal(mris,face->v[2],n_v2,dp->verbose_mode);

    /* finding distance to surface */
#if 1
    for ( k = kmin ; k <= kmax ;  k++ )
      for ( j = jmin ; j <= jmax ; j++ )
        for ( i = imin ; i <= imax ; i++ )
        {
#else
    for ( k = 0 ; k <= mri_distance->depth-1 ;  k++ )
      for ( j = 0 ; j <=  mri_distance->height-1; j++ )
        for ( i = 0 ; i <=  mri_distance->width-1; i++ )
        {
#endif

          x=xSURF(mri_defect,i);
          y=ySURF(mri_defect,j);
          z=zSURF(mri_defect,k);

          vec0[0]=x-x0;
          vec0[1]=y-y0;
          vec0[2]=z-z0;
          vec1[0]=x-x1;
          vec1[1]=y-y1;
          vec1[2]=z-z1;
          vec2[0]=x-x2;
          vec2[1]=y-y2;
          vec2[2]=z-z2;
          vec[0]=(vec0[0]+vec1[0]+vec2[0])/3.0;
          vec[1]=(vec0[1]+vec1[1]+vec2[1])/3.0;
          vec[2]=(vec0[2]+vec1[2]+vec2[2])/3.0;

          /* compute distance to face */
          /* where is the point */
          val0=F_DOT(vec0,n0);
          val1=F_DOT(vec1,n1);
          val2=F_DOT(vec2,n2);

          if ((val0>=0) && (val1>=0) && (val2>=0))
          {
            /* the projection of the vertex is inside */
            val=F_DOT(n_f,vec);
            valu=1;
            sign=val;
            distance=val; /* n_f is already normalized */
          }
          else
          {
            distance=NPY;
            sign=0;
            valu=0;

            if (val0<=0)
            {
              /* compute distance to edge0 */
              val=F_DOT(vec0,e0);
              if (val<0)
              {
                /* closer to x0 */
                sign=F_DOT(n_v0,vec0);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec0));
              }
              else if (val<SQR3(e0))
              {
                /* closer to edge0 */
                sign=F_DOT(n_e0,vec0);
                valu=3;
                distance=SIGN(sign)*MIN(fabs(distance),
                                        sqrt(MAX(0,SQR3(vec0)-
                                                 SQR(val)/SQR3(e0))));
              }
              else
              {
                /* closer to x1 */
                sign=F_DOT(n_v1,vec1);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec1));
              }
            };
            if (val1<=0)
            {
              val=F_DOT(vec1,e1);
              if (val<0)
              {
                /* closer to x1 */
                sign=F_DOT(n_v1,vec1);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec1));
              }
              else if (val<SQR3(e1))
              {
                /* closer to edge1 */
                sign=F_DOT(n_e1,vec1);
                valu=3;
                distance=SIGN(sign)*MIN(fabs(distance),
                                        sqrt(MAX(0,SQR3(vec1)-
                                                 SQR(val)/SQR3(e1))));
              }
              else
              {
                /* closer to x2 */
                sign=F_DOT(n_v2,vec2);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec2));
              }
            };
            if (val2<=0)
            {
              val=F_DOT(vec2,e2);
              if (val<0)
              {
                /* closer to x2 */
                sign=F_DOT(n_v2,vec2);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec2));
              }
              else if (val<SQR3(e2))
              {
                /* closer to edge2 */
                sign=F_DOT(n_e2,vec2);
                valu=3;
                distance=SIGN(sign)*MIN(fabs(distance),
                                        sqrt(MAX(0,SQR3(vec2)-
                                                 SQR(val)/SQR3(e2))));
              }
              else
              {
                /* closer to x0 */
                sign=F_DOT(n_v0,vec0);
                valu=2;
                distance=SIGN(sign)*MIN(fabs(distance),NORM3(vec0));
              }
            };
          }

          /* update distance map */
          if (fabs(distance)<fabs(MRIFvox(mri_distance,i,j,k)))
          {
            MRIFvox(mri_distance,i,j,k)=distance;
#if DEBUG_UL
            MRIFvox(mri_debug1,i,j,k)=fabs(distance);//sign;
            MRIFvox(mri_debug3,i,j,k)=(float)valu;
#endif
          }
        }
  }

#if 0
  /* mark the surface voxels */
  for ( k = 0 ; k < mris->nfaces ; k++)
  {
    //tp->nfaces ; k++){
    fno=k;//tp->faces[k];
    // calculate three vertices
    x0 =mris->vertices[mris->faces[fno].v[0]].origx;
    y0 =mris->vertices[mris->faces[fno].v[0]].origy;
    z0 =mris->vertices[mris->faces[fno].v[0]].origz;
    x1 =mris->vertices[mris->faces[fno].v[1]].origx;
    y1 =mris->vertices[mris->faces[fno].v[1]].origy;
    z1 =mris->vertices[mris->faces[fno].v[1]].origz;
    x2 =mris->vertices[mris->faces[fno].v[2]].origx;
    y2 =mris->vertices[mris->faces[fno].v[2]].origy;
    z2 =mris->vertices[mris->faces[fno].v[2]].origz;
    // calculate the sides
    d0 = mri_defect->xsize*sqrt(SQR(x1-x0)+SQR(y1-y0)+SQR(z1-z0));
    d1 = mri_defect->ysize*sqrt(SQR(x2-x1)+SQR(y2-y1)+SQR(z2-z1));
    d2 = mri_defect->zsize*sqrt(SQR(x0-x2)+SQR(y0-y2)+SQR(z0-z2));

    //fprintf(WHICH_OUTPUT,"(%f,%f,%f)and (%f,%f,%f)",x0,x1,x2,d0,d1,mri_defect->xsize);

    dmax = (d0>=d1&&d0>=d2)?d0:(d1>=d0&&d1>=d2)?d1:d2;

    numu = (int)(ceil(2*d0));
    numv = (int)(ceil(2*dmax));

    for ( v = 0 ; v <= numv ; v++ )
    {
      px0 = x0 + (x2-x0)*v/numv;
      py0 = y0 + (y2-y0)*v/numv;
      pz0 = z0 + (z2-z0)*v/numv;
      px1 = x1 + (x2-x1)*v/numv;
      py1 = y1 + (y2-y1)*v/numv;
      pz1 = z1 + (z2-z1)*v/numv;
      for ( u = 0 ; u <= numu ; u++ )
      {
        px = px0 + (px1-px0)*u/numu;
        py = py0 + (py1-py0)*u/numu;
        pz = pz0 + (pz1-pz0)*u/numu;

        //    fprintf(WHICH_OUTPUT,"(%f,%f,%f) ",px,py,pz);

        i=iVOL(mri_defect,px);
        j=jVOL(mri_defect,py);
        p=kVOL(mri_defect,pz);

        if ((i<0)||(i>=mri_defect->width)||
            (j<0)||(j>=mri_defect->height)||
            (p<0)||(p>=mri_defect->depth))
        {
          continue;
        }

        //    fprintf(WHICH_OUTPUT,"(%d,%d,%d) ",i,j,p);
#if DEBUG_UL
        MRIFvox(mri_debug2,i,j,p)=100;
#endif
        MRIFvox(mri_distance,i,j,p) = 0;
      }
    }
  }
#endif

#if DEBUG_UL
  for ( k = 0 ; k <= mri_distance->depth-1 ;  k++ )
    for ( j = 0 ; j <=  mri_distance->height-1; j++ )
      for ( i = 0 ; i <=  mri_distance->width-1; i++ )
      {
        //  MRIFvox(mri_debug1,i,j,k)=fabs(MRIFvox(mri_distance,i,j,k));
        if (MRIFvox(mri_debug2,i,j,k)<100)
        {
          MRIFvox(mri_debug2,i,j,k)=6;  /* not processed yet*/
        }
        if (MRIFvox(mri_distance,i,j,k)>0)
        {
          if (MRIFvox(mri_distance,i,j,k)<100)
          {
            MRIFvox(mri_debug2,i,j,k)=4;  /* outside */
          }
        }
        else if (MRIFvox(mri_distance,i,j,k)<0)
        {
          MRIFvox(mri_debug2,i,j,k)=2;  /* inside */
        }

      }

#endif


#if 0

#define NOT_DEFINED 5.0
#define AMBIGUOUSV 10.0
#define SIGNV 20.0

  MRIwrite(mri_distance,"./tmp1/distance.mgh");

  fprintf(WHICH_OUTPUT,"expanding sign image...");

  for ( k = 0 ; k <= mri_distance->depth-1 ;  k++ )
    for ( j = 0 ; j <=  mri_distance->height-1; j++ )
      for ( i = 0 ; i <=  mri_distance->width-1; i++ )
      {
        val=MRIFvox(mri_distance,i,j,k);
        if (val>100)
        {
          continue;
        }
        if (val>0)
        {
          MRIFvox(mri_distance,i,j,k)=SIGNV;
        }
        if (val<0)
        {
          MRIFvox(mri_distance,i,j,k)=-SIGNV;
        }
      }

  changed=1;
  while (changed)
  {
    int ncount=0;
    changed=0;

    for ( k = 3 ; k < mri_distance->depth-3 ;  k++ )
      for ( j = 3 ; j <  mri_distance->height-3; j++ )
        for ( i = 3 ; i <  mri_distance->width-3; i++ )
        {
          if (fabs(MRIFvox(mri_distance,i,j,k))==SIGNV)
          {
            continue;
          }
          signp=0;
          signm=0;
          val=MRIFvox(mri_distance,i+1,j,k);
          if (val<100&&val>15)
          {
            signp=1;
          }
          if (val<-15)
          {
            signm=1;
          }
          val=MRIFvox(mri_distance,i-1,j,k);
          if (val<100&&val>15)
          {
            signp=1;
          }
          if (val<-15)
          {
            signm=1;
          }
          val=MRIFvox(mri_distance,i,j+1,k);
          if (val<100&&val>15)
          {
            signp=1;
          }
          if (val<-15)
          {
            signm=1;
          }
          val=MRIFvox(mri_distance,i,j-1,k);
          if (val<100&&val>15)
          {
            signp=1;
          }
          if (val<-15)
          {
            signm=1;
          }
          val=MRIFvox(mri_distance,i,j,k+1);
          if (val<100&&val>15)
          {
            signp=1;
          }
          if (val<-15)
          {
            signm=1;
          }
          val=MRIFvox(mri_distance,i,j,k-1);
          if (val<100&&val>15)
          {
            signp=1;
          }
          if (val<-15)
          {
            signm=1;
          }

          if (signp==0 && signm==1)
          {
            MRIFvox(mri_distance,i,j,k)=-AMBIGUOUSV;
            changed=1;
          }
          if (signp==1 && signm==0)
          {
            MRIFvox(mri_distance,i,j,k)=AMBIGUOUSV;
            changed=1;
          }
          if (signp==1 && signm==1)
          {
            MRIFvox(mri_distance,i,j,k)=NOT_DEFINED;
          }
        }

    for ( k = 1 ; k < mri_distance->depth-1 ;  k++ )
      for ( j = 1 ; j <  mri_distance->height-1; j++ )
        for ( i = 1 ; i <  mri_distance->width-1; i++ )
        {
          val=MRIFvox(mri_distance,i,j,k);
          if (val == AMBIGUOUSV)
          {
            MRIFvox(mri_distance,i,j,k)=SIGNV;
            ncount++;
          }
          if (val == -AMBIGUOUSV)
          {
            MRIFvox(mri_distance,i,j,k)=-SIGNV;
            ncount++;
          }
        }
    fprintf(WHICH_OUTPUT,"\n%d voxels",ncount);
  }

  /*  for( k = 0 ; k <= mri_distance->depth-1 ;  k++ )
      for ( j = 0 ; j <=  mri_distance->height-1; j++ )
      for ( i = 0 ; i <=  mri_distance->width-1; i++ )
      if(MRIFvox(mri_distance,i,j,k)>100)
      MRIFvox(mri_distance,i,j,k)=1;
  */
  fprintf(WHICH_OUTPUT,"done\nsaving image \n");
#endif

#if DEBUG_UL
  MRIwrite(mri_distance,"./tmp1/sign.mgh");
  MRIwrite(mri_debug1,"./tmp1/debug1.mgh");
  MRIwrite(mri_debug2,"./tmp1/debug2.mgh");
  MRIwrite(mri_debug3,"./tmp1/debug3.mgh");
  MRIwrite(mri_defect,"./tmp1");
  MRIwrite(mri_intensity,"./tmp1/int.mgh");

  {
    static int counter=0;
    counter++;
    if (counter==1)
      ErrorExit
      (ERROR_BADPARM,
       "mrisComputeDefectMRILogUnlikelihood: SHOULD NOT HAPPEN\n");
  }
#endif

  /* compute the volumeLikelihood */
  /* init log values */
  white_ll=dp->defect->white_mean_ll;
  gray_ll=dp->defect->gray_mean_ll;
  nwhite=1;
  ngray=1;
  max_distance=0.0;
  int_g = dp->defect->gray_mean;
  int_w = dp->defect->white_mean;
  for ( k = 3 ; k < mri_distance->depth-3 ;  k++ )
    for ( j = 3 ; j <  mri_distance->height-3; j++ )
      for ( i = 3 ; i <  mri_distance->width-3; i++ )
      {
        if (!MRIvox(mri_defect,i,j,k))
        {
          continue;
        }
        val=MRIFvox(mri_distance,i,j,k);
        if (val==NPY)
        {
          continue;
        }
        if (fabs(val)>max_distance)
        {
          max_distance=fabs(val);
        }

        if (val>0.5)
        {
          /* gray matter */
          gray_ll+=MRIFvox(mri_gray,i,j,k);
          int_g += MRIvox(mri_defect,i,j,k);
          ngray++;
        }
        if (val<-0.5)
        {
          white_ll+=MRIFvox(mri_white,i,j,k);
          int_w += MRIvox(mri_defect,i,j,k);
          nwhite++;
        }
      }
  if (nwhite)
  {
    white_ll/=nwhite;
    int_w /= nwhite;
  }
  if (ngray)
  {
    gray_ll/=ngray;
    int_g /= ngray;
  }
  // fs_topo_fixer_test
  //  fprintf(stderr,"UNMRI : gray = %f - white = %f  \n",int_g,int_w);
  //  fprintf(WHICH_OUTPUT,
  // " volume= %3.3f: white (%3.3f, %d) - gray (%3.3f, %d)\n",
  //                  white_ll+gray_ll,white_ll,nwhite,gray_ll,ngray);

  {
    int vno;
    DEFECT *defect;
    VERTEX *vertex;

    max_distance=MIN(2.0f,MAX(1.0f,max_distance));

    defect=dp->defect;
    for (p = 0 ; p < defect->nvertices ; p++)
    {
      if (defect->status[p]==DISCARD_VERTEX)
      {
        continue;
      }
      vno=defect->vertex_trans[defect->vertices[p]];
      vertex = &mris->vertices[vno] ;

      i=iVOL(mri_defect,vertex->fx);
      j=jVOL(mri_defect,vertex->fy);
      k=kVOL(mri_defect,vertex->fz);

      if ((i<0) || (i>=mri_defect->width) ||
          (j<0) || (j>=mri_defect->height) ||
          (k<0) || (k>=mri_defect->depth))
      {
        continue;
      }

      //fprintf(WHICH_OUTPUT,"*%d-%d-%d");
      val=MRIFvox(mri_distance,i,j,k);

      //FLO : max_distance=MIN(2.0f, max_distance) ?
      if (val==NPY)
      {
        val=1.0f;
      }
      else
      {
        val=fabs(val)/max_distance;
      }

      val=MIN(1.0f,val);

      vertex->curvbak *= val;

    }
  }

  dp->tp.unmri_ll=(white_ll+gray_ll);

  return (white_ll+gray_ll);
}


static double
mrisComputeDefectCurvatureLogLikelihood
(MRI_SURFACE *mris, TP *tp,HISTOGRAM *h_k1, HISTOGRAM *h_k2,MRI *mri_k1_k2)
{
  double   v_ll,total_ll = 0.0 ,new_total;
  int      i,vno,bin,bink1,bink2;
  VERTEX   *v ;
  double t_area,tc_area;

  new_total=0.0;

  t_area=tc_area=0.0;

  /* compute faces only for modified vertices */
  for (i = 0 ; i < tp->nvertices ; i++)
  {
    vno=tp->vertices[i];
    v = &mris->vertices[vno] ;

    bin = nint((v->k1-h_k1->bins[0]) / h_k1->bin_size) ;
    if (bin < 0)
    {
      bin = 0 ;
    }
    else if (bin >= h_k1->nbins)
    {
      bin = h_k1->nbins-1 ;
    }
    v_ll = log(h_k1->counts[bin]) ;

    total_ll += v_ll;

    bin = nint((v->k2-h_k2->bins[0]) / h_k2->bin_size) ;
    if (bin < 0)
    {
      bin = 0 ;
    }
    else if (bin >= h_k2->nbins)
    {
      bin = h_k2->nbins-1 ;
    }
    v_ll += log(h_k2->counts[bin]) ;

    total_ll += v_ll;

    bink1=MIN(mri_k1_k2->width-1 ,
              MAX(0,(int)((v->k1 - mri_k1_k2->xstart) / mri_k1_k2->xsize))) ;
    bink2=MIN(mri_k1_k2->height-1,
              MAX(0,(int)((v->k2 - mri_k1_k2->ystart) / mri_k1_k2->ysize))) ;

    new_total += log(MRIFvox(mri_k1_k2,bink1,bink2,0));

    t_area += v->area;
    tc_area += v->area* log(MRIFvox(mri_k1_k2,bink1,bink2,0));

  }
  if (tp->nvertices)
  {
    new_total /= (double)tp->nvertices;
  }

  if (tp->nvertices)
  {
    tp->qcurv_ll=total_ll/(double)tp->nvertices;
    tp->qcll=tc_area/t_area;
  }
  else
  {
    tp->qcll=0.0;
    tp->qcurv_ll=0.0;
  }

  tp->qcurv_ll=new_total; /* using mri_k1_k2 */

  return tp->qcurv_ll ;
}

static double
mrisComputeDefectNormalDotLogLikelihood
(MRI_SURFACE *mris, TP *tp, HISTOGRAM *h_dot)
{
  double   v_ll,total_ll = 0.0, nx, ny, nz, x, y, z, dx, dy, dz, dot ;
  int      vno, n, i, bin ;
  VERTEX   *v, *vn ;
  double t_area,tc_area;

  t_area=tc_area=0.0;

  /* compute faces only for modified vertices */
  for (i = 0 ; i < tp->nvertices ; i++)
  {
    vno=tp->vertices[i];
    v = &mris->vertices[vno] ;

    x = v->origx ;
    y = v->origy ;
    z = v->origz ;

    nx = v->nx;
    ny = v->ny;
    nz = v->nz;

    for (v_ll = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dx = vn->origx - x ;
      dy = vn->origy - y ;
      dz = vn->origz - z ;
      dot = dx*nx + dy*ny + dz*nz ;

      bin = nint((dot-h_dot->bins[0]) / h_dot->bin_size) ;
      if (bin < 0)
      {
        bin = 0 ;
      }
      else if (bin >= h_dot->nbins)
      {
        bin = h_dot->nbins-1 ;
      }

      v_ll += log(h_dot->counts[bin]) ;
    }
    total_ll += v_ll / v->vnum ;
    t_area += v->area;
    tc_area += v->area*v_ll/v->vnum;
  }

  if (tp->nvertices)
  {
    tp->cll = tc_area / t_area;
    tp->curv_ll=total_ll/(double)tp->nvertices;
  }
  else
  {
    tp->cll = 0.0;
    tp->curv_ll=0.0;
  }

  return tp->curv_ll;
}

#if 0
#include "tritri.h"
static int
mrisComputeDefectVertexNormal
(MRI_SURFACE *mris, int vno, double *pnx, double *pny, double *pnz)
{
  VERTEX  *v, *vn ;
  int     n ;
  double  a0[3], an[3], ac0[3], acn[3],
          a_cross[3], ac_cross[3], dot, xc[3], nx, ny, nz,
          ax, ay, az, len ;

  v = &mris->vertices[vno] ;
  if (v->vnum < 2)
  {
    *pnx = *pny = *pnz = 0 ;
    return(ERROR_BADPARM) ;
  }

  /* in original space */
  vn = &mris->vertices[v->v[0]] ;
  ax = vn->origx - v->origx ;
  ay = vn->origy - v->origy ;
  az = vn->origz - v->origz ;
  a0[0] = ax ;
  a0[1] = ay ;
  a0[2] = az ;

  /* on sphere */
  ax = vn->cx - v->cx ;
  ay = vn->cy - v->cy ;
  az = vn->cz - v->cz ;
  ac0[0] = ax ;
  ac0[1] = ay ;
  ac0[2] = az ;

  xc[0] = v->cx ;
  xc[1] = v->cy ;
  xc[2] = v->cz ;   /* vector for orienting cross products */

  nx = ny = nz = 0.0 ;
  for (n = 1 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;

    /* do original surface */
    ax = vn->origx - v->origx ;
    ay = vn->origy - v->origy ;
    az = vn->origz - v->origz ;
    an[0] = ax ;
    an[1] = ay ;
    an[2] = az ;
    CROSS(a_cross, a0, an) ;

    /* do it on sphere, to orient things */
    ax = vn->cx - v->cx ;
    ay = vn->cy - v->cy ;
    az = vn->cz - v->cz ;
    acn[0] = ax ;
    acn[1] = ay ;
    acn[2] = az ;
    CROSS(ac_cross, ac0, acn) ;
    dot = DOT(ac_cross, xc) ;
    if (dot < 0)
    {
      a_cross[0] *= -1 ;
      a_cross[1] *= -1 ;
      a_cross[2] *= -1 ;
    }
    nx += a_cross[0] ;
    ny += a_cross[1] ;
    nz += a_cross[2] ;
  }

  len = sqrt(nx*nx + ny*ny + nz*nz) ;
  if (FZERO(len))
  {
    len = 1 ;
  }
  nx /= len ;
  ny /= len ;
  nz /= len ;
  *pnx = nx ;
  *pny = ny ;
  *pnz = nz ;
  return(NO_ERROR) ;
}

static double
mrisComputeDefectNormalDotLogLikelihood
(MRI_SURFACE *mris, DEFECT *defect, int *vertex_trans, HISTOGRAM *h_dot)
{
  double   total_ll = 0.0, nx, ny, nz, x, y, z, dx, dy, dz, ll, dot ;
  int      vno, n, i, bin, nvertices ;
  VERTEX   *v, *vn ;

  for (nvertices = i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    if (i < defect->nvertices)
    {
      vno = vertex_trans[defect->vertices[i]] ;
    }
    else
    {
      vno = vertex_trans[defect->border[i-defect->nvertices]] ;
    }
    if (vno < 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->vnum <= 0)
    {
      continue ;
    }

    nvertices++ ;
    mrisComputeDefectVertexNormal(mris, vno, &nx, &ny, &nz) ;
    x = v->origx ;
    y = v->origy ;
    z = v->origz ;
    for (ll = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dx = vn->origx - x ;
      dy = vn->origy - y ;
      dz = vn->origz - z ;
      dot = dx*nx + dy*nz * dz*nz ;
      bin = nint((dot-h_dot->bins[0]) / h_dot->bin_size) ;
      if (bin < 0)
      {
        bin = 0 ;
      }
      else if (bin >= h_dot->nbins)
      {
        bin = h_dot->nbins-1 ;
      }
      ll += log(h_dot->counts[bin]) ;
    }
    total_ll += ll / v->vnum ;
    if (!finite(total_ll))
    {
      DiagBreak() ;
    }
  }

  return(total_ll/*/(float)nvertices*/) ;
}

static double
mrisComputeDefectMRILogUnlikelihood
(MRI_SURFACE *mris, MRI *mri, DEFECT_PATCH *dp,
 int *vertex_trans, HISTOGRAM *h_border)
{
  double dx, dy, dz, d, len, ll, total_ll ;
  int    i, nedges = 0, nsamples ;
  VERTEX *v, *vn ;
  double   val, xv, yv, zv, x, y, z ;
  EDGE    *edge ;
  EDGE_TABLE *etable = dp->etable ;

  for (total_ll = 0.0, i = 0 ; i < dp->nedges ; i++)
  {
    edge = &etable->edges[i] ;
    if (edge->used)   /* only count edges not in current tessellation */
    {
      continue ;
    }
    v = &mris->vertices[edge->vno1] ;
    vn = &mris->vertices[edge->vno2] ;

    if (v->ripflag || vn->ripflag)
    {
      continue ;
    }

    if (edge->vno1 == Gdiag_no || edge->vno2 == Gdiag_no)
    {
      DiagBreak() ;
    }
    nedges++ ;

    /* sample MR values along line and build estimate of log likelihood
       as distance.
    */

    /* traverse the edge connecting the two
       vertices in equal increments, sampling
       MRI volume outside and inside */
    dx = vn->origx - v->origx ;
    dy = vn->origy - v->origy ;
    dz = vn->origz - v->origz ;
    len = sqrt(dx*dx + dy*dy + dz*dz) ;
    len = .5 / len ;  /* sample every 1/2 mm */
    if (len > 1)
    {
      len = 1 ;
    }

    ll = 0.0 ;
    for (nsamples = 0, d = 0 ; d <= 1 ; d += len, nsamples++)
    {
      x = v->origx+d*dx ;
      y = v->origy+d*dy ;
      z = v->origz+d*dz ;
      //MRIworldToVoxel(mri, x, y, z, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x,y,z,&xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &val) ;
      ll += log(1-h_border->counts[nint(val)]) ;
    }

    if (!finite(ll))
    {
      DiagBreak() ;
    }
    total_ll += ll / (float)nsamples ;
  }
  return(total_ll/*/(double)nedges*/) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeDefectTangentPlanes
(MRI_SURFACE *mris, DEFECT *defect, int *vertex_trans)
{
  VECTOR  *v_n, *v_e1, *v_e2, *v ;
  int     vno, i ;
  VERTEX  *vertex ;
  double  nx, ny, nz ;

  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_e1 = VectorAlloc(3, MATRIX_REAL) ;
  v_e2 = VectorAlloc(3, MATRIX_REAL) ;
  v = VectorAlloc(3, MATRIX_REAL) ;

  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    if (i < defect->nvertices)
    {
      vno = vertex_trans[defect->vertices[i]] ;
    }
    else
    {
      vno = vertex_trans[defect->border[i-defect->nvertices]] ;
    }
    if (vno < 0)
    {
      continue ;
    }
    vertex = &mris->vertices[vno] ;
    mrisComputeDefectVertexNormal(mris, vno, &nx, &ny, &nz) ;
    vertex->nx = nx ;
    vertex->ny = ny ;
    vertex->nz = nz ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    VECTOR_LOAD(v_n, vertex->nx, vertex->ny, vertex->nz) ;
    /* now find some other non-parallel vector */
#if 0
    if (!FZERO(vertex->nx) || !FZERO(vertex->ny))
    {
      VECTOR_LOAD(v, 0.0, 0.0, 1.0) ;
    }
    else
    {
      VECTOR_LOAD(v, 0.0, 1.0, 0.0) ;
    }
#else
    VECTOR_LOAD(v, vertex->ny, vertex->nz, vertex->nx) ;
#endif
    V3_CROSS_PRODUCT(v_n, v, v_e1) ;
    if (VectorLen(v_e1) < .001)  /* happened to pick a parallel vector */
    {
      VECTOR_LOAD(v, vertex->ny, -vertex->nz, vertex->nx) ;
      V3_CROSS_PRODUCT(v_n, v, v_e1) ;
    }

    if ((V3_LEN_IS_ZERO(v_e1)) &&
        DIAG_VERBOSE_ON)  /* happened to pick a parallel vector */
    {
      fprintf(stdout, "vertex %d: degenerate tangent plane\n", vno) ;
    }
    V3_CROSS_PRODUCT(v_n, v_e1, v_e2) ;
    V3_NORMALIZE(v_e1, v_e1) ;
    V3_NORMALIZE(v_e2, v_e2) ;
    vertex->e1x = V3_X(v_e1) ;
    vertex->e2x = V3_X(v_e2) ;
    vertex->e1y = V3_Y(v_e1) ;
    vertex->e2y = V3_Y(v_e2) ;
    vertex->e1z = V3_Z(v_e1) ;
    vertex->e2z = V3_Z(v_e2) ;
  }

  VectorFree(&v) ;
  VectorFree(&v_n) ;
  VectorFree(&v_e1) ;
  VectorFree(&v_e2) ;
  return(NO_ERROR) ;
}

static double
mrisComputeDefectCurvatureLogLikelihood
(MRI_SURFACE *mris, DEFECT *defect, int *vertex_trans,
 HISTOGRAM *h_k1, HISTOGRAM *h_k2)
{
  double   total_ll = 0.0 ;
  int      vno, i ;
  VERTEX   *v ;
  int      nbrs[MAX_NBRS], num_nbrs, bin ;

  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
  /*    MRIScomputeMetricProperties(mris) ;*/

  mrisComputeDefectTangentPlanes(mris, defect, vertex_trans) ;
  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    if (i < defect->nvertices)
    {
      vno = vertex_trans[defect->vertices[i]] ;
    }
    else
    {
      vno = vertex_trans[defect->border[i-defect->nvertices]] ;
    }
    if (vno < 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->vnum <= 0)
    {
      continue ;
    }
    mrisFindSecondNeighborhood(mris, vno, nbrs, &num_nbrs) ;
    if (num_nbrs < 3)
    {
      continue ;
    }
    MRIScomputeSecondFundamentalFormAtVertex(mris, vno, nbrs, num_nbrs) ;
    bin = nint((v->k1-h_k1->bins[0]) / h_k1->bin_size) ;
    if (bin < 0)
    {
      bin = 0 ;
    }
    else if (bin >= h_k1->nbins)
    {
      bin = h_k1->nbins-1 ;
    }
    total_ll += log(h_k1->counts[bin]) ;
    bin = nint((v->k2-h_k2->bins[0]) / h_k2->bin_size) ;
    if (bin < 0)
    {
      bin = 0 ;
    }
    else if (bin >= h_k2->nbins)
    {
      bin = h_k2->nbins-1 ;
    }
    total_ll += log(h_k2->counts[bin]) ;
    if (!finite(total_ll))
    {
      DiagBreak() ;
    }
  }

  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  return(total_ll) ;
}

static float mrisDefectFaceMRILogLikelihood
(MRI_SURFACE *mris, int vno1, int vno2,
 int vno3, MRI *mri, DEFECT *defect,
 HISTOGRAM *h_white, HISTOGRAM *h_gray,
 HISTOGRAM *h_grad, MRI *mri_gray_white) ;
static float
mrisDefectFaceMRILogLikelihood
(MRI_SURFACE *mris, int vno0, int vno1, int vno2,
 MRI *mri, DEFECT *defect, HISTOGRAM *h_white,
 HISTOGRAM *h_gray, HISTOGRAM *h_grad, MRI *mri_gray_white)
{
  double   x, y, z, xa, ya, za, xc, yc, zc, t0,
           t1, adx, ady, adz, dx, dy, dz, grad,
           cdx, cdy, cdz, alen, clen, delta_t0, delta_t1, len, nx, ny, nz, xv, yv, zv,
           white_val, gray_val, cnx, cny, cnz, dot, val ;
  double ll = 0.0, jll = 0.0 ;
  int    bin, nsamples ;
  VERTEX *v0, *v1, *v2 ;
  float   l0[3],l1[3];


  v0 = &mris->vertices[vno0] ;
  v1 = &mris->vertices[vno1] ;
  v2 = &mris->vertices[vno2] ;
  l0[0] = v0->origx - v1->origx;
  l0[1] = v0->origy - v1->origy;
  l0[2] = v0->origz - v1->origz;
  l1[0] = v2->origx - v0->origx;
  l1[1] = v2->origy - v0->origy;
  l1[2] = v2->origz - v0->origz;
  mrisNormalize(l0);
  mrisNormalize(l1);
  nx = -l1[1]*l0[2] + l0[1]*l1[2];
  ny = l1[0]*l0[2] - l0[0]*l1[2];
  nz = -l1[0]*l0[1] + l0[0]*l1[1];
  alen = nx*nx + ny*nz + nz*nz ;
  if (FZERO(alen))
  {
    alen = 1 ;
  }
  nx /= alen ;
  ny /= alen ;
  nz /= alen ;

  /* now use sphere to orient normal vector */
  l0[0] = v0->cx - v1->cx;
  l0[1] = v0->cy - v1->cy;
  l0[2] = v0->cz - v1->cz;
  l1[0] = v2->cx - v0->cx;
  l1[1] = v2->cy - v0->cy;
  l1[2] = v2->cz - v0->cz;
  mrisNormalize(l0);
  mrisNormalize(l1);
  cnx = -l1[1]*l0[2] + l0[1]*l1[2];
  cny = l1[0]*l0[2] - l0[0]*l1[2];
  cnz = -l1[0]*l0[1] + l0[0]*l1[1];
  dot = v0->cx*cnx + v0->cy*cny + v0->cz*cnz ;
  if (dot < 0)
  {
    nx *= -1 ;
    ny *= -1 ;
    nz *= -1 ;
  }

  adx = v1->x - v0->x ;
  ady = v1->y - v0->y ;
  adz = v1->z - v0->z ;
  alen = sqrt(SQR(adx)+SQR(ady)+SQR(adz)) ;
  cdx = v2->x - v0->x ;
  cdy = v2->y - v0->y ;
  cdz = v2->z - v0->z ;
  clen = sqrt(SQR(cdx)+SQR(cdy)+SQR(cdz)) ;

  /*
    sample along legs of the triangle making sure the maximum spacing
    between samples (along the longer leg) is SAMPLE_DIST.
  */

  /*
    move along v0->v1 and v3->v2 lines and draw in crossing line to fill face
    t0 parameterizes lines from v0->v1 and v0->v2
  */
  if (FZERO(alen) && FZERO(clen))
  {
    delta_t0 = 0.99 ;
  }
  else
  {
    delta_t0 = (alen > clen) ? (SAMPLE_DIST / alen) : (SAMPLE_DIST / clen ) ;
  }
  if (FZERO(delta_t0))
    ErrorReturn
    (ERROR_BADPARM,
     (ERROR_BADPARM,
      "mrisDefectFaceMRILogLikelihood: face has infinite leg (%d, %d)\n",
      alen, clen)) ;

  if (delta_t0 >= 1.0)
  {
    delta_t0 = 0.99 ;
  }

  /* delta_t0 is % of alen or clen (whichever is bigger) of SAMPLE_DIST */
  for (nsamples = 0, ll = 0.0f, t0 = 0 ; t0 <= 1.0f ; t0 += delta_t0)
  {
    /* compute points (xa,ya,za) and (xc,yc,zc) on the a and c lines resp. */
    xa = v0->x + t0*adx ;
    ya = v0->y + t0*ady ;
    za = v0->z + t0*adz ;
    xc = v0->x + t0*cdx ;
    yc = v0->y + t0*cdy ;
    zc = v0->z + t0*cdz ;
    dx = xc-xa ;
    dy = yc-ya ;
    dz = zc-za ;
    len = sqrt(SQR(dx)+SQR(dy)+SQR(dz)) ;
    if (FZERO(len))
    {
      delta_t1 = 0.99 ;
    }
    else
    {
      delta_t1 = SAMPLE_DIST / len ;  /* sample at SAMPLE_DIST intervals */
      if (delta_t1 >= 1.0f)
      {
        delta_t1 = 0.99 ;
      }
    }

    /* now draw a line from (xa,ya,za) to (xc, yc, zc) */
    for (t1 = 0 ; t1 <= 1.0f ; t1 += delta_t1, nsamples++)
    {
      /* compute a point on the line connecting a and c */
      x = xa + t1*dx ;
      y = ya + t1*dy ;
      z = za + t1*dz ;
      // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;
      ll += log(h_gray->counts[nint(gray_val)]) ;
      // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &white_val) ;
      ll += log(h_white->counts[nint(white_val)]) ;
      grad = white_val - gray_val ;
      bin = nint((grad-h_grad->bins[0]) / h_grad->bin_size) ;
      if (bin < 0)
      {
        bin = 0 ;
      }
      else if (bin >= h_grad->nbins)
      {
        bin = h_grad->nbins-1 ;
      }
      ll += log(h_grad->counts[bin]) ;
      MRIsampleVolume(mri_gray_white, white_val, gray_val, 0, &val) ;
      jll += log(val) ;
    }
    /* compute last point on line */
    t1 = 1.0f ;
    x = xa + t1*dx ;
    y = ya + t1*dy ;
    z = za + t1*dz ;
    // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;
    ll += log(h_gray->counts[nint(gray_val)]) ;
    // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &white_val) ;
    ll += log(h_white->counts[nint(white_val)]) ;
    grad = white_val - gray_val ;
    bin = nint((grad-h_grad->bins[0]) / h_grad->bin_size) ;
    if (bin < 0)
    {
      bin = 0 ;
    }
    else if (bin >= h_grad->nbins)
    {
      bin = h_grad->nbins-1 ;
    }
    ll += log(h_grad->counts[bin]) ;
    nsamples++ ;
    MRIsampleVolume(mri_gray_white, white_val, gray_val, 0, &val) ;
    jll += log(val) ;
  }

  /* compute last line on the a and c lines resp. */
  t0 = 1.0f ;
  xa = v0->x + t0*adx ;
  ya = v0->y + t0*ady ;
  za = v0->z + t0*adz ;
  xc = v0->x + t0*cdx ;
  yc = v0->y + t0*cdy ;
  zc = v0->z + t0*cdz ;
  dx = xc-xa ;
  dy = yc-ya ;
  dz = zc-za ;
  len = sqrt(SQR(dx)+SQR(dy)+SQR(dz)) ;
  if (FZERO(len))
  {
    delta_t1 = 0.99 ;
  }
  else
  {
    delta_t1 = SAMPLE_DIST / len ;  /* sample at SAMPLE_DIST intervals */
    if (delta_t1 >= 1.0f)
    {
      delta_t1 = 0.99 ;
    }
  }

  /* now draw a line from (xa,ya,za) to (xc, yc, zc) */
  for (t1 = 0 ; t1 <= 1.0f ; t1 += delta_t1, nsamples++)
  {
    /* compute a point on the line connecting a and c */
    x = xa + t1*dx ;
    y = ya + t1*dy ;
    z = za + t1*dz ;
    // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;
    ll += log(h_gray->counts[nint(gray_val)]) ;
    // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &white_val) ;
    ll += log(h_white->counts[nint(white_val)]) ;
    grad = white_val - gray_val ;
    bin = nint((grad-h_grad->bins[0]) / h_grad->bin_size) ;
    if (bin < 0)
    {
      bin = 0 ;
    }
    else if (bin >= h_grad->nbins)
    {
      bin = h_grad->nbins-1 ;
    }
    ll += log(h_grad->counts[bin]) ;
    MRIsampleVolume(mri_gray_white, white_val, gray_val, 0, &val) ;
    jll += log(val) ;
  }
  /* compute last point on line */
  t1 = 1.0f ;
  x = xa + t1*dx ;
  y = ya + t1*dy ;
  z = za + t1*dz ;
  // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
  mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
  MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
  MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;
  ll += log(h_gray->counts[nint(gray_val)]) ;
  // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
  mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
  MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
  MRIsampleVolume(mri, xv, yv, zv, &white_val) ;
  ll += log(h_white->counts[nint(white_val)]) ;
  grad = white_val - gray_val ;
  bin = nint((grad-h_grad->bins[0]) / h_grad->bin_size) ;
  if (bin < 0)
  {
    bin = 0 ;
  }
  else if (bin >= h_grad->nbins)
  {
    bin = h_grad->nbins-1 ;
  }
  ll += log(h_grad->counts[bin]) ;
  MRIsampleVolume(mri_gray_white, white_val, gray_val, 0, &val) ;
  jll += log(val) ;
  nsamples++ ;

#if 0
  return(ll/nsamples) ;
#else
  return(jll/nsamples) ;
#endif
}


static double
mrisComputeDefectMRILogLikelihood
(MRI_SURFACE *mris, MRI *mri, DEFECT *defect,
 int *vertex_trans, HISTOGRAM *h_white, HISTOGRAM *h_gray,
 HISTOGRAM *h_grad, MRI *mri_gray_white)
{
  double sse = 0.0, nx, ny, nz, n1x, n1y, n1z,
         n2x, n2y, n2z, dx, dy, dz, d, len, total, ll, total_ll, jll, total_jll ;
  int    i, vno, n, nvertices = 0, nsamples, m, vno2, bin ;
  VERTEX *v, *vn ;
  double   white_val, gray_val, val0, wval, gval,
           xv, yv, zv, x, y, z, vtotal, val ;
#if (!SPHERE_INTERSECTION)
  double  origin[3], e0[3], e1[3] ;
#endif
  double grad;
  EDGE    edge ;

  for (total_jll = total_ll = 0.0, i = 0 ;
       i < defect->nvertices+defect->nborder ;
       i++)
  {
    if (i < defect->nvertices)
    {
      vno = vertex_trans[defect->vertices[i]] ;
    }
    else
    {
      vno = vertex_trans[defect->border[i-defect->nvertices]] ;
    }
    if (vno < 0)
    {
      continue ;
    }
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    nvertices++ ;
    mrisComputeDefectVertexNormal(mris, vno, &n1x, &n1y, &n1z) ;
    vtotal = 0.0f ;
    edge.vno1 = vno ;
    for (nsamples = n = 0 ; n < v->vnum ; n++)
    {
      if (((vno == Gdiag_no) && (v->v[n] == Gx)) ||
          ((vno == Gx) && (v->v[n] == Gdiag_no)))
      {
        DiagBreak() ;
      }
      vn = &mris->vertices[v->v[n]] ;
      mrisComputeDefectVertexNormal(mris, v->v[n], &n2x, &n2y, &n2z) ;
      nx = (n1x + n2x) / 2 ;
      ny = (n1y + n2y) / 2 ;
      nz = (n1z + n2z) / 2 ;
      len = sqrt(nx*nx + ny*ny + nz*nz) ;
      if (FZERO(len))
      {
        len = 1 ;
      }
      nx /= len ;
      ny /= len ;
      nz /= len ;

      /* sample MR values along line and build estimate of log likelihood
         as distance.
      */
      val0 = (v->val + vn->val) / 2 ;  /* gray/white border value */
      wval = (v->val2 + vn->val2) / 2 ;  /* white matter mean */
      gval = (v->val2bak + vn->val2bak) / 2 ;  /* gray matter mean */

      /* traverse the edge connecting the two
         vertices in equal increments, sampling
         MRI volume outside and inside */
      dx = vn->origx - v->origx ;
      dy = vn->origy - v->origy ;
      dz = vn->origz - v->origz ;
      len = sqrt(dx*dx + dy*dy + dz*dz) ;
#define SAMPLE_DIST 0.25
      len = SAMPLE_DIST / len ;  /* sample every 1/2 mm */
      if (len > 1)
      {
        len = 1 ;
      }

      jll = ll = total = 0.0 ;
      for (d = 0 ; d <= 1 ; d += len, nsamples++)
      {
        x = v->origx+d*dx ;
        y = v->origy+d*dy ;
        z = v->origz+d*dz ;
        // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
        mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
        MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
        MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;
        /*   ll += log(h_gray->counts[nint(gray_val)]) ;*/
        total += fabs(gray_val-gval) ;
        // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
        mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
        MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
        MRIsampleVolume(mri, xv, yv, zv, &white_val) ;
        total += fabs(white_val-wval) ;
        /*   ll += log(h_white->counts[nint(white_val)]) ;*/
        grad = white_val - gray_val ;
        bin = nint((grad-h_grad->bins[0]) / h_grad->bin_size) ;
        if (bin < 0)
        {
          bin = 0 ;
        }
        else if (bin >= h_grad->nbins)
        {
          bin = h_grad->nbins-1 ;
        }
        /*   ll += log(h_grad->counts[bin]) ;*/
        if (!finite(ll))
        {
          DiagBreak() ;
        }
        MRIsampleVolume(mri_gray_white, white_val, gray_val, 0, &val) ;
        jll += log(val) ;
      }

      /* add one sample from the centroid of any face that will get added */
      edge.vno2 = vno2 = v->v[n] ;
#if (!SPHERE_INTERSECTION)
      mrisComputeCanonicalEdgeBasis(mris, &edge, &edge, origin, e0, e1) ;
#endif
      for (m = 0 ; m < v->vnum ; m++)
      {
        if (v->v[m] == vno2)
        {
          continue ;
        }
        if (vertexNeighbor(mris, vno2, v->v[m]) &&
            !isFace(mris,vno, vno2, v->v[m]) &&
#if SPHERE_INTERSECTION
            !containsAnotherVertexOnSphere
            (mris,vno,vno2,v->v[m],defect->optimal_mapping))
        {
#else
            !containsAnotherVertex(mris,vno,vno2,v->v[m],e0,e1,origin))
        {
#endif

#if 1
          jll += mrisDefectFaceMRILogLikelihood
                 (mris, vno, vno2, v->v[m],
                  mri, defect,
                  h_white, h_gray, h_grad, mri_gray_white) ;
#else
          VERTEX *v0, *v1, *v2 ;
          float  x, y, z ;

          v0 = v ;
          v1 = &mris->vertices[vno2] ;
          v2 = &mris->vertices[v->v[m]] ;
          x = (v1->origx + v2->origx) / 2.0f ;
          y = (v1->origy + v2->origy) / 2.0f ;
          z = (v1->origz + v2->origz) / 2.0f ;

          /* now bisect v0->bisector line */
          x = (v0->origx + x) / 2.0f ;
          y = (v0->origy + y) / 2.0f ;
          z = (v0->origz + z) / 2.0f ;
          nsamples++ ;

          // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
          mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
          MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
          MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;
          ll += log(h_gray->counts[nint(gray_val)]) ;
          total += fabs(gray_val-gval) ;
          // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
          mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
          MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
          MRIsampleVolume(mri, xv, yv, zv, &white_val) ;
          ll += log(h_white->counts[nint(white_val)]) ;
          total += fabs(white_val-wval) ;
          grad = white_val - gray_val ;
          bin = nint((grad-h_grad->bins[0]) / h_grad->bin_size) ;
          if (bin < 0)
          {
            bin = 0 ;
          }
          else if (bin >= h_grad->nbins)
          {
            bin = h_grad->nbins-1 ;
          }
          ll += log(h_grad->counts[bin]) ;
#endif
        }
      }

      if (!finite(total))
      {
        DiagBreak() ;
      }
      vtotal += total / (float)nsamples ;  /* 11 samples */
      total_ll += ll / (float)nsamples ;
      total_jll += jll / (float)nsamples ;
    }
    if (v->vnum == 0)
    {
      continue ;
    }
    sse += (vtotal / (float)v->vnum) ;
  }
#if 0
  return(total_ll/*/(double)nvertices*/) ;
#else
  return(total_jll/*/(double)nvertices*/) ;
#endif
}
#endif


#if 0
static double
mrisComputeDefectMRIEnergy
(MRI_SURFACE *mris, MRI *mri, DEFECT *defect, int *vertex_trans)
{
  double sse = 0.0, nx, ny, nz, n1x, n1y, n1z,
         n2x, n2y, n2z, dx, dy, dz, d, len, total ;
  int    i, vno, n, nvertices = 0, nsamples, m, vno2 ;
  VERTEX *v, *vn ;
  double   val, val0, wval, gval, xv, yv, zv, x, y, z, vtotal ;
#if (!SPHERE_INTERSECTION)
  double  origin[3], e0[3], e1[3] ;
#endif
  EDGE    edge ;

  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    if (i < defect->nvertices)
    {
      vno = vertex_trans[defect->vertices[i]] ;
    }
    else
    {
      vno = vertex_trans[defect->border[i-defect->nvertices]] ;
    }
    if (vno < 0)
    {
      continue ;
    }
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    nvertices++ ;
    mrisComputeDefectVertexNormal(mris, vno, &n1x, &n1y, &n1z) ;
    vtotal = 0.0f ;
    edge.vno1 = vno ;
    for (nsamples = n = 0 ; n < v->vnum ; n++)
    {
      if (((vno == Gdiag_no) && (v->v[n] == Gx)) ||
          ((vno == Gx) && (v->v[n] == Gdiag_no)))
      {
        DiagBreak() ;
      }
      vn = &mris->vertices[v->v[n]] ;
      mrisComputeDefectVertexNormal(mris, v->v[n], &n2x, &n2y, &n2z) ;
      nx = (n1x + n2x) / 2 ;
      ny = (n1y + n2y) / 2 ;
      nz = (n1z + n2z) / 2 ;
      len = sqrt(nx*nx + ny*ny + nz*nz) ;
      if (FZERO(len))
      {
        len = 1 ;
      }
      nx /= len ;
      ny /= len ;
      nz /= len ;

      /* sample MR values along line and build estimate of log likelihood
         as distance.
      */
      val0 = (v->val + vn->val) / 2 ;  /* gray/white border value */
      wval = (v->val2 + vn->val2) / 2 ;  /* white matter mean */
      gval = (v->val2bak + vn->val2bak) / 2 ;  /* gray matter mean */

      /* traverse the edge connecting the two
         vertices in equal increments, sampling
         MRI volume outside and inside */
      dx = vn->origx - v->origx ;
      dy = vn->origy - v->origy ;
      dz = vn->origz - v->origz ;
      len = sqrt(dx*dx + dy*dy + dz*dz) ;
      len = .5 / len ;  /* sample every 1/2 mm */

      total = 0.0 ;
      for (d = 0 ; d <= 1 ; d += len, nsamples++)
      {
        x = v->origx+d*dx ;
        y = v->origy+d*dy ;
        z = v->origz+d*dz ;
        // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
        mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
        MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
        MRIsampleVolume(mri, xv, yv, zv, &val) ;
        total += fabs(val-gval) ;
        // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
        mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
        MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
        MRIsampleVolume(mri, xv, yv, zv, &val) ;
        total += fabs(val-wval) ;
      }

      /* add one sample from the centroid of any face that will get added */
      edge.vno2 = vno2 = v->v[n] ;
#if (!SPHERE_INTERSECTION)
      mrisComputeCanonicalEdgeBasis(mris, &edge, &edge, origin, e0, e1) ;
#endif
      for (m = 0 ; m < v->vnum ; m++)
      {
        if (v->v[m] == vno2)
        {
          continue ;
        }
        if (vertexNeighbor(mris, vno2, v->v[m]) &&
            !isFace(mris,vno, vno2, v->v[m]) &&
#if SPHERE_INTERSECTION
            !containsAnotherVertexOnSphere
            (mris,vno,vno2,v->v[m],defect->optimal_mapping))
        {
#else
            !containsAnotherVertex(mris,vno,vno2,v->v[m],e0,e1,origin))
        {
#endif
          VERTEX *v0, *v1, *v2 ;
          float  x, y, z ;

          v0 = v ;
          v1 = &mris->vertices[vno2] ;
          v2 = &mris->vertices[v->v[m]] ;
          x = (v1->origx + v2->origx) / 2.0f ;
          y = (v1->origy + v2->origy) / 2.0f ;
          z = (v1->origz + v2->origz) / 2.0f ;

          /* now bisect v0->bisector line */
          x = (v0->origx + x) / 2.0f ;
          y = (v0->origy + y) / 2.0f ;
          z = (v0->origz + z) / 2.0f ;
          nsamples++ ;

          // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
          mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
          MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
          MRIsampleVolume(mri, xv, yv, zv, &val) ;
          total += fabs(val-gval) ;
          // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
          mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
          MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
          MRIsampleVolume(mri, xv, yv, zv, &val) ;
          total += fabs(val-wval) ;
        }
      }

      if (!finite(total))
      {
        DiagBreak() ;
      }
      vtotal += total / (float)nsamples ;  /* 11 samples */
    }
    if (v->vnum == 0)
    {
      continue ;
    }
    sse += (vtotal / (float)v->vnum) ;
  }
  return(sse) ;
}
#endif

static double
mrisComputeDefectLogLikelihood
(MRI_SURFACE *mris, MRI *mri, DEFECT_PATCH *dp,
 HISTOGRAM *h_k1, HISTOGRAM *h_k2, MRI *mri_k1_k2,
 HISTOGRAM *h_white, HISTOGRAM *h_gray,
 HISTOGRAM *h_border, HISTOGRAM *h_grad,MRI *mri_gray_white,
 HISTOGRAM *h_dot, TOPOLOGY_PARMS *parms)
{
  static int first_time = 1 ;
  double ll = 0.0 ;

  dp->tp.face_ll=0.0f;
  dp->tp.vertex_ll=0.0f;
  dp->tp.curv_ll=0.0f;
  dp->tp.qcurv_ll=0.0f;
  dp->tp.unmri_ll=0.0f;


  if (first_time)
  {
    l_mri = parms->l_mri ;
    l_unmri = parms->l_unmri ;
    l_curv =  parms->l_curv ;
    l_qcurv = parms->l_qcurv;

    first_time = 0 ;

    /*      if (!FZERO(l_mri))
            fprintf(WHICH_OUTPUT,"l_mri = %2.2f ", l_mri) ;
            if (!FZERO(l_unmri))
            fprintf(WHICH_OUTPUT,"l_unmri = %2.2f ", l_unmri) ;
            if (!FZERO(l_curv))
            fprintf(WHICH_OUTPUT,"l_curv = %2.2f ", l_curv) ;
            if (!FZERO(l_qcurv))
            fprintf(WHICH_OUTPUT,"l_qcurv = %2.2f ", l_qcurv) ;
            fprintf(WHICH_OUTPUT,"\n") ;*/
  }

  if (!FZERO(l_unmri) &&
      (dp->mri_defect->width <=5 ||
       dp->mri_defect->height <= 5 ||
       dp->mri_defect->depth <= 5))
  {
    l_unmri=0;
  }

  if (!FZERO(l_mri))
  {
    ll += l_mri * mrisComputeDefectMRILogLikelihood
          (mris, mri, &dp->tp, h_white, h_gray,h_grad, mri_gray_white) ;
  }
  if (!FZERO(l_unmri))
  {
    ll+= l_unmri * mrisComputeDefectMRILogUnlikelihood( mris, dp, h_border) ;
  }
  if (!FZERO(l_qcurv))
  {
    /*compute the second fundamental form */
    computeDefectSecondFundamentalForm(mris,&dp->tp);
    ll+= l_qcurv * mrisComputeDefectCurvatureLogLikelihood
         (mris, &dp->tp, h_k1, h_k2,mri_k1_k2) ;
  }
  if (!FZERO(l_curv))
  {
    ll+= l_curv * mrisComputeDefectNormalDotLogLikelihood
         (mris, &dp->tp, h_dot) ;
  }

  l_unmri = parms->l_unmri ;

  return(ll) ;
}



#if 0
static double
mrisComputeDefectCurvatureEnergy
(MRI_SURFACE *mris, DEFECT *defect, int *vertex_trans)
{
  double sse = 0.0, nx, ny, nz, dx, dy, dz, vtotal, dot ;
  int    i, vno, n, nvertices = 0 ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    if (i < defect->nvertices)
    {
      vno = vertex_trans[defect->vertices[i]] ;
    }
    else
    {
      vno = vertex_trans[defect->border[i-defect->nvertices]] ;
    }
    if (vno < 0)
    {
      continue ;
    }
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    nvertices++ ;
    mrisComputeDefectVertexNormal(mris, vno, &nx, &ny, &nz) ;
    vtotal = 0.0f ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dx = vn->origx - v->origx ;
      dy = vn->origy - v->origy ;
      dz = vn->origz - v->origz ;
      dot = dx*nx + dy*ny + dz*nz ;
      vtotal += (dot*dot) ;
      if (!finite(vtotal))
      {
        DiagBreak() ;
      }
    }
    if (v->vnum == 0)
    {
      continue ;
    }
    sse += (vtotal / (float)v->vnum) ;
  }
  return(sse) ;
}
#endif
#if 0
static int
mrisFindSecondNeighborhood
(MRI_SURFACE *mris, int vno, int *nbrs, int *num_nbrs)
{
  int     n, n2 ;
  VERTEX  *v, *vn, *vn2 ;

  *num_nbrs = 0 ;
  v = &mris->vertices[vno] ;
  v->marked = 1 ;
  for (n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;
    vn->marked = 1 ;
    nbrs[*num_nbrs] = v->v[n] ;
    *num_nbrs += 1 ;
  }

  for (n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;
    for (n2 = 0 ; n2 < vn->vnum ; n2++)
    {
      vn2 = &mris->vertices[vn->v[n2]] ;
      if (vn2->marked)
      {
        continue ;
      }
      vn2->marked = 1 ;
      nbrs[*num_nbrs] = vn->v[n2] ;
      *num_nbrs += 1 ;
    }
  }

  v->marked = 0 ;
  for (n = 0 ; n < *num_nbrs ; n++)
  {
    mris->vertices[nbrs[n]].marked = 0 ;
  }
  return(NO_ERROR) ;
}
#endif

#if 0
static double
mrisComputeDefectQuadraticCurvatureEnergy
(MRI_SURFACE *mris, DEFECT *defect, int *vertex_trans)
{
  MATRIX   *m_R, *m_R_inv ;
  VECTOR   *v_Y, *v_A, *v_n, *v_e1, *v_e2, *v_nbr ;
  int      vno, n, i ;
  VERTEX   *v, *vn ;
  float    ui, vi, rsq, a, b ;
  double   sse = 0.0 ;
  int      nbrs[MAX_NBRS], num_nbrs ;

  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  MRISrestoreVertexPositions(mris, ORIGINAL_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;

  mrisComputeTangentPlanes(mris) ;
  v_n = VectorAlloc(3, MATRIX_REAL) ;
  v_A = VectorAlloc(2, MATRIX_REAL) ;
  v_e1 = VectorAlloc(3, MATRIX_REAL) ;
  v_e2 = VectorAlloc(3, MATRIX_REAL) ;
  v_nbr = VectorAlloc(3, MATRIX_REAL) ;
  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    if (i < defect->nvertices)
    {
      vno = vertex_trans[defect->vertices[i]] ;
    }
    else
    {
      vno = vertex_trans[defect->border[i-defect->nvertices]] ;
    }
    if (vno < 0)
    {
      continue ;
    }
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->vnum <= 0)
    {
      continue ;
    }
    mrisFindSecondNeighborhood(mris, vno, nbrs, &num_nbrs) ;
    if (num_nbrs < 3)
    {
      continue ;
    }
    MRIScomputeSecondFundamentalFormAtVertex(mris, vno, nbrs, num_nbrs) ;
    v_Y = VectorAlloc(num_nbrs, MATRIX_REAL) ;    /* heights above TpS */
    m_R = MatrixAlloc(num_nbrs, 2, MATRIX_REAL) ; /* radial distances */
    VECTOR_LOAD(v_n, v->nx, v->ny, v->nz) ;
    VECTOR_LOAD(v_e1, v->e1x, v->e1y, v->e1z) ;
    VECTOR_LOAD(v_e2, v->e2x, v->e2y, v->e2z) ;
    for (n = 0 ; n < num_nbrs ; n++)  /* build data matrices */
    {
      vn = &mris->vertices[nbrs[n]] ;
      VERTEX_EDGE(v_nbr, v, vn) ;
      VECTOR_ELT(v_Y, n+1) = V3_DOT(v_nbr, v_n) ;
      ui = V3_DOT(v_e1, v_nbr) ;
      vi = V3_DOT(v_e2, v_nbr) ;
      rsq = ui*ui + vi*vi ;
      *MATRIX_RELT(m_R, n+1, 1) = rsq ;
      *MATRIX_RELT(m_R, n+1, 2) = 1 ;
    }
    m_R_inv = MatrixPseudoInverse(m_R, NULL) ;
    if (!m_R_inv)
    {
      MatrixFree(&m_R) ;
      VectorFree(&v_Y) ;
      continue ;
    }
    v_A = MatrixMultiply(m_R_inv, v_Y, v_A) ;
    a = VECTOR_ELT(v_A, 1) ;
    b = VECTOR_ELT(v_A, 2) ;
    if (!finite(b))
    {
      DiagBreak() ;
    }
    sse += b*b ;
    if (vno == Gdiag_no && Gdiag > 0)
    {
      printf("v %d: curvature sse %2.2f\n", vno, b*b) ;
    }
    MatrixFree(&m_R) ;
    VectorFree(&v_Y) ;
    MatrixFree(&m_R_inv) ;
  }

  VectorFree(&v_n) ;
  VectorFree(&v_e1) ;
  VectorFree(&v_e2) ;
  VectorFree(&v_nbr) ;
  VectorFree(&v_A) ;

  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  return(sse) ;
}
#endif

#if 0
static int writeOverlap(MRIS *mris,int nclusters)
{
  int n,m,found;
  float diameter,dist,curv;
  VERTEX *vn,*vm;

  diameter=0.0f;
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    vn=&mris->vertices[n];
    for (m = 0 ; m < mris->nvertices ; m++)
    {
      vm=&mris->vertices[m];
      diameter=MAX(diameter,SQR(vn->x-vm->x)+
                   SQR(vn->y-vm->y)+SQR(vn->z-vm->z));
    }
  }

  fprintf(stderr,"the diameter of the defect is %2.3f ",sqrt(diameter));

  if (nclusters<2)
  {
    nclusters=2;
  }
  dist=MAX(1.0,diameter/(float)SQR(nclusters)); /* work with the
                                                   square of the distance */

  fprintf(stderr,"(clustering distance : %2.3f)\n",sqrt(dist));

  curv=0.0f;
  found=1;
  while (found)
  {
    found=0;
    for (n = 0 ; n < mris->nvertices ; n++)
    {
      vn=&mris->vertices[n];
      if (vn->marked)
      {
        continue;
      }
      curv += 1.0f;
      vn->curv = curv;
      vn->marked = 1;
      found=1;
      for (m = 0 ; m < mris->nvertices ; m++)
      {
        vm=&mris->vertices[m];
        if (vm->marked)
        {
          continue;
        }
        if (SQR(vn->x-vm->x)+SQR(vn->y-vm->y)+SQR(vn->z-vm->z)>dist)
        {
          continue;
        }
        vm->curv = curv;
        vm->marked=1;
      }
    }
  }
  /* unmark vertices */
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    mris->vertices[n].marked=0;
  }

  return NO_ERROR;
}
#endif

#if 0
static int generateMovie(MRIS *mris_src)
{
  int n,counter;
  static int nbr=0;
  float t,x,y,z;
  VERTEX *vd,*vs;
  char fname[100];

  MRIS *mris;
  mris=MRISclone(mris_src);
  nbr++; /* static */

  for (counter = 0 , t=0.0f ; t<=1.0f ; t += 0.01f)
  {
    /* compute new coords */
    for (n = 0 ; n < mris->nvertices; n++)
    {
      vd=&mris->vertices[n];
      vs=&mris_src->vertices[n];
      vd->x=t*vs->cx+(1.0f-t)*vs->origx;
      vd->y=t*vs->cy+(1.0f-t)*vs->origy;
      vd->z=t*vs->cz+(1.0f-t)*vs->origz;
    }
    /* center coords to (0,0,0) */
    x=y=z=0.0f;
    for (n = 0 ; n < mris->nvertices ; n++)
    {
      vd=&mris->vertices[n];
      x += vd->x;
      y += vd->y;
      z += vd->z;
    }
    x /= (float)mris->nvertices;
    y /= (float)mris->nvertices;
    z /= (float)mris->nvertices;
    for (n = 0 ; n < mris->nvertices ; n++)
    {
      vd=&mris->vertices[n];
      vd->x -= x;
      vd->y -= y;
      vd->z -= z;
    }
    /* write out image */
    sprintf(fname,"./mov%d_%03d",nbr,counter);
    MRISwrite(mris,fname);
    counter++;
  }

  MRISfree(&mris);
  return NO_ERROR;
}
#endif

#define SAVING_SURFACES 0

#define NB_OF_CLUSTERS 2

static int findNumberOfClusters(MRIS *mris)
{

  return NB_OF_CLUSTERS;
}
/* using orig vertices to cluster
   fixedval indexes the clusters */
static int clusterDefectVertices(MRIS *mris)
{
  int n,niters,nvertices,k;
  int p,q,nclusters,found;
  int clusters[10],ngroups;
  float dist,ndist,x,y,z,nbv;
  VERTEX *v,*vq;
  int rgb[10],v_rgb;

  ngroups=findNumberOfClusters(mris);
  nclusters=ngroups;

  MRISRGBToAnnot(0,225,225,rgb[0]);
  MRISRGBToAnnot(205,62,78,rgb[1]);
  MRISRGBToAnnot(120,62,78,rgb[2]);
  MRISRGBToAnnot(196,58,250,rgb[3]);
  MRISRGBToAnnot(0,148,0,rgb[4]);
  MRISRGBToAnnot(220,248,164,rgb[5]);
  MRISRGBToAnnot(230,148,34,rgb[6]);
  MRISRGBToAnnot(0,118,14,rgb[7]);
  MRISRGBToAnnot(12,48,255,rgb[8]);
  MRISRGBToAnnot(122,186,220,rgb[9]);

  niters=10;

  nvertices=mris->nvertices;

  /* set marks to zero */
  for ( n = 0 ; n < mris->nvertices ; n++)
  {
    v=&mris->vertices[n];
    v->fixedval=0;
  }
  /* first cluster = border points */
  for ( n = 0 ; n < mris->nvertices ; n++)
  {
    v=&mris->vertices[n];
    if (v->flags==VERTEX_INTERIOR)
    {
      continue;
    }
    v->fixedval=1;
  }
  /* initialize other clusters */
  for ( p = 1 ; p < nclusters ; p++ )
  {
    found=0;
    while (!found)
    {
      //                        fprintf(stderr,".");
      /* draw a random number */
      k=nint(randomNumber(0.0 , (double)nvertices-0.7)) ;
      k=MIN(nvertices,MAX(0,k));
      v=&mris->vertices[k];
      if (v->fixedval)
      {
        continue;
      }
      //fprintf(stderr,"*%d-%d*",k,p+1);
      found=1;
      v->fixedval=p+1;
      clusters[p]=k;
    }
  }
  /* classify vertices */
  for (n=0; n<mris->nvertices; n++)
  {
    v=&mris->vertices[n];
    if (v->fixedval)
    {
      continue;
    }
    /* find the correct cluster */
    /* compute distance with first cluster */
    dist=1000;
    v->fixedval=1;
#if 0
    for (q = 0 ; q < mris->nvertices ; q++ )
    {
      vq=&mris->vertices[q];
      if (vq->flags==VERTEX_INTERIOR)
      {
        continue;
      }
      dist=MIN(dist,SQR(vq->origx-v->origx)+
               SQR(vq->origy-v->origy)+SQR(vq->origz-v->origz));
    }
#endif
    /* compute distance for the remaining clusters */
    for (q=1; q<nclusters; q++)
    {
      vq=&mris->vertices[clusters[q]];
      ndist = SQR(vq->origx-v->origx)+
              SQR(vq->origy-v->origy)+SQR(vq->origz-v->origz);
      if (ndist<dist)
      {
        dist=ndist;
        v->fixedval=q+1;
      }
    }
  }
  for (q=0; q<mris->nvertices; q++)
  {
    vq=&mris->vertices[q];
    vq->curv=vq->fixedval;
  }

  /*    MRISwriteCurvature(mris,"./lh.test.curv1"); */

  while (niters--)
  {

    for (p = 1 ; p < nclusters ; p++ )
    {
      /* regenerate clusters' center */
      x=y=z=0;
      nbv=0;
      for (n=0; n<mris->nvertices; n++)
      {
        v=&mris->vertices[n];
        if (v->fixedval!=p+1)
        {
          continue;
        }
        x += v->origx;
        y += v->origy;
        z += v->origz;
        nbv +=1.0f;
      }
      if (!nbv)
      {
        fprintf(stderr,"ERROR in clusterDefectVertices");
      }
      else
      {
        x /= nbv ;
        y /= nbv ;
        z /= nbv ;
      }

      /* update clustering */
      dist = 1000;
      for (n=0; n<mris->nvertices; n++)
      {
        v=&mris->vertices[n];
        if (v->fixedval!=p+1)
        {
          continue;
        }
        ndist=SQR(v->origx-x)+SQR(v->origy-y)+SQR(v->origz-z);
        if (ndist<dist)
        {
          clusters[p]=n;
          dist=ndist;
        }
      }
    }
    /* re-classify vertices */
    for (n=0; n<mris->nvertices; n++)
    {
      v=&mris->vertices[n];
      if (v->flags!=VERTEX_INTERIOR)
      {
        continue;
      }
      /* find the correct cluster */
      /* compute distance with first cluster */
      dist=1000;
#if 0
      v->fixedval=1;
      for (q=0; q<mris->nvertices; q++)
      {
        vq=&mris->vertices[q];
        if (vq->flags==VERTEX_INTERIOR)
        {
          continue;
        }
        dist=MIN(dist,SQR(vq->origx-v->origx)+
                 SQR(vq->origy-v->origy)+SQR(vq->origz-v->origz));
      }
#endif
      /* compute distance for the remaining clusters */
      for (q=1; q<nclusters; q++)
      {
        vq=&mris->vertices[clusters[q]];
        ndist = SQR(vq->origx-v->origx)+
                SQR(vq->origy-v->origy)+SQR(vq->origz-v->origz);
        if (ndist<dist)
        {
          dist=ndist;
          v->fixedval=q+1;
        }
      }
    }
  }
  for (q=0; q<mris->nvertices; q++)
  {
    vq=&mris->vertices[q];
    vq->curv=vq->fixedval;
    v_rgb=rgb[(int)(vq->fixedval)%10];
    vq->annotation=v_rgb;
  }

#if SAVING_SURFACES
  MRISrestoreVertexPositions(mris,ORIGINAL_VERTICES);
  MRISwrite(mris,"./test.now");
  MRISrestoreVertexPositions(mris,CANONICAL_VERTICES);
  MRISwriteCurvature(mris,"./lh.test.curv2");
  MRISwriteAnnotation(mris,"./lh.ant");
#endif

  return ngroups;
}

static void computeInteriorGradients(MRIS *mris,int option)
{
  int n,p,count;
  float x,y,z;
  VERTEX *v,*vp;

  for ( n = 0 ; n < mris->nvertices ; n++ )
  {
    v=&mris->vertices[n];

    if (v->flags!=VERTEX_INTERIOR)
    {
      continue;
    }

    x = y = z = 0.0f;

    for (count=p=0; p<v->vnum; p++)
    {
      vp=&mris->vertices[v->v[p]];
      if (v->fixedval != option && vp->fixedval == option)
      {
        continue;
      }
      x += vp->x;
      y += vp->y;
      //z += vp->z;
      count++;
    }

    if (count)
    {
      /* compute average */
      x /= (float)count;
      y /= (float)count;
      //z /= (float)count;
      /* generate gradient */
      v->dx += (x-v->x);
      v->dy += (y-v->y);
      //v->dz += (z-v->z);
    }
  }

}

/* use fixedval to exclude some random vertices */
static void computeGradients(MRIS *mris,int option)
{
  int n;
  VERTEX *v;

  /* set gradients to zero */
  for ( n = 0 ; n < mris->nvertices ; n++ )
  {
    v=&mris->vertices[n];
    v->dx=v->dy=v->dz=0.0f;
  }

  /* repulsive term for chull vertices */
  //computeChullGradients(mris);

  /* repulsive term for border vertices */
  //computeBorderGradients(mris);

  /* compute spring term for interior vertices */
  computeInteriorGradients(mris,option);

}

static void circleProjection(float x, float y, float *xd,float *yd,float r)
{
  float dist;

  dist=sqrt(SQR(x)+SQR(y));
  if (dist>r)
  {
    fprintf(stderr,"!");
    *xd = x * 0.99*r / dist;
    *yd = y * 0.99*r / dist;
  }

}

/* generate a place xy mapping */
static void generateDefectMapping(MRIS *mris,int option)
{
  int n,niter=100;
  double dt=0.1;
  VERTEX *v;

#if 0
  {
    int n,vlist[8];
    for (n=0; n<mris->nvertices; n++)
    {
      mris->vertices[n].fixedval=0;
    }
    //option=2;
    vlist[0]=508;
    vlist[1]=509;
    vlist[2]=538;
    vlist[3]=539;
    vlist[4]=540;
    vlist[5]=541;
    vlist[6]=569;
    vlist[7]=510;
    for (n=0; n<8; n++)
    {
      mris->vertices[vlist[n]].fixedval=option;
    }
  }
  /*    fprintf(stderr," label is %d or %d or %d :
        option=%d\n",mris->vertices[361].fixedval,
        mris->vertices[392].fixedval,mris->vertices[391].fixedval,option); */
#endif



  while (niter--)
  {

    if (niter%20==0)
    {
      fprintf(stderr,".");
    }

    /* compute gradients */
    computeGradients(mris,option);
    /* apply gradients */
    for (n=0; n<mris->nvertices; n++)
    {
      v=&mris->vertices[n];
      if (v->flags==VERTEX_BORDER)
      {
        continue;
      }
      v->x += dt*v->dx;
      v->y += dt*v->dy;
      circleProjection(v->x,v->y,&v->x,&v->y,mris->radius);
      v->cx=v->x;
      v->cy=v->y;
    }

  }

}

static OPTIMAL_DEFECT_MAPPING* mrisFindOptimalDefectMapping
(MRIS *mris_src , DEFECT *defect)
{
  int nvertices , nfaces ,nchull;
  int *vertex_trans,*face_trans,*vertex_list;
  int vno,n,m,i, first_inside_vertex,first_border_vertex;
  MAPPING *mapping;
  FS_VERTEX_INFO *vinfo;
  FACE *face,*face_dst;
  VERTEX *v_dst,*v_src,*v;
  MRIS *mris_dst;
#if 0 /* useless with the new plane mapping */
  EDGE_LIST_INFO e_l_i;
#endif
  OPTIMAL_DEFECT_MAPPING *o_d_m;
  int option=0,nclusters;
  EDGE *edge;

  /* first neighbors only */
  MRISsetNeighborhoodSize(mris_src, 1) ;

  nvertices=defect->nvertices+defect->nchull;
  vertex_list=(int*)malloc(nvertices*sizeof(int));

  vertex_trans=(int*)malloc(mris_src->nvertices*sizeof(int));
  face_trans=(int*)malloc(mris_src->nfaces*sizeof(int));
  memset(vertex_trans,-1,mris_src->nvertices*sizeof(int));
  memset(face_trans,-1,mris_src->nfaces*sizeof(int));

  nvertices=0;

  nchull =
    defect->nchull-defect->nborder; /* number of chull vertices :
                                       should be zero */
  for (n = 0 ; n < nchull ; n++ )
  {
    /* first chull */
    vertex_list[nvertices]=defect->chull[n+defect->nborder];
    vertex_trans[defect->chull[defect->nborder+n]]=nvertices;
    nvertices++;
  }
  first_border_vertex = nvertices;
  for (n = 0 ; n < defect->nborder ; n++ )
  {
    /* then border */
    vertex_list[nvertices]=defect->chull[n];
    vertex_trans[defect->chull[n]]=nvertices;
    nvertices++;
  }
  first_inside_vertex = nvertices;
  for (n = 0 ; n < defect->nvertices ; n++ )
  {
    /* finally inside defect vertices */
    vertex_list[nvertices]=defect->vertices[n];
    vertex_trans[defect->vertices[n]]=nvertices;
    nvertices++;
  }

  /* mark vertices */
  mrisMarkDefectConvexHull(mris_src, defect, 1) ;
  mrisMarkDefect(mris_src, defect, 1) ;

  for ( nfaces = n = 0 ; n < mris_src->nfaces  ; n++)
  {
    face = &mris_src->faces[n];
    if (mris_src->vertices[face->v[0]].marked &&
        mris_src->vertices[face->v[1]].marked &&
        mris_src->vertices[face->v[2]].marked)
    {
      face_trans[n] = nfaces;
      nfaces++;
    }
  }

  /* allocate temporary surface */
  mris_dst = MRISalloc( nvertices , nfaces);
  mris_dst->status=MRIS_SPHERICAL_PATCH;
  mris_dst->type=MRIS_TRIANGULAR_SURFACE ;
  mris_dst->radius = DEFAULT_RADIUS;
#if 0
  mris_dst->vp=(void*)&e_l_i;
#endif

  /* copy faces */
  for (n = 0 ; n < mris_src->nfaces ; n++)
  {
    if (face_trans[n] < 0)
    {
      continue;
    }
    face = &mris_src->faces[n];
    face_dst=&mris_dst->faces[face_trans[n]];
    for (m = 0 ; m < VERTICES_PER_FACE ; m++)
    {
      face_dst->v[m] = vertex_trans[face->v[m]] ;
    }
  }

  /* copy vertices with their neighbors */
  for ( n = 0 ; n < mris_dst->nvertices ; n++)
  {

    v_dst=&mris_dst->vertices[n];
    v_src=&mris_src->vertices[vertex_list[n]];

    /* useless since we reinitialize the locations */
    /* making sure the vertices are in canonical space */
    v_dst->x  = v_src->cx ;
    v_dst->y  = v_src->cy ;
    v_dst->z  = v_src->cz ;
    v_dst->tx = v_src->tx ;
    v_dst->ty = v_src->ty ;
    v_dst->tz = v_src->tz ;
    v_dst->nx = v_src->nx ;
    v_dst->ny = v_src->ny ;
    v_dst->nz = v_src->nz ;
    v_dst->cx = v_src->cx ;
    v_dst->cy = v_src->cy ;
    v_dst->cz = v_src->cz ;
    v_dst->origx = v_src->origx ;
    v_dst->origy = v_src->origy ;
    v_dst->origz = v_src->origz ;
    v_dst->ripflag = v_src->ripflag;  /* none of them should be ripped */

    if ( n < nchull)                 /* vertex in the convex hull */
    {
      v_dst->flags = VERTEX_CHULL ;
    }
    else if ( n < defect->nchull )   /* vertex in the border */
    {
      v_dst->flags = VERTEX_BORDER ;
    }
    else                             /* vertex inside the defect */
    {
      v_dst->flags = VERTEX_INTERIOR ;
    }

    /* count the number of kept neighboring vertices */
    if ( n < nchull )
    {
      /* if n < nchull, we need to watch for the
         right neighboring vertices/faces */
      /* count # of valid neighbors */
      for (m = v_dst->vnum = 0 ; m < v_src->vnum ; m++)
        if ( mris_src->vertices[v_src->v[m]].marked )
        {
          v_dst->vnum++ ;
        }

      v_dst->vtotal = v_dst->vnum ;
      v_dst->v = (int *)calloc(v_dst->vnum, sizeof(int)) ;
      v_dst->dist = (float*)calloc(v_dst->vnum,sizeof(float));
      v_dst->dist_orig = (float*)calloc(v_dst->vnum,sizeof(float));

      for (i = m = 0 ; m < v_src->vnum ; m++)
        if ( mris_src->vertices[v_src->v[m]].marked )
        {
          v_dst->v[i] = vertex_trans[v_src->v[m]] ;
          v_dst->dist[i] = v_src->dist[m];
          v_dst->dist_orig[i] = v_src->dist_orig[m];
          i++;
        }

      /* count # of good triangles attached to this vertex */
      for (v_dst->num = m = 0 ; m < v_src->num ; m++)
      {
        face = &mris_src->faces[v_src->f[m]];
        if (mris_src->vertices[face->v[0]].marked &&
            mris_src->vertices[face->v[1]].marked
            && mris_src->vertices[face->v[2]].marked)
        {
          v_dst->num++ ;
        }
      }

      v_dst->f = (int*)calloc(v_dst->num, sizeof(int)) ;
      v_dst->n = (uchar *)calloc(v_dst->num, sizeof(uchar)) ;
      for (i = m = 0 ; m < v_src->num ; m++)
      {
        face = &mris_src->faces[v_src->f[m]];
        if (mris_src->vertices[face->v[0]].marked &&
            mris_src->vertices[face->v[1]].marked
            && mris_src->vertices[face->v[2]].marked)
        {
          v_dst->n[i] = v_src->n[m] ;
          v_dst->f[i] = face_trans[v_src->f[m]] ;
          i++ ;
        }
      }
    }
    else
    {
      /* neighboring vertices */
      v_dst->vnum=v_src->vnum;
      v_dst->vtotal = v_dst->vnum ;
      v_dst->v = (int *)calloc(v_dst->vnum, sizeof(int)) ;
      v_dst->dist = (float*)calloc(v_dst->vnum,sizeof(float));
      v_dst->dist_orig = (float*)calloc(v_dst->vnum,sizeof(float));
      for (m = 0 ; m < v_src->vnum ; m++)
      {
        v_dst->v[m] = vertex_trans[v_src->v[m]] ;
        v_dst->dist[m] = v_src->dist[m];
        v_dst->dist_orig[m] = v_src->dist_orig[m];
      }
      /* neighboring faces */
      v_dst->num = v_src->num;
      v_dst->f = (int*)calloc(v_dst->num, sizeof(int)) ;
      v_dst->n = (uchar *)calloc(v_dst->num, sizeof(uchar)) ;
      for (m = 0 ; m < v_src->num ; m++)
      {
        v_dst->n[m] = v_src->n[m] ;
        v_dst->f[m] = face_trans[v_src->f[m]] ;
      }
    }
  }

  /* unmark vertices */
  mrisMarkDefectConvexHull(mris_src, defect, 0) ;
  mrisMarkDefect(mris_src, defect, 0) ;

#if 0
  e_l_i.n_inside_edges=0;
  e_l_i.n_border_edges=0;
  for ( n = 0 ; n < mris_dst->nvertices ; n++)
  {
    v=&mris_dst->vertices[n];
    if (v->flags==VERTEX_CHULL)
    {
      continue;
    }
    for ( m = 0 ; m < v->vnum ; m++)
    {
      if (v->v[m]<=n)
      {
        continue;
      }
      vm = &mris_dst->vertices[v->v[m]];
      if (v->flags==VERTEX_BORDER && vm->flags==VERTEX_BORDER)
      {
        e_l_i.n_border_edges++;
      }
      if (v->flags==VERTEX_INTERIOR && vm->flags==VERTEX_INTERIOR)
      {
        e_l_i.n_inside_edges++;
      }
    }
  }
  e_l_i.inside_edges=(EDGE*)malloc(e_l_i.n_inside_edges*sizeof(EDGE));
  e_l_i.border_edges=(EDGE*)malloc(e_l_i.n_border_edges*sizeof(EDGE));
  e_l_i.n_inside_edges=0;
  e_l_i.n_border_edges=0;
  for ( n = 0 ; n < mris_dst->nvertices ; n++)
  {
    v=&mris_dst->vertices[n];
    if (v->flags==VERTEX_CHULL)
    {
      continue;
    }
    for ( m = 0 ; m < v->vnum ; m++)
    {
      if (v->v[m]<=n)
      {
        continue;
      }
      vm = &mris_dst->vertices[v->v[m]];
      if (v->flags==VERTEX_BORDER && vm->flags==VERTEX_BORDER)
      {
        e_l_i.border_edges[e_l_i.n_border_edges].vno1=n;
        e_l_i.border_edges[e_l_i.n_border_edges].vno2=v->v[m];
        e_l_i.n_border_edges++;
      }
      if (v->flags==VERTEX_INTERIOR && vm->flags==VERTEX_INTERIOR)
      {
        e_l_i.inside_edges[e_l_i.n_inside_edges].vno1=n;
        e_l_i.inside_edges[e_l_i.n_inside_edges].vno2=v->v[m];
        e_l_i.n_inside_edges++;
      }
    }
  }
#endif

  o_d_m=(OPTIMAL_DEFECT_MAPPING*)calloc(1,sizeof(OPTIMAL_DEFECT_MAPPING));
  o_d_m->mris=mris_dst;
  o_d_m->vertex_trans=vertex_trans;
  o_d_m->face_trans=face_trans;
  o_d_m->orig_mapping.vertices=
    (FS_VERTEX_INFO*)calloc(mris_dst->nvertices,sizeof(FS_VERTEX_INFO));
  o_d_m->orig_mapping.nvertices=mris_dst->nvertices;
  o_d_m->orig_mapping.ninside=first_inside_vertex;
  for ( n = 0 ; n < 10 ; n++)
  {
    o_d_m->mappings[n].vertices=
      (FS_VERTEX_INFO*)calloc(mris_dst->nvertices,sizeof(FS_VERTEX_INFO));
    o_d_m->mappings[n].nvertices=mris_dst->nvertices;
    o_d_m->mappings[n].ninside=first_inside_vertex;
  }

  /* saving original configurations */
  mapping = &o_d_m->orig_mapping;
  for ( n = 0 ; n < defect->nvertices ; n++)
  {
    vinfo=&mapping->vertices[n+mapping->ninside];
    vinfo->status=defect->status[n];
  }
  /* initializing border vertices */
  for (n = 0 ; n < defect->nedges ; n++ )
  {
    /* init border */
    edge=&defect->edges[n];
    vno=vertex_trans[edge->vno1];
    vinfo=&mapping->vertices[vno];
    v=&mris_dst->vertices[vno];
    /* circle */
    vinfo->c_x=20.0*cos(2*PI*(float)n/defect->nedges);
    vinfo->c_y=20.0*sin(2*PI*(float)n/defect->nedges);
    vinfo->c_z=0;
    vinfo->oc_x=v->origx; /* orig coord */
    vinfo->oc_y=v->origy;
    vinfo->oc_z=v->origz;
  }
  /* init radius critical distance */
  mris_dst->radius=20.0*cos(PI/(float)defect->nedges);
  //fprintf(stderr,"critical radius is %f\n",mris_dst->radius);

  for (n = 0 ; n < defect->nvertices ; n++ )
  {
    /* init inside */
    vno=vertex_trans[defect->vertices[n]];
    vinfo=&mapping->vertices[vno];
    v=&mris_dst->vertices[vno];
    vinfo->c_x=0;
    vinfo->c_y=0;
    vinfo->c_z=0;
    vinfo->oc_x=v->origx; /* orig coord */
    vinfo->oc_y=v->origy;
    vinfo->oc_z=v->origz;
  }

  /* clustering defect vertices into groups */
  nclusters=clusterDefectVertices(mris_dst);

  o_d_m->nmappings=nclusters+1; /* 1 = smoothed ; then others */

  /////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////
  // Now, we are ready to generate different mappings...

  for (m = 0 ; m < o_d_m->nmappings ; m++)
  {
    fprintf(stderr,"generating mapping #%d\n",m);


    /* transfer initial coordinates into surface */
    mapping = &o_d_m->orig_mapping;
    for ( n = 0 ; n < mris_dst->nvertices ; n++)
    {
      vinfo=&mapping->vertices[n];
      v=&mris_dst->vertices[n];
      v->cx=vinfo->c_x; /* plane xy coord */
      v->cy=vinfo->c_y;
      v->cz=vinfo->c_z;
      v->x=v->cx;
      v->y=v->cy;
      v->z=v->cz;
    }
    fprintf(stderr,".");
#if SAVING_SURFACES
    if (m==0)
    {
      MRISwrite(mris_dst,"lh.test_init");
    }
#endif

    option=0;
    if (m)
    {
      option=m+1;
    }


    /* generate the mapping */
    generateDefectMapping(mris_dst,option);

#if SAVING_SURFACES
    {
      char fname[100];
      sprintf(fname,"lh.test_%d",m);
      fprintf(stderr,"writting file into %s\n",fname);
      MRISwrite(mris_dst,fname);
    }
#endif
    /* save the mapping onto the sphere (hack!) */
    mapping = &o_d_m->mappings[m];
    for ( n = 0 ; n < mris_dst->nvertices ; n++)
    {
      vinfo=&mapping->vertices[n];
      v=&mris_dst->vertices[n];
      vinfo->c_x=v->cx; /* spherical coord */
      vinfo->c_y=v->cy;
      v->cz=sqrt(10000.0-SQR(v->cx)-SQR(v->cy));
      vinfo->c_z=v->cz;
      v->x=v->cx;
      v->y=v->cy;
      v->z=v->cz;
    }
#if SAVING_SURFACES
    {
      char fname[100];
      sprintf(fname,"lh.tests_%d",m);
      fprintf(stderr,"writting file into %s\n",fname);
      MRISwrite(mris_dst,fname);
    }
#endif
  }

#if 0
  free(e_l_i.border_edges);
  free(e_l_i.inside_edges);
#endif
  free(vertex_list);

  return o_d_m;
}



static int
mrisTessellateDefect
(MRI_SURFACE *mris, MRI_SURFACE *mris_corrected, DEFECT *defect,
 int *vertex_trans,
 MRI *mri, HISTOGRAM *h_k1,HISTOGRAM *h_k2,MRI *mri_k1_k2,
 HISTOGRAM *h_white, HISTOGRAM *h_gray,
 HISTOGRAM *h_border, HISTOGRAM *h_grad, MRI *mri_gray_white,
 HISTOGRAM *h_dot, TOPOLOGY_PARMS *parms)
{
#define MAX_DEFECT_VERTICES 200000
  int    i, j, vlist[MAX_DEFECT_VERTICES], n, nvertices, nedges, ndiscarded ;
  VERTEX *v, *v2 ;
  EDGE   *et ;
  /*  double  cx, cy, cz, max_len ;*/
  static int dno = 0 ;
  double    x, y, z, xv, yv, zv, val0, val,
            total, dx, dy, dz, d, wval, gval, Ix, Iy, Iz ;
  float   norm1[3], norm2[3], nx, ny, nz ;
  int nes; /* number of edges present in original tessellation */
  ES *es;  /* list of edges present in original tessellation */
  /*generate an initial ordering*/
  int *ordering=NULL;

  /* first build table of all possible edges among vertices in the defect
     and on its border.
  */
  fprintf(stderr,"\nCORRECTING DEFECT %d (vertices=%d, convex hull=%d)\n",
          defect->defect_number, defect->nvertices, defect->nchull);

  if (parms->search_mode!=GREEDY_SEARCH)
    computeDefectStatistics
    (mri,mris,defect, h_white,h_gray,mri_gray_white,h_k1,h_k2,mri_k1_k2,0);

  /* first build table of all possible edges among vertices in the defect
     and on its border.*/
  for (nes = nvertices = i = 0 ; i < defect->nvertices ; i++)
  {
    if (nvertices >= MAX_DEFECT_VERTICES)
      ErrorExit
      (ERROR_NOMEMORY,
       "mrisTessellateDefect: too many vertices in defect (%d)",
       MAX_DEFECT_VERTICES) ;
    if (defect->status[i] == KEEP_VERTEX)
    {
      vlist[nvertices++] = defect->vertices[i] ;
    }
  }

  for (i = 0 ; i < defect->nborder ; i++)
  {
    vlist[nvertices++] = defect->border[i] ;
  }
  //  if (nvertices > 250)  //FLO
  if (DIAG_VERBOSE_ON)
    fprintf
    (WHICH_OUTPUT,
     "retessellating defect %d with %d vertices (convex hull=%d).\n",
     defect->defect_number, nvertices, defect->nchull) ;
  dno++ ;
  if (nvertices == 0)  /* should never happen */
  {
    return(NO_ERROR) ;
  }

  nedges = (nvertices * (nvertices-1)) / 2 ;  /* won't be more than this */

  et = (EDGE *)calloc(nedges, sizeof(EDGE)) ;
  if (!et)
    ErrorExit
    (ERROR_NOMEMORY,
     "Excessive topologic defect encountered: "
     "could not allocate %d edges for retessellation", nedges) ;

  for (n = i = 0 ; i < nvertices ; i++)
  {
    v = &mris->vertices[vlist[i]] ;
    if (vlist[i] == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (vertex_trans[vlist[i]] == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (j = i+1 ; j < nvertices ; j++, n++)
    {
      if (vlist[j] == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (vlist[j] == Gdiag_no || vlist[i] == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (vertex_trans[vlist[j]] ==
          Gdiag_no || vertex_trans[vlist[i]] == Gdiag_no)
      {
        DiagBreak() ;
      }
      mrisComputeOrigNormal(mris, vlist[i], norm1) ;
      mrisComputeOrigNormal(mris, vlist[j], norm2) ;
      nx = (norm1[0] + norm2[0]) / 2 ;
      ny = (norm1[1] + norm2[1]) / 2 ;
      nz = (norm1[2] + norm2[2]) / 2 ;
      total = sqrt(nx*nx + ny*ny + nz*nz) ;
      if (FZERO(total))
      {
        total = 1 ;
      }
      nx /= total ;
      ny /= total ;
      nz /= total ;
      v2 = &mris->vertices[vlist[j]] ;
      x = (v->origx+v2->origx)/2 ;
      y = (v->origy+v2->origy)/2 ;
      z = (v->origz+v2->origz)/2 ;
      // MRIworldToVoxel(mri, x, y, z, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x,y,z,&xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xv, &yv, &zv) ;
#endif
      MRIsampleVolumeGradient(mri, xv, yv, zv, &Ix, &Iy, &Iz) ;
      total = sqrt(Ix*Ix + Iy*Iy + Iz*Iz) ;
      if (FZERO(total))
      {
        total = 1 ;
      }
      Ix /= total ;
      Iy /= total ;
      Iz /= total ;

      /* assign value for edge table : values in mris_corrected */
      et[n].vno1 = vertex_trans[vlist[i]];
      et[n].vno2 = vertex_trans[vlist[j]];
      if ((et[n].vno1 == 141823 && et[n].vno2 == 141908) ||
          (et[n].vno2 == 141823 && et[n].vno1 == 141908))
      {
        DiagBreak() ;
      }
      if ((vlist[i] == Gdiag_no && vlist[j] == Gx) ||
          (vlist[j] == Gdiag_no && vlist[i] == Gx))
      {
        DiagBreak() ;
      }
      if ((vertex_trans[vlist[i]] ==
           Gdiag_no && vertex_trans[vlist[j]] == Gx) ||
          (vertex_trans[vlist[j]] ==
           Gdiag_no && vertex_trans[vlist[i]] == Gx))
      {
        DiagBreak() ;
      }

      /* sample MR values along line and build estimate of log likelihood
         as distance.
      */
      val0 = (v->val + v2->val) / 2 ;  /* gray/white border value */
      wval = (v->val2 + v2->val2) / 2 ;  /* white matter mean */
      gval = (v->val2bak + v2->val2bak) / 2 ;  /* gray matter mean */

      /* sample one end point */
      x = v->origx ;
      y = v->origy ;
      z = v->origz ;
      // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &val) ;
      total = fabs(val-gval) ;
      // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &val) ;
      total += fabs(val-wval) ;

      /* sample the other end point */
      x = v2->origx ;
      y = v2->origy ;
      z = v2->origz ;
      // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &val) ;
      total += fabs(val-gval) ;
      // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
      mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
      MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
      MRIsampleVolume(mri, xv, yv, zv, &val) ;
      total += fabs(val-wval) ;

      dx = v2->origx - v->origx ;
      dy = v2->origy - v->origy ;
      dz = v2->origz - v->origz ;
      for (d = .1 ; d <= .9 ; d += .1)
      {
        /* sample the midpoint end point */
        x = v->origx+d*dx ;
        y = v->origy+d*dy ;
        z = v->origz+d*dz ;
        // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
        mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
        MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
        MRIsampleVolume(mri, xv, yv, zv, &val) ;
        total += fabs(val-gval) ;
        // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
        mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
        MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
        MRIsampleVolume(mri, xv, yv, zv, &val) ;
        total += fabs(val-wval) ;
      }

      et[n].len = total / (4.0+18.0) ;
      if (et[n].vno1 == 120811 && et[n].vno2 == 120951)
      {
        VERTEX *v1, *v2 ;
        v1 = &mris_corrected->vertices[et[n].vno1] ;
        v2 = &mris_corrected->vertices[et[n].vno2] ;
        fprintf(stdout, "v %d (%d) --> %d (%d), len = %2.3f\n",
                et[n].vno1, vlist[i], et[n].vno2, vlist[j], et[n].len) ;
        fprintf(stdout, "INFLATED:  (%2.1f, %2.1f, %2.1f) --> "
                "(%2.1f, %2.1f, %2.1f), len = %2.2f\n",
                v1->tx, v1->ty, v1->tz,
                v2->tx, v2->ty, v2->tz,
                sqrt(SQR(v1->tx-v2->tx)+
                     SQR(v1->ty-v2->ty)+SQR(v1->tz-v2->tz)));
        fprintf(stdout, "CANON:  (%2.1f, %2.1f, %2.1f) --> "
                "(%2.1f, %2.1f, %2.1f), len = %2.2f\n",
                v1->cx, v1->cy, v1->cz,
                v2->cx, v2->cy, v2->cz,
                sqrt(SQR(v1->cx-v2->cx)+
                     SQR(v1->cy-v2->cy)+SQR(v1->cz-v2->cz)));
        fprintf(stdout, "CURRENT:  (%2.1f, %2.1f, %2.1f) --> "
                "(%2.1f, %2.1f, %2.1f), len = %2.2f\n",
                v1->x, v1->y, v1->z,
                v2->x, v2->y, v2->z,
                sqrt(SQR(v1->x-v2->x)+SQR(v1->y-v2->y)+SQR(v1->z-v2->z)));
        fprintf(stdout, "ORIG:  (%2.1f, %2.1f, %2.1f) --> "
                "(%2.1f, %2.1f, %2.1f), len = %2.2f\n",
                v1->origx, v1->origy, v1->origz,
                v2->origx, v2->origy, v2->origz,
                sqrt(SQR(v1->origx-v2->origx)+
                     SQR(v1->origy-v2->origy)+SQR(v1->origz-v2->origz)));
        DiagBreak() ;
      }
      if (edgeExists(mris_corrected, et[n].vno1, et[n].vno2))
      {
        et[n].used = USED_IN_TESSELLATION ;
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
          fprintf(stdout, "excluding existing edge %d <--> %d\n",
                  vlist[i],vlist[j]) ;
      }

      if (!edgeExists(mris, vlist[i], vlist[j]))
      {
        /* prioritize edges in original tessellation */
        et[n].len += 100 ; /*ASCENDING ORDER*/
      }
      else
      {
        if (et[n].used==USED_IN_TESSELLATION)
        {
          continue;
        }
        et[n].used = USED_IN_ORIGINAL_TESSELLATION ; /* to list
                                                        the original edges */
        nes++;
      }
    }
  }


  /* find and discard all edges that intersect one that is already in the
     tessellation.
  */
  for (ndiscarded = i = 0 ; i < nedges ; i++)
  {

    if (et[i].used != USED_IN_TESSELLATION)
    {
      continue ;
    }

    for (j = i+1 ; j < nedges ; j++)
    {

      if (et[j].used==USED_IN_TESSELLATION)
      {
        continue ;
      }

      if (edgesIntersect(mris_corrected, &et[i], &et[j]))
      {
        ndiscarded++ ;
        if (j < nedges-1)
        {
          memmove(&et[j], &et[j+1], (nedges-j-1)*sizeof(EDGE)) ;
        }

        nedges-- ;
        j-- ;
      }
    }
  }

  if (DIAG_VERBOSE_ON)
    fprintf(WHICH_OUTPUT,"%d of %d overlapping edges discarded\n",
            ndiscarded, nedges) ;

  /* sort the edge list by edge length */
  qsort(et, nedges, sizeof(EDGE), compare_edge_length) ;

  if (!n)   /* should never happen */
  {
    return(NO_ERROR) ;
  }

#if 0
  //modify initial ordering, just for fun...
  {
    int k,m,tmp,rd;

    fprintf(WHICH_OUTPUT,"generating random ordering\n");

    ordering=(int*)calloc(nedges,sizeof(int));
    for (j=0; j< nedges; j++)
    {
      ordering[j]=nedges-j-1;
    }

    for (m=0; m<11; m++)
      for (j=0; j< nedges; j++)
      {
        k=nint(randomNumber(0.0, (double)nedges-1)) ;

        tmp=ordering[j];
        ordering[j]=ordering[k];
        ordering[k]=tmp;
      }
  }
#else  //no modification
  ordering=(int*)calloc(nedges,sizeof(int));
  for (j=0; j< nedges; j++)
  {
    ordering[j]=j;  //nedges-j-1;
  }
#endif

  /* list the edges used in the original tessellation */
  es=(ES*)malloc(nes*sizeof(ES));
  for ( nes = i = 0 ; i < nedges ; i++)
    if (et[i].used==USED_IN_ORIGINAL_TESSELLATION)
    {
      //et[i].used=0; //reset state
      es[nes].vno1=et[i].vno1;
      es[nes].vno2=et[i].vno2;

      es[nes].segment=-1;
      es[nes++].n=i;
    }

  // main part of the routine: the retessellation (using a specific method) !
  if (getenv("USE_GA_TOPOLOGY_CORRECTION") != NULL)
  {
    parms->search_mode=GENETIC_SEARCH;
  }
  if (getenv("USE_RANDOM_TOPOLOGY_CORRECTION") != NULL)
  {
    parms->search_mode=RANDOM_SEARCH;
  }

  switch (parms->search_mode)
  {
  case GENETIC_SEARCH:
    mrisComputeOptimalRetessellation
    (mris, mris_corrected,mri, defect, vertex_trans,et, nedges,es,nes,
     h_k1,h_k2,mri_k1_k2,h_white, h_gray, h_border, h_grad, mri_gray_white,
     h_dot, parms) ;
    break;
  case RANDOM_SEARCH:
    mrisComputeRandomRetessellation
    (mris, mris_corrected,mri, defect, vertex_trans,et, nedges,es,nes,
     h_k1,h_k2,mri_k1_k2,h_white, h_gray, h_border, h_grad, mri_gray_white,
     h_dot, parms) ;
    break;
  default:
    parms->search_mode=GREEDY_SEARCH;
    mrisRetessellateDefect
    (mris, mris_corrected, defect, vertex_trans, et, nedges, ordering, NULL);
    break;
  }

  free(es);
  if (ordering)
  {
    free(ordering);
  }
  free(et) ;
  defect_no++ ;     /* for diagnostics */
  return(NO_ERROR) ;
}


#define NUM_TO_ADD_FROM_ONE_PARENT 1

static int
mrisCrossoverDefectPatches(DEFECT_PATCH *dp1, DEFECT_PATCH *dp2,
                           DEFECT_PATCH *dp_dst, EDGE_TABLE *etable)
{
  int          i1, i2, *added, i, isrc, j, nadded ;
  double       p ;
  DEFECT_PATCH *dp_src ;

  added = (int *)calloc(dp1->nedges, sizeof(int)) ;
  p = randomNumber(0.0, 1.0) ;
  if (p < 0.5)  /* add from first defect */
  {
    dp_src = dp1 ;
  }
  else
  {
    dp_src = dp2 ;
  }

  for (nadded = isrc = i1 = i2 = i = 0 ; i < dp_dst->nedges ; i++)
  {
    if (nadded >= NUM_TO_ADD_FROM_ONE_PARENT)
    {
      nadded = 0 ;

      if ((dp_src == dp1 &&
           i2 < dp2->nedges) ||
          i1 >= dp1->nedges)  /* use dp2 */
      {
        dp_src = dp2 ;
        isrc = i2 ;
      }
      else if (i1 < dp1->nedges)
      {
        dp_src = dp1 ;
        isrc = i1 ;
      }
    }
    else  /* keep adding from the same parent */
    {
      nadded++ ;
      if (dp_src == dp1)
      {
        isrc = i1 ;
      }
      else
      {
        isrc = i2 ;
      }
    }
    if (isrc >= dp_src->nedges) /* shouldn't happen */
    {
      i-- ;
      continue ;
    }

    /* find the next index in the src dp that hasn't been added yet */
    while (added[dp_src->ordering[isrc]])
      if (++isrc >= dp_src->nedges)
      {
        break ;
      }
    if (isrc >= dp_src->nedges)
    {
      i-- ;      /* process this one again */
      continue ;
    }
    if (dp_src->ordering[isrc] == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (isrc == Gdiag_no)
    {
      DiagBreak() ;
    }

    if (dp_src == dp1)    /* update source index for next iteration */
    {
      i1 = isrc+1 ;
    }
    else
    {
      i2 = isrc+1 ;
    }

    dp_dst->ordering[i] = dp_src->ordering[isrc] ;
    if (dp_dst->ordering[i] >= dp_dst->nedges)
    {
      DiagBreak() ;
    }

    added[dp_src->ordering[isrc]] = 1 ; /* make sure every edge
                                           is represented */
  }

  for (i = 0 ; i < dp_dst->nedges ; i++)
  {
    if ((dp_dst->ordering[i] >= dp_dst->nedges) ||
        (dp_dst->ordering[i] < 0))
    {
      DiagBreak() ;
      dp_dst->ordering[i] = 0 ;
    }
    if (added[i] == 0)
    {
      for (j = 0 ; j < dp_dst->nedges ; j++)
        if (dp_dst->ordering[j] < 0)  /* nothing in this slot */
        {
          dp_dst->ordering[j] = i ;
          added[i] = 1 ; /* make sure every edge is represented */
          break ;
        }
    }
  }

  free(added) ;

  return(NO_ERROR) ;
}
#define NTRY 0
#if 1
static int
mrisMutateDefectPatch(DEFECT_PATCH *dp, EDGE_TABLE *etable, double pmutation)
{
  int   i, j, eti, etj, tmp, *dp_indices,ntry;
  double p ;
  EDGE *e;

  //    fprintf(WHICH_OUTPUT,"m");
  dp_indices = (int *)calloc(dp->nedges, sizeof(int)) ;
  for (i = 0 ; i < dp->nedges ; i++)
  {
    dp_indices[dp->ordering[i]] = i ;
  }

  for (i = 0 ; i < dp->nedges ; i++)
  {
    p = randomNumber(0.0, 1.0) ;
    eti = dp->ordering[i] ;

    if (p < pmutation)
    {
      /* mutation */
      if (etable->use_overlap && etable->noverlap[eti] > 0)
      {
        if (etable->flags[eti] & ET_OVERLAP_LIST_INCOMPLETE)  /* swap any
                                                                 two */
        {
          ntry=0;
          j = (int)randomNumber(0.0, dp->nedges-.1) ;
          while (ntry<NTRY)
          {
            e=&etable->edges[dp->ordering[j]]; /*potential new edge */
            if (e->used!=USED_IN_ORIGINAL_TESSELLATION)
            {
              ntry++;
            }
            else
            {
              break;
            }
            j = (int)randomNumber(0.0, dp->nedges-.1) ;
          }
          tmp = dp->ordering[i] ;
          dp->ordering[i] = dp->ordering[j] ;
          dp->ordering[j] = tmp ;

        }
        else    /* swap two edges that intersect */
        {
          ntry=0;
          j = (int)randomNumber(0.0, etable->noverlap[eti]-0.0001) ;
          etj = etable->overlapping_edges[eti][j] ;  /* index of jth
                                                        overlapping edge */
          j = dp_indices[etj] ;  /* find where it is in this
                                    defect patch ordering */
          while (ntry<NTRY)
          {
            e=&etable->edges[dp->ordering[j]]; /*potential new edge */
            if (e->used!=USED_IN_ORIGINAL_TESSELLATION)
            {
              ntry++;
            }
            else
            {
              break;
            }
            j = (int)randomNumber(0.0, etable->noverlap[eti]-0.0001) ;
            etj = etable->overlapping_edges[eti][j] ;  /* index of
                                                          jth overlapping
                                                          edge */
            j = dp_indices[etj] ;  /* find where it is in this
                                      defect patch ordering */
          }
          tmp = dp->ordering[i] ;
          dp->ordering[i] = dp->ordering[j] ;
          dp->ordering[j] = tmp ;
          dp_indices[dp->ordering[i]] = i ;
          dp_indices[dp->ordering[j]] = j ;
        }
      }
      else
      {
        /* swap any two */
        ntry=0;
        j = (int)randomNumber(0.0, dp->nedges-.1) ;
        while (ntry<NTRY)
        {
          e=&etable->edges[dp->ordering[j]]; /*potential new edge */
          if (e->used!=USED_IN_ORIGINAL_TESSELLATION)
          {
            ntry++;
          }
          else
          {
            break;
          }
          j = (int)randomNumber(0.0, dp->nedges-.1) ;
        }
        tmp = dp->ordering[i] ;
        dp->ordering[i] = dp->ordering[j] ;
        dp->ordering[j] = tmp ;
      }
    }
  }
  //  fprintf(WHICH_OUTPUT,".");
  free(dp_indices) ;
  return(NO_ERROR) ;
}
#else
static int
mrisMutateDefectPatch(DEFECT_PATCH *dp, EDGE_TABLE *etable, double pmutation)
{
  int   i, j, eti, etj, tmp, *dp_indices ;
  double p ;

  dp_indices = (int *)calloc(dp->nedges, sizeof(int)) ;
  for (i = 0 ; i < dp->nedges ; i++)
  {
    dp_indices[dp->ordering[i]] = i ;
  }

  for (i = 0 ; i < dp->nedges ; i++)
  {
    p = randomNumber(0.0, 1.0) ;
    eti = dp->ordering[i] ;
    if (p < pmutation && etable->noverlap[eti] > 0)
    {
      if (etable->flags[eti] & ET_OVERLAP_LIST_INCOMPLETE)  /* swap any two */
      {
        j = (int)randomNumber(0.0, dp->nedges-.1) ;
        tmp = dp->ordering[i] ;
        dp->ordering[i] = dp->ordering[j] ;
        dp->ordering[j] = tmp ;
      }
      else   /* swap two edges that intersect */
      {
        j = (int)randomNumber(0.0, etable->noverlap[eti]-0.0001) ;
        etj = etable->overlapping_edges[eti][j] ;  /* index of jth
                                                      overlapping edge */
        j = dp_indices[etj] ;  /* find where it is in this
                                  defect patch ordering */

        tmp = dp->ordering[i] ;
        dp->ordering[i] = dp->ordering[j] ;
        dp->ordering[j] = tmp ;
        dp_indices[dp->ordering[i]] = i ;
        dp_indices[dp->ordering[j]] = j ;
      }
    }
  }

  free(dp_indices) ;
  return(NO_ERROR) ;
}
#endif
#if 0
//old version (sept. 2004)
static double
mrisDefectPatchFitness
(MRI_SURFACE *mris, MRI_SURFACE *mris_corrected, MRI *mri,
 DEFECT_PATCH *dp, int *vertex_trans, DEFECT_VERTEX_STATE *dvs,
 HISTOGRAM *h_k1, HISTOGRAM *h_k2, HISTOGRAM *h_white, HISTOGRAM *h_gray,
 HISTOGRAM *h_border, HISTOGRAM *h_grad, MRI *mri_gray_white,
 HISTOGRAM *h_dot, TOPOLOGY_PARMS *parms)
{
  int i ;

  mrisRetessellateDefect
  (mris, mris_corrected, dp->defect,
   vertex_trans, dp->etable->edges, dp->nedges, dp->ordering,
   dp->etable) ;
#if 0
  dp->fitness = -mrisComputeDefectEnergy
                (mris_corrected, mri, dp->defect, vertex_trans) ;
#else
  dp->fitness = mrisComputeDefectLogLikelihood
                (mris_corrected, mri, dp->defect, vertex_trans, dp,
                 h_k1, h_k2, h_white, h_gray, h_border, h_grad,
                 mri_gray_white, h_dot, parms) ;
#endif
  mrisRestoreVertexState(mris_corrected, dvs) ;

  /* reset the edges to the unused state
     (unless they were in the original tessellation */
  for (i = 0 ; i < dp->nedges ; i++)
    if (dp->etable->edges[i].used == USED_IN_NEW_TESSELLATION)
    {
      dp->etable->edges[i].used = NOT_USED ;
    }

  return(dp->fitness) ;
}
#endif


static int
mrisCopyDefectPatch(DEFECT_PATCH *dp_src, DEFECT_PATCH *dp_dst)
{
  int i ;

  dp_dst->etable = dp_src->etable ;
  dp_dst->defect = dp_src->defect ;
  dp_dst->nedges = dp_src->nedges ;
  dp_dst->fitness = dp_src->fitness ;
  dp_dst->rank = dp_src->rank ;
  dp_dst->retessellation_mode=dp_src->retessellation_mode;

  for (i = 0 ; i < dp_src->nedges ; i++)
  {
    dp_dst->ordering[i] = dp_src->ordering[i] ;
  }

  return(NO_ERROR) ;
}


static int
defectPatchRank(DEFECT_PATCH *dps, int index, int npatches)
{
  int   i, rank = 0 ;

  for (i = 0 ; i < npatches ; i++)
  {
    if (i == index)
    {
      continue ;
    }

    if (FEQUAL(dps[i].fitness, dps[index].fitness))
    {
      if (index > i)
      {
        rank++ ;
      }
    }
    else if (dps[i].fitness > dps[index].fitness)
    {
      rank++ ;
    }
  }
  return(rank) ;
}

#define MAX_EDGES 1000

static int tessellatePatch(MRI *mri,
                           MRI_SURFACE *mris,
                           MRI_SURFACE *mris_corrected,
                           DEFECT *defect,
                           int *vertex_trans,
                           EDGE *et,
                           int nedges, int *ordering,
                           EDGE_TABLE *etable,
                           TOPOLOGY_PARMS *parms)
{
  int i,k,vni;
  DVS *dvs;
  DP dp;
  EDGE_TABLE *new_et=NULL;

  if (DIAG_VERBOSE_ON)
  {
    fprintf(WHICH_OUTPUT,"tessellating patch....\n");
  }

  /* allocation */
  dvs = mrisRecordVertexState(mris_corrected, defect, vertex_trans) ;

  if (etable)
  {
    new_et=etable;
  }
  else
  {
    new_et=(EDGE_TABLE*)calloc(1,sizeof(EDGE_TABLE));
    new_et->nedges=nedges;
    new_et->edges=et;
    new_et->use_overlap=0;
  }

  if (parms->retessellation_mode)
  {
    dp.retessellation_mode=USE_SOME_VERTICES;
  }
  else
  {
    dp.retessellation_mode=USE_ALL_VERTICES;
  }
  dp.nedges = nedges ;
  dp.defect = defect ;
  dp.etable = new_et ;
  dp.ordering=ordering;
  dp.mri=mri;

  /* compute the final tessellation */
  retessellateDefect(mris, mris_corrected, dvs,&dp) ;

  /* free */
  mrisFreeDefectVertexState(dvs) ;

  /* detect the new set of faces */
  detectDefectFaces(mris_corrected,&dp);

  /* orient the patch faces */
  orientDefectFaces(mris_corrected,&dp);

  /* smooth original vertices in the retessellated patch */
  defectMatch(mri,mris_corrected,&dp,parms->smooth,parms->match);

  /* should free the tessellated patch structure */
  TPfree(&dp.tp);

  if (!etable)
  {
    free(new_et);
  }

  /* discard the vertices that are not used in the
     final tessellation and set marks to zero!!!*/
  for (i = 0 ; i < dp.nedges ; i++)
    if (dp.etable->edges[i].used == USED_IN_NEW_TESSELLATION ||
        dp.etable->edges[i].used == USED_IN_BOTH_TESSELLATION)
    {
      mris_corrected->vertices[dp.etable->edges[i].vno1].marked=FINAL_VERTEX ;
      mris_corrected->vertices[dp.etable->edges[i].vno2].marked=FINAL_VERTEX ;
    }

  for (k = i = 0 ; i < dp.defect->nvertices ; i++)
  {
    vni=vertex_trans[dp.defect->vertices[i]];
    if (vni < 0 )
    {
      continue;
    }
    if (mris_corrected->vertices[vni].marked!=FINAL_VERTEX)
    {
      if (dp.defect->status[i]!=DISCARD_VERTEX)
      {
        k++;
      }
      dp.defect->status[i]=DISCARD_VERTEX;
      mris_corrected->vertices[vertex_trans[dp.defect->vertices[i]]].ripflag=1;
    }
    mris_corrected->vertices[vertex_trans[dp.defect->vertices[i]]].marked=0;
  }

  for (i = 0 ; i < dp.defect->nborder ; i++)
  {
    mris_corrected->vertices[vertex_trans[dp.defect->border[i]]].marked=0;
  }

  if (DIAG_VERBOSE_ON)
  {
    fprintf(WHICH_OUTPUT,"done\n");
  }

  return NO_ERROR;
}

#define USE_SCALING 0

int mrisCountIntersectingFaces(MRIS *mris, int*flist , int nfaces)
{
  int n,m,i,count,intersect,j;
  int vn[3];
  int un[3];
  int vertex_in_common;
  double v0[3], v1[3], v2[3], u0[3], u1[3], u2[3] ;
  double d0,d1,d2,d,scale,SCALE_FACTOR;
  FACE   *f1, *f2 ;

  SCALE_FACTOR=100.0f;

  for (count=n=0; n < nfaces ; n++)
  {
    f1 = &mris->faces[flist[n]];
    /* fill vertices of 1st triangle */
    vn[0]=f1->v[0];
    vn[1]=f1->v[1];
    vn[2]=f1->v[2];
    v0[0] = (double)mris->vertices[f1->v[0]].origx ;
    v0[1] = (double)mris->vertices[f1->v[0]].origy ;
    v0[2] = (double)mris->vertices[f1->v[0]].origz ;
    v1[0] = (double)mris->vertices[f1->v[1]].origx ;
    v1[1] = (double)mris->vertices[f1->v[1]].origy ;
    v1[2] = (double)mris->vertices[f1->v[1]].origz ;
    v2[0] = (double)mris->vertices[f1->v[2]].origx ;
    v2[1] = (double)mris->vertices[f1->v[2]].origy ;
    v2[2] = (double)mris->vertices[f1->v[2]].origz ;
    d0=SQR(v1[0]-v0[0])+SQR(v1[1]-v0[1])+SQR(v1[2]-v0[2]);
    d1=SQR(v1[0]-v2[0])+SQR(v1[1]-v2[1])+SQR(v1[2]-v2[2]);
    d2=SQR(v0[0]-v2[0])+SQR(v0[1]-v2[1])+SQR(v0[2]-v2[2]);
    d=sqrt(MIN(d0,MIN(d1,d2)));
    /* scaling */
    if (FZERO(d))
    {
      continue;
    }
    scale = SCALE_FACTOR/d;
#if USE_SCALING
    for (i=0; i<3; i++)
    {
      v0[i] *= scale;
      v1[i] *= scale;
      v2[i] *= scale;
    }
#endif
    for ( m = n+1; m < nfaces ; m++ )
    {
      f2 = &mris->faces[flist[m]];
      un[0]=f2->v[0];
      un[1]=f2->v[1];
      un[2]=f2->v[2];
      /* count the number of common vertices */
      vertex_in_common=0;
      for (i=0; i<3; i++)
      {
        for (j=0; j<3; j++)
          if (vn[i]==un[j])
          {
            vertex_in_common++;
            break;
          }
      }

      if (vertex_in_common>0)
      {
        continue;
      }

      // fprintf(WHICH_OUTPUT,"vertex in common = %d \n",vertex_in_common);

      /* fill vertices of 2nd triangle */
      u0[0] = (double)mris->vertices[f2->v[0]].origx ;
      u0[1] = (double)mris->vertices[f2->v[0]].origy ;
      u0[2] = (double)mris->vertices[f2->v[0]].origz ;
      u1[0] = (double)mris->vertices[f2->v[1]].origx ;
      u1[1] = (double)mris->vertices[f2->v[1]].origy ;
      u1[2] = (double)mris->vertices[f2->v[1]].origz ;
      u2[0] = (double)mris->vertices[f2->v[2]].origx ;
      u2[1] = (double)mris->vertices[f2->v[2]].origy ;
      u2[2] = (double)mris->vertices[f2->v[2]].origz ;

      d0=SQR(u1[0]-u0[0])+SQR(u1[1]-u0[1])+SQR(u1[2]-u0[2]);
      d1=SQR(u1[0]-u2[0])+SQR(u1[1]-u2[1])+SQR(u1[2]-u2[2]);
      d2=SQR(u0[0]-u2[0])+SQR(u0[1]-u2[1])+SQR(u0[2]-u2[2]);
      d=sqrt(MIN(d0,MIN(d1,d2)));
      if (FZERO(d))
      {
        continue;
      }
      /* scaling */
#if USE_SCALING
      for (i=0; i<3; i++)
      {
        u0[i] *= scale;
        u1[i] *= scale;
        u2[i] *= scale;
      }
#endif
      intersect = tri_tri_intersect(v0,v1,v2,u0,u1,u2) ;

      if (intersect)
      {
#if 0
        fprintf(stderr,"face %d intersect face %d\n",
                flist[n],flist[m]);
        fprintf(stderr,"face %d : vertex %d [ %f , %f , %f ]\n",
                flist[n],f1->v[0],v0[0],v0[1],v0[2]);
        fprintf(stderr,"face %d : vertex %d [ %f , %f , %f ]\n",
                flist[n],f1->v[1],v1[0],v1[1],v1[2]);
        fprintf(stderr,"face %d : vertex %d [ %f , %f , %f ]\n",
                flist[n],f1->v[2],v2[0],v2[1],v2[2]);
        fprintf(stderr,"face %d : vertex %d [ %f , %f , %f ]\n",
                flist[m],f2->v[0],u0[0],u0[1],u0[2]);
        fprintf(stderr,"face %d : vertex %d [ %f , %f , %f ]\n",
                flist[m],f2->v[1],u1[0],u1[1],u1[2]);
        fprintf(stderr,"face %d : vertex %d [ %f , %f , %f ]\n",
                flist[m],f2->v[2],u2[0],u2[1],u2[2]);
        fprintf(stderr,"\nXXXXXXXXXX\n");
#endif
        count++;
        break;
      }
    }
  }
#if 0
  fprintf(stderr,"\n\nYYYYYYYYYYYYYYYYYYYYY LIST FACES \n");
  for (n=0; n < nfaces ; n++)
  {
    f1 = &mris->faces[flist[n]];
    /* fill vertices of 1st triangle */
    v0[0] = (double)mris->vertices[f1->v[0]].origx ;
    v0[1] = (double)mris->vertices[f1->v[0]].origy ;
    v0[2] = (double)mris->vertices[f1->v[0]].origz ;
    v1[0] = (double)mris->vertices[f1->v[1]].origx ;
    v1[1] = (double)mris->vertices[f1->v[1]].origy ;
    v1[2] = (double)mris->vertices[f1->v[1]].origz ;
    v2[0] = (double)mris->vertices[f1->v[2]].origx ;
    v2[1] = (double)mris->vertices[f1->v[2]].origy ;
    v2[2] = (double)mris->vertices[f1->v[2]].origz ;

    fprintf(stderr,"face %d : vertex %d [ %f , %f , %f ]\n",
            flist[n],f1->v[0],v0[0],v0[1],v0[2]);
    fprintf(stderr,"face %d : vertex %d [ %f , %f , %f ]\n",
            flist[n],f1->v[1],v1[0],v1[1],v1[2]);
    fprintf(stderr,"face %d : vertex %d [ %f , %f , %f ]\n",
            flist[n],f1->v[2],v2[0],v2[1],v2[2]);
  }
#endif

  return count;
}

#define SAVE_FIT_VALS 0
#if SAVE_FIT_VALS
static float fitness_values[11000];
static float best_values[11000];
#endif


static int mrisComputeOptimalRetessellation
(MRI_SURFACE *mris, MRI_SURFACE *mris_corrected,
 MRI *mri, DEFECT *defect, int *vertex_trans,
 EDGE *et, int nedges,
 ES *es, int nes, HISTOGRAM *h_k1, HISTOGRAM *h_k2,MRI* mri_k1_k2,
 HISTOGRAM *h_white, HISTOGRAM *h_gray, HISTOGRAM *h_border,
 HISTOGRAM *h_grad, MRI *mri_gray_white, HISTOGRAM *h_dot,
 TOPOLOGY_PARMS *parms)
{
  DEFECT_VERTEX_STATE *dvs ;
  DEFECT_PATCH dps1[MAX_PATCHES], dps2[MAX_PATCHES], \
  *dps, *dp, *dps_next_generation ;
  int i, best_i, j, g, nselected, nreplacements,rank, nunchanged = 0,
                                                      nelite, ncrossovers, k, l, noverlap ;
  int *overlap ,ngenerations,nbests,last_euthanasia,
      nremovedvertices,nfinalvertices;
  double fitness, best_fitness, last_best, fitness_mean,
         fitness_sigma, fitness_norm, pfitness,two_sigma_sq ,last_fitness;
  static int dno = 0 ;   /* for debugging */
  static int nmovies=1; /* for making movies :
                               0 is left for the original surface*/
  EDGE_TABLE etable ;
  int max_patches = MAX_PATCHES, ranks[MAX_PATCHES], next_gen_index,
      selected[MAX_PATCHES], nzero, sno=0, max_edges,
                                    debug_patch_n=-1, nbest = 0 ;
  MRI *mri_defect,*mri_defect_white,*mri_defect_gray,*mri_defect_sign;
  char fname[500];
  SEGMENTATION *segmentation;
  RP rp;
  int number_of_patches,nbestpatch;
  int ncross_overs , ntotalcross_overs , ntotalmutations , nmutations ;
  int nintersections;
  static int first_time=1;

  nbestpatch = number_of_patches = 0;
  ncross_overs=nmutations=0;
  ntotalcross_overs=ntotalmutations=0;

  if (first_time)
  {
    char *cp;

    if ((cp = getenv("FS_QCURV")) != NULL)
    {
      parms->l_qcurv = atof(cp) ;
      fprintf(WHICH_OUTPUT,"setting qcurv = %2.3f\n", l_qcurv) ;
    }
    if ((cp = getenv("FS_CURV")) != NULL)
    {
      parms->l_curv = atof(cp) ;
      fprintf(WHICH_OUTPUT,"setting curv = %2.3f\n", l_curv) ;
    }
    if ((cp = getenv("FS_MRI")) != NULL)
    {
      parms->l_mri = atof(cp) ;
      fprintf(WHICH_OUTPUT,"setting mri = %2.3f\n", l_mri) ;
    }
    if ((cp = getenv("FS_UNMRI")) != NULL)
    {
      parms->l_unmri = atof(cp) ;
      fprintf(WHICH_OUTPUT,"setting unmri = %2.3f\n", l_unmri) ;
    }
    first_time=0;
  }

  max_patches = parms->max_patches ;
  max_unchanged = parms->max_unchanged ;
  max_edges = MAX_EDGES ;

  if (dno == Gdiag_no)
  {
    DiagBreak() ;
  }

  if (getenv("FS_DEBUG_PATCH") != NULL)
  {
    int debug_patch = atoi(getenv("FS_DEBUG_PATCH"));
    if (debug_patch != dno)
    {
      max_patches = 0 ;
    }
    else
    {
      if (getenv("FS_DEBUG_PATCH_N") != NULL)
      {
        debug_patch_n = atoi(getenv("FS_DEBUG_PATCH_N")) ;
        fprintf
        (WHICH_OUTPUT,
         "terminating after %dth best tessellation\n", debug_patch_n) ;
      }
    }
  }

#if 0

  dno++ ;  /* for debugging */
  tessellatePatch(mri,mris, mris_corrected, defect,
                  vertex_trans, et, nedges, NULL, NULL,parms);

  return(NO_ERROR) ;


#endif


  if (!max_patches)
  {
    dno++ ;  /* for debugging */
    //mrisRetessellateDefect(mris, mris_corrected,
    // defect, vertex_trans, et, nedges, NULL, NULL) ;

    tessellatePatch(mri,mris, mris_corrected,
                    defect,vertex_trans, et, nedges, NULL, NULL,parms);

    return(NO_ERROR) ;
  }

#if 0
  if (defect->defect_number!=parms->correct_defect)
  {
    dno++ ;  /* for debugging */
    //mrisRetessellateDefect(mris, mris_corrected,
    // defect, vertex_trans, et, nedges, NULL, NULL) ;

    tessellatePatch(mri,mris, mris_corrected, defect,
                    vertex_trans, et, nedges, NULL, NULL,parms);

    return(NO_ERROR) ;
  }
#endif

  dno++ ;  /* for debugging */

  if (nedges > 200000)
  {
    //add some code here to select a good tessellation (ordering) FLO
    //mrisRetessellateDefect(mris, mris_corrected,
    // defect, vertex_trans, et, nedges, NULL, NULL) ;
    tessellatePatch(mri,mris, mris_corrected,
                    defect,vertex_trans, et, nedges, NULL, NULL,parms);


    return(NO_ERROR) ;
  }
  else if (nedges > 100000)
  {
    max_unchanged = MIN(max_unchanged, 1) ;
    max_patches = MAX(MIN(max_patches, 10),1) ;
    max_edges = MIN(max_edges, 100) ;
  }
  else if (nedges > 50000)
  {
    max_patches = MAX(max_patches/2,1) ;
    max_edges = max_edges/5 ;
    max_unchanged = max_unchanged / 5 ;
  }

  etable.use_overlap=parms->edge_table;
  etable.nedges = nedges ;
  etable.edges = (EDGE *)calloc(nedges, sizeof(EDGE)) ;
  memmove(etable.edges, et, nedges*sizeof(EDGE)) ;

  if (etable.use_overlap)
  {
    etable.overlapping_edges = (int **)calloc(nedges, sizeof(int *)) ;
    etable.noverlap = (int *)calloc(nedges, sizeof(int)) ;
    etable.flags = (unsigned char *)calloc(nedges, sizeof(unsigned char)) ;
    overlap = (int *)calloc(nedges, sizeof(int)) ;
    if (!etable.edges ||
        !etable.overlapping_edges ||
        !etable.noverlap ||
        !overlap)
      ErrorExit(ERROR_NOMEMORY, "mrisComputeOptimalRetessellation: Excessive "
                "topologic defect encountered: could not allocate %d "
                "edge table",nedges) ;

    for (nzero = i = 0 ; i < nedges ; i++)  /* compute overlapping
                                                           for each edge */
    {
      if (nedges > 50000 && !(i % 25000))
      {
        fprintf(WHICH_OUTPUT,"%d of %d edges processed\n", i, nedges) ;
      }
      etable.noverlap[i] = 0 ;
      for (noverlap = j = 0 ; j < nedges ; j++)
      {
        if (j == i)
        {
          continue ;
        }
        if (edgesIntersect(mris_corrected, &et[i], &et[j]))
        {
          overlap[noverlap] = j ;
          noverlap++ ;
        }
        if (noverlap > MAX_EDGES)
        {
          break ;
        }
      }
      if (noverlap > 0)
      {
        if (noverlap > MAX_EDGES)
        {
          etable.noverlap[i] = MAX_EDGES ;
          etable.flags[i] |= ET_OVERLAP_LIST_INCOMPLETE ;
        }
        else
        {
          etable.noverlap[i] = noverlap ;
        }

        etable.overlapping_edges[i] =
          (int *)calloc(etable.noverlap[i], sizeof(int)) ;
        if (!etable.overlapping_edges[i])
          ErrorExit(ERROR_NOMEMORY,
                    "mrisComputeOptimalRetessellation: Excessive "
                    "topologic defect encountered: could not allocate "
                    "overlap list %d "
                    "with %d elts",i, etable.noverlap[i]) ;
        memmove(etable.overlapping_edges[i],
                overlap, etable.noverlap[i]*sizeof(int)) ;
      }
      else
      {
        nzero++ ;
      }
    }

    free(overlap) ;
  }


  /* allocate the volume constituted by the potential edges */
  mri_defect = mri_defect_white = mri_defect_gray = mri_defect_sign = NULL;
  if (!FZERO(parms->l_unmri))
  {
    mri_defect = mriDefectVolume(mris_corrected, &etable,parms);
    mri_defect_white =
      MRIalloc
      (mri_defect->width,mri_defect->height,mri_defect->depth,MRI_FLOAT);
    mri_defect_gray =
      MRIalloc
      (mri_defect->width,mri_defect->height,mri_defect->depth,MRI_FLOAT);
    mri_defect_sign =
      MRIalloc
      (mri_defect->width,mri_defect->height,mri_defect->depth,MRI_FLOAT);
    defectVolumeLikelihood(mri, mri_defect, mri_defect_white,
                           mri_defect_gray, h_white,
                           h_gray,defect->white_mean,defect->gray_mean,0,0);
  };


  if ((!FZERO(parms->l_unmri)) &&
      parms->save_fname &&
      (parms->defect_number<0 ||
       (parms->defect_number==defect->defect_number)))
  {
    sprintf(fname,"%s/white_%d.mgh",parms->save_fname,defect->defect_number);
    MRIwrite(mri_defect_white,fname);
    sprintf(fname,"%s/gray_%d.mgh",parms->save_fname,defect->defect_number);
    MRIwrite(mri_defect_gray,fname);
  }

  dvs = mrisRecordVertexState(mris_corrected, defect, vertex_trans) ;
  dps = dps1 ;

  ngenerations=0;
  last_euthanasia=-1;
  number_of_patches=0;
  nremovedvertices=0;
  nfinalvertices=0;

  /* generate Random Patch */
  rp.best_ordering=(int*)malloc(nedges*sizeof(int));
  rp.status=(char*)malloc(defect->nvertices*sizeof(char));
  memmove(rp.status,defect->status,defect->nvertices*sizeof(char));
  rp.nused=(int*)calloc(defect->nvertices,sizeof(int));
  rp.vertex_fitness=(float*)calloc(defect->nvertices,sizeof(float));

  nbests=0;

  /* generate initial population of patches */
  if (parms->initial_selection)
  {
    /* segment overlapping edges into clusters */
    segmentation=segmentIntersectingEdges
                 (mris_corrected, defect, vertex_trans,es, &nes);
    if (parms->save_fname &&
        (parms->defect_number<0 ||
         (parms->defect_number==defect->defect_number)))
      saveSegmentation(mris, mris_corrected, defect,
                       vertex_trans,es,nes,parms->save_fname);

    /* generate initial population of patches */
    best_fitness = -1000000 ;
    best_i = 0 ;
    for (i = 0 ; i < max_patches ; i++)
    {
      dp = &dps2[i] ;

      if (parms->retessellation_mode)
      {
        dp->retessellation_mode=USE_SOME_VERTICES;
      }
      else
      {
        dp->retessellation_mode=USE_ALL_VERTICES;
      }

      dp->nedges = nedges ;
      dp->defect = defect ;
      dp->etable = &etable ;
      dp->ordering = (int *)calloc(nedges, sizeof(int)) ;
      if (!dp->ordering)
        ErrorExit
        (ERROR_NOMEMORY,
         "could not allocate %dth defect patch with %d indices",
         i, nedges) ;
      for (j = 0 ; j < nedges ; j++)
      {
        dp->ordering[j] = j;
      }

      dp->mri_defect=mri_defect;
      dp->mri_defect_white=mri_defect_white;
      dp->mri_defect_gray=mri_defect_gray;
      dp->mri_defect_sign=mri_defect_sign;

      dp->mri=mri;

      dp = &dps1[i] ;

      if (parms->retessellation_mode)
      {
        dp->retessellation_mode=USE_SOME_VERTICES;
      }
      else
      {
        dp->retessellation_mode=USE_ALL_VERTICES;
      }

      dp->nedges = nedges ;
      dp->defect = defect ;
      dp->etable = &etable ;
      dp->ordering = (int *)calloc(nedges, sizeof(int)) ;
      if (!dp->ordering)
        ErrorExit(ERROR_NOMEMORY,
                  "could not allocate %dth defect patch with %d indices",
                  i, nedges) ;
      for (j = 0 ; j < nedges ; j++)
      {
        dp->ordering[j] = j;  //nedges-j-1 ;
      }
      /* initial in same order -
         will change later */

      dp->mri_defect=mri_defect;
      dp->mri_defect_white=mri_defect_white;
      dp->mri_defect_gray=mri_defect_gray;
      dp->mri_defect_sign=mri_defect_sign;

      dp->mri=mri;

      /* generate ordering from edge segmentation */
      generateOrdering(dp,segmentation,i);

      fitness =
        mrisDefectPatchFitness
        (mris, mris_corrected, mri, dp, vertex_trans, dvs, &rp,
         h_k1,h_k2,mri_k1_k2,h_white,h_gray,h_border,h_grad,mri_gray_white,
         h_dot, parms) ;

#if SAVE_FIT_VALS
      fitness_values[number_of_patches]=fitness;
      if (number_of_patches)
        best_values[number_of_patches]=
          MAX(best_values[number_of_patches-1],fitness);
      else
      {
        best_values[number_of_patches]=fitness;
      }
#endif
      number_of_patches++;

      if (parms->verbose==VERBOSE_MODE_LOW)
        fprintf(WHICH_OUTPUT,
                "for the patch #%d, we have fitness = %f \n",i,fitness);


      /* saving the initial selection */
      if (parms->save_fname &&
          (parms->defect_number<0 ||
           (parms->defect_number==defect->defect_number)))
      {
        sprintf(fname,"%s/rh.defect_%d_select%d",
                parms->save_fname,defect->defect_number,i);
        savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
        if (parms->movie)
        {
          sprintf(fname,"%s/rh.defect_%d_movie_%d",
                  parms->save_fname,defect->defect_number,nmovies++);
          savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
        }
      }

      if (!i)  //fisrt patch
      {
        memmove(rp.best_ordering,dp->ordering,nedges*sizeof(int));
        memmove(rp.status,defect->status,defect->nvertices*sizeof(char));
        dp->defect->initial_face_ll=dp->tp.face_ll;
        dp->defect->initial_vertex_ll=dp->tp.vertex_ll;
        dp->defect->initial_curv_ll=dp->tp.curv_ll;
        dp->defect->initial_qcurv_ll=dp->tp.qcurv_ll;
        dp->defect->initial_mri_ll=dp->tp.mri_ll;
        dp->defect->initial_unmri_ll=dp->tp.unmri_ll;

        if (parms->verbose==VERBOSE_MODE_LOW)
        {
          fprintf(WHICH_OUTPUT,"initial defect\n");
          printDefectStatistics(dp);
        }
        best_fitness = fitness ;
        best_i = 0 ;
        //saving first patch
        if (parms->save_fname &&
            (parms->defect_number<0 ||
             (parms->defect_number==defect->defect_number)))
        {
          sprintf(fname,"%s/rh.defect_%d_best_%d",
                  parms->save_fname,defect->defect_number,nbests++);
          savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
        }

        if (++nbest == debug_patch_n)
        {
          goto debug_use_this_patch ;
        }
      }

      if (fitness > best_fitness)
      {
        best_fitness = fitness ;
        best_i = i ;
        if (parms->verbose>VERBOSE_MODE_DEFAULT)
          fprintf(WHICH_OUTPUT,
                  "new optimal fitness found at %d: %2.4f\n", i, fitness) ;

        nfinalvertices=nremovedvertices;
        nbestpatch=number_of_patches;

        rp.best_fitness=best_fitness;
        /* save ordering*/
        memmove(rp.best_ordering,dp->ordering,nedges*sizeof(int));
        /* save current status of vertices */
        memmove(rp.status,defect->status,defect->nvertices*sizeof(char));

        if (parms->verbose==VERBOSE_MODE_LOW)
        {
          printDefectStatistics(dp);
        }
        if (parms->save_fname &&
            (parms->defect_number<0 ||
             (parms->defect_number==defect->defect_number)))
        {
          sprintf(fname,"%s/rh.defect_%d_best_%d_%d",
                  parms->save_fname,defect->defect_number,ngenerations,i);
          savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
          sprintf(fname,"%s/rh.defect_%d_best_%d",
                  parms->save_fname,defect->defect_number,nbests++);
          savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
        }

        if (++nbest == debug_patch_n)
        {
          goto debug_use_this_patch ;
        }
      }
    }
    if (segmentation)
    {
      SEGMENTATIONfree(&segmentation);
    }
  }
  else
  {
    /* generate initial population of patches */
    best_fitness = -1000000 ;
    best_i = 0 ;
    for (i = 0 ; i < max_patches ; i++)
    {
      dp = &dps2[i] ;

      if (parms->retessellation_mode)
      {
        dp->retessellation_mode=USE_SOME_VERTICES;
      }
      else
      {
        dp->retessellation_mode=USE_ALL_VERTICES;
      }

      dp->nedges = nedges ;
      dp->defect = defect ;
      dp->etable = &etable ;
      dp->ordering = (int *)calloc(nedges, sizeof(int)) ;
      if (!dp->ordering)
        ErrorExit(ERROR_NOMEMORY,
                  "could not allocate %dth defect patch with %d indices",
                  i, nedges) ;
      for (j = 0 ; j < nedges ; j++)
      {
        dp->ordering[j] = j ;
      }   /* initial in same order -
                                                 will change later */

      dp->mri_defect=mri_defect;
      dp->mri_defect_white=mri_defect_white;
      dp->mri_defect_gray=mri_defect_gray;
      dp->mri_defect_sign=mri_defect_sign;

      dp->mri=mri;

      dp = &dps1[i] ;

      if (parms->retessellation_mode)
      {
        dp->retessellation_mode=USE_SOME_VERTICES;
      }
      else
      {
        dp->retessellation_mode=USE_ALL_VERTICES;
      }

      dp->nedges = nedges ;
      dp->defect = defect ;
      dp->etable = &etable ;
      dp->ordering = (int *)calloc(nedges, sizeof(int)) ;
      if (!dp->ordering)
        ErrorExit(ERROR_NOMEMORY,
                  "could not allocate %dth defect patch with %d indices",
                  i, nedges) ;
      for (j = 0 ; j < nedges ; j++)
      {
        dp->ordering[j] = j ;
      }   /* initial in same order -
                                                 will change later */

      dp->mri_defect=mri_defect;
      dp->mri_defect_white=mri_defect_white;
      dp->mri_defect_gray=mri_defect_gray;
      dp->mri_defect_sign=mri_defect_sign;

      dp->mri=mri;

      if (i)  /* first one is in same order as original edge table */
      {
        mrisMutateDefectPatch(dp, &etable, MUTATION_PCT_INIT) ;
      }

      fitness =
        mrisDefectPatchFitness
        (mris, mris_corrected, mri, dp, vertex_trans, dvs, &rp,
         h_k1,h_k2,mri_k1_k2,h_white,h_gray,
         h_border,h_grad,mri_gray_white,
         h_dot, parms) ;
#if SAVE_FIT_VALS
      fitness_values[number_of_patches]=fitness;
      if (number_of_patches)
        best_values[number_of_patches]=
          MAX(best_values[number_of_patches-1],fitness);
      else
      {
        best_values[number_of_patches]=fitness;
      }
#endif
      number_of_patches++;

      if (i == 0 && Gdiag & 0x1000000)
      {
        int i ;
        char fname[STRLEN] ;
        sprintf(fname, "%s_defect%d_%03d", mris->fname, dno-1, sno++) ;
        dp = &dps[best_i] ;
        mrisRetessellateDefect
        (mris, mris_corrected, dp->defect,
         vertex_trans, dp->etable->edges, dp->nedges, dp->ordering,
         dp->etable) ;
        MRISsaveVertexPositions(mris_corrected, TMP_VERTICES) ;
        MRISrestoreVertexPositions(mris_corrected, ORIGINAL_VERTICES) ;
        fprintf(WHICH_OUTPUT,"writing surface snapshow to %s...\n",fname) ;
        MRISwrite(mris_corrected, fname) ;
        MRISrestoreVertexPositions(mris_corrected, TMP_VERTICES) ;
        mrisRestoreVertexState(mris_corrected, dvs) ;
        /* reset the edges to the unused state
           (unless they were in the original tessellation */
        for (i = 0 ; i < dp->nedges ; i++)
          if (dp->etable->edges[i].used == USED_IN_NEW_TESSELLATION)
          {
            dp->etable->edges[i].used = NOT_USED ;
          }
      }

      /* saving the initial selection */
      if (parms->save_fname &&
          (parms->defect_number<0 ||
           (parms->defect_number==defect->defect_number)))
      {
        sprintf(fname,"%s/rh.defect_%d_select%d",
                parms->save_fname,defect->defect_number,i);
        savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
        if (parms->movie)
        {
          sprintf(fname,"%s/rh.defect_%d_movie_%d",
                  parms->save_fname,defect->defect_number,nmovies++);
          savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
        }
      }

      if (!i)
      {
        memmove(rp.best_ordering,dp->ordering,nedges*sizeof(int));
        memmove(rp.status,defect->status,defect->nvertices*sizeof(char));

        dp->defect->initial_face_ll=dp->tp.face_ll;
        dp->defect->initial_vertex_ll=dp->tp.vertex_ll;
        dp->defect->initial_curv_ll=dp->tp.curv_ll;
        dp->defect->initial_qcurv_ll=dp->tp.qcurv_ll;
        dp->defect->initial_mri_ll=dp->tp.mri_ll;
        dp->defect->initial_unmri_ll=dp->tp.unmri_ll;
        if (parms->verbose==VERBOSE_MODE_LOW)
        {
          fprintf(WHICH_OUTPUT,"defect %d: initial fitness = %2.4e, "
                  "nvertices=%d, nedges=%d, max patches=%d\n",
                  dno-1, fitness,
                  defect->nvertices, nedges, max_patches) ;
          printDefectStatistics(dp);
        }
        best_fitness = fitness ;
        best_i = 0 ;

        //saving first patch
        if (parms->save_fname &&
            (parms->defect_number<0 ||
             (parms->defect_number==defect->defect_number)))
        {
          sprintf(fname,"%s/rh.defect_%d_best_%d",
                  parms->save_fname,defect->defect_number,nbests++);
          savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
        }
        if (++nbest == debug_patch_n)
        {
          goto debug_use_this_patch ;
        }
      }

      if (fitness > best_fitness)
      {
        best_fitness = fitness ;
        best_i = i ;
        if (parms->verbose>VERBOSE_MODE_DEFAULT)
          fprintf(WHICH_OUTPUT,"new optimal fitness found at %d: "
                  "%2.4f\n", i, fitness) ;

        nfinalvertices=nremovedvertices;
        nbestpatch=number_of_patches;

        rp.best_fitness=best_fitness;
        /* save ordering*/
        memmove(rp.best_ordering,dp->ordering,nedges*sizeof(int));
        /* save current status of vertices */
        memmove(rp.status,defect->status,defect->nvertices*sizeof(char));

        if (parms->verbose==VERBOSE_MODE_LOW)
        {
          printDefectStatistics(dp);
        }
        if (parms->save_fname &&
            (parms->defect_number<0 ||
             (parms->defect_number==defect->defect_number)))
        {
          sprintf(fname,"%s/rh.defect_%d_best_%d_%d",
                  parms->save_fname,defect->defect_number,ngenerations,i);
          savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
          sprintf(fname,"%s/rh.defect_%d_best_%d",
                  parms->save_fname,defect->defect_number,nbests++);
          savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
        }
        if (++nbest == debug_patch_n)
        {
          goto debug_use_this_patch ;
        }
      }
    }
  }

  /*compute statistics*/
  for (fitness_mean = fitness_sigma = 0.0, i = 0 ; i < max_patches ; i++)
  {
    dp = &dps[i] ;
    fitness_mean += dp->fitness ;
    fitness_sigma += dp->fitness*dp->fitness ;
  }
  fitness_mean /= (float)max_patches ;
  fitness_sigma = (fitness_sigma/max_patches - (fitness_mean*fitness_mean)) ;
  if (fitness_sigma < 0)
  {
    fitness_sigma = 0 ;
  }
  else
  {
    fitness_sigma = sqrt(fitness_sigma) ;
  }

  if (parms->verbose>VERBOSE_MODE_DEFAULT)
    fprintf(WHICH_OUTPUT,
            "Initial population for defect %d:\nbest fitness at %d: %2.4f "
            "(%2.4f +- %2.4f)\n"
            ,defect->defect_number,best_i,best_fitness,
            fitness_mean,fitness_sigma);

  nelite = nint(ELITISM_PCT*max_patches) ;  /* # to keep in next generation */
  if (nelite < 1)
  {
    nelite = 1 ;
  }
  nselected = nint(SELECTION_PCT*max_patches) ;  /* # to allow to crossover */
  if (nselected < 2)
  {
    nselected = 2 ;
  }
  nreplacements =
    nint(REPLACEMENT_PCT*max_patches) ; /* # to replace with
                                           mutated versions of
                                           best */
  if (nreplacements + nelite > max_patches)
  {
    nreplacements = max_patches-nelite ;
  }
  g = 0 ;
  dps = dps1 ;


  last_fitness=best_fitness;

  while (nunchanged < max_unchanged)
  {
    if (ngenerations==parms->niters)
    {
      break;
    }

    if (dps == dps1)
    {
      dps_next_generation = dps2 ;
    }
    else
    {
      dps_next_generation = dps1 ;
    }

    last_best = best_fitness ;
    for (i = 0 ; i < max_patches ; i++)
    {
      dp = &dps[i] ;
      dp->rank = rank = defectPatchRank(dps, i, max_patches) ;
      ranks[rank] = i ;
    }

    /* first add the 'elite' group that are retained unchanged */
    next_gen_index = 0 ;
    for (i = 0 ; i < nelite ; i++)
      mrisCopyDefectPatch(&dps[ranks[i]],
                          &dps_next_generation[next_gen_index++]) ;

    /* now replace the worst ones with mutated copies of the best */
    for (i = 0 ; i < nreplacements ; i++)
    {
      ntotalmutations++;

      dp = &dps_next_generation[next_gen_index++] ;
      mrisCopyDefectPatch(&dps[ranks[i]], dp) ;
      mrisMutateDefectPatch(dp, &etable, MUTATION_PCT) ;
      fitness =
        mrisDefectPatchFitness
        (mris, mris_corrected, mri, dp, vertex_trans, dvs, &rp,
         h_k1,h_k2,mri_k1_k2,h_white,h_gray,
         h_border,h_grad, mri_gray_white, h_dot, parms) ;
#if SAVE_FIT_VALS
      fitness_values[number_of_patches]=fitness;
      if (number_of_patches)
        best_values[number_of_patches]=
          MAX(best_values[number_of_patches-1],fitness);
      else
      {
        best_values[number_of_patches]=fitness;
      }
#endif
      number_of_patches++;

      if (fitness > best_fitness)
      {
        nmutations++;
        nunchanged = 0 ;
        best_fitness = fitness ;
        best_i = next_gen_index-1 ;

        nfinalvertices=nremovedvertices;
        nbestpatch=number_of_patches;

        rp.best_fitness=best_fitness;
        /* save ordering*/
        memmove(rp.best_ordering,dp->ordering,nedges*sizeof(int));
        /* save current status of vertices */
        memmove(rp.status,defect->status,defect->nvertices*sizeof(char));

        if (parms->verbose>VERBOSE_MODE_DEFAULT)
          fprintf(WHICH_OUTPUT,"replacement %d MUTATION: new optimal "
                  "fitness found at %d: %2.4e\n",
                  i, best_i, fitness) ;
        if (parms->verbose==VERBOSE_MODE_LOW)
        {
          printDefectStatistics(dp);
        }
        if (parms->save_fname &&
            (parms->defect_number<0 ||
             (parms->defect_number==defect->defect_number)))
        {
          sprintf(fname,"%s/rh.defect_%d_surf_%d_%d",
                  parms->save_fname,defect->defect_number,
                  ngenerations-1,ranks[i]);
          savePatch(mri,mris,mris_corrected,dvs,
                    &dps[ranks[i]],fname,parms);
          sprintf(fname,"%s/rh.defect_%d_best_%d_%dm",
                  parms->save_fname,defect->defect_number,
                  ngenerations,ranks[i]);
          savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
          sprintf(fname,"%s/rh.defect_%d_best_%d",
                  parms->save_fname,defect->defect_number,nbests++);
          savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
          if (parms->movie)
          {
            sprintf(fname,"%s/rh.defect_%d_movie_%d",
                    parms->save_fname,defect->defect_number,nmovies++);
            savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
          }
        }
        nmut++ ;
        if (++nbest == debug_patch_n)
        {
          dps = dps_next_generation ;
          goto debug_use_this_patch ;
        }
      }
    }

    for (fitness_mean = fitness_sigma = 0.0, i = 0 ; i < max_patches ; i++)
    {
      dp = &dps[i] ;
      fitness_mean += dp->fitness ;
      fitness_sigma += dp->fitness*dp->fitness ;
    }

    fitness_mean /= (float)max_patches ;
    fitness_sigma =
      (fitness_sigma/max_patches - (fitness_mean*fitness_mean)) ;
    if (fitness_sigma < 0)
    {
      fitness_sigma = 0 ;
    }
    else
    {
      fitness_sigma = sqrt(fitness_sigma) ;
    }
    if (!finite(fitness_sigma))
    {
      DiagBreak() ;
    }

    two_sigma_sq = (dps[ranks[0]].fitness-dps[ranks[nselected-1]].fitness) ;
    if (FZERO(two_sigma_sq))
    {
      two_sigma_sq = 1 ;
    }
    for (fitness_norm = 0.0, j = 0 ; j < nselected ; j++)
    {
      i = ranks[j] ;
      dp = &dps[i] ;
      fitness_norm +=
        exp((dp->fitness-dps[ranks[0]].fitness)/two_sigma_sq);
      /* make
         them
         positive
         and
         increasing */
    }
    if (FZERO(fitness_norm))  /* something wrong */
    {
      for (i = 0 ; i < max_patches ; i++)
      {
        dp = &dps[i] ;
        dp->rank = rank = defectPatchRank(dps, i, max_patches) ;
        if (dp->fitness >= best_fitness)
        {
          best_fitness = dp->fitness ;
          best_i = i ;
        }
        ranks[rank] = i ;
      }
      break ;
    }

    /* selection of chromosomes for cross-over */
    ncrossovers = max_patches-(nelite+nreplacements) ;
    for (l = k = j = 0 ; j < nselected ; j++)
    {
      int  nadd ;

      i = ranks[j] ;
      dp = &dps[i] ;
      pfitness =
        exp((dp->fitness-dps[ranks[0]].fitness)/two_sigma_sq)/fitness_norm;
      nadd = nint(pfitness * ncrossovers) ;
      if (nadd >= ncrossovers)
      {
        nadd = ncrossovers-1 ;
      }
      else if (nadd == 0)
      {
        nadd = 1 ;
      }

      for (k = 0 ; l < ncrossovers && k < nadd ; l++, k++)
      {
        selected[l] = i ;
      }
    }
    for ( ; l < ncrossovers ; l++)   /* fill out rest of list */
    {
      double p ;
      p = randomNumber(0.0, 1.0)  ;
      for (fitness = 0.0, j = 0 ; j < nselected ; j++)
      {
        i = ranks[j] ;
        dp = &dps[i] ;
        pfitness = exp(dp->fitness/two_sigma_sq)/fitness_norm ;
        fitness += pfitness ;
        if (fitness > p)
        {
          break ;
        }
      }
      selected[l] = i ;
    }

    for (i = 0 ; i < ncrossovers ; i++)
    {
      int   p1, p2 ;
      ntotalcross_overs++;

      p1 = selected[i] ;
      do   /* select second parent at random */
      {
        p2 = selected[(int)randomNumber(0, ncrossovers-.001)] ;
      }
      while (p2 == p1) ;

      dp = &dps_next_generation[next_gen_index++] ;
      mrisCrossoverDefectPatches(&dps[p1], &dps[p2], dp, &etable) ;
      fitness = mrisDefectPatchFitness
                (mris, mris_corrected, mri, dp, vertex_trans, dvs, &rp,
                 h_k1,h_k2,mri_k1_k2,h_white,h_gray,
                 h_border,h_grad, mri_gray_white, h_dot, parms) ;
#if SAVE_FIT_VALS
      fitness_values[number_of_patches]=fitness;
      if (number_of_patches)
        best_values[number_of_patches]=
          MAX(best_values[number_of_patches-1],fitness);
      else
      {
        best_values[number_of_patches]=fitness;
      }
#endif
      number_of_patches++;

      if (fitness > best_fitness)
      {
        ncross_overs++;
        nunchanged = 0 ;
        best_fitness = fitness ;
        best_i = next_gen_index-1 ;

        nfinalvertices=nremovedvertices;
        nbestpatch=number_of_patches;

        rp.best_fitness=best_fitness;
        /* save ordering*/
        memmove(rp.best_ordering,dp->ordering,nedges*sizeof(int));
        /* save current status of vertices */
        memmove(rp.status,defect->status,defect->nvertices*sizeof(char));

        if (parms->verbose>VERBOSE_MODE_DEFAULT)
          fprintf(WHICH_OUTPUT,
                  "CROSSOVER (%d x %d): new optimal fitness "
                  "found at %d: %2.4e\n",
                  dps[p1].rank, dps[p2].rank, best_i, fitness) ;
        if (parms->verbose==VERBOSE_MODE_LOW)
        {
          printDefectStatistics(dp);
        }
        if (parms->save_fname &&
            (parms->defect_number<0 ||
             (parms->defect_number==defect->defect_number)))
        {
          sprintf(fname,"%s/rh.defect_%d_surf_%d_%d",
                  parms->save_fname,defect->defect_number,
                  ngenerations-1,dps[p1].rank);
          savePatch(mri,mris,mris_corrected,dvs,&dps[p1],fname,parms);
          sprintf(fname,"%s/rh.defect_%d_surf_%d_%d",
                  parms->save_fname,defect->defect_number,
                  ngenerations-1,dps[p2].rank);
          savePatch(mri,mris,mris_corrected,dvs,&dps[p2],fname,parms);
          sprintf(fname,"%s/rh.defect_%d_best_%d_%dc%d_%d",
                  parms->save_fname,defect->defect_number,
                  ngenerations,best_i,dps[p1].rank, dps[p2].rank);
          savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
          sprintf(fname,"%s/rh.defect_%d_best_%d",
                  parms->save_fname,defect->defect_number,nbests++);
          savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
          if (parms->movie)
          {
            sprintf(fname,"%s/rh.defect_%d_movie_%d",
                    parms->save_fname,defect->defect_number,nmovies++);
            savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
          }
        }

        ncross++ ;
        if (++nbest == debug_patch_n)
        {
          dps = dps_next_generation ;
          goto debug_use_this_patch ;
        }
      }
      else   /* mutate it also */
      {
        mrisMutateDefectPatch(dp, &etable, MUTATION_PCT) ;
        fitness =
          mrisDefectPatchFitness
          (mris, mris_corrected, mri, dp, vertex_trans, dvs, &rp,
           h_k1,h_k2,mri_k1_k2,h_white,h_gray,
           h_border, h_grad, mri_gray_white, h_dot, parms) ;
#if SAVE_FIT_VALS
        fitness_values[number_of_patches]=fitness;
        if (number_of_patches)
          best_values[number_of_patches]=
            MAX(best_values[number_of_patches-1],fitness);
        else
        {
          best_values[number_of_patches]=fitness;
        }
#endif
        number_of_patches++;
        ntotalmutations++;

        if (fitness > best_fitness)
        {
          nmutations++;
          nunchanged = 0 ;
          best_fitness = fitness ;
          best_i = next_gen_index-1 ;

          nfinalvertices=nremovedvertices;
          nbestpatch=number_of_patches;

          rp.best_fitness=best_fitness;
          /* save ordering*/
          memmove(rp.best_ordering,dp->ordering,nedges*sizeof(int));
          /* save current status of vertices */
          memmove(rp.status,defect->status,
                  defect->nvertices*sizeof(char));

          if (parms->verbose>VERBOSE_MODE_DEFAULT)
            fprintf(WHICH_OUTPUT,"CROSSOVER (%d x %d) & MUTATION: "
                    "new optimal fitness found at %d: %2.4e\n",
                    dps[p1].rank , dps[p2].rank , best_i, fitness) ;
          if (parms->verbose==VERBOSE_MODE_LOW)
          {
            printDefectStatistics(dp);
          }
          if (parms->save_fname &&
              (parms->defect_number<0 ||
               (parms->defect_number==defect->defect_number)))
          {
            sprintf(fname,"%s/rh.defect_%d_surf_%d_%d",
                    parms->save_fname,defect->defect_number,
                    ngenerations-1,dps[p1].rank);
            savePatch(mri,mris,mris_corrected,dvs,
                      &dps[p1],fname,parms);
            sprintf(fname,"%s/rh.defect_%d_surf_%d_%d",
                    parms->save_fname,defect->defect_number,
                    ngenerations-1,dps[p2].rank);
            savePatch(mri,mris,mris_corrected,dvs,
                      &dps[p2],fname,parms);
            sprintf(fname,"%s/rh.defect_%d_best_%d_%dcm%d_%d",
                    parms->save_fname,
                    defect->defect_number,
                    ngenerations,best_i,dps[p1].rank, dps[p2].rank);
            savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);

            sprintf(fname,"%s/rh.defect_%d_best_%d",
                    parms->save_fname,
                    defect->defect_number,nbests++);
            savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
            if (parms->movie)
            {
              sprintf(fname,"%s/rh.defect_%d_movie_%d",
                      parms->save_fname,
                      defect->defect_number,nmovies++);
              savePatch(mri,mris,mris_corrected,dvs,dp,fname,parms);
            }
          }

          if (++nbest == debug_patch_n)
          {
            dps = dps_next_generation ;
            goto debug_use_this_patch ;
          }
          nmut++ ;
          ncross++;
        }
      }
    }

    /* make next generation current */
    if (dps == dps1)
    {
      dps = dps2 ;
      dps_next_generation = dps1 ;
    }
    else
    {
      dps = dps1 ;
      dps_next_generation = dps2 ;
    }


    best_fitness = dps[0].fitness ;
    best_i = 0 ;
    for (fitness_mean = fitness_sigma = 0.0, i = 0 ; i < max_patches ; i++)
    {
      dp = &dps[i] ;
      dp->rank = rank = defectPatchRank(dps, i, max_patches) ;
      if (dp->fitness >= best_fitness)
      {
        best_fitness = dp->fitness ;
        best_i = i ;
      }
      ranks[rank] = i ;
      fitness_mean += dp->fitness ;
      fitness_sigma += dp->fitness*dp->fitness ;
    }

    fitness_mean /= (float)max_patches ;
    fitness_sigma =
      sqrt(fitness_sigma/max_patches - (fitness_mean*fitness_mean)) ;
    if (parms->verbose>VERBOSE_MODE_DEFAULT)
      fprintf
      (WHICH_OUTPUT,
       "generation %d complete, optimal fitness = "
       "%2.4e (%2.4e +- %2.4e)\n", ++g,best_fitness,
       fitness_mean, fitness_sigma);
    if (FEQUAL(last_best, best_fitness))
    {
      nunchanged++ ;
    }
    else
    {
      last_euthanasia=-1;
      nunchanged = 0 ;
    }

    if (parms->save_fname && (parms->defect_number<0 ||
                              (parms->defect_number==defect->defect_number)))
    {
      sprintf(fname,"%s/rh.defect_%d_generation_%d",
              parms->save_fname,defect->defect_number,ngenerations);
      savePatch(mri,mris,mris_corrected,dvs,&dps[best_i],fname,parms);
    }

#define NEXT 5

    if (parms->vertex_eliminate)
    {
      static int count=1;
      int ndeleted;
      if (nunchanged >= max_unchanged)
      {
        //will eventually break out
        if (last_euthanasia<0)
        {
          last_euthanasia=ngenerations;
          last_fitness=best_fitness;
        }
        if (last_euthanasia+NEXT <= ngenerations)
        {
          break;
        }
        if (last_fitness<best_fitness)
        {
          last_euthanasia=ngenerations;
        }
        if (nunchanged >= max_unchanged)
        {
          nunchanged -= NEXT;
        }

        if (parms->verbose==VERBOSE_MODE_LOW)
        {
          fprintf(WHICH_OUTPUT,"Deleting worst vertices : ");
        }
        ndeleted=deleteWorstVertices
                 (mris_corrected,&rp,defect,vertex_trans,0.2,count);
        nremovedvertices+=ndeleted;
        if (parms->verbose==VERBOSE_MODE_LOW)
        {
          fprintf(WHICH_OUTPUT,"%d vertices have been deleted\n",ndeleted);
        }
        if (ndeleted==0)
        {
          break;
        }
        count++;
      }
      else if (ngenerations>=10 && (ngenerations%3 == 0))
      {
        ndeleted=deleteWorstVertices
                 (mris_corrected,&rp,defect,vertex_trans,0.1,count);
        nremovedvertices+=ndeleted;
        if (parms->verbose==VERBOSE_MODE_LOW)
        {
          if (ndeleted==1)
          {
            fprintf(WHICH_OUTPUT,"Worst vertex has been deleted\n");
          }
          else if (ndeleted)
            fprintf
            (WHICH_OUTPUT,
             "Worst %d vertices have been deleted (corresponds to ~1%%)\n",
             ndeleted);
        }
      }
    }

    ngenerations++;
  }

debug_use_this_patch:
  dp = &dps[best_i] ;

  if (parms->save_fname && (parms->defect_number<0 ||
                            (parms->defect_number==defect->defect_number)))
  {
    /* save eliminated vertices */
    for ( i = 0 ; i < mris->nvertices ; i++)
    {
      mris->vertices[i].curv=0;
    }

    for (i = 0 ; i < defect->nvertices ; i++)
    {
      if (vertex_trans[dp->defect->vertices[i]] < 0 )
      {
        continue;
      }
      k=mris_corrected->vertices\
        [vertex_trans[dp->defect->vertices[i]]].ripflag;
      if (k)
      {
        mris->vertices[defect->vertices[i]].curv=k;
      }
    }
    sprintf(fname,"%s/rh.eliminated_%d",
            parms->save_fname,defect->defect_number);
    MRISwriteCurvature(mris,fname);

    /* save vertex statistics */
    for (i = 0 ; i < defect->nvertices ; i++)
    {
      mris->vertices[defect->vertices[i]].curv=0;
      if (defect->status[i]==DISCARD_VERTEX)
      {
        continue;
      }
      mris->vertices[defect->vertices[i]].curv=rp.vertex_fitness[i];
    }
    sprintf(fname,"%s/rh.rp_fitness_%d",
            parms->save_fname,defect->defect_number);
    MRISwriteCurvature(mris,fname);
  }

  nkilled += nfinalvertices;

  /* use the best ordering to retessellate the defected patch */
  memmove(dp->ordering,rp.best_ordering,nedges*sizeof(int));
  memmove(defect->status,rp.status,defect->nvertices*sizeof(char));

  /* set back to unrip the correct vertices*/
  for (i = 0 ; i < defect->nvertices ; i++)
  {
    /* careful with vertex_trans */
    int vni;
    vni=vertex_trans[dp->defect->vertices[i]];
    if (vni<0)
    {
      continue;
    }
    if (defect->status[i]!=DISCARD_VERTEX)
    {
      mris_corrected->vertices[vni].ripflag=0;
    }
    else
    {
      mris_corrected->vertices[vni].ripflag=1;
    }
  }

  fitness = mrisDefectPatchFitness
            (mris, mris_corrected, mri, dp, vertex_trans,dvs,
             &rp,h_k1,h_k2,mri_k1_k2,h_white,h_gray,
             h_border, h_grad, mri_gray_white, h_dot, parms);

  defect->fitness=fitness; /* saving the fitness of the patch */

  if (fitness != best_fitness)
    fprintf(WHICH_OUTPUT,
            "Warning - incorrect dp selected!!!!(%f >= %f ) \n",
            fitness,best_fitness) ;

  if (parms->verbose==VERBOSE_MODE_LOW)
  {
    printDefectStatistics(dp);
  }

  /* compute the final tessellation */
  retessellateDefect(mris, mris_corrected, dvs,dp) ;

  /* detect the new set of faces */
  detectDefectFaces(mris_corrected,dp);
  /* orient the patch faces */
  orientDefectFaces(mris_corrected,dp);
  /* smooth original vertices in the retessellated patch */
  defectMatch(mri,mris_corrected,dp,parms->smooth,parms->match);

  /* reset the number of original faces in the
     surface before the retessellation */
  //mrisRestoreFaceVertexState(mris_corrected, dvs) ;

  nintersections=0; /* compiler warnings... */
  if (parms->check_surface_intersection)
    nintersections=mrisCountIntersectingFaces
                   (mris_corrected,dp->tp.faces,dp->tp.nfaces);

  /* saving self-intersection */
  defect->intersect=nintersections;

  if (parms->verbose==VERBOSE_MODE_HIGH)
  {
    fprintf
    (WHICH_OUTPUT,
     "PATCH #:%03d:  FITNESS:   %2.2f\n              "
     "MUTATIONS: %d (out of %d)\n              "
     "CROSSOVERS: %d (out of %d)\n",
     defect->defect_number,fitness,nmutations,
     ntotalmutations,ncross_overs,ntotalcross_overs);
    fprintf
    (WHICH_OUTPUT,
     "              ELIMINATED VERTICES:  %d (out of %d)\n",
     nfinalvertices,defect->nvertices);
    fprintf
    (WHICH_OUTPUT,
     "              BEST PATCH #: %d (out of %d generated patches)\n",
     nbestpatch,number_of_patches);
    if (parms->check_surface_intersection)
      fprintf
      (WHICH_OUTPUT,
       "              NUMBER OF INTERSECTING FACES: %d (out of %d) \n",
       nintersections,dp->tp.nfaces);
  }

  /* should free the tessellated patch structure */
  TPfree(&dp->tp);

  /* discard the vertices that are not used in the
     final tessellation and set marks to zero!!!*/
  for (i = 0 ; i < dp->nedges ; i++)
    if (dp->etable->edges[i].used == USED_IN_NEW_TESSELLATION ||
        dp->etable->edges[i].used == USED_IN_BOTH_TESSELLATION)
    {
      mris_corrected->vertices[dp->etable->edges[i].vno1].marked=FINAL_VERTEX ;
      mris_corrected->vertices[dp->etable->edges[i].vno2].marked=FINAL_VERTEX ;
    }

  for (k = i = 0 ; i < dp->defect->nvertices ; i++)
  {
    if (mris_corrected->vertices[vertex_trans[dp->defect->vertices[i]]].marked
        !=FINAL_VERTEX)
    {
      if (dp->defect->status[i]!=DISCARD_VERTEX)
      {
        k++;
      }
      dp->defect->status[i]=DISCARD_VERTEX;
      mris_corrected->\
      vertices[vertex_trans[dp->defect->vertices[i]]].ripflag=1;
    }
    mris_corrected->vertices[vertex_trans[dp->defect->vertices[i]]].marked=0;
  }

  for (i = 0 ; i < dp->defect->nborder ; i++)
  {
    mris_corrected->vertices[vertex_trans[dp->defect->border[i]]].marked=0;
  }

  /* free everything */
  mrisFreeDefectVertexState(dvs) ;

  for (i = 0 ; i < max_patches ; i++)
  {
    free(dps1[i].ordering) ;
    free(dps2[i].ordering) ;
  }

  if (etable.use_overlap)
  {
    for (i = 0 ; i < nedges ; i++)
    {
      if (etable.overlapping_edges[i])
      {
        free(etable.overlapping_edges[i]) ;
      }
    }
    free(etable.overlapping_edges) ;
    free(etable.noverlap) ;
    free(etable.flags) ;
  }
  free(etable.edges) ;

  free(rp.best_ordering);
  free(rp.status);
  free(rp.nused);
  free(rp.vertex_fitness);

  if (mri_defect)
  {
    MRIfree(&mri_defect);
  }
  if (mri_defect_white)
  {
    MRIfree(&mri_defect_white);
  }
  if (mri_defect_gray)
  {
    MRIfree(&mri_defect_gray);
  }
  if (mri_defect_sign)
  {
    MRIfree(&mri_defect_sign);
  }

#if SAVE_FIT_VALS
  {
    FILE *f;
    int n;
    f=fopen("./optimal1.plt", "w+") ;
    for (n=0; n<number_of_patches; n++)
    {
      fprintf(f,"%d %2.2f\n",n,fitness_values[n]);
    }
    fclose(f);
    f=fopen("./optimal2.plt", "w+") ;
    for (n=0; n<number_of_patches; n++)
    {
      fprintf(f,"%d %2.2f\n",n,best_values[n]);
    }
    fclose(f);
  }
#endif


  return(NO_ERROR) ;
}


static int
mrisComputeRandomRetessellation
(MRI_SURFACE *mris, MRI_SURFACE *mris_corrected,
 MRI *mri, DEFECT *defect, int *vertex_trans,
 EDGE *et, int nedges, ES *es,int nes,
 HISTOGRAM *h_k1, HISTOGRAM *h_k2,MRI* mri_k1_k2,
 HISTOGRAM *h_white, HISTOGRAM *h_gray, HISTOGRAM *h_border,
 HISTOGRAM *h_grad, MRI *mri_gray_white, HISTOGRAM *h_dot,
 TOPOLOGY_PARMS *parms)
{
  DEFECT_VERTEX_STATE *dvs ;
  DEFECT_PATCH        dp;
  int niters,m, tmp,best_i, i,j, k,noverlap ;
  int *overlap ,ngenerations,nbests,last_euthanasia;
  int nremovedvertices,nfinalvertices;
  double              fitness, best_fitness;
  static int dno = 0 ;   /* for debugging */
  //static int nmovies=1;
  /* for making movies :
     0 is left for the original surface*/
  EDGE_TABLE          etable ;
  MRI *mri_defect,*mri_defect_white,*mri_defect_gray,*mri_defect_sign;
  char fname[500];
  RP rp;
  int nbestpatch;
  static int first_time=1;

  if (first_time)
  {
    char *cp;

    if ((cp = getenv("FS_QCURV")) != NULL)
    {
      parms->l_qcurv = atof(cp) ;
      printf("setting qcurv = %2.3f\n", l_qcurv) ;
    }
    if ((cp = getenv("FS_CURV")) != NULL)
    {
      parms->l_curv = atof(cp) ;
      printf("setting curv = %2.3f\n", l_curv) ;
    }
    if ((cp = getenv("FS_MRI")) != NULL)
    {
      parms->l_mri = atof(cp) ;
      printf("setting mri = %2.3f\n", l_mri) ;
    }
    if ((cp = getenv("FS_UNMRI")) != NULL)
    {
      parms->l_unmri = atof(cp) ;
      printf("setting unmri = %2.3f\n", l_unmri) ;
    }
    first_time=0;
  }


  dno++ ;  /* for debugging */

  if (nedges > 200000)
  {
    //add some code here to select a good tessellation (ordering) FLO
    //mrisRetessellateDefect(mris, mris_corrected, defect,
    // vertex_trans, et, nedges, NULL, NULL) ;
    tessellatePatch(mri,mris, mris_corrected, defect,vertex_trans,
                    et, nedges, NULL, NULL,parms);

    return(NO_ERROR) ;
  };

  etable.use_overlap=0;// XXX parms->edge_table;
  etable.nedges = nedges ;
  etable.edges = (EDGE *)calloc(nedges, sizeof(EDGE)) ;
  memmove(etable.edges, et, nedges*sizeof(EDGE)) ;

  if (etable.use_overlap)
  {
    etable.overlapping_edges = (int **)calloc(nedges, sizeof(int *)) ;
    etable.noverlap = (int *)calloc(nedges, sizeof(int)) ;
    etable.flags = (unsigned char *)calloc(nedges, sizeof(unsigned char)) ;
    overlap = (int *)calloc(nedges, sizeof(int)) ;
    if (!etable.edges ||
        !etable.overlapping_edges ||
        !etable.noverlap ||
        !overlap)
      ErrorExit(ERROR_NOMEMORY, "mrisComputeOptimalRetessellation: Excessive "
                "topologic defect encountered: could not allocate "
                "%d edge table",nedges) ;

    for (i = 0 ; i < nedges ; i++)  /* compute overlapping for each edge */
    {
      if (nedges > 50000 && !(i % 25000))
      {
        printf("%d of %d edges processed\n", i, nedges) ;
      }
      etable.noverlap[i] = 0 ;
      for (noverlap = j = 0 ; j < nedges ; j++)
      {
        if (j == i)
        {
          continue ;
        }
        if (edgesIntersect(mris_corrected, &et[i], &et[j]))
        {
          overlap[noverlap] = j ;
          noverlap++ ;
        }
        if (noverlap > MAX_EDGES)
        {
          break ;
        }
      }
      if (noverlap > 0)
      {
        if (noverlap > MAX_EDGES)
        {
          etable.noverlap[i] = MAX_EDGES ;
          etable.flags[i] |= ET_OVERLAP_LIST_INCOMPLETE ;
        }
        else
        {
          etable.noverlap[i] = noverlap ;
        }

        etable.overlapping_edges[i] =
          (int *)calloc(etable.noverlap[i], sizeof(int)) ;
        if (!etable.overlapping_edges[i])
          ErrorExit(ERROR_NOMEMORY,
                    "mrisComputeOptimalRetessellation: Excessive "
                    "topologic defect encountered: could not allocate "
                    "overlap list %d "
                    "with %d elts",i, etable.noverlap[i]) ;
        memmove(etable.overlapping_edges[i], overlap,
                etable.noverlap[i]*sizeof(int)) ;
      };
    }
    free(overlap) ;
  }

  /* allocate the volume constituted by the potential edges */
  mri_defect = mri_defect_white = mri_defect_gray = mri_defect_sign = NULL;
  if (!FZERO(parms->l_unmri))
  {
    mri_defect = mriDefectVolume(mris_corrected, &etable,parms);
    mri_defect_white =
      MRIalloc
      (mri_defect->width,mri_defect->height,mri_defect->depth,MRI_FLOAT);
    mri_defect_gray =
      MRIalloc
      (mri_defect->width,mri_defect->height,mri_defect->depth,MRI_FLOAT);
    mri_defect_sign =
      MRIalloc
      (mri_defect->width,mri_defect->height,mri_defect->depth,MRI_FLOAT);
    defectVolumeLikelihood(mri, mri_defect, mri_defect_white, mri_defect_gray,
                           h_white, h_gray,defect->white_mean,
                           defect->gray_mean,0,0);
  };

  if ((!FZERO(parms->l_unmri)) && parms->save_fname &&
      (parms->defect_number<0 ||
       (parms->defect_number==defect->defect_number)))
  {
    sprintf(fname,"%s/white_%d.mgh",parms->save_fname,defect->defect_number);
    MRIwrite(mri_defect_white,fname);
    sprintf(fname,"%s/gray_%d.mgh",parms->save_fname,defect->defect_number);
    MRIwrite(mri_defect_gray,fname);
  }

  dvs = mrisRecordVertexState(mris_corrected, defect, vertex_trans) ;

  ngenerations=0;
  last_euthanasia=-1;
  nremovedvertices=0;
  nfinalvertices=0;
  nbests=0;
  nbestpatch=0;
  best_fitness=0;

  /* generate Random Patch */
  rp.best_ordering=(int*)malloc(nedges*sizeof(int));
  rp.status=(char*)malloc(defect->nvertices*sizeof(char));
  memmove(rp.status,defect->status,defect->nvertices*sizeof(char));
  rp.nused=(int*)calloc(defect->nvertices,sizeof(int));
  rp.vertex_fitness=(float*)calloc(defect->nvertices,sizeof(float));

  if (parms->retessellation_mode)
  {
    dp.retessellation_mode=USE_SOME_VERTICES;
  }
  else
  {
    dp.retessellation_mode=USE_ALL_VERTICES;
  }

  dp.nedges = nedges ;
  dp.defect = defect ;
  dp.etable = &etable ;
  dp.ordering = (int *)calloc(nedges, sizeof(int)) ;
  if (!dp.ordering)
    ErrorExit
    (ERROR_NOMEMORY,
     "could not allocate defect patch with %d indices",nedges) ;
  for (j = 0 ; j < nedges ; j++)
  {
    dp.ordering[j] = j ;  /* initial in same order - will change later */
  }

  dp.mri_defect=mri_defect;
  dp.mri_defect_white=mri_defect_white;
  dp.mri_defect_gray=mri_defect_gray;
  dp.mri_defect_sign=mri_defect_sign;
  dp.mri=mri;

  niters=0;
  while (niters <= parms->niters)
  {
    if (niters%100==0)
    {
      fprintf(stderr,"iteration %d\n",niters);
    }

    if (niters)
    {
      /* first one is in same order as
         original edge table -random ordering otherwise */
      for (m=0; m<11; m++)
        for (j=0; j< nedges; j++)
        {
          k=nint(randomNumber(0.0, (double)nedges-1)) ;

          tmp=dp.ordering[j];
          dp.ordering[j]=dp.ordering[k];
          dp.ordering[k]=tmp;
        }
    }

    fitness =
      mrisDefectPatchFitness
      (mris, mris_corrected, mri, &dp, vertex_trans, dvs, &rp,
       h_k1,h_k2,mri_k1_k2,h_white,h_gray,h_border,h_grad,mri_gray_white,
       h_dot, parms) ;


#if SAVE_FIT_VALS
    fitness_values[niters]=fitness;
    if (niters)
    {
      best_values[niters]=MAX(best_values[niters-1],fitness);
    }
    else
    {
      best_values[niters]=fitness;
    }
#endif

    if ((!niters) || (fitness > best_fitness))
    {
      best_fitness = fitness ;
      best_i = niters ;
      printf("new optimal fitness found at %d: %2.4f\n", niters, fitness) ;

      nfinalvertices=nremovedvertices;
      nbestpatch=niters;

      rp.best_fitness=best_fitness;
      /* save ordering*/
      memmove(rp.best_ordering,dp.ordering,nedges*sizeof(int));
      /* save current status of vertices */
      memmove(rp.status,defect->status,defect->nvertices*sizeof(char));

      if (parms->verbose==VERBOSE_MODE_LOW)
      {
        printDefectStatistics(&dp);
      }
      if (parms->save_fname && (parms->defect_number<0 ||
                                (parms->defect_number==defect->defect_number)))
      {
        sprintf(fname,"%s/rh.defect_%d_best_%d_%d",
                parms->save_fname,defect->defect_number,ngenerations,niters);
        savePatch(mri,mris,mris_corrected,dvs,&dp,fname,parms);
        sprintf(fname,"%s/rh.defect_%d_best_%d",
                parms->save_fname,defect->defect_number,nbests++);
        savePatch(mri,mris,mris_corrected,dvs,&dp,fname,parms);
      }
    }
    niters++;
  }



  if (parms->save_fname && (parms->defect_number<0 ||
                            (parms->defect_number==defect->defect_number)))
  {
    /* save eliminated vertices */
    for ( i = 0 ; i < mris->nvertices ; i++)
    {
      mris->vertices[i].curv=0;
    }

    for (i = 0 ; i < defect->nvertices ; i++)
    {
      if (vertex_trans[dp.defect->vertices[i]]<0)
      {
        continue;
      }
      k=mris_corrected->vertices[vertex_trans[dp.defect->vertices[i]]].ripflag;
      if (k)
      {
        mris->vertices[defect->vertices[i]].curv=k;
      }
    }
    sprintf(fname,"%s/rh.eliminated_%d",
            parms->save_fname,defect->defect_number);
    MRISwriteCurvature(mris,fname);

    /* save vertex statistics */
    for (i = 0 ; i < defect->nvertices ; i++)
    {
      mris->vertices[defect->vertices[i]].curv=0;
      if (defect->status[i]==DISCARD_VERTEX)
      {
        continue;
      }
      mris->vertices[defect->vertices[i]].curv=rp.vertex_fitness[i];
    }
    sprintf(fname,"%s/rh.rp_fitness_%d",
            parms->save_fname,defect->defect_number);
    MRISwriteCurvature(mris,fname);
  }

  fprintf
  (WHICH_OUTPUT,
   "%d (out of %d) vertices were eliminated from retessellated patch\n",
   nfinalvertices,defect->nvertices);
  fprintf
  (WHICH_OUTPUT,
   "best patch # is %d - total number of generated patches %d\n",
   nbestpatch,niters-1);
  nkilled += nfinalvertices;

  /* use the best ordering to retessellate the defected patch */
  memmove(dp.ordering,rp.best_ordering,nedges*sizeof(int));
  memmove(defect->status,rp.status,defect->nvertices*sizeof(char));

  /* set back to unrip the correct vertices*/
  for (i = 0 ; i < defect->nvertices ; i++)
  {
    int vni;
    vni= vertex_trans[dp.defect->vertices[i]];
    if ( vni < 0 )
    {
      continue;
    }
    if (defect->status[i]!=DISCARD_VERTEX)
    {
      mris_corrected->vertices[vni].ripflag=0;
    }
    else
    {
      mris_corrected->vertices[vni].ripflag=1;
    }
  }

  fitness =
    mrisDefectPatchFitness
    (mris, mris_corrected, mri, &dp,
     vertex_trans,dvs,&rp,h_k1,h_k2,mri_k1_k2,h_white,h_gray,
     h_border, h_grad, mri_gray_white, h_dot, parms);

  if (fitness != best_fitness)
    fprintf
    (WHICH_OUTPUT,
     "Warning - incorrect dp selected!!!!(%f >= %f ) \n",
     fitness,best_fitness) ;

  if (parms->verbose==VERBOSE_MODE_LOW)
  {
    printDefectStatistics(&dp);
  }

  /* compute the final tessellation */
  retessellateDefect(mris, mris_corrected, dvs,&dp) ;

  /* detect the new set of faces */
  detectDefectFaces(mris_corrected,&dp);
  /* orient the patch faces */
  orientDefectFaces(mris_corrected,&dp);
  /* smooth original vertices in the retessellated patch */
  defectMatch(mri,mris_corrected,&dp,parms->smooth,parms->match);

  /* reset the number of original faces in the
     surface before the retessellation */
  //mrisRestoreFaceVertexState(mris_corrected, dvs) ;

  /* should free the tessellated patch structure */
  TPfree(&dp.tp);

  /* discard the vertices that are not used in the
     final tessellation and set marks to zero!!!*/
  for (i = 0 ; i < dp.nedges ; i++)
    if (dp.etable->edges[i].used == USED_IN_NEW_TESSELLATION ||
        dp.etable->edges[i].used == USED_IN_BOTH_TESSELLATION)
    {
      mris_corrected->vertices[dp.etable->edges[i].vno1].marked=FINAL_VERTEX ;
      mris_corrected->vertices[dp.etable->edges[i].vno2].marked=FINAL_VERTEX ;
    }

  for (k = i = 0 ; i < dp.defect->nvertices ; i++)
  {
    if (mris_corrected->vertices[vertex_trans[dp.defect->vertices[i]]].marked
        !=FINAL_VERTEX)
    {
      if (dp.defect->status[i]!=DISCARD_VERTEX)
      {
        k++;
      }
      dp.defect->status[i]=DISCARD_VERTEX;
      mris_corrected->vertices[vertex_trans[dp.defect->vertices[i]]].ripflag=1;
    }
    mris_corrected->vertices[vertex_trans[dp.defect->vertices[i]]].marked=0;
  }

  for (i = 0 ; i < dp.defect->nborder ; i++)
  {
    mris_corrected->vertices[vertex_trans[dp.defect->border[i]]].marked=0;
  }

  /* free everything */
  mrisFreeDefectVertexState(dvs) ;

  free(dp.ordering);

  if (etable.use_overlap)
  {
    for (i = 0 ; i < nedges ; i++)
    {
      if (etable.overlapping_edges[i])
      {
        free(etable.overlapping_edges[i]) ;
      }
    }
    free(etable.overlapping_edges) ;
    free(etable.noverlap) ;
    free(etable.flags) ;
  }
  free(etable.edges) ;

  free(rp.best_ordering);
  free(rp.status);
  free(rp.nused);
  free(rp.vertex_fitness);

  if (mri_defect)
  {
    MRIfree(&mri_defect);
  }
  if (mri_defect_white)
  {
    MRIfree(&mri_defect_white);
  }
  if (mri_defect_gray)
  {
    MRIfree(&mri_defect_gray);
  }
  if (mri_defect_sign)
  {
    MRIfree(&mri_defect_sign);
  }

#if SAVE_FIT_VALS
  {
    FILE *f;
    int n;
    f=fopen("./random1.plt", "w+") ;
    for (n=0; n<niters; n++)
    {
      fprintf(f,"%d %2.2f\n",n,fitness_values[n]);
    }
    fclose(f);
    f=fopen("./random2.plt", "w+") ;
    for (n=0; n<niters; n++)
    {
      fprintf(f,"%d %2.2f\n",n,best_values[n]);
    }
    fclose(f);
  }
#endif

  return(NO_ERROR) ;
}

static int
mrisRetessellateDefect
(MRI_SURFACE *mris, MRI_SURFACE *mris_corrected, DEFECT *defect,
 int *vertex_trans, EDGE *et, int nedges, int *ordering, EDGE_TABLE *etable)
{
  double  max_len ;
  int     i, j, max_i, max_added, nadded, index ;
  int     (*intersection_function)(MRI_SURFACE *mris, DEFECT *defect,
                                   EDGE *e, int *vertex_trans,
                                   int *v1,int *v2) ;

  max_len = 0 ;
  max_i = 0 ;
  max_added = nadded = 0 ;
  intersection_function = intersectDefectEdges ;
  for (index = 0 ; index < nedges ; index++)
  {
    if (ordering)
    {
      i = ordering[index] ;
    }
    else
    {
      i = index ;
    }

    if (i == 1662 || i == 1685)
    {
      DiagBreak() ;
    }
    if ((et[i].vno1 == 52022 || et[i].vno2 == 52022) &&
        (et[i].vno1 == 53156 || et[i].vno2 == 53156))
    {
      DiagBreak() ;
    }
    if (et[i].vno1 == Gdiag_no || et[i].vno2 == Gdiag_no)
    {
      DiagBreak() ;
    }

    if (et[i].used && et[i].used !=
        USED_IN_ORIGINAL_TESSELLATION )  /* already exists in
                                                          tessellation -
                                                          don't add it again */
    {
      continue ;
    }

    if (etable && etable->use_overlap)   /* use pre-computed
                                                          intersection table */
    {
      int intersects = 0 ;

      for (j = 0 ; j < etable->noverlap[i] ; j++)
        if (et[etable->overlapping_edges[i][j]].used &&
            et[etable->overlapping_edges[i][j]].used !=
            USED_IN_ORIGINAL_TESSELLATION)
        {
          intersects = 1 ;
          break ;
        }
      if (intersects)
      {
        continue ;
      }
      if (etable->flags[i] & ET_OVERLAP_LIST_INCOMPLETE)
      {
        intersection_function = intersectDefectEdges ;
      }
      else
      {
        intersection_function = intersectDefectConvexHullEdges ;
      }
    }

    if ((*intersection_function)(mris_corrected, defect,
                                 &et[i], vertex_trans,NULL,NULL) == 0)
    {
      mrisAddEdge(mris_corrected, et[i].vno1, et[i].vno2) ;
      if (et[i].used)
      {
        et[i].used = USED_IN_BOTH_TESSELLATION ;
        nadded++ ;
      }
      else
      {
        et[i].used = USED_IN_NEW_TESSELLATION ;
        nadded++ ;
      }
      if (et[i].len > max_len)
      {
        max_len = et[i].len ;
        max_added = nadded-1 ;
        max_i = i ;
      }
    }
  }

  return(NO_ERROR) ;
}

static int
compare_edge_length(const void *pe0, const void *pe1)
{
  register EDGE *e0, *e1 ;

  e0 = (EDGE *)pe0 ;
  e1 = (EDGE *)pe1 ;

  /*  return(c1 > c2 ? 1 : c1 == c2 ? 0 : -1) ;*/
  if (e0->len > e1->len)
  {
    return(1) ;
  }
  else if (e0->len < e1->len)
  {
    return(-1) ;
  }

  return(0) ;
}
#if 0
static int
mrisCheckDefectEdges(MRI_SURFACE *mris, DEFECT *defect, int vno,
                     int *vertex_trans)
{
  int    i, n1, n2, n3, vno2, fno1, fno2 ;
  EDGE   edge1, edge2 ;
  VERTEX *v, *vn ;
  FACE   *f ;

  v = &mris->vertices[vno] ;
  edge1.vno1 = vno ;
  for (n1 = 0 ; n1 < v->num ; n1++)
  {
    n2 = v->n[n1] == VERTICES_PER_FACE-1 ? 0 : v->n[n1]+1 ;
    fno1 = v->f[n1] ;
    edge1.vno2 = mris->faces[fno1].v[n2] ;
    for (i = 0 ; i < defect->nborder ; i++)
    {
      vno2 = vertex_trans[defect->border[i]] ;
      if (vno2 < 0)
      {
        continue ;
      }
      vn = &mris->vertices[vno2] ;
      for (n2 = 0 ; n2 < vn->num ; n2++)
      {
        fno2 = vn->f[n2] ;
        f = &mris->faces[fno2] ;
        if (fno2 == Gdiag_no)
        {
          DiagBreak() ;
        }
        if ((fno2 == 103815 && fno1 == 101608) ||
            (fno1 == 103815 && fno2 == 101608))
        {
          DiagBreak() ;
        }
        for (n3 = 0 ; n3 < VERTICES_PER_FACE ; n3++)
        {
          edge2.vno1 = f->v[n3] ;
          edge2.vno2 = f->v[n3 == VERTICES_PER_FACE-1 ? 0 : n3+1] ;
          if (edge2.vno1 == edge1.vno1 || edge2.vno1 == edge1.vno2 ||
              edge2.vno2 == edge1.vno1 || edge2.vno2 == edge1.vno2)
          {
            continue ;
          }
          if (edgesIntersect(mris, &edge1, &edge2))
          {
            fprintf
            (WHICH_OUTPUT,
             "triangles %d (a=%f) and %d (a=%f) intersect!\n",
             fno1, mris->faces[fno1].area, fno2,
             mris->faces[fno2].area) ;
            mrisDumpTriangle(mris, fno1) ;
            mrisDumpTriangle(mris, fno2) ;
          }
        }
      }
    }
  }
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  See if the edge e intersects any edges in the defect or
  it's border. Sorry this code is such a hatchet job. I'm sure
  there are far more elegant ways of doing intersection
  (e.g. sorting).
  ------------------------------------------------------*/
#if 1
static int
intersectDefectEdges(MRI_SURFACE *mris, DEFECT *defect, EDGE *e,
                     int *vertex_trans,int *v1,int *v2)
{
  VERTEX *v ;
  int    i, n, vno ;
  EDGE   edge2 ;


  for (i = 0 ; i < defect->nvertices+defect->nchull ; i++)
  {
    if (i < defect->nvertices)
    {
      vno = vertex_trans[defect->vertices[i]] ;
    }
    else
    {
      vno = vertex_trans[defect->chull[i-defect->nvertices]] ;
    }

    if (vno == e->vno1 || vno == e->vno2 || vno < 0)
    {
      continue ;
    }

    edge2.vno1 = vno ;
    v = &mris->vertices[vno] ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      if ((vno == 53153 && v->v[n] == 53158) ||
          (v->v[n] == 53153 && vno == 53158))
      {
        DiagBreak() ;
      }
      if ((vno == 52024 && v->v[n] == 53158) ||
          (v->v[n] == 52024 && vno == 53158))
      {
        DiagBreak() ;
      }
      if (v->v[n] == e->vno1 || v->v[n] == e->vno2)
      {
        continue ;
      }
      edge2.vno2 = v->v[n] ;
      if (defect->optimal_mapping &&
          mris->vertices[v->v[n]].fixedval == 0 )
      {
        continue;  //experimental
      }
      if (edgesIntersect(mris, e, &edge2))
      {
        if (v1)
        {
          (*v1)=edge2.vno1;
        }
        if (v2)
        {
          (*v2)=edge2.vno2;
        }
        return(1);
      }
    }
  }

  return(0) ;
}

static int
intersectDefectConvexHullEdges(MRI_SURFACE *mris, DEFECT *defect, EDGE *e,
                               int *vertex_trans,int *v1,int *v2)
{
  VERTEX *v ;
  int    i, n, vno ;
  EDGE   edge2 ;


  for (i = defect->nborder ; i < defect->nchull ; i++)
  {
    vno = vertex_trans[defect->chull[i]] ;
    if (vno == e->vno1 || vno == e->vno2 || vno < 0)
    {
      continue ;
    }

    edge2.vno1 = vno ;
    v = &mris->vertices[vno] ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      if ((vno == 53153 && v->v[n] == 53158) ||
          (v->v[n] == 53153 && vno == 53158))
      {
        DiagBreak() ;
      }
      if ((vno == 52024 && v->v[n] == 53158) ||
          (v->v[n] == 52024 && vno == 53158))
      {
        DiagBreak() ;
      }
      if (v->v[n] == e->vno1 || v->v[n] == e->vno2)
      {
        continue ;
      }
      edge2.vno2 = v->v[n] ;
      if (defect->optimal_mapping &&
          mris->vertices[v->v[n]].fixedval == 0 )
      {
        continue;  //experimental
      }
      if (edgesIntersect(mris, e, &edge2))
      {
        if (v1)
        {
          (*v1)=edge2.vno1;
        }
        if (v2)
        {
          (*v2)=edge2.vno2;
        }
        return(1);
      }
    }
  }

  return(0) ;
}
#else
static int
intersectDefectEdges(MRI_SURFACE *mris, DEFECT *defect, EDGE *e,
                     int *vertex_trans)
{
  VERTEX *v ;
  int    i, n, vno ;
  FILE   *fp = NULL ;
  EDGE   edge2 ;

  if ((e->vno1 == 109259 && e->vno2 == 108332) ||
      (e->vno2 == 109259 && e->vno1 == 108332))
  {
    DiagBreak() ;
  }

  for (i = 0 ; i < defect->nvertices+defect->nchull ; i++)
  {
    if (i < defect->nvertices)
    {
      vno = vertex_trans[defect->vertices[i]] ;
    }
    else
    {
      vno = vertex_trans[defect->chull[i-defect->nvertices]] ;
    }

    if (vno == e->vno1 || vno == e->vno2 || vno < 0)
    {
      continue ;
    }

    edge2.vno1 = vno ;
    v = &mris->vertices[vno] ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      if ((vno == 53153 && v->v[n] == 53158) ||
          (v->v[n] == 53153 && vno == 53158))
      {
        DiagBreak() ;
      }
      if ((vno == 52024 && v->v[n] == 53158) ||
          (v->v[n] == 52024 && vno == 53158))
      {
        DiagBreak() ;
      }
      if (v->v[n] == e->vno1 || v->v[n] == e->vno2)
      {
        continue ;
      }
      edge2.vno2 = v->v[n] ;
      if (edgesIntersect(mris, e, &edge2))
      {
        return(1) ;
      }
    }
  }


  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    double     x1_start, x1_end, y1_start, y1_end, x2_start, x2_end,
               y2_start,y2_end, x2min, x2max, y2min, y2max, cx, cy, cz,
               origin[3], e0[3], e1[3] ;
    char       fname[STRLEN] ;
    VERTEX     *v2 ;
    static int dno = -1 ;

    mrisComputeCanonicalEdgeBasis(mris, e, e, origin, e0, e1) ;
    sprintf(fname, "lines%d.log", defect_no) ;
    v = &mris->vertices[e->vno1] ;
    v2 = &mris->vertices[e->vno2] ;
    cx = v->cx-origin[0] ;
    cy = v->cy - origin[1] ;
    cz = v->cz-origin[2];
    x1_start = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
    y1_start = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
    cx = v2->cx-origin[0];
    cy = v2->cy - origin[1] ;
    cz = v2->cz-origin[2];
    x1_end = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
    y1_end = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
    if (dno != defect_no)  /* first time for this defect */
    {
      fp = fopen(fname, "w") ;

      for (i = 0 ; i < defect->nvertices+defect->nchull ; i++)
      {
        if (i < defect->nvertices)
        {
          vno = vertex_trans[defect->vertices[i]] ;
        }
        else
        {
          vno = vertex_trans[defect->chull[i-defect->nvertices]] ;
        }

        if (vno == e->vno1 || vno == e->vno2 || vno < 0)
        {
          continue ;
        }
        v = &mris->vertices[vno] ;
        cx = v->cx-origin[0] ;
        cy = v->cy-origin[1] ;
        cz = v->cz-origin[2];
        x2_start = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
        y2_start = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
        for (n = 0 ; n < v->vnum ; n++)
        {
          if (vno == 6167)
          {
            DiagBreak() ;
          }
          if (v->v[n] == e->vno1 || v->v[n] == e->vno2)
          {
            continue ;
          }
          v2 = &mris->vertices[v->v[n]] ;
          cx = v2->cx-origin[0] ;
          cy = v2->cy-origin[1];
          cz = v2->cz-origin[2];
          x2_end = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
          y2_end = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
          x2min = MIN(x2_start, x2_end) ;
          x2max = MAX(x2_start, x2_end) ;
          y2min = MIN(y2_start, y2_end) ;
          y2max = MAX(y2_start, y2_end) ;
          fprintf(fp, "%2.3f  %2.3f\n%2.3f  %2.3f\n\n",
                  x2_start, y2_start, x2_end, y2_end) ;
        }
      }

    }
    else
    {
      fp = fopen(fname, "a") ;
    }
    fprintf(fp, "%2.3f  %2.3f\n%2.3f  %2.3f\n\n",
            x1_start, y1_start, x1_end, y1_end) ;
    if (fp)
    {
      fclose(fp) ;
    }


    sprintf(fname, "edges%d.log", defect_no) ;
    if (dno != defect_no)  /* first time for this defect */
    {
      dno = defect_no ;
      fp = fopen(fname, "w") ;

      for (i = 0 ; i < defect->nvertices+defect->nchull ; i++)
      {
        if (i < defect->nvertices)
        {
          vno = vertex_trans[defect->vertices[i]] ;
        }
        else
        {
          vno = vertex_trans[defect->chull[i-defect->nvertices]] ;
        }

        if (vno == e->vno1 || vno == e->vno2 || vno < 0)
        {
          continue ;
        }
        v = &mris->vertices[vno] ;
        cx = v->cx-origin[0] ;
        cy = v->cy-origin[1] ;
        cz = v->cz-origin[2];
        x2_start = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
        y2_start = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
        for (n = 0 ; n < v->vnum ; n++)
        {
          if (vno == 6167)
          {
            DiagBreak() ;
          }
          if (v->v[n] == e->vno1 || v->v[n] == e->vno2)
          {
            continue ;
          }
          v2 = &mris->vertices[v->v[n]] ;
          cx = v2->cx-origin[0] ;
          cy = v2->cy-origin[1];
          cz = v2->cz-origin[2];
          x2_end = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
          y2_end = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
          x2min = MIN(x2_start, x2_end) ;
          x2max = MAX(x2_start, x2_end) ;
          y2min = MIN(y2_start, y2_end) ;
          y2max = MAX(y2_start, y2_end) ;
          fprintf(fp, "%d  %d  %2.3f  %2.3f  %2.3f  %2.3f\n",
                  vno, v->v[n],
                  x2_start, y2_start, x2_end, y2_end) ;
        }
      }

    }
    else
    {
      fp = fopen(fname, "a") ;
    }
    fprintf(fp, "%d  %d  %2.3f  %2.3f  %2.3f  %2.3f\n", e->vno1, e->vno2,
            x1_start, y1_start, x1_end, y1_end) ;
    if (fp)
    {
      fclose(fp) ;
    }
  }
  return(0) ;
}
/*-----------------------------------------------------
Parameters:

Returns value:

Description
See if the edge e intersects any edges in the defect or
it's border. Sorry this code is such a hatchet job. I'm sure
there are far more elegant ways of doing intersection
(e.g. sorting).
------------------------------------------------------*/
static int
intersectDefectConvexHullEdges(MRI_SURFACE *mris, DEFECT *defect, EDGE *e,
                               int *vertex_trans)
{
  VERTEX *v ;
  int    i, n, vno ;
  FILE   *fp = NULL ;
  EDGE   edge2 ;

  if ((e->vno1 == 109259 && e->vno2 == 108332) ||
      (e->vno2 == 109259 && e->vno1 == 108332))
  {
    DiagBreak() ;
  }

  for (i = defect->nborder ; i < defect->nchull ; i++)
  {
    vno = vertex_trans[defect->chull[i]] ;

    if (vno == e->vno1 || vno == e->vno2 || vno < 0)
    {
      continue ;
    }

    edge2.vno1 = vno ;
    v = &mris->vertices[vno] ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      if ((vno == 53153 && v->v[n] == 53158) ||
          (v->v[n] == 53153 && vno == 53158))
      {
        DiagBreak() ;
      }
      if ((vno == 52024 && v->v[n] == 53158) ||
          (v->v[n] == 52024 && vno == 53158))
      {
        DiagBreak() ;
      }
      if (v->v[n] == e->vno1 || v->v[n] == e->vno2)
      {
        continue ;
      }
      edge2.vno2 = v->v[n] ;
      if (edgesIntersect(mris, e, &edge2))
      {
        return(1) ;
      }
    }
  }


  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    double     x1_start, x1_end, y1_start, y1_end, x2_start, x2_end,
               y2_start,y2_end, x2min, x2max, y2min, y2max, cx, cy, cz,
               origin[3], e0[3], e1[3] ;
    char       fname[STRLEN] ;
    VERTEX     *v2 ;
    static int dno = -1 ;

    mrisComputeCanonicalEdgeBasis(mris, e, e, origin, e0, e1) ;
    sprintf(fname, "lines%d.log", defect_no) ;
    v = &mris->vertices[e->vno1] ;
    v2 = &mris->vertices[e->vno2] ;
    cx = v->cx-origin[0] ;
    cy = v->cy - origin[1] ;
    cz = v->cz-origin[2];
    x1_start = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
    y1_start = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
    cx = v2->cx-origin[0];
    cy = v2->cy - origin[1] ;
    cz = v2->cz-origin[2];
    x1_end = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
    y1_end = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
    if (dno != defect_no)  /* first time for this defect */
    {
      fp = fopen(fname, "w") ;

      for (i = 0 ; i < defect->nvertices+defect->nchull ; i++)
      {
        if (i < defect->nvertices)
        {
          vno = vertex_trans[defect->vertices[i]] ;
        }
        else
        {
          vno = vertex_trans[defect->chull[i-defect->nvertices]] ;
        }

        if (vno == e->vno1 || vno == e->vno2 || vno < 0)
        {
          continue ;
        }
        v = &mris->vertices[vno] ;
        cx = v->cx-origin[0] ;
        cy = v->cy-origin[1] ;
        cz = v->cz-origin[2];
        x2_start = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
        y2_start = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
        for (n = 0 ; n < v->vnum ; n++)
        {
          if (vno == 6167)
          {
            DiagBreak() ;
          }
          if (v->v[n] == e->vno1 || v->v[n] == e->vno2)
          {
            continue ;
          }
          v2 = &mris->vertices[v->v[n]] ;
          cx = v2->cx-origin[0] ;
          cy = v2->cy-origin[1];
          cz = v2->cz-origin[2];
          x2_end = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
          y2_end = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
          x2min = MIN(x2_start, x2_end) ;
          x2max = MAX(x2_start, x2_end) ;
          y2min = MIN(y2_start, y2_end) ;
          y2max = MAX(y2_start, y2_end) ;
          fprintf(fp, "%2.3f  %2.3f\n%2.3f  %2.3f\n\n",
                  x2_start, y2_start, x2_end, y2_end) ;
        }
      }

    }
    else
    {
      fp = fopen(fname, "a") ;
    }
    fprintf(fp, "%2.3f  %2.3f\n%2.3f  %2.3f\n\n",
            x1_start, y1_start, x1_end, y1_end) ;
    if (fp)
    {
      fclose(fp) ;
    }


    sprintf(fname, "edges%d.log", defect_no) ;
    if (dno != defect_no)  /* first time for this defect */
    {
      dno = defect_no ;
      fp = fopen(fname, "w") ;

      for (i = 0 ; i < defect->nvertices+defect->nchull ; i++)
      {
        if (i < defect->nvertices)
        {
          vno = vertex_trans[defect->vertices[i]] ;
        }
        else
        {
          vno = vertex_trans[defect->chull[i-defect->nvertices]] ;
        }

        if (vno == e->vno1 || vno == e->vno2 || vno < 0)
        {
          continue ;
        }
        v = &mris->vertices[vno] ;
        cx = v->cx-origin[0] ;
        cy = v->cy-origin[1] ;
        cz = v->cz-origin[2];
        x2_start = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
        y2_start = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
        for (n = 0 ; n < v->vnum ; n++)
        {
          if (vno == 6167)
          {
            DiagBreak() ;
          }
          if (v->v[n] == e->vno1 || v->v[n] == e->vno2)
          {
            continue ;
          }
          v2 = &mris->vertices[v->v[n]] ;
          cx = v2->cx-origin[0] ;
          cy = v2->cy-origin[1];
          cz = v2->cz-origin[2];
          x2_end = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
          y2_end = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
          x2min = MIN(x2_start, x2_end) ;
          x2max = MAX(x2_start, x2_end) ;
          y2min = MIN(y2_start, y2_end) ;
          y2max = MAX(y2_start, y2_end) ;
          fprintf(fp, "%d  %d  %2.3f  %2.3f  %2.3f  %2.3f\n",
                  vno, v->v[n],
                  x2_start, y2_start, x2_end, y2_end) ;
        }
      }

    }
    else
    {
      fp = fopen(fname, "a") ;
    }
    fprintf(fp, "%d  %d  %2.3f  %2.3f  %2.3f  %2.3f\n", e->vno1, e->vno2,
            x1_start, y1_start, x1_end, y1_end) ;
    if (fp)
    {
      fclose(fp) ;
    }
  }
  return(0) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  See if the edge e intersects any edges in the defect or
  it's border. Sorry this code is such a hatchet job. I'm sure
  there are far more elegant ways of doing intersection
  (e.g. sorting).
  ------------------------------------------------------*/
#if 0
static int
colinearDefectEdges(MRI_SURFACE *mris, DEFECT *defect, EDGE *e,
                    int *vertex_trans)
{
  VERTEX *v ;
  int    i, n, vno ;
  EDGE   edge2 ;

  if ((e->vno1 == 109259 && e->vno2 == 108332) ||
      (e->vno2 == 109259 && e->vno1 == 108332))
  {
    DiagBreak() ;
  }

  for (i = 0 ; i < defect->nvertices+defect->nchull ; i++)
  {
    if (i < defect->nvertices)
    {
      vno = vertex_trans[defect->vertices[i]] ;
    }
    else
    {
      vno = vertex_trans[defect->chull[i-defect->nvertices]] ;
    }

    if (vno < 0)
    {
      continue ;
    }

    edge2.vno1 = vno ;
    v = &mris->vertices[vno] ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      if ((vno == 53153 && v->v[n] == 53158) ||
          (v->v[n] == 53153 && vno == 53158))
      {
        DiagBreak() ;
      }
      if ((vno == 52024 && v->v[n] == 53158) ||
          (v->v[n] == 52024 && vno == 53158))
      {
        DiagBreak() ;
      }

      edge2.vno2 = v->v[n] ;

      if ((v->v[n] == e->vno1 || v->v[n] == e->vno2) ||
          (vno == e->vno1 || vno == e->vno2))  /* check for colinearity */
      {
        int vno0, vno1, vno2, ncoords ;
        VERTEX *v0, *v1, *v2 ;
        float  dx01, dy01, dz01, dx02, dy02, dz02, len01, len02 ;

        /*
          set vno0 and vno1 so that they are the existing edge, with
          vno0 being the shared vertex, and vno2 is the vertex for the
          putative edge
        */
        if (vno == e->vno1 || vno == e->vno2)  /* vno is shared vertex */
        {
          vno0 = vno ;
          vno1 = v->v[n] ;
        }
        else   /* v->v[n] is shared vertex */
        {
          vno0 = v->v[n] ;
          vno1 = vno ;
        }
        if (e->vno1 == vno0)
        {
          vno2 = e->vno2 ;
        }
        else
        {
          vno2 = e->vno1 ;
        }
        v0 = &mris->vertices[vno0] ;
        v1 = &mris->vertices[vno1] ;
        v2 = &mris->vertices[vno2] ;
        dx01 = v1->origx - v0->origx ;
        dy01 = v1->origy - v0->origy ;
        dz01 = v1->origz - v0->origz ;
        len01 = sqrt(dx01*dx01+dy01*dy01+dz01*dz01) ;
        if (FZERO(len01))
        {
          len01 = 1 ;
        }
        dx01 /= len01 ;
        dy01 /= len01 ;
        dz01 /= len01 ;
        dx02 = v2->origx - v0->origx ;
        dy02 = v2->origy - v0->origy ;
        dz02 = v2->origz - v0->origz ;
        len02 = sqrt(dx02*dx02+dy02*dy02+dz02*dz02) ;
        if (FZERO(len02))
        {
          len02 = 1 ;
        }
        dx02 /= len02 ;
        dy02 /= len02 ;
        dz02 /= len02 ;


        /* see if vno1 and vno2 are colinear. If not, no problemo */
        ncoords = FZERO(dx01-dx02)+FZERO(dy01-dy02)+FZERO(dz01-dz02);
        if (ncoords == 3)
        {
          if (e->vno1 == 16968 || e->vno2 == 16968)
          {
            DiagBreak() ;
          }
          return(1) ;   /* colinear */
        }
      }
    }
  }

  return(0) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Is vno1 is a neighbor of vno2
  ------------------------------------------------------*/
static int
vertexNeighbor(MRI_SURFACE *mris, int vno1, int vno2)
{
  VERTEX *v ;
  int    n ;

  v = &mris->vertices[vno1] ;
  for (n = 0 ; n < v->vnum ; n++)
    if (v->v[n] == vno2)
    {
      return(1) ;
    }
  return(0) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Add the edge vnot <--> vno2 to the tessellation
  ------------------------------------------------------*/
#define MAX_VLIST 255
static int
mrisAddEdge(MRI_SURFACE *mris, int vno1, int vno2)
{
  int    vlist[MAX_VLIST] ;
  VERTEX *v ;

  if (vno1 < 0 || vno2 < 0)
  {
    DiagBreak() ;
  }
  if (vno1 == Gdiag_no || vno2 == Gdiag_no)
  {
    DiagBreak() ;
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "adding edge %d <--> %d\n", vno1, vno2) ;
  }

  /* add v2 link to v1 struct */
  v = &mris->vertices[vno1] ;
  if (v->vnum >= MAX_VLIST-1)
  {
    ErrorExit(ERROR_NOMEMORY, "mrisAddEdge: too many edges (%d)",v->vnum) ;
  }

  memmove(vlist, v->v, v->vnum*sizeof(int)) ;
  vlist[(unsigned int)v->vnum++] = vno2 ;
  v->vtotal = v->vnum ;
  if (v->v)
  {
    free(v->v) ;
  }
  v->v = (int *)calloc(v->vnum, sizeof(int)) ;
  if (!v->v)
    ErrorExit(ERROR_NO_MEMORY,
              "mrisAddEdge(%d, %d): could not allocate %d len vlist", v->vnum);

  memmove(v->v, vlist, v->vnum*sizeof(int)) ;

  /* add v1 link to v2 struct */
  v = &mris->vertices[vno2] ;
  memmove(vlist, v->v, v->vnum*sizeof(int)) ;
  vlist[(unsigned int)v->vnum++] = vno1 ;
  v->vtotal = v->vnum ;
  if (v->v)
  {
    free(v->v) ;
  }
  v->v = (int *)calloc(v->vnum, sizeof(int)) ;
  if (!v->v)
    ErrorExit(ERROR_NO_MEMORY,
              "mrisAddEdge(%d, %d): could not allocate %d len vlist", v->vnum);

  memmove(v->v, vlist, v->vnum*sizeof(int)) ;

  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Add the triangle vno0 --> vno1 --> vno2 to the tessellation
  ------------------------------------------------------*/
static int
mrisAddFace(MRI_SURFACE *mris, int vno0, int vno1, int vno2)
{
  int    n, fno, ilist[1000], n0, n1 ;
  FACE   *f ;
  VERTEX *v ;
  uchar  ulist[1000] ;
  float  norm[3], dot, cx, cy, cz ;

  if (vno0 < 0 || vno1 < 0 || vno2 < 0)
    ErrorReturn(ERROR_BADPARM, (ERROR_BADPARM, "mrisAddFace(%d,%d,%d)!\n",
                                vno0, vno1, vno2)) ;
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "adding face (%d, %d, %d)\n", vno0, vno1, vno2) ;
  }
  if (vno0 == 6160 && vno1 == 6189 && vno2 == 6176)
  {
    DiagBreak() ;
  }
  if (mris->nfaces >= mris->max_faces)
  {
    ErrorExit(ERROR_NOMEMORY, "mrisAddFace: max faces reached") ;
  }

  fno = mris->nfaces++ ;
  if (fno == Gdiag_no)
  {
    DiagBreak() ;
  }

  f = &mris->faces[fno] ;
  f->v[0] = vno0 ;
  f->v[1] = vno1 ;
  f->v[2] = vno2 ;

  for (n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    v = &mris->vertices[f->v[n]] ;
    if (v->num >= 255)
    {
      continue ;
    }
    memmove(ilist, v->f, v->num*sizeof(int)) ;
    ilist[v->num++] = fno ;
    if (v->f)
    {
      free(v->f) ;
    }
    v->f = (int *)calloc(v->num, sizeof(int)) ;
    if (!v->f)
      ErrorExit(ERROR_NOMEMORY,
                "mrisAddFace: could not allocate face list") ;
    memmove(v->f, ilist, v->num*sizeof(int)) ;

    memmove(ulist, v->n, (v->num-1)*sizeof(uchar)) ;
    ulist[v->num-1] = n ;
    if (v->n)
    {
      free(v->n) ;
    }
    v->n = (uchar *)calloc(v->num, sizeof(uchar)) ;
    if (!v->n)
    {
      ErrorExit(ERROR_NOMEMORY, "mrisAddFace: could not allocate n list") ;
    }
    memmove(v->n, ulist, v->num*sizeof(uchar)) ;
  }

  mrisCalculateCanonicalFaceCentroid(mris, fno, &cx, &cy, &cz);
  for (n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    mrisNormalFace(mris, fno, n, norm) ;  /* compute face normal */
    dot = norm[0]*cx + norm[1]*cy + norm[2]*cz ;

    if (dot < 0) /* they disagree - change order of vertices in face */
    {
      n0 = (n == 0)                   ? VERTICES_PER_FACE-1 : n-1;
      n1 = (n == VERTICES_PER_FACE-1) ? 0                   : n+1;
      vno0 = f->v[n0] ;
      vno1 = f->v[n1] ;
      f->v[n0] = vno1 ;
      f->v[n1] = vno0 ;
      mrisSetVertexFaceIndex(mris, vno0, fno) ;
      mrisSetVertexFaceIndex(mris, vno1, fno) ;
    }
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Is the triangle vno0-->vno1-->vno2 already in the tessellation
  ------------------------------------------------------*/
static int
isFace(MRI_SURFACE *mris, int vno0, int vno1, int vno2)
{
  VERTEX  *v ;
  FACE    *f ;
  int     n, n1, vno ;

  v = &mris->vertices[vno0] ;
  for (n = 0 ; n < v->num ; n++)
  {
    f = &mris->faces[v->f[n]] ;
    for (n1 = 0 ; n1 < VERTICES_PER_FACE ; n1++)
    {
      vno = f->v[n1] ;
      if (vno != vno0 && vno != vno1 && vno != vno2)
      {
        break ;
      }
    }
    if (n1 >= VERTICES_PER_FACE)
    {
      return(1) ;
    }
  }
  return(0) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Is the triangle vno0-->vno1-->vno2 already in the tessellation
  ------------------------------------------------------*/
static int
findFace(MRI_SURFACE *mris, int vno0, int vno1, int vno2)
{
  VERTEX  *v ;
  FACE    *f ;
  int     n, n1, vno, fno ;

  v = &mris->vertices[vno0] ;
  for (n = 0 ; n < v->num ; n++)
  {
    f = &mris->faces[v->f[n]] ;
    for (n1 = 0 ; n1 < VERTICES_PER_FACE ; n1++)
    {
      vno = f->v[n1] ;
      fno  = v->f[n] ;
      if (vno != vno0 && vno != vno1 && vno != vno2)
      {
        break ;
      }
    }
    if (n1 >= VERTICES_PER_FACE)
    {
      return(fno) ;
    }
  }
  return(-1) ;
}
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Orient the faces of the tessellation so that the
  point outward (i.e. in the same direction as the original
  surface).
  ------------------------------------------------------*/
static int
mrisOrientFaces(MRI_SURFACE *mris, DEFECT *defect, int *vtrans)
{
  int    vno, vno0, vno1, i, n, fno, oriented = 0 ;
  FACE   *f ;
  VERTEX *v, *vn ;
  float  norm[3], dot ;

  /* first orient vertices */
  for (i = 0 ; i < defect->nvertices ; i++)
  {
    vno = vtrans[defect->vertices[i]] ;
    if (vno < 0)   /* not in new tessellation */
    {
      continue ;
    }
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (dot = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      dot += v->nx*vn->nx + v->ny*vn->ny + v->nz*vn->nz ;
    }
    if (dot < 0)
    {
      oriented++ ;
      if (Gdiag & DIAG_SHOW)
      {
        fprintf(stdout, "reversing normal for vertex %d\n", vno) ;
      }
      v->nx *= -1.0f ;
      v->ny *= -1.0f ;
      v->nz *= -1.0f ;
    }
  }
  /*  mrisRestoreDefectPositions(mris, defect, ORIGINAL_VERTICES) ;*/
  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    if (i < defect->nvertices)
    {
      vno = vtrans[defect->vertices[i]] ;
    }
    else
    {
      vno = vtrans[defect->border[i-defect->nvertices]] ;
    }
    if (vno < 0)   /* not in new tessellation */
    {
      continue ;
    }
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (n = 0 ; n < v->num ; n++)
    {
      fno = v->f[n] ;
      if (mris->faces[fno].ripflag)  /* only consider it once */
      {
        continue ;
      }
      if (fno == Gdiag_no)
      {
        DiagBreak() ;
      }
      mris->faces[fno].ripflag = 1 ;
      mrisNormalFace(mris, fno, v->n[n], norm) ;
      dot = norm[0]*v->nx + norm[1]*v->ny + norm[2]*v->nz ;
      if (dot < 0)   /* change order of vertices in face */
      {
        oriented++ ;
        f = &mris->faces[fno] ;
        vno0 = f->v[0] ;
        vno1 = f->v[1] ;
        f->v[0] = vno1 ;
        f->v[1] = vno0 ;
        mrisSetVertexFaceIndex(mris, vno0, fno) ;
        mrisSetVertexFaceIndex(mris, vno1, fno) ;
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
        {
          fprintf(stdout, "reversing face %d orientation\n", fno) ;
        }
      }
    }
  }
  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    if (i < defect->nvertices)
    {
      vno = vtrans[defect->vertices[i]] ;
    }
    else
    {
      vno = vtrans[defect->border[i-defect->nvertices]] ;
    }
    if (vno < 0)   /* not in new tessellation */
    {
      continue ;
    }
    v = &mris->vertices[vno] ;
    for (n = 0 ; n < v->num ; n++)
    {
      fno = v->f[n] ;
      mris->faces[fno].ripflag = 0 ;
    }
  }
  /*  mrisRestoreDefectPositions(mris, defect, TMP_VERTICES) ;*/
  return(oriented) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Set the positions of all vertices in a defect to the
  original, canonical, or tmp vertices.
  ------------------------------------------------------*/
static int
mrisRestoreDefectPositions(MRI_SURFACE *mris, DEFECT *defect, int which)
{
  int     vno, i ;
  VERTEX  *v ;

  for (i = 0 ; i < defect->nvertices ; i++)
  {
    vno = defect->vertices[i] ;
    v = &mris->vertices[vno] ;
#if 0
    if (v->ripflag)
    {
      continue ;
    }
#endif
    switch (which)
    {
    case CANONICAL_VERTICES:
      v->x = v->cx ;
      v->y = v->cy ;
      v->z = v->cz ;
      break ;
    case ORIGINAL_VERTICES:
      v->x = v->origx ;
      v->y = v->origy ;
      v->z = v->origz ;
      break ;
    case TMP2_VERTICES:
      v->x = v->tx2 ;
      v->y = v->ty2 ;
      v->z = v->tz2 ;
      break ;
    default:
    case TMP_VERTICES:
      v->x = v->tx ;
      v->y = v->ty ;
      v->z = v->tz ;
      break ;
    }
  }
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Search the face for vno and set the v->n[] field
  appropriately.
  ------------------------------------------------------*/
static int
mrisSetVertexFaceIndex(MRI_SURFACE *mris, int vno, int fno)
{
  VERTEX  *v ;
  FACE    *f ;
  int     n, i ;

  v = &mris->vertices[vno] ;
  f = &mris->faces[fno] ;

  for (n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    if (f->v[n] == vno)
    {
      break ;
    }
  }
  if (n >= VERTICES_PER_FACE)
  {
    return(ERROR_BADPARM) ;
  }

  for (i = 0 ; i < v->num ; i++)
    if (v->f[i] == fno)
    {
      v->n[i] = n ;
    }

  return(n) ;
}
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Add the appropriate face to the tessellation.
  ------------------------------------------------------*/
static int
mrisAddDefectFaces(MRI_SURFACE *mris, double e0[3], double e1[3],
                   double origin[3], EDGE *et, int nedges)
{
  int     i, vno1, vno2, nfaces, n ;
  VERTEX  *v ;

  for (i = 0 ; i < nedges ; i++)
  {
    if (et[i].used == 0)
    {
      continue ;
    }
    vno1 = et[i].vno1 ;
    vno2 = et[i].vno2 ;
#if (!SPHERE_INTERSECTION)
    mrisComputeCanonicalEdgeBasis(mris, et+i, et+i, origin, e0, e1) ;
#endif
    if (vno1 == 108332 && vno2 == 109240)
    {
      DiagBreak() ;
    }

    /* for every vertex which is a neighbor of
       both of these, add 1 triangle */
    v = &mris->vertices[vno1] ;
    for (nfaces = n = 0 ; n < v->vnum ; n++)
    {
      if (v->v[n] == vno2)
      {
        continue ;
      }
      if (vertexNeighbor(mris, vno2, v->v[n]) &&
          !isFace(mris,vno1, vno2, v->v[n]) &&
#if SPHERE_INTERSECTION
          !containsAnotherVertexOnSphere(mris,vno1,vno2,v->v[n],0))
      {
#else
          !containsAnotherVertex(mris,vno1,vno2,v->v[n],e0,e1,origin))
      {
#endif
        if (nfaces++ > 1)
        {
          DiagBreak() ;
        }
        if (mris->nfaces == Gdiag_no)
        {
          DiagBreak() ;
        }
#if 0
        if (((vno1 != 110718) && (vno1 != 110732) && (vno1 != 110748)) ||
            ((vno2 != 110718) && (vno2 != 110732) && (vno2 != 110748)) ||
            ((v->v[n] != 110718) && (v->v[n] != 110732) &&
             (v->v[n]!=110748)))
#endif
          mrisAddFace(mris, vno1, vno2, v->v[n]) ;
      }
    }
  }
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Add the appropriate face to the tessellation.
  ------------------------------------------------------*/
static int
mrisAddAllDefectFaces(MRI_SURFACE *mris, DEFECT_LIST *dl, int *vertex_trans)
{
  DEFECT  *defect ;
  int     i, vno1, vno2, nfaces, n, m, dno ;
  VERTEX  *v ;
#if (!SPHERE_INTERSECTION)
  double  origin[3], e0[3], e1[3] ;
#endif
  EDGE    edge ;

  for (dno = 0 ; dno < dl->ndefects ; dno++)
  {
    defect = &dl->defects[dno] ;
    for (i = 0 ; i < defect->nborder+defect->nvertices ; i++)
    {
      if (i < defect->nvertices)
      {
        if (defect->status[i]==DISCARD_VERTEX)
        {
          continue;
        }
        vno1 = vertex_trans[defect->vertices[i]] ;
      }
      else
      {
        vno1 = vertex_trans[defect->border[i-defect->nvertices]] ;
      }
      if (vno1 < 0)
      {
        continue ;
      }

      v = &mris->vertices[vno1] ;
      edge.vno1 = vno1 ;
      for (m = 0 ; m < v->vnum ; m++)
      {
        edge.vno2 = vno2 = v->v[m] ;
#if (!SPHERE_INTERSECTION)
        mrisComputeCanonicalEdgeBasis
        (mris, &edge, &edge, origin, e0, e1) ;
#endif
        if (vno1 == 108332 && vno2 == 109240)
        {
          DiagBreak() ;
        }

        /*
          for every vertex which is a neighbor of both of these,
          add 1 triangle */
        for (nfaces = n = 0 ; n < v->vnum ; n++)
        {
          if (v->v[n] == vno2)
          {
            continue ;
          }
          if (vertexNeighbor(mris, vno2, v->v[n]) &&
              !isFace(mris,vno1, vno2, v->v[n]) &&
#if SPHERE_INTERSECTION
              !containsAnotherVertexOnSphere
              (mris,vno1,vno2,v->v[n],0))
          {
#else
              !containsAnotherVertex
              (mris,vno1,vno2,v->v[n],e0,e1,origin))
          {
#endif
            if (nfaces++ > 1)
            {
              DiagBreak() ;
            }
            if (mris->nfaces == Gdiag_no)
            {
              DiagBreak() ;
            }
            mrisAddFace(mris, vno1, vno2, v->v[n]) ;
          }
        }
      }
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  See if this triangle contains another vertex within it.
  If so, it should not be added to the tessellation.
  ------------------------------------------------------*/
#if SPHERE_INTERSECTION
static int containsAnotherVertexOnSphere
(MRI_SURFACE *mris, int vno0, int vno1, int vno2,int mode)
{

  VERTEX  *V0,*V1,*V2, *v , *vn;
  int i,n,nvertices,vertices[1000],v1,v2;
  double sign[3],normal[3][3], orgn[3][3],tangent[3],test;

  V0=&mris->vertices[vno0];
  V1=&mris->vertices[vno1];
  V2=&mris->vertices[vno2];

  //first compute the 3 normals, 3 original points and associated constants
  for (i = 0; i<3 ; i++)
  {
    if (i)
    {
      //circular rotation
      v=V0;
      V0=V1;
      V1=V2;
      V2=v;
    }

    //compute normal for edge V1<-->V2
    orgn[i][0]=(V1->cx+V2->cx)/2.0;
    orgn[i][1]=(V1->cy+V2->cy)/2.0;
    orgn[i][2]=(V1->cz+V2->cz)/2.0;

    tangent[0]=V2->cx-V1->cx;
    tangent[1]=V2->cy-V1->cy;
    tangent[2]=V2->cz-V1->cz;
    //normal to edge in the planar basis
    F_CROSS(orgn[i],tangent,normal[i]);

    tangent[0]=V0->cx-orgn[i][0];
    tangent[1]=V0->cy-orgn[i][1];
    tangent[2]=V0->cz-orgn[i][2];

    sign[i]=F_DOT(tangent,normal[i]);
  }

  V0=&mris->vertices[vno0];
  V1=&mris->vertices[vno1];
  V2=&mris->vertices[vno2];

  //Next, list all the neighboring vertices
  memset(vertices,0,1000*sizeof(int));
  for (nvertices=0,i = 0 ; i < 3 ; i++)
  {
    switch (i)
    {
    case 0:
      v=V0;
      v1=vno1;
      v2=vno2;
      break;
    case 1:
      v=V1;
      v1=vno0;
      v2=vno2;
      break;
    default:
      v=V2;
      v1=vno0;
      v2=vno1;
      break;
    }
    for (n = 0 ; n < v->vnum ; n++)
    {
      if (v1==v->v[n] || v2==v->v[n])
      {
        continue;
      }
      vn=&mris->vertices[v->v[n]] ;
      if (vn->marked)
      {
        continue;
      }
      if (mode && vn->fixedval==0)
      {
        continue;  //experimental
      }
      //add vn in the list
      vertices[nvertices++]=v->v[n];
      vn->marked=1;
    }
  }

  //unmark all vertices in the list
  for ( n=0 ; n < nvertices ; n++)
  {
    mris->vertices[vertices[n]].marked=0;
  }

  //then check intersection for all the neighboring vertices
  for (n=0 ; n < nvertices ; n++)
  {
    vn=&mris->vertices[vertices[n]];
    for ( i = 0 ; i< 3 ; i++)
    {
      tangent[0]=vn->cx-orgn[i][0];
      tangent[1]=vn->cy-orgn[i][1];
      tangent[2]=vn->cz-orgn[i][2];

      test=F_DOT(tangent,normal[i]);

      if (sign[i]*test<0)
      {
        break;
      }
    }
    if (i==3)
    {
      return 1;
    }
  }


  return(0) ;
}
#else
static int
containsAnotherVertex(MRI_SURFACE *mris, int vno0, int vno1, int vno2,
                      double e0[3], double e1[3], double origin[3])
#if 1
{
  int     n, vno, i, n1 ;
  VERTEX  *vn, *v0, *v1, *v2, *v ;
  double  cx, cy, cz, x0, y0, x1, y1, x2, y2, xn, yn, m, b ;
  FILE    *fp ;


  v = &mris->vertices[vno0] ;

  if (((vno1 == 110718) || (vno1 == 110732) || (vno1 == 110748)) &&
      ((vno2 == 110718) || (vno2 == 110732) || (vno2 == 110748)) &&
      ((vno0 == 110718) || (vno0 == 110732) || (vno0 == 110748)))
  {
    fp = fopen("triangle.log", "w") ;
    for (n1 = 0 ; n1 < VERTICES_PER_FACE ; n1++)
    {
      switch (n1)
      {
      default:
      case 0:
        v = &mris->vertices[vno0] ;
        break ;
      case 1:
        v = &mris->vertices[vno1] ;
        break ;
      case 2:
        v = &mris->vertices[vno2] ;
        break ;
      }
      for (n = 0 ; n < v->vnum ; n++)
      {
        vno = v->v[n] ;
        if (vno == vno0 || vno == vno1 || vno == vno2)
        {
          continue ;
        }
        vn = &mris->vertices[vno] ;
        cx = vn->cx-origin[0];
        cy = vn->cy - origin[1];
        cz = vn->cz -origin[2];
        xn = cx*e0[0] + cy*e0[1] + cz*e0[2];
        yn = cx*e1[0] + cy*e1[1]+cz*e1[2];
        fprintf(fp, "# vertex %d\n", vno) ;
        fprintf(fp, "%f %f\n\n", xn, yn) ;
      }
    }
    fprintf(fp, "# vertices %d %d %d\n", vno0, vno1, vno2) ;
    v0 = &mris->vertices[vno0] ;
    v1 = &mris->vertices[vno1] ;
    v2 = &mris->vertices[vno2] ;

    cx = v0->cx-origin[0];
    cy = v0->cy - origin[1];
    cz = v0->cz - origin[2];
    x0 = cx*e0[0] + cy*e0[1] + cz*e0[2];
    y0 = cx*e1[0] + cy*e1[1] + cz*e1[2];

    cx = v1->cx-origin[0];
    cy = v1->cy - origin[1];
    cz = v1->cz - origin[2];
    x1 = cx*e0[0] + cy*e0[1] + cz*e0[2];
    y1 = cx*e1[0] + cy*e1[1] + cz*e1[2];

    cx = v2->cx-origin[0];
    cy = v2->cy - origin[1];
    cz = v2->cz - origin[2];
    x2 = cx*e0[0] + cy*e0[1] + cz*e0[2];
    y2 = cx*e1[0] + cy*e1[1] + cz*e1[2];

    fprintf(fp, "%f %f\n%f %f\n%f %f\n%f %f\n\n",
            x0, y0, x1, y1, x2, y2, x0, y0) ;
    fclose(fp) ;
  }

  for (n1 = 0 ; n1 < VERTICES_PER_FACE ; n1++)
  {
    switch (n1)
    {
    default:
    case 0:
      v = &mris->vertices[vno0] ;
      break ;
    case 1:
      v = &mris->vertices[vno1] ;
      break ;
    case 2:
      v = &mris->vertices[vno2] ;
      break ;
    }
    for (n = 0 ; n < v->vnum ; n++)
    {
      vno = v->v[n] ;
      if (vno == vno0 || vno == vno1 || vno == vno2)
      {
        continue ;
      }

      vn = &mris->vertices[v->v[n]] ;
      cx = vn->cx-origin[0];
      cy = vn->cy - origin[1];
      cz = vn->cz - origin[2];
      xn = cx*e0[0] + cy*e0[1] + cz*e0[2];
      yn = cx*e1[0] + cy*e1[1] + cz*e1[2];
      for (i = 0 ; i < VERTICES_PER_FACE ; i++)
      {
        switch (i)
        {
        default:
        case 0:
          v0 = &mris->vertices[vno0] ;
          v1 = &mris->vertices[vno1] ;
          v2 = &mris->vertices[vno2] ;
          break ;
        case 1:
          v0 = &mris->vertices[vno1] ;
          v1 = &mris->vertices[vno2] ;
          v2 = &mris->vertices[vno0] ;
          break ;
        case 2:
          v0 = &mris->vertices[vno2] ;
          v1 = &mris->vertices[vno0] ;
          v2 = &mris->vertices[vno1] ;
          break ;
        }
        cx = v0->cx-origin[0];
        cy = v0->cy - origin[1];
        cz = v0->cz-origin[2];
        x0 = cx*e0[0] + cy*e0[1] + cz*e0[2];
        y0 = cx*e1[0]+cy*e1[1] + cz*e1[2];

        cx = v1->cx-origin[0];
        cy = v1->cy - origin[1];
        cz = v1->cz-origin[2];
        x1 = cx*e0[0] + cy*e0[1] + cz*e0[2];
        y1 = cx*e1[0]+cy*e1[1] + cz*e1[2];

        cx = v2->cx-origin[0];
        cy = v2->cy - origin[1];
        cz = v2->cz-origin[2];
        x2 = cx*e0[0] + cy*e0[1] + cz*e0[2];
        y2 = cx*e1[0]+cy*e1[1] + cz*e1[2];

        if (FEQUAL(x1, x0))   /* vertical leg */
        {
          if (((x2 - x1) *
               (xn - x1)) < 0)  /* on opposite sides of leg */
          {
            break ;
          }
        }
        else
        {
          m = (y1 - y0) / (x1 - x0) ;
          b = y1 - m * x1 ;
          if ((y2 - (m * x2 + b)) * (yn - (m * xn + b)) < 0)
          {
            break ;
          }
        }
      }
      if (i >= VERTICES_PER_FACE)  /* all inside */
      {
        return(1) ;
      }
    }
  }
  return(0) ;
}
#else
{
  int     n, vno, i ;
  VERTEX  *v0, *v1, *v2, *v ;
  double   U0[3], U1[3], U2[3], dot, L0[3], L1[3], *V0, *V1, *V2,
           desc[3], cx, cy, cz, Point[3], len, norm_proj[3], U[3] ;

  /* compute planar coordinate representation of triangle vertices */
  v0 = &mris->vertices[vno0] ;
  v1 = &mris->vertices[vno1] ;
  v2 = &mris->vertices[vno2] ;
  cx = v0->cx-origin[0] ;
  cy = v0->cy-origin[1] ;
  cz = v0->cz-origin[2];
  U0[0] = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
  U0[1] = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
  U0[2] = 0 ;
  cx = v1->cx-origin[0] ;
  cy = v1->cy-origin[1] ;
  cz = v1->cz-origin[2];
  U1[0] = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
  U1[1] = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
  U1[2] = 0 ;
  cx = v2->cx-origin[0] ;
  cy = v2->cy-origin[1] ;
  cz = v2->cz-origin[2];
  U2[0] = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
  U2[1] = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
  U2[2] = 0 ;

  for (n = 0 ; n < v0->vnum ; n++)
  {
    vno = v0->v[n] ;
    if (vno == vno1 || vno == vno2)
    {
      continue ;
    }
    v = &mris->vertices[vno] ;
    cx = v->cx-origin[0] ;
    cy = v->cy-origin[1] ;
    cz = v->cz-origin[2];
    U[0] = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
    U[1] = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
    U[2] = 0 ;

    for (i = 0 ; i < 3 ; i++)
    {
      /*
      build a coordinate system with V0 as the origin, then construct
      the vector connecting V2 with it's normal projection onto V0->V1.
      This will be a descriminant vector for dividing the plane by the
      V0->V1 line. A positive dot product with the
      desc. vector indicates
      that the point is on the positive side of the plane and therefore
      may be contained within the triangle. Doing this for each of the
      legs in sequence gives a test for being inside the triangle.
      */

      switch (i)
      {
      default:
      case 0:
        V0 = U0 ;
        V1 = U1 ;
        V2 = U2 ;
        break ;
      case 1:
        V0 = U1 ;
        V1 = U2 ;
        V2 = U0 ;
        break ;
      case 2:
        V0 = U2 ;
        V1 = U0 ;
        V2 = U1 ;
        break ;
      }
      SUB(L0, V1, V0) ;
      SUB(L1, V2, V0) ;

      /* compute normal projection onto base of triangle */
      len = VLEN(L0) ;
      L0[0] /= len ;
      L0[1] /= len ;
      L0[2] /= len ;
      dot = DOT(L0,L1) ;
      SCALAR_MUL(norm_proj, dot, L0) ;

      /* build descriminant vector */
      SUB(desc, L1, norm_proj) ;

      /*
      transform point in question into local coordinate system and build
      the vector from the point in question to the normal
      projection point.
      The dot product of this vector with the
      descrimant vector will then
      indicate which side of the V0->V1 line the point is on.
      */
      SUB(Point, U, V0) ;
      SUB(Point, Point, norm_proj) ;
      dot = DOT(desc, Point) ;
      if (dot < 0 && !DZERO(dot))  /* not in triangle */
      {
        break ;
      }
    }
    if (i >= 3)  /* contained in triangle */
    {
      return(1) ;
    }
  }

  return(0) ;
}
#endif
#endif

static int computeOrientation(MRIS *mris,int f,int v0, int v1)
{
  FACE *face;

  face=&mris->faces[f];
  if (face->v[0]==v0)
  {
    if (face->v[1]==v1)
    {
      return 1;
    }
    else
    {
      return -1;
    }
  };
  if (face->v[1]==v0)
  {
    if (face->v[2]==v1)
    {
      return 1;
    }
    else
    {
      return -1;
    }
  };
  if (face->v[0]==v1)
  {
    return 1;
  }
  else
  {
    return -1;
  }
}

/* extract the non-marked vertices from a surface */
MRIS* MRISextractMarkedVertices(MRIS *mris)
{
  MRIS *mris_corrected;
  int *face_trans,*vertex_trans;
  VERTEX *v,*vdst;
  FACE *f,*fdst;
  int vno,i,n,fno;

  face_trans  =(int *)calloc(mris->nfaces, sizeof(int)) ;
  vertex_trans = (int *)calloc(mris->nvertices, sizeof(int)) ;
  memset(vertex_trans, -1, mris->nvertices*sizeof(int)) ;
  memset(face_trans, -1, mris->nfaces*sizeof(int)) ;
  // create a new surface
  mris_corrected = MRISalloc(mris->nvertices, mris->nfaces) ;
  // keep the extra info into the new one
  mris_corrected->useRealRAS = mris->useRealRAS;
  copyVolGeom(&mris->vg, &mris_corrected->vg);

  mris_corrected->type = MRIS_TRIANGULAR_SURFACE ;

  for (mris_corrected->nvertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    /* ignore the marked defect vertices but not the bordering ones */
    if (v->marked)
    {
      continue ;
    }
    vdst = &mris_corrected->vertices[mris_corrected->nvertices] ;
    vdst->nsize = v->nsize ;
    /* original vertices */
    vdst->x = v->x ;
    vdst->y = v->y ;
    vdst->z = v->z ;
    /* smoothed vertices */
    vdst->origx = v->origx ;
    vdst->origy = v->origy ;
    vdst->origz = v->origz ;
    vdst->tx = v->tx ;
    vdst->ty = v->ty ;
    vdst->tz = v->tz ;
    vdst->nx = v->nx ;
    vdst->ny = v->ny ;
    vdst->nz = v->nz ;
    /* canonical vertices */
    vdst->cx = v->cx ;
    vdst->cy = v->cy ;
    vdst->cz = v->cz ;
    vdst->num = v->num ;
    vdst->val = v->val ;
    vdst->val2 = v->val2 ;
    vdst->valbak = v->valbak ;
    vdst->val2bak = v->val2bak ;
    vdst->imag_val = v->imag_val ;
    vdst->curv = v->curv ;
    vdst->curvbak = v->curvbak ;
    vdst->stat = v->stat ;
    vdst->mean = v->mean ;
    vdst->mean_imag = v->mean_imag ;
    vdst->std_error = v->std_error;
    vdst->H = v->H ;
    vdst->K = v->K ;
    vdst->k1 = v->k1 ;
    vdst->k2 = v->k2 ;
    vdst->border=0;
    vertex_trans[vno] = mris_corrected->nvertices++ ;
  }

  for (mris_corrected->nfaces = fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    /* don't update triangle with marked vertices */
    if (triangleMarked(mris, fno))
    {
      continue ;
    }
    /* initialize face */
    fdst = &mris_corrected->faces[mris_corrected->nfaces] ;
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      fdst->v[n] = vertex_trans[f->v[n]] ;
    }
    face_trans[fno] = mris_corrected->nfaces++ ;
  }

  /* now allocate face and neighbor stuff in mris_corrected */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked)
    {
      continue ;
    }
    if (vertex_trans[vno]<0 || vertex_trans[vno] >= mris_corrected->nvertices)
    {
      continue ;
    }
    vdst = &mris_corrected->vertices[vertex_trans[vno]] ;

    /* count # of good triangles attached to this vertex */
    for (vdst->num = n = 0 ; n < v->num ; n++)
      if (triangleMarked(mris, v->f[n]) == 0)
      {
        vdst->num++ ;
      }
    vdst->f = (int *)calloc(vdst->num, sizeof(int)) ;
    vdst->n = (uchar *)calloc(vdst->num, sizeof(uchar)) ;
    for (i = n = 0 ; n < v->num ; n++)
    {
      if (triangleMarked(mris, v->f[n]))
      {
        continue ;
      }
      vdst->n[i] = v->n[n] ;
      vdst->f[i] = face_trans[v->f[n]] ;
      i++ ;
    }

    /* count # of valid neighbors */
    for (n = vdst->vnum = 0 ; n < v->vnum ; n++)
      if (mris->vertices[v->v[n]].marked == 0)
      {
        vdst->vnum++ ;
      }
    vdst->vtotal = vdst->vnum ;
    vdst->v = (int *)calloc(vdst->vnum, sizeof(int)) ;
    for (i = n = 0 ; n < v->vnum ; n++)
      if (mris->vertices[v->v[n]].marked == 0)
      {
        vdst->v[i++] = vertex_trans[v->v[n]] ;
      }
  }

  return mris_corrected;
}

/* extract the main connected component from a triangulation
   use the v->marked to extract the surface */
MRIS* MRISextractMainComponent(MRI_SURFACE *mris,int do_not_extract, int verbose , int *ncpts)
{
  MRIS* mris_out;
  VERTEX *v,*vp1,*vp2;
  int n,vn0,vn1,vn2,p,count,max_c,max_nbr,found,ncpt;
  int nv,ne,nf,nX,tX,tv,te,tf;
  float cx,cy,cz;

  /* use marked field for counting purposes */
  MRISclearMarks(mris);

  tX=tv=te=tf=0;
  max_c=0;
  max_nbr=0;
  if(verbose)
  {
    fprintf(WHICH_OUTPUT,"\ncounting number of connected components...");
  }
  for (count=0,vn0=0; vn0 < mris->nvertices ; vn0++)
  {
    v=&mris->vertices[vn0];
    if (v->marked)
    {
      continue;
    }
    count++;
    v->marked=count;
    found=1;
    ncpt=1;
    while (found)
    {
      found=0;
      for (vn1=0; vn1 < mris->nvertices ; vn1++)
      {
        vp1=&mris->vertices[vn1];
        if (vp1->marked)
        {
          continue;
        }
        /* check neighbors */
        for (p=0 ; p < vp1->vnum ; p++)
        {
          vn2=vp1->v[p];
          vp2=&mris->vertices[vn2];
          if (vp2->marked==count)
          {
            vp1->marked=count;
            found=1;
            ncpt++;
            break;
          }
        }
      }
    }
    if (max_nbr<ncpt)
    {
      max_c=count;
      max_nbr=ncpt;
    }
    /* computing Euler Number of component */
    ne=0;
    nv=0;
    cx=cy=cz=0.0f;
    for (vn1=0; vn1 < mris->nvertices ; vn1++)
    {
      vp1=&mris->vertices[vn1];
      if (vp1->marked!=count)
      {
        continue;
      }
      ne += vp1->vnum;
      nv++;
      cx += vp1->x;
      cy += vp1->y;
      cz += vp1->z;
    }
    cx /= nv; // center of gravity
    cy /= nv;
    cz /= nv;
    ne /= 2; // half the number of edges
    /* now counting faces */
    nf=0;
    for (vn1=0; vn1 < mris->nfaces ; vn1++)
    {
      if (mris->vertices[mris->faces[vn1].v[0]].marked==count)
      {
        nf++;
      }
    }
    nX=nv-ne+nf;
    tX += nX;
    tv += nv;
    te += ne;
    tf += nf;
    if(verbose) fprintf(stderr,
                          "\n   %d voxel in cpt #%d: X=%d [v=%d,e=%d,f=%d] located at (%f, %f, %f)",
                          ncpt,count,nX,nv,ne,nf,cx,cy,cz);
  }
  if(verbose)
  {
    fprintf(stderr,"\nFor the whole surface: X=%d [v=%d,e=%d,f=%d]",tX,tv,te,tf);
  }

  if (count <= 1)
  {
    if(verbose)
    {
      fprintf(WHICH_OUTPUT,"\nOne single component has been found");
    }
    if (!do_not_extract && verbose)
    {
      fprintf(WHICH_OUTPUT,"\nnothing to do");
    }
  }
  else
  {
    if(verbose)
    {
      fprintf(WHICH_OUTPUT,"\n%d components have been found",count);
    }
    if (!do_not_extract && verbose)
      fprintf(WHICH_OUTPUT,
              "\nkeeping component #%d with %d vertices",max_c,max_nbr);
  }

  if(ncpts)
  {
    *ncpts=count;
  }

  /* nothing to do */
  if (do_not_extract)
  {
    return mris;
  }

  /* set vertex mark to 1 if removed vertex */
  for (n = 0 ; n < mris->nvertices ; n++)
  {
    v=&mris->vertices[n];
    if (v->marked==max_c)
    {
      v->marked=0;
    }
    else
    {
      v->marked=1;
    }
  }

  mris_out= MRISextractMarkedVertices(mris);
  MRISclearMarks(mris);
  return mris_out;
}

/* This function finds the orientation changes in the triangles
   constituting the tessellation. Writes the orientation changes in
   curv. Note that this function can easily be modified to check the
   orientation changes for any tessellations (not only triangulations) */
int MRISmarkOrientationChanges(MRI_SURFACE *mris)
{

  VERTEX *v;
  int face1,face2,vn0,p,vn1,vn2,d1,d2,count;
#if 0
  int k,vn3,vn4,vn5,vn6,v1,v2,same_orientation;
#endif
  /* to avoid compiler warnings */
  face1=face2=0;
  d1=d2=0;

  /* erase curvature for diag purposes */
  MRISclearCurvature(mris);

#if 1
  for (count=0,vn0=0; vn0 < mris->nvertices ; vn0++)
  {

    int nfaces,n;
    v=&mris->vertices[vn0];
    if (v->ripflag)
    {
      continue;
    }



    /* go through neighbors */
    if (v->vnum==0)
    {
      //                        continue;
      fprintf(WHICH_OUTPUT,"vertex %d without neighbors ! \n",vn0);
      v->curv=-5;
    }
    if (v->num==0)
    {
      fprintf(WHICH_OUTPUT,"vertex %d without faces ! \n",vn0);
    }

    for (p=0 ; p < v->vnum ; p++)
    {
      vn1=v->v[p];
      if (mris->vertices[vn1].ripflag)
        fprintf(WHICH_OUTPUT,
                "vertex %d connected to ripped defect %d !\n ",vn0,vn1);

      /* find the neighboring faces of vn0 and vn1 */
      nfaces=0;
      for (n=0 ; n < v->vnum ; n++)
      {
        vn2=v->v[n];

        if (vn2==vn1)
        {
          continue;
        }

        if (isFace(mris,vn0,vn1,vn2))
        {
          nfaces++;
          if (nfaces==1)
          {
            face1=findFace(mris,vn0,vn1,vn2);
          }
          else
          {
            face2=findFace(mris,vn0,vn1,vn2);
          }
        }
      }

      if (nfaces==1)
      {
        fprintf(WHICH_OUTPUT,"edge (%d<-->%d) has one single face %d !\n",
                vn0,vn1,face1);
        v->curv=-2;
      }

      if (nfaces==0)
      {
        fprintf(WHICH_OUTPUT,"edge (%d<-->%d) has no face !\n",vn0,vn1);
        v->curv=-3;
      }

      if (nfaces>2)
      {
        fprintf(WHICH_OUTPUT,"edge (%d<-->%d) has too many faces "
                "(at least : %d %d) !\n",vn0,vn1,face1,face2);
        v->curv=-4;
      }
      /* check the orientation for face 1 and face 2 */
      if (nfaces==2 &&
          (computeOrientation(mris,face1,vn0,vn1)*
           computeOrientation(mris,face2,vn0,vn1)>0))
      {
        v->curv=-1;
        fprintf(WHICH_OUTPUT,"\ndefective orientation at "
                "vertex %d(%d) with faces %d and %d\n",vn0,vn1,face1,face2);
        count++;
      }
    }
  }
  fprintf(WHICH_OUTPUT,"\n%2.3f %% of the vertices (%d vertices) "
          "exhibit an orientation change\n",100.*count/mris->nvertices,count);
#endif
#if 0
  for (count=0,vn0=0; vn0 < mris->nvertices ; vn0++)
  {

    v=&mris->vertices[vn0];

    //go through neighboring faces
    same_orientation=1;

    for (p=0 ; same_orientation && p < v->num ; p++)
    {

      //study face p with its 2 neighboring faces
      vn1=mris->faces[v->f[p]].v[0];
      vn2=mris->faces[v->f[p]].v[1];
      vn3=mris->faces[v->f[p]].v[2];

      //check all the other faces and see if they share 2 points
      for (k=0 ; same_orientation && k < v->num ; k++)
      {


        if (k==p)
        {
          continue;  /* don't look at the same face! */
        }

        v1=mris->faces[v->f[k]].v[0];

        if (v1!=vn1 && v1!=vn2 && v1!=vn3)
        {
          /* this vertex is not part of the first face */

          v1=mris->faces[v->f[k]].v[1];

          if (v1!=vn1 && v1!=vn2 && v1!=vn3)
          {
            continue;  /* this face is not a neighbor of the first one */
          }

          /* we have found v1 in position 1 */

          v2=mris->faces[v->f[k]].v[2];
          if (v2!=vn1 && v2!=vn2 && v2!=vn3)
          {
            continue;  /* only v in common: the faces are not neighbors! */
          }

          /* we have found v2 in 2 */
        }
        else
        {
          /* we have found v1 in 0 */
          v2=mris->faces[v->f[k]].v[1];

          if (v2!=vn1 && v2!=vn2 && v2!=vn3)
          {
            /* this vertex is not part of the first face */

            v2=mris->faces[v->f[k]].v[2];
            if (v2!=vn1 && v2!=vn2 && v2!=vn3)
            {
              continue;  /* only v in common: the faces are not neighbors */
            }

            /* we have found v2 in 2 */
          }
          /* we have found v2 in 1 */
        }

        /* we have a face that is neighboring */
        vn4=mris->faces[v->f[k]].v[0];
        vn5=mris->faces[v->f[k]].v[1];
        vn6=mris->faces[v->f[k]].v[2];

        /* now check the different orientation of the two faces */
        if (v1==vn1 && v2==vn2)
        {
          d1=1;
        }
        if (v1==vn1 && v2==vn3)
        {
          d1=-1;
        }
        if (v1==vn2 && v2==vn1)
        {
          d1=-1;
        }
        if (v1==vn2 && v2==vn3)
        {
          d1=1;
        }
        if (v1==vn3 && v2==vn1)
        {
          d1=1;
        }
        if (v1==vn3 && v2==vn2)
        {
          d1=-1;
        }

        if (v1==vn4 && v2==vn5)
        {
          d2=1;
        }
        if (v1==vn4 && v2==vn6)
        {
          d2=-1;
        }
        if (v1==vn5 && v2==vn4)
        {
          d2=-1;
        }
        if (v1==vn5 && v2==vn6)
        {
          d2=1;
        }
        if (v1==vn6 && v2==vn4)
        {
          d2=1;
        }
        if (v1==vn6 && v2==vn5)
        {
          d2=-1;
        }

        if (d2*d1>0)
        {
          same_orientation=0;
          face1=v->f[p];
          face2=v->f[k];
        }
      }
    }

    if (same_orientation==0)
    {
      v->curv=-2;
      fprintf(WHICH_OUTPUT,
              "\ndefectuous orientation at vertex %d with faces %d and %d ",
              vn0,face1,face2);
      count++;
    }
    else
    {
      v->curv=0;
    }
  }
  fprintf
  (WHICH_OUTPUT,
   "\n%2.3f %% of the vertices (%d vertices) "
   "exhibit an orientation change\n",
   100.*count/mris->nvertices,count);
#endif

  return count;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  Orient the faces of the tessellation so that the
  point outward (i.e. in the same direction as the original
  surface).
  ------------------------------------------------------*/
#if 1
static int
mrisOrientRetessellatedSurface(MRI_SURFACE *mris, DEFECT_LIST *dl,int *vtrans)
{
  int     vno, n, fno, m, vno0, vno1 ;/*n0, n1;*/
  VERTEX  *v ,*v1,*v2,*v3;
  FACE    *f ;
  float   dot, norm[3], cx, cy, cz ,a[3],b[3];

  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  MRISrestoreVertexPositions(mris, CANONICAL_VERTICES) ;
  /* should not reproject vertices on to sphere */
#if 0
  MRISprojectOntoSphere(mris, mris, MRISaverageRadius(mris)) ;
#endif

  MRIScomputeMetricProperties(mris) ;

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    if (fno == Gdiag_no)
    {
      DiagBreak() ;
    }
    f = &mris->faces[fno] ;
    v1=&mris->vertices[f->v[0]];
    v2=&mris->vertices[f->v[1]];
    v3=&mris->vertices[f->v[2]];
#if 0
    mrisCalculateFaceCentroid(mris, fno, &cx, &cy, &cz) ;
#else
    cx=v1->cx+v2->cx+v3->cx;
    cy=v1->cy+v2->cy+v3->cy;
    cz=v1->cz+v2->cz+v3->cz;
#endif


#if 0
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      mrisNormalFace(mris, fno, n, norm) ;  /* compute face normal */
      dot = norm[0]*cx + norm[1]*cy + norm[2]*cz ;

      if (dot < 0) /* they disagree - change order of vertices in face */
      {
        n0 = (n == 0)                   ? VERTICES_PER_FACE-1 : n-1;
        n1 = (n == VERTICES_PER_FACE-1) ? 0                   : n+1;
        vno0 = f->v[n0] ;
        vno1 = f->v[n1] ;
        f->v[n0] = vno1 ;
        f->v[n1] = vno0 ;
        mrisSetVertexFaceIndex(mris, vno0, fno) ;
        mrisSetVertexFaceIndex(mris, vno1, fno) ;
      }
    }
#else

    a[0]=v2->cx-v1->cx;
    b[0]=v3->cx-v1->cx;
    a[1]=v2->cy-v1->cy;
    b[1]=v3->cy-v1->cy;
    a[2]=v2->cz-v1->cz;
    b[2]=v3->cz-v1->cz;

    F_CROSS(a,b,norm);

    dot = norm[0]*cx + norm[1]*cy + norm[2]*cz ;
    if (dot < 0) /* they disagree - change order of vertices in face */
    {
      vno0 = f->v[1] ;
      vno1 = f->v[2] ;
      f->v[1] = vno1 ;
      f->v[2] = vno0 ;
      mrisSetVertexFaceIndex(mris, vno0, fno) ;
      mrisSetVertexFaceIndex(mris, vno1, fno) ;
    }
#endif
  }

  MRIScomputeMetricProperties(mris) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    dot = v->nx * v->x + v->ny*v->y + v->nz*v->z ;
    if (dot < 0)
    {
      fprintf(stdout, "vertex %d seems to have inverted normal!\n", vno) ;
      DiagBreak() ;
    }

    for (m = 0 ; m < v->num ; m++)
    {
      fno = v->f[m] ;
      f = &mris->faces[fno] ;
      if (fno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (f->area < 0)
      {
        fprintf(stdout, "face %d seems to have negative area!\n", fno) ;
        DiagBreak() ;
      }
      for (n = 0 ; n < VERTICES_PER_FACE ; n++)
      {
        mrisNormalFace(mris, fno, n, norm) ;  /* compute face normal */
        dot = norm[0]*v->x + norm[1]*v->y + norm[2]*v->z ;

        if (dot < 0) /* they disagree - change order
                                                  of vertices in face */
        {
          fprintf(stdout,
                  "face %d seems to have inverted normal!\n", fno) ;
          DiagBreak() ;
        }
      }
    }
  }

  MRISclearMarks(mris) ;
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;
  return(NO_ERROR) ;
}
#else
static int
mrisOrientRetessellatedSurface(MRI_SURFACE *mris, DEFECT_LIST *dl,int *vtrans)
{
#if 1
  int     dno, fno, vno, i, n, m, vno0, vno1, n0, n1, oriented, nreversed ;
  VERTEX  *v, *vn ;
  FACE    *f ;
  DEFECT  *defect ;
  float   dot, norm[3], len, nx, ny, nz ;

  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  MRISrestoreVertexPositions(mris, ORIG_VERTICES) ;
  MRISaverageVertexPositions(mris, 200) ;
  MRIScomputeMetricProperties(mris) ;

  /* compute average boundary normal in the smoothed space */
  for (dno = 0 ; dno < dl->ndefects ; dno++)
  {
    defect = &dl->defects[dno] ;
    nx = ny = nz = 0.0f ;
    for (i = 0 ; i < defect->nborder ; i++)
    {
      vno = vtrans[defect->border[i]] ;
      if (vno < 0)        /* not in new tessellation */
      {
        continue ;
      }
      v = &mris->vertices[vno] ;
      nx += v->nx ;
      ny += v->ny ;
      nz += v->nz ;
    }
    len = sqrt(nx*nx + ny*ny + nz*nz) ;
    if (FZERO(len))
    {
      len = 1.0f ;
    }
    defect->nx = nx/len ;
    defect->ny = ny/len ;
    defect->nz = nz/len ;
  }

  /* orient defect faces so that the outward direction agrees with boundary */
  for (oriented = dno = 0 ; dno < dl->ndefects ; dno++)
  {
    defect = &dl->defects[dno] ;
    for (i = 0 ; i < defect->nvertices ; i++)
    {
      vno = vtrans[defect->vertices[i]] ;
      if (vno < 0)     /* not in new tessellation */
      {
        continue ;
      }
      v = &mris->vertices[vno] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      /* go through each face and orient it to agree with defect normal */
      for (m = 0 ; m < v->num ; m++)
      {
        fno = v->f[m] ;
        f = &mris->faces[fno] ;
        if (fno == Gdiag_no)
        {
          DiagBreak() ;
        }
        for (n = 0 ; n < VERTICES_PER_FACE ; n++)
        {
          mrisNormalFace(mris, fno, n, norm) ; /*compute face normal */
          dot =
            norm[0]*defect->nx +
            norm[1]*defect->ny +
            norm[2]*defect->nz ;
          if (dot < 0)   /* they disagree - change
            order of vertices in face */
          {
            oriented++ ;
            n0 = (n == 0) ? VERTICES_PER_FACE-1 : n-1;
            n1 = (n == VERTICES_PER_FACE-1) ? 0  : n+1;
            vno0 = f->v[n0] ;
            vno1 = f->v[n1] ;
            f->v[n0] = vno1 ;
            f->v[n1] = vno0 ;
            mrisSetVertexFaceIndex(mris, vno0, fno) ;
            mrisSetVertexFaceIndex(mris, vno1, fno) ;
            if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
              fprintf(stdout,
                      "reversing face %d orientation\n", fno) ;
          }
        }
      }
    }
  }

  MRISsetNeighborhoodSize(mris, 2) ;

  i = 0 ;
  do
  {
    MRIScomputeMetricProperties(mris) ;
    nreversed = 0 ;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      for (nx = ny = nz = 0.0, n = 0 ; n < v->vtotal ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        dot = vn->nx*v->nx + vn->ny*v->ny + vn->nz*v->nz ;
        if (dot < 0)
        {
          DiagBreak() ;
        }
        nx += vn->nx ;
        ny += vn->ny ;
        nz += vn->nz ;
      }
      dot = nx*v->nx + ny*v->ny + nz*v->nz ;
      if (dot < 0)
      {
        v->nx *= -1.0 ;
        v->ny *= -1.0 ;
        v->nz *= -1.0 ;
        DiagBreak() ;
      }

      for (m = 0 ; m < v->num ; m++)
      {
        fno = v->f[m] ;
        f = &mris->faces[fno] ;
        if (fno == Gdiag_no)
        {
          DiagBreak() ;
        }
        dot = nx*f->nx + ny*f->ny + nz*f->nz ;
        if (dot < 0)   /* they disagree - change order
          of vertices in face */
        {
          DiagBreak() ;
        }
        for (n = 0 ; n < VERTICES_PER_FACE ; n++)
        {
          mrisNormalFace(mris, fno, n, norm) ; /* compute
          face normal */
          dot = norm[0]*nx + norm[1]*ny + norm[2]*nz ;
          if (dot < 0)   /* they disagree - change
            order of vertices in face */
          {
            nreversed++ ;
            n0 = (n == 0) ? VERTICES_PER_FACE-1 : n-1;
            n1 = (n == VERTICES_PER_FACE-1) ? 0 : n+1;
            vno0 = f->v[n0] ;
            vno1 = f->v[n1] ;
            f->v[n0] = vno1 ;
            f->v[n1] = vno0 ;
            mrisSetVertexFaceIndex(mris, vno0, fno) ;
            mrisSetVertexFaceIndex(mris, vno1, fno) ;
            if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
              fprintf(stdout,
                      "reversing face %d orientation\n", fno) ;
          }
        }
      }
    }
    if (Gdiag & DIAG_SHOW)
    {
      fprintf(stdout, "\rpass %d: %d oriented   ", i+1, nreversed) ;
    }

    oriented += nreversed ;
    if (++i > 20)  /* shouldn't happen, but... */
    {
      break ;
    }
  }
  while (nreversed > 0) ;


  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "orientation complete in %d passes\n", i) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (m = 0 ; m < v->num ; m++)
    {
      fno = v->f[m] ;
      f = &mris->faces[fno] ;
      if (fno == Gdiag_no)
      {
        DiagBreak() ;
      }
      for (n = 0 ; n < VERTICES_PER_FACE ; n++)
      {
        mrisNormalFace(mris, fno, n, norm) ;  /* compute face normal */
        dot = norm[0]*v->nx + norm[1]*v->ny + norm[2]*v->nz ;
        if (dot < 0)   /* they disagree - change order
          of vertices in face */
        {
          DiagBreak() ;
        }
        dot = norm[0]*f->nx + norm[1]*f->ny + norm[2]*f->nz ;
        if (dot < 0)   /* they disagree - change order
          of vertices in face */
        {
          DiagBreak() ;
        }
      }
    }
  }

#if 0
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;  /* back to inflated */
#endif
  MRIScomputeMetricProperties(mris) ;
  return(oriented) ;
#else
  int    vno, vno0, vno1, i, n, fno, oriented, num, dno, m, blist[200000], nb,
         tmp[200000], nbnew, n0, n1 ;
  FACE   *f ;
  VERTEX *v, *vn ;
  float  norm[3], dot, len ;
  DEFECT *defect ;

  oriented = 0 ;
  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;
  MRISsetNeighborhoodSize(mris, 2) ;

  /* first orient vertices */

  /* mark all defective vertices */
  for (nb = dno = 0 ; dno < dl->ndefects ; dno++)
  {
    defect = &dl->defects[dno] ;
    for (n = 0 ; n < defect->nvertices ; n++)
    {
      vno = vtrans[defect->vertices[n]] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (vno < 0)
      {
        continue ;
      }
      mris->vertices[vno].marked = 1 ;
    }
    for (n = 0 ; n < defect->nborder ; n++)
    {
      mris->vertices[vtrans[defect->border[n]]].marked = 1 ;
    }
    memmove(blist+nb, defect->border, defect->nborder*sizeof(int)) ;
    nb += defect->nborder ;
  }

  /* starts out as a list of border vertices and will grow inwards */
  for (i = 0 ; i < nb ; i++)
  {
    blist[i] = vtrans[blist[i]] ;
  }

  do   /* grow border inwards one edge length at each iteration */
  {
    for (nbnew = i = 0 ; i < nb ; i++)
    {
      vno = blist[i] ;
      if (vno < 0)   /* not in new tessellation - shouldn't happen */
      {
        continue ;
      }
      v = &mris->vertices[vno] ;
      if (vno == Gdiag_no || vno == 135681)
      {
        DiagBreak() ;
      }
      v->nx = v->ny = v->nz = 0 ;
      for (dot = 0.0, num = n = 0 ; n < v->vtotal ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;

        /* only use already oriented (or non-defective) vertices */
        if (vn->marked)
        {
          continue ;
        }
        v->nx += vn->nx ;
        v->ny += vn->ny ;
        v->nz += vn->nz ;
        num++ ;
      }
      if (!num)   /* surrounded by unoriented defective vertices */
      {
        tmp[nbnew++] = vno ;   /* so it will be processed
      next time again */
        continue ;
      }
      len = sqrt(v->nx*v->nx + v->ny*v->ny + v->nz*v->nz) ;
      if (FZERO(len))
      {
        len = 1.0f ;
      }
      v->nx /= len ;
      v->ny /= len ;
      v->nz /= len ;
      v->marked = 3 ;   /* it's proper orientation has been established */
    }
    for (i = 0 ; i < nb ; i++)
    {
      vno = blist[i] ;
      if (vno < 0)   /* not in new tessellation - shouldn't happen */
      {
        continue ;
      }
      v = &mris->vertices[vno] ;
      if (v->marked == 3)  /* was oriented properly */
      {
        v->marked = 0 ;
      }
    }

    /* now build new list of vertices, moving inward by one vertex */
    for (i = 0 ; i < nb ; i++)
    {
      vno = blist[i] ;
      v = &mris->vertices[vno] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;

        /* only use already oriented (or non-defective) vertices */
        if (vn->marked == 1)
        {
          vn->marked = 2 ;  /* don't add it more than once */
          tmp[nbnew++] = v->v[n] ;
        }
      }
    }
    nb = nbnew ;
    if (nb > 0)
    {
      memmove(blist, tmp, nb*sizeof(int)) ;
    }
  }
  while (nb > 0) ;


  MRISclearMarks(mris) ;

  /* now orient faces to agree with their vertices */
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    if (fno == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      mrisNormalFace(mris, fno, n, norm) ;  /* how about vertex 2 ???? */
      vno = f->v[n] ;
      v = &mris->vertices[vno] ;
      dot = norm[0]*v->nx + norm[1]*v->ny + norm[2]*v->nz ;
      if (dot < 0)   /* change order of vertices in face */
      {
        oriented++ ;
        n0 = (n == 0)                   ? VERTICES_PER_FACE-1 : n-1;
        n1 = (n == VERTICES_PER_FACE-1) ? 0                   : n+1;
        vno0 = f->v[n0] ;
        vno1 = f->v[n1] ;
        f->v[n0] = vno1 ;
        f->v[n1] = vno0 ;
        mrisSetVertexFaceIndex(mris, vno0, fno) ;
        mrisSetVertexFaceIndex(mris, vno1, fno) ;
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
        {
          fprintf(stdout, "reversing face %d orientation\n", fno) ;
        }
      }
    }
  }

  MRIScomputeMetricProperties(mris) ;
  MRISclearMarks(mris) ;

  /* mark all vertices that have a normal which disagrees with any neighbor */
  for (dno = 0 ; dno < dl->ndefects ; dno++)
  {
    defect = &dl->defects[dno] ;
    for (i = 0 ; i < defect->nvertices ; i++)
    {
      vno = vtrans[defect->vertices[i]] ;
      if (vno < 0)
      {
        continue ;
      }
      v = &mris->vertices[vno] ;
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        dot = vn->nx * v->nx + vn->ny * v->ny + vn->nz * v->nz ;
        if (dot < 0)
        {
          v->marked = 1 ;
          if (!vn->marked)
          {
            vn->marked = 1 ;
          }
          break ;
        }
      }
    }
  }

  /* go back and orient the ambiguous vertices based on the normal of
  the defect.
  */
  for (dno = 0 ; dno < dl->ndefects ; dno++)
  {
    defect = &dl->defects[dno] ;
    for (i = 0 ; i < defect->nvertices ; i++)
    {
      vno = vtrans[defect->vertices[i]] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (vno < 0)
      {
        continue ;
      }
      v = &mris->vertices[vno] ;
      if (!v->marked)
      {
        continue ;
      }
      dot = defect->nx * v->nx + defect->ny * v->ny + defect->nz * v->nz ;
      if (dot < 0)
      {
        v->nx *= -1 ;
        v->ny *= -1 ;
        v->nz *= -1 ;
      }
    }
  }
  MRISclearMarks(mris) ;

  /* now orient faces to agree with their vertices */
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    if (fno == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
    {
      mrisNormalFace(mris, fno, n, norm) ;  /* how about vertex 2 ???? */
      vno = f->v[n] ;
      v = &mris->vertices[vno] ;
      dot = norm[0]*v->nx + norm[1]*v->ny + norm[2]*v->nz ;
      if (dot < 0)   /* change order of vertices in face */
      {
        oriented++ ;
        m = (n+1) >= VERTICES_PER_FACE ? 0 : n+1 ;
        vno0 = f->v[n] ;
        vno1 = f->v[m] ;
        f->v[n] = vno1 ;
        f->v[m] = vno0 ;
        mrisSetVertexFaceIndex(mris, vno0, fno) ;
        mrisSetVertexFaceIndex(mris, vno1, fno) ;
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
        {
          fprintf(stdout, "reversing face %d orientation\n", fno) ;
        }
        mrisNormalFace(mris, fno, n, norm) ;  /* how about
      vertex 2 ???? */
        dot = norm[0]*v->nx + norm[1]*v->ny + norm[2]*v->nz ;
      }
    }
  }

  MRIScomputeMetricProperties(mris) ;

  if (Gdiag_no >= 0)
  {
    v = &mris->vertices[Gdiag_no] ;
    for (dot = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;

      /* only use already oriented (or non-defective) vertices */
      dot += v->nx*vn->nx + v->ny*vn->ny + v->nz*vn->nz ;
    }
    if (dot < 0)
    {
      DiagBreak() ;
    }
    for (dot = 0.0, n = 0 ; n < v->num ; n++)
    {
      fno = v->f[n] ;
      f = &mris->faces[fno] ;

      /* only use already oriented (or non-defective) vertices */
      dot += v->nx*f->nx + v->ny*f->ny + v->nz*f->nz ;
    }
    if (dot < 0)
    {
      DiagBreak() ;
    }
    MRISrestoreVertexPositions(mris, ORIG_VERTICES) ;
    MRIScomputeMetricProperties(mris) ;
    v = &mris->vertices[Gdiag_no] ;
    for (dot = 0.0, n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;

      /* only use already oriented (or non-defective) vertices */
      dot += v->nx*vn->nx + v->ny*vn->ny + v->nz*vn->nz ;
    }
    if (dot < 0)
    {
      DiagBreak() ;
    }

  }

#if 0
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
#endif
  return(oriented) ;
#endif
}
#endif
#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisComputeCanonicalBasis(MRI_SURFACE *mris, int fno, double origin[3],
                          double e0[3], double e1[3])
{
  FACE    *f ;
  double   len, normal[3] ;
  float    fx, fy, fz ;

  f = &mris->faces[fno] ;
  mrisCalculateCanonicalFaceCentroid(mris, fno, &fx, &fy, &fz) ;
  origin[0] = (double)fx ;
  origin[1] = (double)fy ;
  origin[2] = (double)fz ;
  normal[0] = origin[0] ;
  normal[1] = origin[1] ;
  normal[2] = origin[2] ;
  len = 1.0f/VLEN(normal) ;
  SCALAR_MUL(normal, len, normal) ;

  /* pick any non-parallel vector and cross it with normal */
  e1[0] = normal[1] ;
  e1[1] = normal[2] ;
  e1[2] = normal[0] ;
  CROSS(e0, normal, e1) ;
  if ((VZERO(e0)))  /* happened to pick parallel vector */
  {
    e1[0] = normal[1] ;
    e1[1] = -normal[2] ;
    e1[2] = normal[0] ;
    CROSS(e0, normal, e1) ;
  }
  CROSS(e1, e0, normal) ;
  len = 1.0f/VLEN(e0) ;
  SCALAR_MUL(e0, len, e0) ;
  len = 1.0f/VLEN(e1) ;
  SCALAR_MUL(e1, len, e1) ;
  len = DOT(e0, e1) ;
  if ((VZERO(e0)) || (VZERO(e1)))
  {
    fprintf(stdout, "face %d, canonical basis degenerate!\n", fno) ;
  }
  if (fabs(len) > 0.001)
  {
    fprintf(stdout, "face %d, canonical basis not orthogonal!\n", fno) ;
  }
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if (!SPHERE_INTERSECTION)
static int
mrisComputeCanonicalEdgeBasis(MRI_SURFACE *mris, EDGE *edge1, EDGE *edge2,
                              double origin[3], double e0[3], double e1[3])
{
  VERTEX   *v0, *v1, *v2, *v3 ;
  double   len, normal[3] ;
  float    fx, fy, fz ;

  v0 = &mris->vertices[edge1->vno1] ;
  v1 = &mris->vertices[edge1->vno2] ;
  v2 = &mris->vertices[edge2->vno1] ;
  v3 = &mris->vertices[edge2->vno2] ;
  fx = (v0->cx + v1->cx + v2->cx + v3->cx) / 4 ;
  fy = (v0->cy + v1->cy + v2->cy + v3->cy) / 4 ;
  fz = (v0->cz + v1->cz + v2->cz + v3->cz) / 4 ;
  normal[0] = origin[0] = (double)fx ;
  normal[1] = origin[1] = (double)fy ;
  normal[2] = origin[2] = (double)fz ;
  len = 1.0f/VLEN(normal) ;
  SCALAR_MUL(normal, len, normal) ;

  /* pick any non-parallel vector and cross it with normal */
  e1[0] = normal[1] ;
  e1[1] = normal[2] ;
  e1[2] = normal[0] ;
  CROSS(e0, normal, e1) ;
  if ((VZERO(e0)))  /* happened to pick parallel vector */
  {
    e1[0] = normal[1] ;
    e1[1] = -normal[2] ;
    e1[2] = normal[0] ;
    CROSS(e0, normal, e1) ;
  }
  CROSS(e1, e0, normal) ;
  len = 1.0f/VLEN(e0) ;
  SCALAR_MUL(e0, len, e0) ;
  len = 1.0f/VLEN(e1) ;
  SCALAR_MUL(e1, len, e1) ;
  len = DOT(e0, e1) ;
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  find the convex hull of the defect on the sphere (actually,
  just a disk, but at least it's convex....)
  ------------------------------------------------------*/
static int
mrisFindDefectConvexHull(MRI_SURFACE *mris, DEFECT *defect)
{
#if SMALL_CONVEX_HULL
  VERTEX *v, *vn ;
  int    chull[200000], nfound, n, i, vno ;


  defect->chull = chull ;
  defect->nchull = defect->nborder ;  /* include border vertices first*/
  memmove(chull, defect->border, defect->nborder*sizeof(int)) ;

  MRISclearMarks(mris) ;
  mrisMarkDefectConvexHull(mris, defect, 1) ;
  mrisMarkDefect(mris, defect, 1) ;

  for (nfound = i = 0 ; i < defect->nborder ; i++)
  {
    vno = defect->border[i] ;
    v = &mris->vertices[vno] ;

    /* vertex inside convex hull - add all its nbrs */
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->marked)   /* already in defect or convex hull */
      {
        continue ;
      }
      chull[defect->nchull+nfound++] = v->v[n] ; /* first neighbors only! */
      vn->marked = 1 ;
    }
  }
  defect->nchull += nfound ;

  MRISclearMarks(mris) ;
  defect->chull = (int *)calloc(defect->nchull, sizeof(int)) ;
  if (!defect->chull)
    ErrorExit(ERROR_NO_MEMORY,
              "mrisFindConvexHull: could not allocate %d vlist\n",
              defect->nchull) ;
  memmove(defect->chull, chull, defect->nchull*sizeof(int)) ;

  return(NO_ERROR) ;
#else
  float  xmin, xmax, ymin, ymax, zmin, zmax ;
  VERTEX *v, *vn ;
  int    chull[200000], nfound, n, i, vno ;


  xmin = ymin = zmin = 100000 ;
  xmax = ymax = zmax = 0.0f ;


  /* now compute max radius on surface of sphere */
  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    if (i < defect->nvertices)
    {
      vno = defect->vertices[i] ;
      if (defect->status[i] == DISCARD_VERTEX)
      {
        continue ;
      }
    }
    else
    {
      vno = defect->border[i-defect->nvertices] ;
    }
    v = &mris->vertices[vno] ;
    if (v->cx < xmin)
    {
      xmin = v->cx ;
    }
    if (v->cy < ymin)
    {
      ymin = v->cy ;
    }
    if (v->cz < zmin)
    {
      zmin = v->cz ;
    }
    if (v->cx > xmax)
    {
      xmax = v->cx ;
    }
    if (v->cy > ymax)
    {
      ymax = v->cy ;
    }
    if (v->cz > zmax)
    {
      zmax = v->cz ;
    }
  }
  defect->chull = chull ;
  defect->nchull = defect->nborder ;
  memmove(chull, defect->border, defect->nborder*sizeof(int)) ;

  MRISclearMarks(mris) ;
  mrisMarkDefectConvexHull(mris, defect, 1) ;
  mrisMarkDefect(mris, defect, 1) ;

  do
  {
    nfound = 0 ;
    for (i = 0 ; i < defect->nchull ; i++)
    {
      v = &mris->vertices[defect->chull[i]] ;
      if (defect->chull[i] == Gdiag_no)
      {
        DiagBreak() ;
      }
      if ((v->cx >= xmin && v->cx <= xmax) &&
          (v->cy >= ymin && v->cy <= ymax) &&
          (v->cz >= zmin && v->cz <= zmax))
      {
        /* vertex inside convex hull - add all its nbrs */
        for (n = 0 ; n < v->vnum ; n++)
        {
          vn = &mris->vertices[v->v[n]] ;
          if (vn->marked)   /* already in defect or convex hull */
          {
            continue ;
          }
          chull[defect->nchull+nfound++] = v->v[n] ;
          vn->marked = 1 ;
        }
      }
    }
    defect->nchull += nfound ;
  }
  while (nfound > 0) ;

  MRISclearMarks(mris) ;

  defect->chull = (int *)calloc(defect->nchull, sizeof(int)) ;
  if (!defect->chull)
    ErrorExit(ERROR_NO_MEMORY,
              "mrisFindConvexHull: could not allocate %d vlist\n",
              defect->nchull) ;
  memmove(defect->chull, chull, defect->nchull*sizeof(int)) ;

  return(NO_ERROR) ;
#endif
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisCheckSurface(MRI_SURFACE *mris)
{
  int     vno, n, nfaces, m, vno2, nbad, flist[100] ;
  VERTEX  *v ;

  /*  fprintf(stdout, "\n") ;*/
  for (nbad = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (n = 0 ; n < v->vnum ; n++)
    {
      vno2 = v->v[n] ;
      if (vno2 < vno)
      {
        continue ;
      }
      for (nfaces = m = 0 ; m < v->vnum ; m++)
      {
        if (v->v[m] == vno2)
        {
          continue ;
        }
        if (vertexNeighbor(mris, vno2, v->v[m]) &&
            isFace(mris,vno, vno2, v->v[m]))
        {
          flist[nfaces] = findFace(mris, vno, vno2, v->v[m]) ;
          nfaces++ ;
        }
      }
      if (nfaces != 2)
      {
        int i ;

        nbad++ ;
        fprintf(stdout, "edge %d <--> %d has %d face(s)! ",
                vno, vno2, nfaces) ;
        fprintf(stdout, "(") ;
        for (i = 0 ; i < nfaces ; i++)
        {
          fprintf(stdout, "%d%s", flist[i], i < nfaces-1 ? "," : "") ;
        }
        fprintf(stdout, ")\n") ;
        fprintf(stdout,"%d %d %d !!!\n",
                mris->faces[flist[0]].v[0],
                mris->faces[flist[0]].v[1],
                mris->faces[flist[0]].v[2]);
        mrisDumpDefectiveEdge(mris, vno, vno2) ;
        DiagBreak() ;
      }
    }
  }
  fprintf(stdout, "%d defective edges\n", nbad) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisMarkBadEdgeVertices(MRI_SURFACE *mris, int mark)
{
  int     vno, n, nfaces, m, vno2, nmarked ;
  VERTEX  *v ;

  for (nmarked = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (n = 0 ; n < v->vnum ; n++)
    {
      vno2 = v->v[n] ;
      if (vno2 < vno)
      {
        continue ;
      }
      for (nfaces = m = 0 ; m < v->vnum ; m++)
      {
        if (v->v[m] == vno2)
        {
          continue ;
        }
        if (vertexNeighbor(mris, vno2, v->v[m]) &&
            isFace(mris,vno, vno2, v->v[m]))
        {
          nfaces++ ;
        }
      }
      if (nfaces != 2)
      {
        v->marked = mark ;
        mris->vertices[vno2].marked = mark ;
        nmarked += 2 ;
        break ;
      }
    }
  }
  return(nmarked) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISdilateMarked(MRI_SURFACE *mris, int ndil)
{
  int    vno, i, n, mx ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < ndil ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->tx = 0 ;
    }

    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      mx =  v->marked ;
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        mx = MAX(vn->marked, mx) ;
      }
      v->tx = mx ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->marked = (int)v->tx ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISdilateRipped(MRI_SURFACE *mris, int ndil)
{
  int    vno, i, n ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < ndil ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      v->tx = v->ripflag ;
    }

    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag == 0)
      {
        continue ;
      }

      // turn on ripflag of all neighbors of this (ripped) vertex
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        if (vn->ripflag == 0)
        {
          vn->tx = 1 ;
        }
      }
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      v->ripflag = (int)v->tx ;
    }
  }
  MRISripFaces(mris);
  return(NO_ERROR) ;
}
/*---------------------------------------------------------------------
  MRI *MRISdilateConfined() - dilates surface mask niters iterations.
  If annotidmask >= 0, then dilation is confined to the annotidmask
  annotation. If newid >= 0, then the surface annot field of vertices
  in the dilated mask is set to the annot corresponding to newid.
  -------------------------------------------------------------------*/
MRI *MRISdilateConfined(MRIS *surf, MRI *mask, int annotidmask, int niters, int newid)
{
  int vtxno, annot, annotid, nnbrs, nbrvtxno, nthnbr, nthiter,new_annot ;
  VERTEX *vtx;
  MRI *mri1, *mri2;
  float val;

  mri1 = MRIcopy(mask,NULL);
  mri2 = MRIcopy(mask,NULL);

  for(nthiter = 0; nthiter < niters; nthiter++)
  {
    //printf("iter %d\n",nthiter);

    for (vtxno = 0; vtxno < surf->nvertices; vtxno++)
    {
      vtx = &(surf->vertices[vtxno]);

      /* Set to 0 if not in annotidmask (ie, dont dilate outside
      of annotidmask (if it is set) */
      if(annotidmask > -1)
      {
        annot = surf->vertices[vtxno].annotation;
        CTABfindAnnotation(surf->ct, annot, &annotid);
        if(annotid != annotidmask)
        {
          MRIsetVoxVal(mri2,vtxno,0,0,0,0);
          continue;
        }
      }

      // Check whether this vertex has been set
      val = MRIgetVoxVal(mri1,vtxno,0,0,0);
      if(val)
      {
        MRIsetVoxVal(mri2,vtxno,0,0,0,1);
        continue;
      }

      // If it gets here, the vtx is in the annot and has not been set
      nnbrs = surf->vertices[vtxno].vnum;
      for (nthnbr = 0; nthnbr < nnbrs; nthnbr++)
      {
        nbrvtxno = surf->vertices[vtxno].v[nthnbr];
        if (surf->vertices[nbrvtxno].ripflag)
        {
          continue;  //skip ripped vtxs
        }
        val = MRIgetVoxVal(mri1,nbrvtxno,0,0,0);
        if(val)
        {
          MRIsetVoxVal(mri2,vtxno,0,0,0,1);
          continue;
        }
      }
    }
    MRIcopy(mri2,mri1);

  }

  MRIfree(&mri2);
  //MRIwrite(mri1,"mymask2.mgh");

  if(newid > 0)
  {
    // Set annots in this mask to the given annot
    CTABannotationAtIndex(surf->ct, newid, &new_annot) ;
    for (vtxno = 0; vtxno < surf->nvertices; vtxno++)
    {
      if(MRIgetVoxVal(mri1,vtxno,0,0,0))
      {
        surf->vertices[vtxno].annotation = new_annot;
      }
    }
  }

  return(mri1);
}
/*-------------------------------------------------------------
  MRI *MRISfbirnMask_SFG_Cing(MRIS *surf) - creates a mask in the
  SFG where it borders CAcing, PAcing, and RAcing.
  -------------------------------------------------------------*/
MRI *MRISfbirnMask_SFG_Cing(MRIS *surf)
{
  int vtxno, annot, annotid, nnbrs, nbrvtx, nthnbr, nbrannotid;
  VERTEX *vtx;
  int superiorfrontal, posteriorcingulate;
  int caudalanteriorcingulate, rostralanteriorcingulate;
  MRI *mri;

  superiorfrontal = 28;
  posteriorcingulate = 23;
  caudalanteriorcingulate = 2;
  rostralanteriorcingulate = 26;

  mri = MRIalloc(surf->nvertices, 1, 1, MRI_INT) ;

  for (vtxno = 0; vtxno < surf->nvertices; vtxno++)
  {
    MRIsetVoxVal(mri,vtxno,0,0,0, 0);

    vtx = &(surf->vertices[vtxno]);
    annot = surf->vertices[vtxno].annotation;
    CTABfindAnnotation(surf->ct, annot, &annotid);

    // Skip if not one of the target areas
    if(annotid != superiorfrontal &&
        annotid != posteriorcingulate &&
        annotid != caudalanteriorcingulate &&
        annotid != rostralanteriorcingulate)
    {
      continue;
    }

    nnbrs = surf->vertices[vtxno].vnum;
    for (nthnbr = 0; nthnbr < nnbrs; nthnbr++)
    {
      nbrvtx = surf->vertices[vtxno].v[nthnbr];
      if (surf->vertices[nbrvtx].ripflag)
      {
        continue;  //skip ripped vtxs
      }
      annot = surf->vertices[nbrvtx].annotation;
      CTABfindAnnotation(surf->ct, annot, &nbrannotid);
      if(annotid == superiorfrontal &&
          (nbrannotid == posteriorcingulate ||
           nbrannotid == caudalanteriorcingulate ||
           nbrannotid == rostralanteriorcingulate) )
      {
        MRIsetVoxVal(mri,vtxno,0,0,0,1);
      }
    }
  }
  return(mri);
}

/*-------------------------------------------------------------
  MRI *MRISfbirnMask_MOF_RACing(MRIS *surf) - creates a mask at the intersection
  Meidal Orbital Frontal and RA Cingulate
  -------------------------------------------------------------*/
MRI *MRISfbirnMask_MOF_RACing(MRIS *surf)
{
  int vtxno, annot, annotid, nnbrs, nbrvtx, nthnbr, nbrannotid;
  VERTEX *vtx;
  int medialorbitofrontal, rostralanteriorcingulate;
  MRI *mri;

  CTABfindName(surf->ct, "medialorbitofrontal", &medialorbitofrontal);
  CTABfindName(surf->ct, "rostralanteriorcingulate", &rostralanteriorcingulate);

  printf("medialorbitofrontal %d\n",medialorbitofrontal);
  printf("rostralanteriorcingulate %d\n",rostralanteriorcingulate);

  mri = MRIalloc(surf->nvertices, 1, 1, MRI_INT) ;

  for (vtxno = 0; vtxno < surf->nvertices; vtxno++)
  {
    MRIsetVoxVal(mri,vtxno,0,0,0, 0);

    vtx = &(surf->vertices[vtxno]);
    annot = surf->vertices[vtxno].annotation;
    CTABfindAnnotation(surf->ct, annot, &annotid);

    if(annotid != medialorbitofrontal)
    {
      continue;
    }

    nnbrs = surf->vertices[vtxno].vnum;
    for (nthnbr = 0; nthnbr < nnbrs; nthnbr++)
    {

      nbrvtx = surf->vertices[vtxno].v[nthnbr];
      if (surf->vertices[nbrvtx].ripflag)
      {
        continue;  //skip ripped vtxs
      }

      annot = surf->vertices[nbrvtx].annotation;
      CTABfindAnnotation(surf->ct, annot, &nbrannotid);
      if(nbrannotid == rostralanteriorcingulate)
      {
        MRIsetVoxVal(mri,vtxno,0,0,0,1);
      }

    }
  }
  return(mri);
}

/*-----------------------------------------------------
  Parameters:
  Returns value:
  Description
  ------------------------------------------------------*/
int MRISerodeRipped(MRI_SURFACE *mris, int ndil)
{
  int    vno, i, n, mn ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < ndil ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      v->tx = 0 ;
    }

    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      mn =  v->ripflag ;
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        mn = MIN(vn->ripflag, mn) ;
      }
      v->tx = mn ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      v->ripflag = (int)v->tx ;
    }
  }
  MRISripFaces(mris);
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISerodeMarked(MRI_SURFACE *mris, int num)
{
  int    vno, i, n, mn ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < num ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->tx = 0 ;
    }

    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      mn =  v->marked ;
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        mn = MIN(vn->marked, mn) ;
      }
      v->tx = mn ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->marked = (int)v->tx ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScloseMarked(MRI_SURFACE *mris, int order)
{
  MRISdilateMarked(mris, order) ;
  MRISerodeMarked(mris, order) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISopenMarked(MRI_SURFACE *mris, int order)
{
  MRISerodeMarked(mris, order) ;
  MRISdilateMarked(mris, order) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisDumpDefectiveEdge(MRI_SURFACE *mris, int vno1, int vno2)
{
#if 0
  FILE   *fp ;
  char   fname[STRLEN] ;
  int    n, m, fno, first = 1 ;
  VERTEX *v1, *v2, *vn ;
  double origin[3], e0[3], e1[3], cx, cy, cz, x, y ;
  FACE   *f ;

  sprintf(fname, "edge%d_%d.log", vno1, vno2) ;
  fp = fopen(fname, "w") ;


  v1 = &mris->vertices[vno1] ;
  v2 = &mris->vertices[vno2] ;
  for (n = 0 ; n < v1->vnum ; n++)
  {
    if (v1->v[n] == vno2)
    {
      continue ;
    }
    fno = findFace(mris, vno1, vno2, v1->v[n]) ;
    if ((fno >= 0) && vertexNeighbor(mris, vno2, v1->v[n]))
    {
      f = &mris->faces[fno] ;
      if (first)
      {
        mrisComputeCanonicalBasis(mris, fno, origin, e0, e1) ;
        first = 0 ;
      }
      fprintf(fp, "# triangle %d\n", fno) ;
      for (m = 0 ; m < VERTICES_PER_FACE ; m++)
      {
        vn = &mris->vertices[f->v[m]] ;
        cx = vn->cx-origin[0];
        cy = vn->cy-origin[1];
        cz = vn->cz-origin[2];
        x = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
        y = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
        fprintf(fp, "# vertex %d\n", f->v[m]) ;
        fprintf(fp, "%f %f\n", x, y) ;
      }
      vn = &mris->vertices[f->v[0]] ;
      cx = vn->cx-origin[0];
      cy = vn->cy-origin[1];
      cz = vn->cz-origin[2];
      x = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
      y = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
      fprintf(fp, "#%d\n", f->v[0]) ;
      fprintf(fp, "%f %f\n", x, y) ;
      fprintf(fp, "\n") ;
    }
  }
  cx = v1->cx-origin[0];
  cy = v1->cy-origin[1];
  cz = v1->cz-origin[2];
  x = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
  y = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
  fprintf(fp, "%f %f\n", x, y) ;
  cx = v2->cx-origin[0];
  cy = v2->cy-origin[1];
  cz = v2->cz-origin[2];
  x = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
  y = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
  fprintf(fp, "%f %f\n", x, y) ;
  fclose(fp) ;
#endif
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
#if 0
static int
mrisDumpTriangle(MRI_SURFACE *mris, int fno)
{
  char   fname[STRLEN] ;
  VERTEX *v0, *v1, *v2 ;
  FACE   *f ;
  FILE   *fp ;
  double cx, cy, cz, x, y, origin[3], e0[3], e1[3] ;

  mrisComputeCanonicalBasis(mris, fno, origin, e0, e1) ;
  f = &mris->faces[fno] ;
  sprintf(fname, "triangle%d.log", fno) ;
  fp = fopen(fname, "w") ;

  v0 = &mris->vertices[f->v[0]] ;
  v1 = &mris->vertices[f->v[1]] ;
  v2 = &mris->vertices[f->v[2]] ;
  fprintf(fp, "# triangle %d, vertices %d, %d, %d\n",
          fno, f->v[0], f->v[1], f->v[2]) ;

  cx = v0->cx-origin[0];
  cy = v0->cy-origin[1];
  cz = v0->cz-origin[2];
  x = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
  y = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
  fprintf(fp, "%f  %f\n", x, y) ;
  cx = v1->cx-origin[0];
  cy = v1->cy-origin[1];
  cz = v1->cz-origin[2];
  x = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
  y = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
  fprintf(fp, "%f  %f\n", x, y) ;
  cx = v2->cx-origin[0];
  cy = v2->cy-origin[1];
  cz = v2->cz-origin[2];
  x = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
  y = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
  fprintf(fp, "%f  %f\n", x, y) ;
  cx = v0->cx-origin[0];
  cy = v0->cy-origin[1];
  cz = v0->cz-origin[2];
  x = cx*e0[0] + cy*e0[1] + cz*e0[2] ;
  y = cx*e1[0] + cy*e1[1] + cz*e1[2] ;
  fprintf(fp, "%f  %f\n", x, y) ;

  fclose(fp) ;
  return(NO_ERROR) ;
}
#endif
static int
mrisDefectRemoveNegativeVertices(MRI_SURFACE *mris, DEFECT *defect)
{
  int    i, n ;
  VERTEX *v ;

  for (i = 0 ; i < defect->nvertices ; i++)
  {
    if (defect->status[i] == DISCARD_VERTEX)
    {
      continue ;
    }
    v = &mris->vertices[defect->vertices[i]] ;
    for (n = 0 ; n < v->num ; n++)
      if (mris->faces[v->f[n]].area < 0.0)
      {
        defect->status[i] = DISCARD_VERTEX ;
      }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisDefectRemoveDegenerateVertices(MRI_SURFACE *mris, float min_sphere_dist,
                                   DEFECT *defect)
{
  float  dx, dy, dz, dist ;
  int    i, j ;
  VERTEX *v, *vn ;

  /* discard vertices that are too close to another vertex on sphere */
  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    if (i < defect->nvertices)
    {
      if (defect->status[i] == DISCARD_VERTEX)
      {
        continue ;
      }
      v = &mris->vertices[defect->vertices[i]] ;
      if (defect->vertices[i] == Gdiag_no)
      {
        DiagBreak() ;
      }
    }
    else
    {
      v = &mris->vertices[defect->border[i-defect->nvertices]] ;
      if (defect->border[i-defect->nvertices] == Gdiag_no)
      {
        DiagBreak() ;
      }
    }
    for (j = i+1 ; j < defect->nvertices ; j++)
    {
      if (defect->status[j] == DISCARD_VERTEX)
      {
        continue ;
      }
      vn = &mris->vertices[defect->vertices[j]] ;
      dx = vn->cx-v->cx ;
      dy = vn->cy-v->cy ;
      dz = vn->cz-v->cz ;
      dist = (dx*dx+dy*dy+dz*dz) ;  /* no sqrt */
      if (dist < min_sphere_dist)
      {
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
          fprintf(stdout, "discarding proximal vertex %d\n",
                  defect->vertices[j]);
        defect->status[j] = DISCARD_VERTEX ;
      }
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisDefectRemoveProximalVertices(MRI_SURFACE *mris, float min_orig_dist,
                                 DEFECT *defect)
{
  float  dx, dy, dz, dist ;
  int    i, j ;
  VERTEX *v, *vn ;

  /* discard vertices that are too close to another vertex on sphere */
  for (i = 0 ; i < defect->nvertices+defect->nborder ; i++)
  {
    if (i < defect->nvertices)
    {
      if (defect->status[i] == DISCARD_VERTEX)
      {
        continue ;
      }
      v = &mris->vertices[defect->vertices[i]] ;
      if (defect->vertices[i] == Gdiag_no)
      {
        DiagBreak() ;
      }
    }
    else
    {
      v = &mris->vertices[defect->border[i-defect->nvertices]] ;
      if (defect->border[i-defect->nvertices] == Gdiag_no)
      {
        DiagBreak() ;
      }
    }

    for (j = i+1 ; j < defect->nvertices ; j++)
    {
      if (defect->status[j] == DISCARD_VERTEX)
      {
        continue ;
      }
      vn = &mris->vertices[defect->vertices[j]] ;
      dx = vn->origx-v->origx ;
      dy = vn->origy-v->origy ;
      dz = vn->origz-v->origz ;
      dist = (dx*dx+dy*dy+dz*dz) ;  /* no sqrt */
      if (dist < min_orig_dist)
      {
        if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
          fprintf(stdout, "discarding proximal vertex %d\n",
                  defect->vertices[j]);
        defect->status[j] = DISCARD_VERTEX ;
      }
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  ------------------------------------------------------*/
static int
mrisInitializeNeighborhood(MRI_SURFACE *mris, int vno)
{
  VERTEX  *v, *vnb, *vnb2 ;
  int     vtmp[MAX_NEIGHBORS], vnum, i, j, n, neighbors, nsize ;

  v = &mris->vertices[vno] ;
  if (vno == Gdiag_no)
  {
    DiagBreak()  ;
  }

  v->nsize = mris->nsize ;
  if (v->ripflag || !v->vnum)
  {
    return(ERROR_BADPARM) ;
  }
  memmove(vtmp, v->v, v->vnum*sizeof(int)) ;

  /* mark 1-neighbors so we don't count them twice */
  v->marked = 1 ;

  vnum = neighbors = v->vnum ;
  for (nsize = 2 ; nsize <= v->nsize ; nsize++)
  {
    /* mark all current neighbors */
    vnum = neighbors ;  /* neighbors will be incremented during loop */
    for (i = 0 ; i < neighbors ; i++)
    {
      mris->vertices[vtmp[i]].marked = 1 ;
    }
    for (i = 0; neighbors < MAX_NEIGHBORS && i < vnum; i++)
    {
      n = vtmp[i] ;
      vnb = &mris->vertices[n] ;
      if (vnb->ripflag)
      {
        continue ;
      }

      for (j = 0 ; j < vnb->vnum ; j++)
      {
        vnb2 = &mris->vertices[vnb->v[j]] ;
        if (vnb2->ripflag || vnb2->marked)
        {
          continue ;
        }
        vtmp[neighbors] = vnb->v[j] ;
        vnb2->marked = 1 ;
        if (++neighbors >= MAX_NEIGHBORS)
        {
          fprintf(stdout, "vertex %d has too many neighbors!\n",vno) ;
          break ;
        }
      }
    }
  }
  /*
    now reallocate the v->v structure and place the 2-connected neighbors
    suquentially after the 1-connected neighbors.
  */
  free(v->v) ;
  v->v = (int *)calloc(neighbors, sizeof(int)) ;
  if (!v->v)
    ErrorExit(ERROR_NO_MEMORY,
              "MRISsetNeighborhoodSize: could not allocate list of %d "
              "nbrs at v=%d", neighbors, vno) ;

  v->marked = 0 ;
  for (n = 0 ; n < neighbors ; n++)
  {
    v->v[n] = vtmp[n] ;
    mris->vertices[vtmp[n]].marked = 0 ;
  }
  if (v->dist)
  {
    free(v->dist) ;
  }
  if (v->dist_orig)
  {
    free(v->dist_orig) ;
  }

  v->dist = (float *)calloc(neighbors, sizeof(float)) ;
  if (!v->dist)
    ErrorExit(ERROR_NOMEMORY,
              "MRISsetNeighborhoodSize: could not allocate list of %d "
              "dists at v=%d", neighbors, vno) ;
  v->dist_orig = (float *)calloc(neighbors, sizeof(float)) ;
  if (!v->dist_orig)
    ErrorExit(ERROR_NOMEMORY,
              "MRISsetNeighborhoodSize: could not allocate list of %d "
              "dists at v=%d", neighbors, vno) ;
  switch (v->nsize)
  {
  case 2:
    v->v2num = neighbors ;
    break ;
  case 3:
    v->v3num = neighbors ;
    break ;
  default:   /* store old neighborhood size in v3num */
    v->v3num = v->vtotal ;
    break ;
  }
  v->vtotal = neighbors ;
  for (n = 0 ; n < neighbors ; n++)
    for (i = 0 ; i < neighbors ; i++)
      if (i != n && v->v[i] == v->v[n])
        fprintf(stdout,
                "warning: vertex %d has duplicate neighbors %d and %d!\n",
                vno, i, n) ;
  if ((vno == Gdiag_no) && (Gdiag & DIAG_SHOW) && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "v %d: vnum=%d, v2num=%d, vtotal=%d\n",
            vno, v->vnum, v->v2num, v->vtotal) ;
    for (n = 0 ; n < neighbors ; n++)
    {
      fprintf(stdout, "v[%d] = %d\n", n, v->v[n]) ;
    }
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISmarkNegativeVertices(MRI_SURFACE *mris, int mark)
{
  int    fno, n ;
  FACE   *f ;

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    if (f->area < 0)
      for (n = 0 ; n < VERTICES_PER_FACE ; n++)
      {
        mris->vertices[f->v[n]].marked = mark ;
      }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISripNegativeVertices(MRI_SURFACE *mris)
{
  int    fno, n ;
  FACE   *f ;

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    if (f->area < 0)
    {
      for (n = 0 ; n < VERTICES_PER_FACE ; n++)
      {
        mris->vertices[f->v[n]].ripflag = 1 ;
      }
      f->ripflag = 1 ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
double
MRIScomputeAverageCurvature(MRI_SURFACE *mris, double *psigma)
{
  double mean, var, total, total_sq, nv, d;
  int    vno ;
  VERTEX *v ;

  for (vno = 0, nv = total_sq = total = 0.0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    d = (double)v->curv ;
    total_sq += d*d ;
    total += d ;
    nv += 1.0 ;
  }
  if (nv)
  {
    mean = total / nv ;
    var = total_sq / nv - (mean*mean) ;
  }
  else
  {
    var = mean = 0.0 ;
  }
  if (psigma)
  {
    *psigma = sqrt(var) ;
  }
  return(mean) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyValToVal2(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val2 = v->val ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyValuesToVal2Bak(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val2bak = v->val ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyValToValBak(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->valbak = v->val ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScopyValToVal2Bak(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val2bak = v->val ;
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------

Parameters:

Returns value:

Description
------------------------------------------------------*/
int
MRISsqrtVal(MRI_SURFACE *mris)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (v->val > 0)
    {
      v->val = sqrt(v->val) ;
    }
  }
  return(NO_ERROR) ;
}
/*-----------------------------------------------------

Parameters:

Returns value:

Description
------------------------------------------------------*/
int
MRISmulVal(MRI_SURFACE *mris, float mul)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val *= mul ;
  }
  return(NO_ERROR) ;
}


SMALL_SURFACE *
MRISreadVerticesOnly(char *fname)
{
  SMALL_SURFACE *mriss = NULL ;
  int           type, magic, version, ix, iy, iz, nquads, nvertices, vno ;
  SMALL_VERTEX  *vertex ;
  FILE          *fp ;

  type = MRISfileNameType(fname) ;
  switch (type)
  {
  case MRIS_ASCII_TRIANGLE_FILE:
  case MRIS_ICO_FILE:
  case MRIS_GEO_TRIANGLE_FILE:
    ErrorReturn(NULL,
                (ERROR_UNSUPPORTED,
                 "MRISreadVerticesOnly: file type %d not supported",type)) ;
    break ;  /* not used */
  default:
    break ;
  }

  fp = fopen(fname, "rb") ;
  if (!fp)
    ErrorReturn(NULL,(ERROR_NOFILE,"MRISread(%s): could not open file",
                      fname));

  fread3(&magic, fp) ;
  if (magic == QUAD_FILE_MAGIC_NUMBER)
  {
    version = -1;
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    {
      fprintf(stdout, "new surface file format\n");
    }
  }
  else if (magic == NEW_QUAD_FILE_MAGIC_NUMBER)
  {
    version = -2 ;
  }
  else if (magic == TRIANGLE_FILE_MAGIC_NUMBER)
  {
    fclose(fp) ;
    mriss = mrisReadTriangleFileVertexPositionsOnly(fname) ;
    if (!mriss)
    {
      ErrorReturn(NULL, (Gerror, "mrisReadTriangleFile failed.\n")) ;
    }
    version = -3 ;
  }
  else
  {
    rewind(fp);
    version = 0;
    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    {
      printf("surfer: old surface file format\n");
    }
  }
  if (version >= -2)  /* some type of quadrangle file */
  {
    fread3(&nvertices, fp);
    fread3(&nquads, fp);   /* # of qaudrangles - not triangles */

    if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
      fprintf(stdout,"reading %d vertices and %d faces.\n",
              nvertices,2*nquads);

    mriss = (SMALL_SURFACE *)calloc(1, sizeof(SMALL_SURFACE)) ;
    if (!mriss)
      ErrorReturn(NULL,
                  (ERROR_NOMEMORY,
                   "MRISreadVerticesOnly: could not allocate surface")) ;

    mriss->nvertices = nvertices ;
    mriss->vertices =
      (SMALL_VERTEX *)calloc(nvertices, sizeof(SMALL_VERTEX)) ;
    if (!mriss->nvertices)
    {
      free(mriss) ;
      ErrorReturn(NULL,
                  (ERROR_NOMEMORY,
                   "MRISreadVerticesOnly: could not allocate surface")) ;
    }
    for (vno = 0 ; vno < nvertices ; vno++)
    {
      vertex = &mriss->vertices[vno] ;
      if (version == -1)
      {
        fread2(&ix,fp);
        fread2(&iy,fp);
        fread2(&iz,fp);
        vertex->x = ix/100.0;
        vertex->y = iy/100.0;
        vertex->z = iz/100.0;
      }
      else  /* version == -2 */
      {
        vertex->x = freadFloat(fp) ;
        vertex->y = freadFloat(fp) ;
        vertex->z = freadFloat(fp) ;
      }
    }
  }

  return(mriss) ;
}
int
MRISSfree(SMALL_SURFACE **pmriss)
{
  SMALL_SURFACE *mriss ;

  mriss = *pmriss ;
  *pmriss = NULL ;
  free(mriss->vertices) ;
  free(mriss) ;
  return(NO_ERROR) ;
}
int
MRISextractCurvatureVector(MRI_SURFACE *mris, float *curvs)
{
  int     vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    curvs[vno] = mris->vertices[vno].curv ;
  }

  return(NO_ERROR) ;
}
int
MRISextractCurvatureVectorDouble(MRI_SURFACE *mris, double *curvs, int offset)
{
  int     vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    curvs[vno+offset] = (double)mris->vertices[vno].curv ;
  }

  return(NO_ERROR) ;
}
int
MRISextractCurvatureDoubleVector(MRI_SURFACE *mris, double *curvs)
{
  int     vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    curvs[vno] = (double)mris->vertices[vno].curv ;
  }

  return(NO_ERROR) ;
}
int
MRISimportCurvatureVector(MRI_SURFACE *mris, float *curvs)
{
  int     vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].curv = curvs[vno] ;
  }

  return(NO_ERROR) ;
}

int
MRISimportValVector(MRI_SURFACE *mris, float *vals)
{
  int     vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].val = vals[vno] ;
  }

  return(NO_ERROR) ;
}
int
MRISimportValFromMatrixColumn(MRI_SURFACE *mris, MATRIX *m, int col)
{
  int     vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].val = *MATRIX_RELT(m, vno+1, col) ;
  }

  return(NO_ERROR) ;
}
int
MRISexportValVector(MRI_SURFACE *mris, float *vals)
{
  int     vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vals[vno] = mris->vertices[vno].val ;
  }

  return(NO_ERROR) ;
}
int
MRISexportValVectorDouble(MRI_SURFACE *mris, double *vals, int offset)
{
  int     vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vals[vno+offset] = (double)mris->vertices[vno].val ;
  }

  return(NO_ERROR) ;
}
int
MRISmaskLabel(MRI_SURFACE *mris, LABEL *area)
{
  int     i ;
  VERTEX  *v ;

  for (i = 0 ; i < area->n_points ; i++)
  {
    v = &mris->vertices[area->lv[i].vno] ;
    v->curv = v->stat = v->val =
                          v->imag_val=v->val2=v->valbak=v->val2bak = 0.0;
  }
  return(NO_ERROR) ;
}
int
MRISmaskNotLabel(MRI_SURFACE *mris, LABEL *area)
{
  int     i, vno ;
  VERTEX  *v ;

  for (i = 0 ; i < area->n_points ; i++)
  {
    v = &mris->vertices[area->lv[i].vno] ;
    v->marked = 1 ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked)
    {
      continue ;
    }
    v->curv = v->stat = v->val =
                          v->imag_val=v->val2=v->valbak=v->val2bak = 0.0;
  }
  for (i = 0 ; i < area->n_points ; i++)
  {
    v = &mris->vertices[area->lv[i].vno] ;
    v->marked = 0 ;
  }
  return(NO_ERROR) ;
}
int
MRISripLabel(MRI_SURFACE *mris, LABEL *area)
{
  int     i ;
  VERTEX  *v ;

  for (i = 0 ; i < area->n_points ; i++)
  {
    v = &mris->vertices[area->lv[i].vno] ;
    v->ripflag = 1 ;
  }
  return(NO_ERROR) ;
}
int
MRISripNotLabel(MRI_SURFACE *mris, LABEL *area)
{
  int     i, vno ;
  VERTEX  *v ;

  for (i = 0 ; i < area->n_points ; i++)
  {
    v = &mris->vertices[area->lv[i].vno] ;
    v->marked = 1 ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked)
    {
      continue ;
    }
    v->ripflag = 1 ;
  }
  for (i = 0 ; i < area->n_points ; i++)
  {
    v = &mris->vertices[area->lv[i].vno] ;
    v->marked = 0 ;
  }
  return(NO_ERROR) ;
}
int
MRISinvertMarks(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->marked = !v->marked ;
  }
  return(NO_ERROR) ;
}

int
MRISsegmentMarked(MRI_SURFACE *mris, LABEL ***plabel_array, int *pnlabels,
                  float min_label_area)
{
  int     vno, nfound, n, nlabels, *marks ;
  VERTEX  *v ;
  LABEL   *area = NULL, **tmp, **label_array ;

  marks = (int *)calloc(mris->nvertices, sizeof(int)) ;
  label_array = (LABEL **)calloc(mris->nvertices, sizeof(LABEL *)) ;
  if (!label_array || !marks)
    ErrorExit(ERROR_NOMEMORY,
              "%s: MRISsegmentMarked could not allocate tmp storage",
              Progname) ;

  /* save current marks */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    marks[vno] = v->marked ;
    if (v->marked != 0)
    {
      v->marked = 1 ;
    }
  }

  nlabels = 0 ;
  do
  {
    nfound = 0 ;

    v = &mris->vertices[0] ;

    /* find a marked vertex */
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked != 1)
      {
        continue ;
      }
      break ;
    }
    if (vno < mris->nvertices)
    {
      area = LabelAlloc(mris->nvertices, NULL, NULL) ;
      area->n_points = 1 ;
      area->lv[0].x = v->x ;
      area->lv[0].y = v->y ;
      area->lv[0].z = v->z ;
      area->lv[0].vno = vno ;
      LabelFillMarked(area, mris) ;
      if (LabelArea(area, mris) >= min_label_area)
      {
        label_array[nlabels++] = LabelCopy(area, NULL) ;
      }
      LabelFree(&area) ;
      nfound = 1 ;
    }
    else
    {
      nfound = 0 ;
    }

  }
  while (nfound > 0) ;

  /* restore original marks */
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->marked = marks[vno] ;
  }

  free(marks) ;

  /* crunch label array down to a reasonable size */
  tmp = label_array ;
  label_array = (LABEL **)calloc(mris->nvertices, sizeof(LABEL *)) ;
  if (!label_array)
    ErrorExit(ERROR_NOMEMORY,
              "%s: MRISsegmentMarked could not allocate tmp storage",
              Progname) ;
  for (n = 0 ; n < nlabels ; n++)
  {
    label_array[n] = tmp[n] ;
  }
  free(tmp) ;
  *plabel_array = label_array ;
  *pnlabels = nlabels ;
  return(NO_ERROR) ;
}

int
MRISsegmentAnnotated(MRI_SURFACE *mris, LABEL ***plabel_array, int *pnlabels,
                     float min_label_area)
{
  int     vno, nfound, n, nlabels, last_vno ;
  VERTEX  *v ;
  LABEL   *area = NULL, **tmp, **label_array ;

  label_array = (LABEL **)calloc(mris->nvertices, sizeof(LABEL *)) ;
  if (!label_array)
    ErrorExit(ERROR_NOMEMORY,
              "%s: MRISsegmentAnnotated could not allocate tmp storage",
              Progname) ;

  MRISclearMarks(mris) ;

  nlabels = 0 ;
  last_vno = -1 ;
  do
  {
    nfound = 0 ;

    v = &mris->vertices[0] ;

    /* find an un-marked vertex */
    for (vno = last_vno+1 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->annotation == 0 || v->marked)
      {
        continue ;
      }
      break ;
    }
    if (vno < mris->nvertices)
    {
      area = LabelAlloc(mris->nvertices, NULL, NULL) ;
      area->n_points = 1 ;
      area->lv[0].x = v->x ;
      area->lv[0].y = v->y ;
      area->lv[0].z = v->z ;
      area->lv[0].vno = vno ;
      LabelFillAnnotated(area, mris) ;
      if (LabelArea(area, mris) >= min_label_area)
      {
        label_array[nlabels++] = LabelCopy(area, NULL) ;
      }
      LabelMarkSurface(area, mris) ;
      LabelFree(&area) ;
      nfound = 1 ;
      last_vno = vno ;
    }
    else
    {
      nfound = 0 ;
    }

  }
  while (nfound > 0) ;


  /* crunch label array down to a reasonable size */
  tmp = label_array ;
  label_array = (LABEL **)calloc(mris->nvertices, sizeof(LABEL *)) ;
  if (!label_array)
    ErrorExit(ERROR_NOMEMORY,
              "%s: MRISsegmentAnnotated could not allocate tmp storage",
              Progname) ;
  for (n = 0 ; n < nlabels ; n++)
  {
    label_array[n] = tmp[n] ;
  }
  free(tmp) ;
  *plabel_array = label_array ;
  *pnlabels = nlabels ;
  return(NO_ERROR) ;
}

int
MRISsubsampleDist(MRI_SURFACE *mris, float spacing)
{
  int k,m,n, sub_num;
  VERTEX *v;


  sub_num = 0;
  for (k=0; k<mris->nvertices; k++)
  {
    v = &mris->vertices[k];
    v->d = 10000;
    v->val = 0;
  }
  for (k=0; k<mris->nvertices; k++)
  {
    v = &mris->vertices[k];
    for (m=0; m<v->vnum; m++)
    {
      if (mris->vertices[v->v[m]].d+1 < v->d)
      {
        v->d = mris->vertices[v->v[m]].d+1;
      }
    }
    if (v->d>=spacing)
    {
      v->d = 0;
      v->val = 1;
      sub_num++;
    }
    for (m=0; m<v->vnum; m++)
    {
      if (mris->vertices[v->v[m]].d > v->d+1)
      {
        mris->vertices[v->v[m]].d = v->d+1;
      }
    }
  }
  for (k=mris->nvertices-1; k>=0; k--)
  {
    v = &mris->vertices[k];
    for (m=0; m<v->vnum; m++)
    {
      if (mris->vertices[v->v[m]].d+1 < v->d)
      {
        v->d = mris->vertices[v->v[m]].d+1;
      }
      if (mris->vertices[v->v[m]].d > v->d+1)
      {
        mris->vertices[v->v[m]].d = v->d+1;
      }
    }
  }

  if (spacing==2)
    for (k=0; k<mris->nvertices; k++)
      if (mris->vertices[k].d > 0)
      {
        v = &mris->vertices[k];
        n = 0;
        for (m=0; m<v->vnum; m++)
        {
          if (mris->vertices[v->v[m]].d == 0)
          {
            n++;
          }
        }
        if (n <= 2)
        {
          v->d = 0;
          v->val = 1;
          v->fixedval = TRUE;
          sub_num++;
        }
        for (m=0; m<v->vnum; m++)
        {
          if (mris->vertices[v->v[m]].d > v->d+1)
          {
            mris->vertices[v->v[m]].d = v->d+1;
          }
        }
      }

  return(sub_num) ;
}
int
MRISwriteDecimation(MRI_SURFACE *mris, char *fname)
{
  int k;
  FILE *fptr;

  fptr = fopen(fname,"w");
  if (fptr==NULL)
    ErrorReturn(ERROR_BADFILE,
                (ERROR_BADFILE, "MRISwriteDecimation: could not create %s",
                 fname)) ;
  fputc('\0',fptr);
  fwriteInt(mris->nvertices,fptr);
  for (k=0; k<mris->nvertices; k++)
  {
    if (mris->vertices[k].d==0)
    {
      fputc('\1',fptr);
    }
    else
    {
      fputc('\0',fptr);
    }
  }
  fclose(fptr);
  return(NO_ERROR) ;
}
int
MRISreadDecimation(MRI_SURFACE *mris, char *fname)
{
  int k,d, ndec;
  char c;
  FILE *fptr;


  ndec = 0;
  for (k=0; k<mris->nvertices; k++)
  {
    mris->vertices[k].undefval = TRUE;
    mris->vertices[k].fixedval = FALSE;
  }
  fptr = fopen(fname,"r");
  if (fptr==NULL)
    ErrorReturn(ERROR_BADFILE,
                (ERROR_BADFILE, "MRISreadDecimation: could not create %s",
                 fname)) ;
  c = fgetc(fptr);
  if (c=='#')
  {
    fscanf(fptr,"%*s");
    fscanf(fptr,"%d",&d);
    if (d!=mris->nvertices)
      ErrorReturn(0,
                  (ERROR_BADFILE,
                   "%s: decimation file %s has wrong # of vertices\n",
                   Progname, fname, d)) ;
    for (k=0; k<mris->nvertices; k++)
    {
      fscanf(fptr,"%d",&d);
      if (d!=0)
      {
        mris->vertices[k].d=0;
        mris->vertices[k].fixedval=TRUE;
        mris->vertices[k].undefval=FALSE;
        ndec++;
      }
    }
  }
  else
  {
    d = freadInt(fptr);
    if (d!=mris->nvertices)
      ErrorReturn(0,
                  (ERROR_BADFILE,
                   "%s: decimation file %s has wrong # of vertices\n",
                   Progname, fname, d)) ;
    for (k=0; k<mris->nvertices; k++)
    {
      c = fgetc(fptr);
      if (c!='\0')
      {
        mris->vertices[k].d=0;
        mris->vertices[k].fixedval=TRUE;
        mris->vertices[k].undefval=FALSE;
        ndec++;
      }
    }
  }
  fclose(fptr);
  return(ndec) ;
}

int
MRIScombine(MRI_SURFACE *mris_src, MRI_SURFACE *mris_total,
            MRIS_HASH_TABLE *mht, int which)
{
  int    vno ;
  VERTEX *v, *vdst ;
  MHT    *mht_src = NULL ;
  double max_len, mean ;

  MRISclearMarks(mris_total) ;
  for (vno = 0 ; vno < mris_total->nvertices ; vno++)
  {
    vdst = &mris_total->vertices[vno] ;
    vdst->d = 0 ;
  }

  for (vno = 0 ; vno < mris_src->nvertices ; vno++)
  {
    v = &mris_src->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    vdst = MHTfindClosestVertex(mht, mris_total, v) ;
    if (!vdst)
    {
      ErrorPrintf(ERROR_BADPARM, "MRIScombine: cannot map vno %d", vno) ;
      continue ;
    }
    if (vdst-mris_total->vertices == Gdiag_no)
    {
      DiagBreak() ;
    }
    vdst->marked++ ;
    switch (which)
    {
    case VERTEX_COORDS:
      vdst->origx += v->origx ;
      vdst->origy += v->origy ;
      vdst->origz += v->origz ;
      break ;
    case VERTEX_AREA:
      vdst->d += v->origarea ;
      break ;
    case VERTEX_CURV:
      vdst->d += v->curv ;
      break ;
    case VERTEX_LOGODDS:
    case VERTEX_VALS:
      vdst->d += v->val ;
      break ;
    case VERTEX_ANNOTATION:
      vdst->annotation = v->annotation ;
      break ;
    }
  }

  /* normalize by # of times a vertex is mapped to */
  for (vno = 0 ; vno < mris_total->nvertices ; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    vdst = &mris_total->vertices[vno] ;
    if (vdst->ripflag || !vdst->marked)
    {
      continue ;
    }
    mean = vdst->d / (float)vdst->marked ;
    switch (which)
    {
    case VERTEX_COORDS:
      vdst->origx /= (float)vdst->marked ;
      vdst->origy /= (float)vdst->marked ;
      vdst->origz /= (float)vdst->marked ;
      break ;
    case VERTEX_AREA:  /* don't normalize by # of vertices mapped!! */
      vdst->origarea += vdst->d ;
      vdst->val2 += vdst->d * vdst->d ;
      break ;
    case VERTEX_CURV:
      vdst->curv += mean ;
      vdst->val2 += mean*mean ;
      break ;
    case VERTEX_LOGODDS:
    case VERTEX_VALS:
      vdst->val += mean ;
      vdst->val2 += mean*mean ;
      break ;
    }
  }

  /* sample from dst to source to fill holes */
  for (vno = 0 ; vno < mris_total->nvertices ; vno++)
  {
    vdst = &mris_total->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (vdst->marked || vdst->ripflag)
    {
      continue ;
    }
    if (!mht_src)
    {
      double mean, sigma ;

      mean = MRIScomputeVertexSpacingStats
             (mris_src, &sigma, NULL, &max_len, NULL,NULL, CURRENT_VERTICES);
      if (max_len > mean+3*sigma)
      {
        max_len = mean+3*sigma ;
      }
      mht_src = MHTfillVertexTableRes
                (mris_src, NULL, CURRENT_VERTICES, 2*max_len);
    }
    v = MHTfindClosestVertex(mht_src, mris_src, vdst) ;
    if (!v)
    {
      ErrorPrintf
      (ERROR_BADPARM,
       "MRIScombine: cannot map dst vno %d", vno) ;
      continue ;
    }
    if (v - mris_src->vertices == Gdiag_no)
    {
      DiagBreak() ;
    }
    vdst->marked++ ;
    switch (which)
    {
    case VERTEX_COORDS:
      vdst->origx = v->origx ;
      vdst->origy = v->origy ;
      vdst->origz = v->origz ;
      break ;
    case VERTEX_ANNOTATION:
      vdst->annotation = v->annotation ;
      break ;
    case VERTEX_AREA:
      vdst->origarea += v->origarea ;
      vdst->val2 += (v->origarea*v->origarea) ;
      break ;
    case VERTEX_CURV:
      vdst->curv += v->curv ;
      vdst->val2 += (v->curv*v->curv) ;
      break ;
    case VERTEX_LOGODDS:
    case VERTEX_VALS:
      vdst->val += v->val ;
      vdst->val2 += (v->val*v->val) ;
      break ;
    }
  }
  if (mht_src)
  {
    MHTfree(&mht_src) ;
  }

  return(NO_ERROR) ;
}

#if 1
int
MRISsphericalCopy(MRI_SURFACE *mris_src, MRI_SURFACE *mris_dst,
                  MRIS_HASH_TABLE *mht, int which)
{
  int    vno ;
  VERTEX *v, *vdst ;
  MHT    *mht_src = NULL ;
  double max_len ;

  MRISclear(mris_dst, which) ;
  for (vno = 0 ; vno < mris_dst->nvertices ; vno++)
  {
    vdst = &mris_dst->vertices[vno] ;
    vdst->d = 0 ;
    vdst->val2 = 0 ;
  }

  MRIScomputeVertexSpacingStats(mris_src, NULL, NULL, &max_len, NULL,NULL, CURRENT_VERTICES);
  mht_src = MHTfillVertexTableRes(mris_src, NULL, CURRENT_VERTICES, 2*max_len);

  /* sample from dst to source to fill holes */
  for (vno = 0 ; vno < mris_dst->nvertices ; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    vdst = &mris_dst->vertices[vno] ;
    if (vdst->ripflag)
    {
      continue ;
    }
    v = MHTfindClosestVertex(mht_src, mris_src, vdst) ;
    if (!v)
    {
      ErrorPrintf(ERROR_BADPARM,
                  "MRISsphericalCopy: cannot map dst vno %d", vno) ;
      continue ;
    }
    if (v-mris_src->vertices == Gdiag_no)
    {
      DiagBreak() ;
    }
    vdst->marked++ ;
    vdst->val2 = v->val2 ;
    switch (which)
    {
    case VERTEX_COORDS:
      vdst->origx = v->origx ;
      vdst->origy = v->origy ;
      vdst->origz = v->origz ;
      break ;
    case VERTEX_ANNOTATION:
      vdst->annotation = v->annotation ;
      break ;
    case VERTEX_AREA:
      vdst->origarea = v->origarea ;
      break ;
    case VERTEX_CURV:
      vdst->curv = v->curv ;
      break ;
    case VERTEX_LOGODDS:
    case VERTEX_VALS:
      vdst->val = v->val ;
      break ;
    }
  }
  if (mht_src)
  {
    MHTfree(&mht_src) ;
  }

  return(NO_ERROR) ;
}
#else
int
MRISsphericalCopy(MRI_SURFACE *mris_src, MRI_SURFACE *mris_dst,
                  MRIS_HASH_TABLE *mht, int which)
{
  int    vno ;
  VERTEX *v, *vdst ;
  MHT    *mht_src = NULL ;
  double max_len, mean ;

  MRISclearMarks(mris_dst) ;
  MRISclear(mris_dst, which) ;
  MRISclearMarks(mris_src) ;
  for (vno = 0 ; vno < mris_dst->nvertices ; vno++)
  {
    vdst = &mris_dst->vertices[vno] ;
    vdst->d = 0 ;
    vdst->val2 = 0 ;
  }

  /*
  First determine how much of a fan in there is in the mapping.
  */

  /*
  go through each vertex in the source and see what destination
  vertex it maps to.
  */
  for (vno = 0 ; vno < mris_src->nvertices ; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v = &mris_src->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    vdst = MHTfindClosestVertex(mht, mris_dst, v) ;
    if (!vdst)
    {
      ErrorPrintf
      (ERROR_BADPARM, "MRISsphericalCopy: cannot map vno %d", vno) ;
      continue ;
    }
    if (vdst-mris_dst->vertices == Gdiag_no)
    {
      DiagBreak() ;
    }
    vdst->marked++ ;
    v->marked++ ;
  }

  /* sample from dst to source  */
  for (vno = 0 ; vno < mris_dst->nvertices ; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    vdst = &mris_dst->vertices[vno] ;
    if (vdst->marked || vdst->ripflag)
    {
      continue ;
    }
    if (!mht_src)
    {
      MRIScomputeVertexSpacingStats
      (mris_src, NULL, NULL, &max_len, NULL,NULL, CURRENT_VERTICES);
      mht_src =
        MHTfillVertexTableRes(mris_src, NULL, CURRENT_VERTICES, 2*max_len);
    }
    v = MHTfindClosestVertex(mht_src, mris_src, vdst) ;
    if (!v)
    {
      ErrorPrintf(ERROR_BADPARM,
                  "MRISsphericalCopy: cannot map dst vno %d", vno) ;
      continue ;
    }
    if (v-mris_src->vertices == Gdiag_no)
    {
      DiagBreak() ;
    }
    vdst->marked++ ;
    v->marked++ ;
  }

  MRISclearMarks(mris_dst) ;
  /*
  go through each vertex in the source and sample it onto
  the destination surface.
  */
  for (vno = 0 ; vno < mris_src->nvertices ; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v = &mris_src->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    vdst = MHTfindClosestVertex(mht, mris_dst, v) ;
    if (!vdst)
    {
      ErrorPrintf
      (ERROR_BADPARM, "MRISsphericalCopy: cannot map vno %d", vno) ;
      continue ;
    }
    if (vdst-mris_dst->vertices == Gdiag_no)
    {
      DiagBreak() ;
    }
    vdst->marked++ ;
    vdst->val2 += v->val2/(float)v->marked ;  /* variances */
    switch (which)
    {
    case VERTEX_AREA:
      vdst->d += v->origarea/(float)v->marked ;
      break ;
    case VERTEX_CURV:
      vdst->d += v->curv ;
      break ;
    case VERTEX_LOGODDS:
    case VERTEX_VALS:
      vdst->d += v->val ;
      break ;
    }
  }

  /* normalize by # of times a vertex is mapped to */
  for (vno = 0 ; vno < mris_dst->nvertices ; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    vdst = &mris_dst->vertices[vno] ;
    if (vdst->ripflag || !vdst->marked)
    {
      continue ;
    }
    vdst->val2 /= (float)vdst->marked ;
    mean = vdst->d / (float)vdst->marked ;
    switch (which)
    {
    case VERTEX_AREA:
      vdst->origarea = mean ;
      break ;
    case VERTEX_CURV:
      vdst->curv = mean ;
      break ;
    case VERTEX_LOGODDS:
    case VERTEX_VALS:
      vdst->val = mean ;
      break ;
    }
  }

  /* sample from dst to source to fill holes */
  for (vno = 0 ; vno < mris_dst->nvertices ; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    vdst = &mris_dst->vertices[vno] ;
    if (vdst->marked || vdst->ripflag)
    {
      continue ;
    }
    v = MHTfindClosestVertex(mht_src, mris_src, vdst) ;
    if (!v)
    {
      ErrorPrintf(ERROR_BADPARM,
                  "MRISsphericalCopy: cannot map dst vno %d", vno) ;
      continue ;
    }
    if (v-mris_src->vertices == Gdiag_no)
    {
      DiagBreak() ;
    }
    vdst->marked++ ;
    vdst->val2 = v->val2/(float)v->marked ;
    switch (which)
    {
    case VERTEX_AREA:
      vdst->origarea = v->origarea/(float)v->marked ;
      break ;
    case VERTEX_CURV:
      vdst->curv = v->curv ;
      break ;
    case VERTEX_LOGODDS:
    case VERTEX_VALS:
      vdst->val = v->val ;
      break ;
    }
  }
  if (mht_src)
  {
    MHTfree(&mht_src) ;
  }

  return(NO_ERROR) ;
}
#endif

int
MRISorigAreaToCurv(MRI_SURFACE *mris)
{
  int     vno ;
  VERTEX  *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = v->origarea ;
  }
  return(NO_ERROR) ;
}

int
MRISareaToCurv(MRI_SURFACE *mris)
{
  int     vno ;
  VERTEX  *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = v->area ;
  }
  return(NO_ERROR) ;
}

int
MRISmarkedToCurv(MRI_SURFACE *mris)
{
  int     vno ;
  VERTEX  *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = (float)v->marked ;
  }
  return(NO_ERROR) ;
}

int
MRIScurvToMarked(MRI_SURFACE *mris)
{
  int     vno ;
  VERTEX  *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->marked = (int)v->curv ;
  }
  return(NO_ERROR) ;
}

int
MRISclearOrigArea(MRI_SURFACE *mris)
{
  int     vno ;
  VERTEX  *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->origarea = 0 ;
  }
  return(NO_ERROR) ;
}

int
MRISclearOrigDistances(MRI_SURFACE *mris)
{
  int     vno, n ;
  VERTEX  *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    for (n = 0 ;  n < v->vtotal ; n++)
    {
      v->dist_orig[n] = 0 ;
    }
  }
  return(NO_ERROR) ;
}


int
MRISclear(MRI_SURFACE *mris, int which)
{
  int     vno ;
  VERTEX  *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    switch (which)
    {
    case VERTEX_AREA:
      v->origarea = 0 ;
      break ;
    case VERTEX_CURV:
      v->curv = 0 ;
      break ;
    case VERTEX_LOGODDS:
    case VERTEX_VAL:
      v->val = 0 ;
      break ;
    }
    v->val2 = 0 ;
  }
  return(NO_ERROR) ;
}
int
MRISnormalize(MRI_SURFACE *mris, int dof, int which)
{
  int     vno ;
  VERTEX  *v ;
  float   fdof = (float)dof, mean ;

  if (dof <= 0)
    ErrorReturn(ERROR_BADPARM,
                (ERROR_BADPARM, "MRISnormalize: invalid dof %d", dof)) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    switch (which)
    {
    case VERTEX_AREA:
      v->origarea /= fdof ;
      mean = v->origarea ;
      break ;
    case VERTEX_CURV:
      v->curv /= fdof ;
      mean = v->curv ;
      break ;
    default:
    case VERTEX_LOGODDS:
    case VERTEX_VAL:
      v->val /= fdof ;
      mean = v->val ;
      break ;
    }
    v->val2 = v->val2/fdof - mean*mean ;
  }
  return(NO_ERROR) ;
}

static int
mrisComputeGrayWhiteBorderDistributions
(MRI_SURFACE *mris, MRI *mri, DEFECT *defect,
 HISTOGRAM *h_white, HISTOGRAM *h_gray, HISTOGRAM *h_border,
 HISTOGRAM *h_grad)
{
  int    vno, n2, n, i, nvertices, bin ;
  VERTEX *v, *vn, *vn2 ;
  HISTOGRAM *h_white_raw, *h_gray_raw, *h_border_raw, *h_grad_raw ;
  double    grad, min_grad, max_grad, bin_val, bin_size ;

  HISTOclear(h_gray, h_gray) ;
  HISTOclear(h_white, h_white) ;
  HISTOclear(h_border, h_border) ;
  HISTOclear(h_grad, h_grad) ;

  mrisMarkDefect(mris, defect, 1);  /* avoid vertices in the defect */
  for (bin = 0 ; bin < h_gray->nbins ; bin++)
  {
    h_gray->bins[bin] = h_white->bins[bin] = h_border->bins[bin] = bin ;
  }

  min_grad = 100000 ;
  max_grad = -min_grad ;

  for (nvertices = i = 0 ; i < defect->nchull  ; i++)
  {
    vno = defect->chull[i] ;
    v = &mris->vertices[vno] ;
    for (n = 0 ; n < v->vtotal ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      for (n2 = 0 ; n2 < vn->vtotal ; n2++)
      {
        vn2 = &mris->vertices[vn->v[n2]] ;
        if (vn2->marked)  /* already processed */
        {
          continue ;
        }
        grad = vn2->val2 - vn2->val2bak ;
        if (grad < min_grad)
        {
          min_grad = grad ;
        }
        if (grad > max_grad)
        {
          max_grad = grad ;
        }
      }
    }
  }


  /* add one bin at either end for almost zero probability events */
  bin_size = (max_grad - min_grad) / (h_grad->nbins-2) ;
  h_grad->bin_size = bin_size ;
  for (bin_val = min_grad-bin_size, bin = 0 ;
       bin < h_grad->nbins ;
       bin++, bin_val += bin_size)
  {
    h_grad->bins[bin] = bin_val ;
  }

  min_grad = h_grad->bins[0] ;

  for (nvertices = i = 0 ; i < defect->nchull  ; i++)
  {
    vno = defect->chull[i] ;
    v = &mris->vertices[vno] ;
    for (n = 0 ; n < v->vtotal ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      for (n2 = 0 ; n2 < vn->vtotal ; n2++)
      {
        vn2 = &mris->vertices[vn->v[n2]] ;
        if (vn2->marked)  /* already processed */
        {
          continue ;
        }
        nvertices++ ;

        if (vn2->val2bak < 70)
        {
          DiagBreak() ;
        }

        bin = nint(vn2->val2) ;
        bin=MIN(h_white->nbins,MAX(0,bin));
        h_white->counts[bin]++ ;     /* wm value */
        bin = nint(vn2->val2bak) ;
        bin=MIN(h_gray->nbins,MAX(0,bin));
        h_gray->counts[bin]++ ;      /* gray value */
        bin = nint(vn2->val) ;
        bin=MIN(h_border->nbins,MAX(0,bin));
        h_border->counts[bin]++ ;      /* border value */
        grad = vn2->val2 - vn2->val2bak ;
        bin = (int)((grad - min_grad) / bin_size) ;
        bin=MIN(h_grad->nbins,MAX(0,bin));
        h_grad->counts[bin]++ ;

        vn2->marked = 1 ;   /* don't process it twice */
      }
    }
  }

  /* unmark them all */
  for (i = 0 ; i < defect->nchull  ; i++)
  {
    vno = defect->chull[i] ;
    v = &mris->vertices[vno] ;
    for (n = 0 ; n < v->vtotal ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      for (n2 = 0 ; n2 < vn->vtotal ; n2++)
      {
        vn2 = &mris->vertices[vn->v[n2]] ;
        vn2->marked = 0 ;
      }
    }
  }

  for (bin = 0 ; bin < h_gray->nbins ; bin++)
  {
    if (h_gray->counts[bin] == 0)
    {
      h_gray->counts[bin] = 0.1 ;
    }
    if (h_white->counts[bin] == 0)
    {
      h_white->counts[bin] = 0.1 ;
    }
    if (h_border->counts[bin] == 0)
    {
      h_border->counts[bin] = 0.1 ;
    }
    if (h_grad->counts[bin] == 0)
    {
      h_grad->counts[bin] = 0.1 ;
    }
    h_grad->counts[bin] /= (float)nvertices ;
    h_gray->counts[bin] /= (float)nvertices ;
    h_white->counts[bin] /= (float)nvertices ;
    h_border->counts[bin] /= (float)nvertices ;
  }

  h_grad_raw = HISTOcopy(h_grad, NULL) ;
  h_gray_raw = HISTOcopy(h_gray, NULL) ;
  h_white_raw = HISTOcopy(h_white, NULL) ;
  h_border_raw = HISTOcopy(h_border, NULL) ;

  //to correct the bug in HISTOsmooth
  h_grad_raw->bin_size=h_grad->bin_size;
  h_gray_raw->bin_size=h_gray->bin_size;
  h_white_raw->bin_size=h_white->bin_size;
  h_border_raw->bin_size=h_border->bin_size;

  HISTOsmooth(h_grad_raw, h_grad, 2) ;
  HISTOsmooth(h_gray_raw, h_gray, 2) ;
  HISTOsmooth(h_white_raw, h_white, 2) ;
  HISTOsmooth(h_border_raw, h_border, 2) ;

  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    HISTOplot(h_gray, "g.plt") ;
    HISTOplot(h_white, "w.plt") ;
    HISTOplot(h_border, "b.plt") ;
    HISTOplot(h_gray_raw, "gr.plt") ;
    HISTOplot(h_white_raw, "wr.plt") ;
    HISTOplot(h_border_raw, "br.plt") ;
    HISTOplot(h_grad, "d.plt") ;
    HISTOplot(h_grad_raw, "dr.plt") ;
  }
  mrisMarkDefect(mris, defect, 0);
  HISTOfree(&h_gray_raw) ;
  HISTOfree(&h_white_raw) ;
  HISTOfree(&h_border_raw) ;
  HISTOfree(&h_grad_raw) ;
  return(NO_ERROR) ;
}

static int
mrisComputeJointGrayWhiteBorderDistributions(MRI_SURFACE *mris, MRI *mri,
    MRI *mri_gray_white, MRI *mri_wm)
{
  int    vno, x, y ;
  VERTEX *v ;
  float  norm ;
  double   nx, ny, nz, xv, yv, zv, xw, yw, zw, white_val, gray_val ;

  MRIScomputeMetricProperties(mris) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked || v->ripflag)  /* part of a defect - ignore it */
    {
      continue ;
    }

    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    xw = v->x ;
    yw = v->y ;
    zw = v->z ;

    // MRIworldToVoxel(mri, xw+.5*nx, yw+.5*ny, zw+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(xw+.5*nx, yw+.5*ny, zw+.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, xw+.5*nx, yw+.5*ny, zw+.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolumeType(mri, xv, yv, zv, &gray_val, SAMPLE_NEAREST) ;
    // MRIworldToVoxel(mri, xw-.5*nx, yw-.5*ny, zw-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(xw-.5*nx, yw-.5*ny, zw-.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, xw-.5*nx, yw-.5*ny, zw-.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolumeType(mri, xv, yv, zv, &white_val, SAMPLE_NEAREST) ;



#if 0
    //to be checked
#if 0
    if (gray_val >= MIN_WM_VAL &&
        white_val >= MIN_WM_VAL)  /* white on both sides */
    {
      continue ;
    }
#endif

    MRIFvox(mri_gray_white, nint(white_val), nint(gray_val), 0) += 1.0f ;
#else
    // set the value
    if (nint(v->val2) < 0 || nint(v->val2bak < 0) ||
        nint(v->val2) >= mri_gray_white->width ||
        nint(v->val2bak) >= mri_gray_white->height)
      ErrorExit(ERROR_UNSUPPORTED, "gray/white vals out of [0 255] range (%d, %d)\n",
                nint(v->val2), nint(v->val)) ;
    MRIFvox(mri_gray_white, nint(v->val2), nint(v->val2bak), 0) += 1.0f ;

    //      if ((nint(nint(v->val2)) == 110) && (nint(v->val2bak) == 110)) DiagBreak() ;
#endif
  }


  for (x = 0 ; x < 256; x++)
    for (y = 0 ; y < 256 ; y++)
    {
      if (FZERO(MRIFvox(mri_gray_white, x, y, 0)))
      {
        MRIFvox(mri_gray_white, x, y, 0) = 0.1 ;
      }
    }
  for (norm = 0.0, x = 0 ; x < 256 ; x++)
    for (y = 0 ; y < 256 ; y++)
    {
      norm += MRIFvox(mri_gray_white, x, y, 0) ;
    }

  for (x = 0 ; x < 256; x++)
    for (y = 0 ; y < 256 ; y++)
    {
      MRIFvox(mri_gray_white, x, y, 0) =
        MRIFvox(mri_gray_white, x, y, 0) / norm ;
    }

  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    MRIwrite(mri_gray_white, "gw.mgh") ;
  }
  return(NO_ERROR) ;
}

static int mrisFindGrayWhiteBorderMean(MRI_SURFACE *mris, MRI *mri)
{
  double    x, y, z, xv, yv, zv, gray_val, white_val, nx, ny, nz ;
  int     vno ;
  VERTEX  *v ;

  MRIScomputeNormals(mris) ;
  /*  MRISsmoothSurfaceNormals(mris, 10) ;*/
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->marked)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    x = v->x ;
    y = v->y ;
    z = v->z ;

    // MRIworldToVoxel(mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x+.5*nx, y+.5*ny, z+.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x+.5*nx, y+.5*ny, z+.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &gray_val) ;
    // MRIworldToVoxel(mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#if MATRIX_ALLOCATION
    mriSurfaceRASToVoxel(x-.5*nx, y-.5*ny, z-.5*nz,&xv, &yv, &zv) ;
#else
    MRISsurfaceRASToVoxelCached(mris, mri, x-.5*nx, y-.5*ny, z-.5*nz, &xv, &yv, &zv) ;
#endif
    MRIsampleVolume(mri, xv, yv, zv, &white_val) ;
    v->val2 = white_val ;
    v->val2bak = gray_val ;
    v->val = (white_val + gray_val) / 2 ;
  }
#if 0
  MRISaverageVals(mris, 10) ;
  MRISaverageVal2s(mris, 10) ;
  MRISaverageVal2baks(mris, 10) ;
#else
  MRISmedianFilterVals(mris, 2) ;
  MRISmedianFilterVal2s(mris, 2) ;
  MRISmedianFilterVal2baks(mris, 2) ;
#endif
  return(NO_ERROR) ;
}

int
MRISreadNewCurvatureFile(MRI_SURFACE *mris, const char *sname)
{
  int    k,vnum,fnum, vals_per_vertex ;
  float  curv, curvmin, curvmax;
  FILE   *fp;
  char   *cp, path[STRLEN], fname[STRLEN] ;

  cp = strchr(sname, '/') ;
  if (!cp)                 /* no path - use same one as mris was read from */
  {
    cp = strchr(sname, '.') ;
    FileNamePath(mris->fname, path) ;
    if (cp)
    {
      sprintf(fname, "%s/%s", path, sname) ;
    }
    else   /* no hemisphere specified */
      sprintf(fname, "%s/%s.%s", path,
              mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh", sname) ;
  }
  else
  {
    strcpy(fname, sname) ;  /* path specified explcitly */
  }

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "reading curvature file...") ;
  }

  fp = fopen(fname,"r");
  if (fp==NULL)
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISreadBinaryCurvature: could not open %s",
                 fname)) ;

  fread3(&vnum,fp);
  if (vnum != NEW_VERSION_MAGIC_NUMBER)
  {
    fclose(fp) ;
    return(MRISreadCurvatureFile(mris, fname)) ;
  }

  vnum = freadInt(fp);
  fnum = freadInt(fp);
  if (vnum!= mris->nvertices)
  {
    fclose(fp) ;
    ErrorReturn(ERROR_NOFILE,
                (ERROR_NOFILE, "MRISreadNewCurvature: incompatible vertex "
                 "number in file %s", fname)) ;
  }
  vals_per_vertex = freadInt(fp) ;
  if (vals_per_vertex != 1)
  {
    fclose(fp) ;
    ErrorReturn
    (ERROR_NOFILE,
     (ERROR_NOFILE,
      "MRISreadNewCurvature(%s): vals/vertex %d unsupported (must be 1) ",
      fname, vals_per_vertex)) ;
  }

  curvmin = 10000.0f ;
  curvmax = -10000.0f ;  /* for compiler warnings */
  for (k=0; k<vnum; k++)
  {
    curv = freadFloat(fp) ;
    if (k==0)
    {
      curvmin=curvmax=curv;
    }
    if (curv>curvmax)
    {
      curvmax=curv;
    }
    if (curv<curvmin)
    {
      curvmin=curv;
    }
    mris->vertices[k].curv = curv;
  }
  mris->max_curv = curvmax ;
  mris->min_curv = curvmin ;
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "done. min=%2.3f max=%2.3f\n", curvmin, curvmax) ;
  }
  fclose(fp);
  return(NO_ERROR) ;
}
float *
MRISreadNewCurvatureVector(MRI_SURFACE *mris, const char *sname)
{
  char   *cp, path[STRLEN], fname[STRLEN] ;
  float  *cvec  = NULL;
  int return_code = ERROR_NONE;

  cp = strchr(sname, '/') ;
  if (!cp)                 /* no path - use same one as mris was read from */
  {
    cp = strchr(sname, '.') ;
    FileNamePath(mris->fname, path) ;
    if (cp)
    {
      sprintf(fname, "%s/%s", path, sname) ;
    }
    else   /* no hemisphere specified */
      sprintf(fname, "%s/%s.%s", path,
              mris->hemisphere == LEFT_HEMISPHERE ? "lh" : "rh", sname) ;
  }
  else
  {
    strcpy(fname, sname) ;  /* path specified explcitly */
  }

  /* Try to read an array of values from this file. If we get an
     error, return NULL. */
  return_code = MRISreadNewCurvatureIntoArray (fname, mris->nvertices, &cvec);
  if (NO_ERROR != return_code)
  {
    return NULL;
  }

  /* Return the array we read. */
  return cvec;
}

int
MRISreadNewCurvatureIntoArray(const char *sname,
                              int in_array_size,
                              float** out_array)
{
  int    k,vnum,fnum;
  float  *cvec ;
  FILE   *fp;
  int vals_per_vertex;

  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
  {
    fprintf(stdout, "reading curvature file...") ;
  }

  fp = fopen(sname,"r");
  if (fp==NULL)
    ErrorReturn(ERROR_BADFILE,
                (ERROR_BADFILE, "MRISreadNewCurvatureIntoArray(%s): fopen failed"));

  /* This is the version number. */
  fread3(&vnum,fp);
  if (vnum != NEW_VERSION_MAGIC_NUMBER)
  {
    fclose(fp) ;
    return(MRISreadCurvatureIntoArray(sname, in_array_size, out_array)) ;
  }

  /* Read number of vertices and faces. */
  vnum = freadInt(fp);
  fnum = freadInt(fp);

  /* Make sure the number of vertices mathces what we're expecting. */
  if (vnum != in_array_size)
  {
    fclose(fp) ;
    ErrorReturn(ERROR_BADFILE,
                (ERROR_BADFILE, "MRISreadNewCurvatureIntoArray(%s): number of vertices (%d) doesn't match what was expected (%d)", sname, vnum, in_array_size));
  }

  /* Number of values per vertex. */
  vals_per_vertex = freadInt(fp) ;
  if (vals_per_vertex != 1)
  {
    fclose(fp) ;
    ErrorReturn(ERROR_BADFILE,
                (ERROR_BADFILE, "MRISreadNewCurvatureIntoArray(%s): vals_per_vertex was not 1", sname));
  }

  /* Allocate to size of vnum.*/
  cvec = (float *)calloc(in_array_size, sizeof(float)) ;
  if (!cvec)
    ErrorExit(ERROR_NOMEMORY, "MRISreadNewCurvatureVector(%s): calloc failed",
              sname) ;

  /* Read in values. */
  for (k=0; k<vnum; k++)
  {
    cvec[k] = freadFloat(fp) ;
  }
  fclose(fp);

  /* Return what we read. */
  *out_array = cvec;

  return (ERROR_NONE);
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISpaintVolume(MRI_SURFACE *mris, LTA *lta, MRI *mri)
{
  VERTEX   *v ;
  int      vno, width, height, depth ;
  double     x, y, z, val ;
  MATRIX   *m_L, *m_ras_to_voxel ;
  VECTOR   *v_surf, *v_vol ;

  if (lta->type != LINEAR_RAS_TO_RAS)
    ErrorReturn
    (ERROR_UNSUPPORTED,
     (ERROR_UNSUPPORTED,
      "MRISsampleVolume: unsupported transform type %d",
      lta->type)) ;

  v_surf = VectorAlloc(4, MATRIX_REAL) ;
  v_vol = VectorAlloc(4, MATRIX_REAL) ;
  *MATRIX_RELT(v_surf, 4, 1) = 1.0 ;
  *MATRIX_RELT(v_vol, 4, 1) = 1.0 ;
  m_ras_to_voxel = MRIgetRasToVoxelXform(mri) ;

  m_L = MatrixMultiply(m_ras_to_voxel, lta->xforms[0].m_L, NULL) ;
  width  = mri->width ;
  height  = mri->height ;
  depth  = mri->depth ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v = &mris->vertices[vno] ;
    V3_X(v_surf) = v->x+.5*v->curv*v->nx ;
    V3_Y(v_surf) = v->y+.5*v->curv*v->ny ;
    V3_Z(v_surf) = v->z+.5*v->curv*v->nz ;

    MatrixMultiply(m_L, v_surf, v_vol) ;
    x = V3_X(v_vol) ;
    y = V3_Y(v_vol) ;
    z = V3_Z(v_vol) ;

    MRIsampleVolume(mri, x, y, z, &val) ;
    v->val = val ;
    if (Gdiag_no == vno)
      printf("vertex %d at (%2.1f, %2.1f, %2.1f) --> "
             "voxel (%2.1f, %2.1f, %2.1f) = %2.2f\n",
             vno, v->x+.5*v->curv*v->nx,
             v->y+.5*v->curv*v->ny, v->z+.5*v->curv*v->nz, x, y, z, val) ;
  }

  MatrixFree(&v_surf) ;
  MatrixFree(&v_vol) ;
  MatrixFree(&m_L) ;
  MatrixFree(&m_ras_to_voxel) ;
  return(NO_ERROR) ;
}
static int
mrisComputePositioningGradients(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  MHT  *mht_v_orig = NULL, *mht_v_current = NULL, *mht_f_current ;
  MRI  *mri_brain = parms->mri_brain ;
  int  avgs ;

  avgs = parms->n_averages ;
  if (!FZERO(parms->l_surf_repulse))
  {
    mht_v_orig = MHTfillVertexTable(mris, NULL, ORIGINAL_VERTICES) ;
  }
  if (!FZERO(parms->l_repulse))
  {
    mht_v_current = MHTfillVertexTable(mris, mht_v_current,CURRENT_VERTICES);
    mht_f_current = MHTfillTable(mris, mht_f_current);
  }
  mrisComputeTargetLocationTerm(mris, parms->l_location, parms) ;
  mrisComputeIntensityTerm(mris, parms->l_intensity, mri_brain, mri_brain,
                           parms->sigma, parms);
  mrisComputeDuraTerm(mris, parms->l_dura,
                      parms->mri_dura, parms->dura_thresh) ;
  mrisComputeIntensityGradientTerm(mris, parms->l_grad,mri_brain,mri_brain);
  mrisComputeSurfaceRepulsionTerm(mris, parms->l_surf_repulse, mht_v_orig);

  mrisComputeLaplacianTerm(mris, parms->l_lap) ;
  MRISaverageGradients(mris, avgs) ;

  /* smoothness terms */
  mrisComputeSpringTerm(mris, parms->l_spring) ;
  mrisComputeNormalizedSpringTerm(mris, parms->l_spring_norm) ;
  mrisComputeRepulsiveTerm(mris, parms->l_repulse,mht_v_current,mht_f_current);
  mrisComputeThicknessSmoothnessTerm(mris, parms->l_tsmooth) ;
  mrisComputeThicknessMinimizationTerm(mris, parms->l_thick_min, parms) ;
  mrisComputeThicknessParallelTerm(mris, parms->l_thick_parallel, parms) ;
  mrisComputeNormalSpringTerm(mris, parms->l_nspring) ;
  mrisComputeQuadraticCurvatureTerm(mris, parms->l_curv) ;
  /*    mrisComputeAverageNormalTerm(mris, avgs, parms->l_nspring) ;*/
  /*    mrisComputeCurvatureTerm(mris, parms->l_curv) ;*/
  mrisComputeNonlinearSpringTerm(mris, parms->l_nlspring, parms) ;
  mrisComputeTangentialSpringTerm(mris, parms->l_tspring) ;
  mrisComputeNonlinearTangentialSpringTerm(mris, parms->l_nltspring, parms->min_dist) ;


  if (mht_v_orig)
  {
    MHTfree(&mht_v_orig) ;
  }
  if (mht_v_current)
  {
    MHTfree(&mht_v_current) ;
  }
  if (mht_f_current)
  {
    MHTfree(&mht_f_current) ;
  }
  return(NO_ERROR) ;
}
int
MRISallocExtraGradients(MRI_SURFACE *mris)
{
  if (mris->dx2)
  {
    return(NO_ERROR) ;  /* already allocated */
  }

  mris->dx2 = (float *)calloc(mris->nvertices, sizeof(float)) ;
  mris->dy2 = (float *)calloc(mris->nvertices, sizeof(float)) ;
  mris->dz2 = (float *)calloc(mris->nvertices, sizeof(float)) ;
  if (!mris->dx2 || !mris->dy2 || !mris->dz2)
    ErrorExit(ERROR_NO_MEMORY,
              "MRISallocExtraGradients: could allocate gradient vectors") ;
  return(NO_ERROR) ;
}

int
MRISrestoreExtraGradients(MRI_SURFACE *mris)
{
  int   vno ;
  VERTEX *v ;

  if (!mris->dx2)
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->dx = mris->dx2[vno] ;
    v->dy = mris->dy2[vno] ;
    v->dz = mris->dz2[vno] ;
  }

  return(NO_ERROR) ;
}

int
MRISclearDistances(MRI_SURFACE *mris)
{
  int   vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->d = 0.0 ;
  }

  return(NO_ERROR) ;
}
/*-----------------------------------------------------------------
  MRISloadSurfVals() - loads surfaces values directly into an MRI
  structure. The surface value file can be any format read by
  MRIread. In addition, it can be a curv or paint file. If
  Surf is non-null, then it is used as a template; otherwise,
  the caller must spec the subject and hemisphere, and then the
  ?h.white surface is used as the template (and then freed).

  If the source file is neither curv nor paint, then MRIreadType is
  used to read the file in as a "volume", and the "volume" is reshaped
  to be nvertices X 1 X 1 X nframes (which is the final size
  regardless).

  If the source is curv format, then the given file is read from the
  subject's surf directory. If Surf is non-null, then the sujbect
  name and hemisphere in the MRI_SURFACE struct are used; otherwise
  they must be passed.

  If the subjectsdir string is NULL, then it reads SUBJECTS_DIR
  from the environment.
  -----------------------------------------------------------------*/
MRI *MRISloadSurfVals(const char *srcvalfile, const char *typestring, MRI_SURFACE *Surf,
                      const char *subject, const char *hemi, const char *subjectsdir)
{
  MRI *SrcVals, *mritmp;
  char fname[2000];
  int srctype,reshapefactor=0,f;
  float *framepower = NULL;
  SXADAT *sxa;
  int freesurface = 0, err=0;

  if (Surf == NULL)
  {
    /*-------- set SUBJECTS DIR -------------*/
    if (subjectsdir == NULL)
    {
      subjectsdir = getenv("SUBJECTS_DIR");
      if (subjectsdir==NULL)
      {
        fprintf(stderr,"ERROR: SUBJECTS_DIR not defined in environment\n");
        return(NULL);
      }
    }
    /*------- load the surface -------------*/
    sprintf(fname,"%s/%s/surf/%s.white",subjectsdir,subject,hemi);
    printf("INFO: loading surface %s\n",fname);
    Surf = MRISread(fname);
    if (Surf == NULL)
    {
      fprintf(stderr,"ERROR: could not read %s\n",fname);
      return(NULL);
    }
    freesurface = 1;
  }
  else
  {
    subject = Surf->subject_name;
    if (Surf->hemisphere == LEFT_HEMISPHERE)
    {
      hemi = "lh";
    }
    if (Surf->hemisphere == RIGHT_HEMISPHERE)
    {
      hemi = "rh";
    }
  }

  /* ------------------ load the source data ----------------------------*/
  printf("Loading surface source data %s as %s\n",srcvalfile,typestring);
  if (!strcmp(typestring,"curv"))
  {
    /* curvature file */
    sprintf(fname,"%s/%s/surf/%s.%s",subjectsdir,subject,hemi,srcvalfile);
    printf("Reading curvature file %s\n",fname);
    err = MRISreadCurvatureFile(Surf, fname);
    if (err)
    {
      printf("ERROR: reading curvature\n");
      return(NULL);
    }
    SrcVals = MRIcopyMRIS(NULL, Surf, 0, "curv");
    if (SrcVals == NULL)
    {
      printf("ERROR: converting surface curv to MRI\n");
      return(NULL);
    }

    //SrcVals = MRIallocSequence(Surf->nvertices, 1, 1,MRI_FLOAT,1);
    //for(vtx = 0; vtx < Surf->nvertices; vtx++){
    //  MRIFseq_vox(SrcVals,vtx,0,0,0) = Surf->vertices[vtx].curv;
    //}
  }
  else if (!strcmp(typestring,"paint") || !strcmp(typestring,"w"))
  {
    MRISreadValues(Surf,srcvalfile);
    SrcVals = MRIcopyMRIS(NULL, Surf, 0, "val");
    //SrcVals = MRIallocSequence(Surf->nvertices, 1, 1,MRI_FLOAT,1);
    //for(vtx = 0; vtx < Surf->nvertices; vtx++)
    //  MRIFseq_vox(SrcVals,vtx,0,0,0) = Surf->vertices[vtx].val;
  }
  else
  {
    /* Use MRIreadType */
    srctype = string_to_type(typestring);
    if (srctype == MRI_VOLUME_TYPE_UNKNOWN)
    {
      printf("ERROR: typestring %s unrecognized\n",typestring);
      return(NULL);
    }
    SrcVals =  MRIreadType(srcvalfile,srctype);
    if (SrcVals == NULL)
    {
      printf("ERROR: could not read %s as type %d\n",srcvalfile,srctype);
      return(NULL);
    }
    if (SrcVals->height != 1 || SrcVals->depth != 1)
    {
      reshapefactor = SrcVals->height * SrcVals->depth;
      printf("Reshaping %d\n",reshapefactor);
      mritmp = mri_reshape(SrcVals, reshapefactor*SrcVals->width,
                           1, 1, SrcVals->nframes);
      MRIfree(&SrcVals);
      SrcVals = mritmp;
    }

    if (SrcVals->width != Surf->nvertices)
    {
      fprintf(stdout,"ERROR: dimension inconsistency in source data\n");
      fprintf(stdout,"       Number of surface vertices = %d\n",
              Surf->nvertices);
      fprintf(stdout,"       Number of value vertices = %d\n",SrcVals->width);
      return(NULL);
    }
    if(0 && is_sxa_volume(srcvalfile))
    {
      // Dont need to do this anymore 10/19/2010
      printf("INFO: Source volume detected as selxavg format\n");
      sxa = ld_sxadat_from_stem(srcvalfile);
      if (sxa == NULL)
      {
        return(NULL);
      }
      framepower = sxa_framepower(sxa,&f);
      if (f != SrcVals->nframes)
      {
        fprintf(stderr," number of frames is incorrect (%d,%d)\n",
                f,SrcVals->nframes);
        return(NULL);
      }
      printf("INFO: Adjusting Frame Power\n");
      fflush(stdout);
      mri_framepower(SrcVals,framepower);
    }
  }
  if (SrcVals == NULL)
  {
    fprintf(stderr,"ERROR loading source values from %s\n",srcvalfile);
    return(NULL);
  }
  printf("Done Loading %s\n",srcvalfile);

  if (freesurface)
  {
    MRISfree(&Surf);
  }

  return(SrcVals);
}
/*-----------------------------------------------------------------
  MRIScopyMRI() - copies the data from an MRI_VOLUME struct into a
  field in the MRI_SURFACE vertex struct. The MRI_VOLUME struct is
  assumed to have the dimension such that ncols*nrows*nslices =
  nvertices. Frame is the zero-based frame number to copy. Field is a
  string that indicates which field of the vertex structure the data
  should be copied to. For example, "val" indicates the val field.
  Other supported fields are: val, stat, valbak, val2, val2bak,
  imag_val, curv, curvbak, fsmask, nc. Others can be easily added. If
  there is an error, a 1 is returned; otherwise 0.
  -----------------------------------------------------------------*/
int MRIScopyMRI(MRIS *Surf, MRI *Src, int Frame, char *Field)
{
  int vtx, useval=0, usecurv=0, nvox, c, r, s;
  float val;

  if (Gdiag_no > 0)
  {
    printf("MRIScopyMRI\n");
  }

  nvox = Src->width * Src->height * Src->depth;
  if (Surf->nvertices != nvox)
  {
    printf("ERROR: MRIScopyMRI: Surf/Src dimension mismatch.\n");
    return(1);
  }

  if (Frame >= Src->nframes)
  {
    printf("ERROR: MRIScopyMRI: requested frame number is too large.\n");
    printf("ERROR:   requested = %d, max = %d\n",Frame,Src->nframes);
    return(1);
  }

  /* A separate variable is used for val and curv for speed purposes */
  if (!strcmp(Field,"val"))
  {
    useval = 1;
  }
  else
  {
    useval = 0;
  }
  if (!strcmp(Field,"curv"))
  {
    usecurv = 1;
  }
  else
  {
    usecurv = 0;
  }

  /*------------------------------------------------*/
  vtx = 0;
  for (s = 0; s < Src->depth; s++)
  {
    for (r = 0; r < Src->height; r++)
    {
      for (c = 0; c < Src->width; c++)
      {
        val = MRIgetVoxVal(Src, c, r, s, Frame);
        //val = MRIgetVoxVal(Src, vtx, 0, 0, Frame); // was vtx,0,0 dng, wrong

        if (useval)
        {
          Surf->vertices[vtx].val = val;
        }
        else if (usecurv)
        {
          Surf->vertices[vtx].curv = val;
        }
        else if (!strcmp(Field,"stat"))
        {
          Surf->vertices[vtx].stat = val;
        }
        else if (!strcmp(Field,"valbak"))
        {
          Surf->vertices[vtx].valbak = val;
        }
        else if (!strcmp(Field,"val2"))
        {
          Surf->vertices[vtx].val2 = val;
        }
        else if (!strcmp(Field,"val2bak"))
        {
          Surf->vertices[vtx].val2bak = val;
        }
        else if (!strcmp(Field,"imag_val"))
        {
          Surf->vertices[vtx].imag_val = val;
        }
        else if (!strcmp(Field,"curvbak"))
        {
          Surf->vertices[vtx].curvbak = val;
        }
        else if (!strcmp(Field,"fsmask"))
        {
          Surf->vertices[vtx].fsmask = val;
        }
        else if (!strcmp(Field,"nc"))
        {
          Surf->vertices[vtx].nc = val;
        }
        else if (!strcmp(Field,"undefval"))
        {
          Surf->vertices[vtx].undefval = val;
        }
        else if (!strcmp(Field,"x"))
        {
          Surf->vertices[vtx].x = val;
        }
        else if (!strcmp(Field,"y"))
        {
          Surf->vertices[vtx].y = val;
        }
        else if (!strcmp(Field,"z"))
        {
          Surf->vertices[vtx].z = val;
        }
        else if (!strcmp(Field,"vnum"))
        {
          Surf->vertices[vtx].vnum = val;
        }
        else if (!strcmp(Field,"annotation"))
        {
          Surf->vertices[vtx].annotation = val;
        }
        else if (!strcmp(Field,"ripflag"))
        {
          Surf->vertices[vtx].ripflag = val;
        }
        else if (!strcmp(Field,"area"))
        {
          Surf->vertices[vtx].area = val;
        }
        else if (!strcmp(Field,"group_avg_area"))
        {
          Surf->vertices[vtx].group_avg_area = val;
        }
        else if (!strcmp(Field,"K"))
        {
          Surf->vertices[vtx].K = val;
        }
        else if (!strcmp(Field,"H"))
        {
          Surf->vertices[vtx].H = val;
        }
        else if (!strcmp(Field,"k1"))
        {
          Surf->vertices[vtx].k1 = val;
        }
        else if (!strcmp(Field,"k2"))
        {
          Surf->vertices[vtx].k2 = val;
        }
        else if (!strcmp(Field,"nx"))
        {
          Surf->vertices[vtx].nx = val;
        }
        else if (!strcmp(Field,"ny"))
        {
          Surf->vertices[vtx].ny = val;
        }
        else if (!strcmp(Field,"nz"))
        {
          Surf->vertices[vtx].nz = val;
        }
        else if (!strcmp(Field,"tx"))
        {
          Surf->vertices[vtx].tx = val;
        }
        else if (!strcmp(Field,"ty"))
        {
          Surf->vertices[vtx].ty = val;
        }
        else if (!strcmp(Field,"tz"))
        {
          Surf->vertices[vtx].tz = val;
        }
        else if (!strcmp(Field,"dx"))
        {
          Surf->vertices[vtx].dx = val;
        }
        else if (!strcmp(Field,"dy"))
        {
          Surf->vertices[vtx].dy = val;
        }
        else if (!strcmp(Field,"dz"))
        {
          Surf->vertices[vtx].dz = val;
        }
        else if (!strcmp(Field,"tdx"))
        {
          Surf->vertices[vtx].tdx = val;
        }
        else if (!strcmp(Field,"tdy"))
        {
          Surf->vertices[vtx].tdy = val;
        }
        else if (!strcmp(Field,"tdz"))
        {
          Surf->vertices[vtx].tdz = val;
        }
        else
        {
          printf("ERROR: MRIScopyMRI(): Field %s not supported\n",Field);
          return(1);
        }
        vtx++;
      }
    }
  }
  return(0);
}
/*-----------------------------------------------------------------
  MRIcopyMRIS() - copies the data from the given field of an
  MRI_SURFACE struct into a given frame of an MRI_VOLUME struct. The
  MRI_VOLUME should have the dimension such that: ncols*nrows*nslices
  = nvertices.  Frame is the zero-based frame number to copy to. Field
  is a string that indicates which field of the vertex structure the
  data should be copied from. For example, "val" indicates the val
  field.  Other supported fields are: val, stat, valbak, val2,
  val2bak, imag_val, curv, curvbak, fsmask, nc. If mri is NULL, it
  will be allocated with nframes=Frame+1 (ie, just enough frames) and
  type will be MRI_FLOAT. A pointer to mri is returned. If an error
  occurs, NULL is returned.
  -----------------------------------------------------------------*/
MRI *MRIcopyMRIS(MRI *mri, MRIS *surf, int Frame, char *Field)
{
  int vtx, useval=0, usecurv=0, nvox, c, r, s;
  float val;

  if (mri == NULL)
  {
    mri = MRIallocSequence(surf->nvertices, 1, 1, MRI_FLOAT, Frame+1);
    if (mri==NULL)
    {
      printf("ERROR: MRIcopyMRIS: could not alloc\n");
      return(NULL);
    }
  }
  nvox = mri->width * mri->height * mri->depth;
  if (surf->nvertices != nvox)
  {
    printf("ERROR: MRIcopyMRIS: Surf/Src dimension mismatch.\n");
    return(NULL);
  }
  if (Frame >= mri->nframes)
  {
    printf("ERROR: MRIScopyMRI: requested frame number is too large.\n");
    printf("ERROR:   requested = %d, max = %d\n",Frame,mri->nframes);
    return(NULL);
  }

  /* A separate variable is used for val and curv for speed purposes */
  if (!strcmp(Field,"val"))
  {
    useval = 1;
  }
  else
  {
    useval = 0;
  }
  if (!strcmp(Field,"curv"))
  {
    usecurv = 1;
  }
  else
  {
    usecurv = 0;
  }

  /*------------------------------------------------*/
  vtx = 0;
  for (s = 0; s < mri->depth; s++)
  {
    for (r = 0; r < mri->height; r++)
    {
      for (c = 0; c < mri->width; c++)
      {
        if (useval)
        {
          val = surf->vertices[vtx].val;
        }
        else if (usecurv)
        {
          val = surf->vertices[vtx].curv;
        }
        else if (!strcmp(Field,"stat"))
        {
          val = surf->vertices[vtx].stat;
        }
        else if (!strcmp(Field,"d"))
        {
          val = surf->vertices[vtx].d;
        }
        else if (!strcmp(Field,"valbak"))
        {
          val = surf->vertices[vtx].valbak;
        }
        else if (!strcmp(Field,"val2"))
        {
          val = surf->vertices[vtx].val2;
        }
        else if (!strcmp(Field,"val2bak"))
        {
          val = surf->vertices[vtx].val2bak;
        }
        else if (!strcmp(Field,"imag_val"))
        {
          val = surf->vertices[vtx].imag_val;
        }
        else if (!strcmp(Field,"curvbak"))
        {
          val = surf->vertices[vtx].curvbak;
        }
        else if (!strcmp(Field,"fsmask"))
        {
          val = surf->vertices[vtx].fsmask;
        }
        else if (!strcmp(Field,"fieldsign"))
        {
          val = surf->vertices[vtx].fieldsign;
        }
        else if (!strcmp(Field,"nc"))
        {
          val = surf->vertices[vtx].nc;
        }
        else if (!strcmp(Field,"undefval"))
        {
          val = surf->vertices[vtx].undefval;
        }
        else if (!strcmp(Field,"x"))
        {
          val = surf->vertices[vtx].x;
        }
        else if (!strcmp(Field,"y"))
        {
          val = surf->vertices[vtx].y;
        }
        else if (!strcmp(Field,"z"))
        {
          val = surf->vertices[vtx].z;
        }
        else if (!strcmp(Field,"vnum"))
        {
          val = surf->vertices[vtx].vnum;
        }
        else if (!strcmp(Field,"annotation"))
        {
          val = surf->vertices[vtx].annotation;
        }
        else if (!strcmp(Field,"ripflag"))
        {
          val = surf->vertices[vtx].ripflag;
        }
        else if (!strcmp(Field,"area"))
        {
          val = surf->vertices[vtx].area;
        }
        else if (!strcmp(Field,"group_avg_area"))
        {
          val = surf->vertices[vtx].group_avg_area;
        }
        else if (!strcmp(Field,"K"))
        {
          val = surf->vertices[vtx].K;
        }
        else if (!strcmp(Field,"H"))
        {
          val = surf->vertices[vtx].H;
        }
        else if (!strcmp(Field,"k1"))
        {
          val = surf->vertices[vtx].k1;
        }
        else if (!strcmp(Field,"k2"))
        {
          val = surf->vertices[vtx].k2;
        }
        else if (!strcmp(Field,"nx"))
        {
          val = surf->vertices[vtx].nx;
        }
        else if (!strcmp(Field,"ny"))
        {
          val = surf->vertices[vtx].ny;
        }
        else if (!strcmp(Field,"nz"))
        {
          val = surf->vertices[vtx].nz;
        }
        else if (!strcmp(Field,"tx"))
        {
          val = surf->vertices[vtx].tx;
        }
        else if (!strcmp(Field,"ty"))
        {
          val = surf->vertices[vtx].ty;
        }
        else if (!strcmp(Field,"tz"))
        {
          val = surf->vertices[vtx].tz;
        }
        else if (!strcmp(Field,"tdx"))
        {
          val = surf->vertices[vtx].tdx;
        }
        else if (!strcmp(Field,"tdy"))
        {
          val = surf->vertices[vtx].tdy;
        }
        else if (!strcmp(Field,"tdz"))
        {
          val = surf->vertices[vtx].tdz;
        }
        else if (!strcmp(Field,"dx"))
        {
          val = surf->vertices[vtx].dx;
        }
        else if (!strcmp(Field,"dy"))
        {
          val = surf->vertices[vtx].dy;
        }
        else if (!strcmp(Field,"dz"))
        {
          val = surf->vertices[vtx].dz;
        }
        else
        {
          printf("ERROR: MRIScopyMRI(): Field %s not supported\n",Field);
          return(NULL);
        }
        MRIsetVoxVal(mri, c, r, s, Frame, val);
        vtx++;
      }
    }
  }
  return(mri);
}
/*-------------------------------------------------------------------
  MRISsmoothMRI() - smooths values on the surface when the surface
  values are stored in an MRI_VOLUME structure with the number of
  spatial voxels equal to the number of nvertices on the surface. Can
  handle multiple frames. Can be performed in-place. If Targ is NULL,
  it will automatically allocate a new MRI structure. Note that the
  input MRI struct does not have to have any particular configuration
  of cols, rows, and slices as long as the product equals nvertices.
  Does not smooth data from ripped vertices into unripped vertices
  (but does go the other way). Same for mask. If mask is NULL, it
  is ignored. See also MRISsmoothMRIFast()
  -------------------------------------------------------------------*/
MRI *MRISsmoothMRI(MRIS *Surf,
                   MRI *Src,
                   int nSmoothSteps,
                   MRI *BinMask,
                   MRI *Targ)
{
  int nnbrs, nthstep, frame, vtx, nbrvtx, nthnbr, **crslut, c,r,s, nvox;
  int nnbrs_actual;
  float val,m;
  MRI *SrcTmp;
  struct timeb  mytimer;
  int msecTime;
  char *UFSS;

  // Must explicity "setenv USE_FAST_SURF_SMOOTHER 0" to turn off fast
  UFSS = getenv("USE_FAST_SURF_SMOOTHER");
  if(!UFSS)
  {
    UFSS = "1";
  }
  if(strcmp(UFSS,"0"))
  {
    Targ = MRISsmoothMRIFast(Surf,Src,nSmoothSteps,BinMask,Targ);
    return(Targ);
  }
  if(Gdiag_no > 0)
  {
    printf("MRISsmoothMRI()\n");
  }

  nvox = Src->width * Src->height * Src->depth;
  if (Surf->nvertices != nvox)
  {
    printf("ERROR: MRISsmooth: Surf/Src dimension mismatch\n");
    return(NULL);
  }

  //Build LUT to map from col,row,slice to vertex
  crslut = MRIScrsLUT(Surf, Src);

  if(Targ == NULL)
  {
    Targ = MRIallocSequence(Src->width, Src->height, Src->depth,
                            MRI_FLOAT, Src->nframes);
    if (Targ==NULL)
    {
      printf("ERROR: MRISsmooth: could not alloc\n");
      return(NULL);
    }
    MRIcopyHeader(Src,Targ);
  }
  else
  {
    if(Src->width   != Targ->width  ||
        Src->height  != Targ->height ||
        Src->depth   != Targ->depth  ||
        Src->nframes != Targ->nframes)
    {
      printf("ERROR: MRISsmooth: output dimension mismatch\n");
      return(NULL);
    }
    if(Targ->type != MRI_FLOAT)
    {
      printf("ERROR: MRISsmooth: structure passed is not MRI_FLOAT\n");
      return(NULL);
    }
  }

  /*------------------------------------------------------------*/
  TimerStart(&mytimer) ;
  SrcTmp = MRIcopy(Src,NULL);
  for (nthstep = 0; nthstep < nSmoothSteps; nthstep ++)
  {
    if (Gdiag_no > 1)
    {
      msecTime = TimerStop(&mytimer) ;
      printf("Step = %d, tsec = %g\n",nthstep,msecTime/1000.0);
      fflush(stdout);
    }

    for (vtx = 0; vtx < Surf->nvertices; vtx++)
    {
      nnbrs = Surf->vertices[vtx].vnum;
      c = crslut[0][vtx];
      r = crslut[1][vtx];
      s = crslut[2][vtx];
      if(BinMask)
      {
        m = MRIgetVoxVal(BinMask,c,r,s,0);
        if (m < 0.5)
        {
          for (frame = 0; frame < Targ->nframes; frame ++)
          {
            MRIFseq_vox(Targ,c,r,s,frame) = 0;
          }
          continue;
        }
      }
      for(frame = 0; frame < Targ->nframes; frame ++)
      {
        val = MRIFseq_vox(SrcTmp,c,r,s,frame);

        nnbrs_actual = 0;
        for(nthnbr = 0; nthnbr < nnbrs; nthnbr++)
        {
          nbrvtx = Surf->vertices[vtx].v[nthnbr];
          if(Surf->vertices[nbrvtx].ripflag)
          {
            continue;  //skip ripped vtxs
          }
          // check mask
          if(BinMask)
          {
            m = MRIgetVoxVal(BinMask,crslut[0][nbrvtx],
                             crslut[1][nbrvtx],crslut[2][nbrvtx],0);
            if (m < 0.5)
            {
              continue;
            }
          }
          val += MRIFseq_vox(SrcTmp,crslut[0][nbrvtx],
                             crslut[1][nbrvtx],crslut[2][nbrvtx],frame);
          nnbrs_actual++;
        }/* end loop over neighbor */

        MRIFseq_vox(Targ,c,r,s,frame) = (val/(nnbrs_actual+1));
      }/* end loop over frame */

    } /* end loop over vertex */

    MRIcopy(Targ,SrcTmp);
  }/* end loop over smooth step */

  msecTime = TimerStop(&mytimer) ;
  if(Gdiag_no > 0)
  {
    printf("Smoothing done, nsteps = %d, tsec = %g\n",nthstep,msecTime/1000.0);
  }
  fflush(stdout);

  MRIfree(&SrcTmp);
  MRIScrsLUTFree(crslut);
  return(Targ);
}
/*-------------------------------------------------------------------
  MRISsmoothMRIFast() - faster version of MRISsmoothMRI(). Smooths
  values on the surface when the surface values are stored in an
  MRI_VOLUME structure with the number of spatial voxels equal to the
  number of nvertices on the surface. Can handle multiple frames. Can
  be performed in-place. If Targ is NULL, it will automatically
  allocate a new MRI structure. Note that the input MRI struct does
  not have to have any particular configuration of cols, rows, and
  slices as long as the product equals nvertices.  Does not smooth
  data from ripped vertices into unripped vertices (but does go the
  other way). Same for mask. The mask is inclusive, so voxels with
  mask=1 are included. If mask is NULL, it is ignored. Gives identical
  results as MRISsmoothMRI(); see MRISsmoothMRIFastCheck().
  -------------------------------------------------------------------*/
MRI *MRISsmoothMRIFast(MRIS *Surf, MRI *Src, int nSmoothSteps, MRI *IncMask,  MRI *Targ)
{
  int nnbrs, nthstep, frame, vno, nthnbr, num, nvox, nbrvno,reshape;
  MRI *SrcTmp,*mritmp,*IncMaskTmp=NULL;
  struct timeb  mytimer;
  int msecTime;
  int *nNbrs, *nNbrs0, *rip, *rip0, nNbrsMax;
  float **pF, **pF0, *tF, *tF0, sumF;
  VERTEX *v, *vn;

  if(Gdiag_no > 0) printf("MRISsmoothMRIFast()\n");

  nvox = Src->width * Src->height * Src->depth;
  if (Surf->nvertices != nvox){
    printf("ERROR: MRISsmoothMRIFast(): Surf/Src dimension mismatch\n");
    return(NULL);
  }
  if(IncMask){
    if(IncMask->width * IncMask->height * IncMask->depth != nvox){
      printf("ERROR: MRISsmoothMRIFast(): Surf/Mask dimension mismatch\n");
      return(NULL);      
    }
    if(IncMask->width != nvox) IncMaskTmp = mri_reshape(IncMask, nvox, 1, 1, IncMask->nframes);
    else                       IncMaskTmp = MRIcopy(IncMask,NULL);
  }
  // Reshape the source if needed
  if(Src->width != nvox){
    if(Gdiag_no > 0) printf("MRISsmoothMRIFast(): reshaping\n");
    SrcTmp = mri_reshape(Src, nvox, 1, 1, Src->nframes);
    reshape = 1;
  } 
  else{
    reshape = 0;
    SrcTmp = MRIcopy(Src,NULL);
  }
  if(Targ != NULL){
    if(MRIdimMismatch(Src,Targ,1)){
      printf("ERROR: MRISsmoothFast(): output dimension mismatch\n");
      return(NULL);
    }
    if(Targ->type != MRI_FLOAT){
      printf("ERROR: MRISsmoothFast(): structure passed is not MRI_FLOAT\n");
      return(NULL);
    }
  }

  // Alloc arrays. If there are ripped vertices, then only rip
  // needs nvertices elements
  nNbrsMax = 12; // Should measure this, but overalloc does not hurt
  pF = (float **) calloc(Surf->nvertices*nNbrsMax,sizeof(float *));
  tF = (float *)  calloc(Surf->nvertices,sizeof(float));
  nNbrs = (int *) calloc(Surf->nvertices,sizeof(int));
  rip = (int *)   calloc(Surf->nvertices,sizeof(int));

  pF0 = pF;
  tF0 = tF;
  rip0 = rip;
  nNbrs0 = nNbrs;

  TimerStart(&mytimer) ;

  // Loop through frames
  for (frame = 0; frame < Src->nframes; frame ++)
  {

    // Set up pointers for this frame
    pF = pF0;
    rip = rip0;
    nNbrs = nNbrs0;
    for (vno = 0 ; vno < Surf->nvertices ; vno++)
    {
      v = &Surf->vertices[vno] ;
      if(IncMaskTmp && MRIgetVoxVal(IncMaskTmp,vno,0,0,0) < 0.5)
      {
        // Mask is inclusive, so look for out of mask
        // should exclude rips here too? Original does not.
        rip[vno] = 1;
        MRIFseq_vox(SrcTmp,vno,0,0,frame) = 0;
        continue ;
      }
      rip[vno] = 0;
      *pF++ = (float *)(&(MRIFseq_vox(SrcTmp,vno,0,0,frame)));
      nnbrs = Surf->vertices[vno].vnum;
      num = 1;
      for (nthnbr = 0 ; nthnbr < nnbrs ; nthnbr++)
      {
        nbrvno = Surf->vertices[vno].v[nthnbr];
        vn = &Surf->vertices[nbrvno] ;
        if(vn->ripflag)
        {
          continue ;
        }
        if(IncMaskTmp && MRIgetVoxVal(IncMaskTmp,nbrvno,0,0,0) < 0.5)
        {
          continue ;
        }
        *pF++ = (float *)(&(MRIFseq_vox(SrcTmp,nbrvno,0,0,frame)));
        num++ ;
      }
      *nNbrs++ = num; // num takes into account all rips/masks
    }

    // Step through the iterations
    for(nthstep = 0; nthstep < nSmoothSteps; nthstep++)
    {
      // Init pointers for this iteration
      pF  = pF0;
      rip = rip0;
      tF  = tF0;
      nNbrs = nNbrs0;
      // Loop through vertices, average nearest neighbors
      for (vno = 0 ; vno < Surf->nvertices ; vno++)
      {
        if(*rip++)
        {
          continue ;
        }
        sumF = *(*pF++);
        for(nthnbr = 0 ; nthnbr < (*nNbrs)-1 ; nthnbr++)
        {
          sumF += *(*pF++);
        }
        *tF++ = sumF/(*nNbrs);
        nNbrs++;
      }
      // Load up for the next step
      rip = rip0;
      tF  = tF0;
      for (vno = 0 ; vno < Surf->nvertices ; vno++)
      {
        if(*rip++)
        {
          continue ;
        }
        MRIsetVoxVal(SrcTmp,vno,0,0,frame, *tF++);
      }
    }

  }/* end loop over frame */

  // Copy to the output
  if(reshape){
    if(Gdiag_no > 0) printf("MRISsmoothFast() reshaping again\n");
    mritmp = mri_reshape(SrcTmp, Src->width, Src->height, Src->depth, Src->nframes);
    Targ = MRIcopy(mritmp,Targ);
    MRIfree(&mritmp);
  }
  else Targ = MRIcopy(SrcTmp,Targ);

  msecTime = TimerStop(&mytimer) ;
  if(Gdiag_no > 0)
  {
    printf("MRISsmoothFast() nsteps = %d, tsec = %g\n",nSmoothSteps,msecTime/1000.0);
    fflush(stdout);
  }

  MRIfree(&SrcTmp);
  if(IncMaskTmp) MRIfree(&IncMaskTmp);
  free(pF0);
  free(tF0);
  free(rip0);
  free(nNbrs0);

  return(Targ);
}

/*-------------------------------------------------------------------
  MRISsmoothMRIFastD() - basically the same thing as MRISsmoothMRIFasD()
  but uses a double array internally to reduce accumulation errors.
  Tests indicate that there is not much difference between using
  float or using double (and this function is slower than the float
  version).
  -------------------------------------------------------------------*/
MRI *MRISsmoothMRIFastD(MRIS *Surf, MRI *Src, int nSmoothSteps, MRI *IncMask,  MRI *Targ)
{
  int nnbrs, nthstep, frame, vno, nthnbr, num, nvox, nbrvno,c,r,s;
  MRI *IncMaskTmp=NULL;
  struct timeb  mytimer;
  int msecTime;
  int *nNbrs, *nNbrs0, *rip, *rip0, nNbrsMax;
  double **pF, **pF0, *tF, *tF0, sumF;
  double *pD, *pD0;
  VERTEX *v, *vn;

  if(Gdiag_no > 0) printf("MRISsmoothMRIFastD()\n");

  nvox = Src->width * Src->height * Src->depth;
  if (Surf->nvertices != nvox){
    printf("ERROR: MRISsmoothMRIFastD(): Surf/Src dimension mismatch\n");
    return(NULL);
  }
  if(IncMask){
    if(IncMask->width * IncMask->height * IncMask->depth != nvox){
      printf("ERROR: MRISsmoothMRIFastD(): Surf/Mask dimension mismatch\n");
      return(NULL);      
    }
    if(IncMask->width != nvox) IncMaskTmp = mri_reshape(IncMask, nvox, 1, 1, IncMask->nframes);
    else                       IncMaskTmp = MRIcopy(IncMask,NULL);
  }
  if(Targ == NULL){
    Targ = MRIallocSequence(Src->width,Src->height,Src->depth,MRI_FLOAT,Src->nframes);
    if(Targ==NULL){
      printf("ERROR: MRISsmoothMRIFastD(): could not alloc\n");
      return(NULL);
    }
    MRIcopyHeader(Src,Targ);
  }
  if(MRIdimMismatch(Src,Targ,1)){
    printf("ERROR: MRISsmoothFastD(): output dimension mismatch\n");
    return(NULL);
  }
  if(Targ->type != MRI_FLOAT){
    printf("ERROR: MRISsmoothFastD(): structure passed is not MRI_FLOAT\n");
    return(NULL);
  }

  // Alloc arrays. If there are ripped vertices, then only rip
  // needs nvertices elements
  nNbrsMax = 12; // Should measure this, but overalloc does not hurt
  pF = (double **) calloc(Surf->nvertices*nNbrsMax,sizeof(double *));
  tF = (double *)  calloc(Surf->nvertices,sizeof(double));
  nNbrs = (int *) calloc(Surf->nvertices,sizeof(int));
  rip = (int *)   calloc(Surf->nvertices,sizeof(int));
  pD  = (double *) calloc(Surf->nvertices,sizeof(double));

  pF0 = pF;
  tF0 = tF;
  rip0 = rip;
  nNbrs0 = nNbrs;
  pD0 = pD;

  TimerStart(&mytimer) ;

  // Loop through frames
  for (frame = 0; frame < Src->nframes; frame ++) {

    // Set up pointers for this frame
    pD = pD0;
    pF = pF0;
    rip = rip0;
    nNbrs = nNbrs0;
    for (vno = 0 ; vno < Surf->nvertices ; vno++){
      v = &Surf->vertices[vno] ;
      if(IncMaskTmp && MRIgetVoxVal(IncMaskTmp,vno,0,0,0) < 0.5) {
        // Mask is inclusive, so look for out of mask
        // should exclude rips here too? Original does not.
        rip[vno] = 1;
	*pD++ = 0;
        continue ;
      }
      *pD++ = MRIgetVoxVal(Src,vno,0,0,frame);
      *pF++ = (double *)(&(pD0[vno]));
      rip[vno] = 0;
      nnbrs = Surf->vertices[vno].vnum;
      num = 1;
      for (nthnbr = 0 ; nthnbr < nnbrs ; nthnbr++){
        nbrvno = Surf->vertices[vno].v[nthnbr];
        vn = &Surf->vertices[nbrvno] ;
        if(vn->ripflag) continue ;
        if(IncMaskTmp && MRIgetVoxVal(IncMaskTmp,nbrvno,0,0,0) < 0.5) continue ;
        *pF++ = (double *)(&(pD0[nbrvno]));
	num++ ;
      }
      *nNbrs++ = num; // num takes into account all rips/masks
    }

    // Step through the iterations
    for(nthstep = 0; nthstep < nSmoothSteps; nthstep++){
      // Init pointers for this iteration
      pF  = pF0;
      rip = rip0;
      tF  = tF0;
      nNbrs = nNbrs0;
      // Loop through vertices, average nearest neighbors
      for (vno = 0 ; vno < Surf->nvertices ; vno++){
        if(*rip++) continue ;
        sumF = *(*pF++);
        for(nthnbr = 0 ; nthnbr < (*nNbrs)-1 ; nthnbr++) sumF += *(*pF++);
        *tF++ = sumF/(*nNbrs);
        nNbrs++;
      }
      // Load up for the next step
      rip = rip0;
      tF  = tF0;
      for (vno = 0 ; vno < Surf->nvertices ; vno++){
        if(*rip++) continue ;
	pD0[vno] = *tF++;
      }
    } // end iteration steps
    
    // Pack output back into MRI structure (float)
    pD = pD0;
    for(c=0; c < Targ->width; c++) {
      for(r=0; r < Targ->height; r++) {
	for(s=0; s < Targ->depth; s++) {
	  MRIsetVoxVal(Targ,c,r,s,frame,(*pD));
	  pD++;
	}
      }
    }

  }/* end loop over frame */

  msecTime = TimerStop(&mytimer) ;
  if(Gdiag_no > 0){
    printf("MRISsmoothFastD() nsteps = %d, tsec = %g\n",nSmoothSteps,msecTime/1000.0);
    fflush(stdout);
  }

  if(IncMaskTmp) MRIfree(&IncMaskTmp);
  free(pF0);
  free(tF0);
  free(rip0);
  free(nNbrs0);
  free(pD0);

  return(Targ);
}

/*------------------------------------------------------------------
  MRISsmoothMRIFastFrame() same as MRISsmoothMRIFast() but operates
  on a single frame. This allows the pointers to be cached in
  a static data structure. Note: this will fail if Src is not
  nvertices x 1 x 1 x nframes.
  ------------------------------------------------------------------*/
int MRISsmoothMRIFastFrame(MRIS *Surf, MRI *Src, int frame, int nSmoothSteps, MRI *IncMask)
{
  int nnbrs, nthstep, vno, nthnbr, num, nvox, nbrvno;
  struct timeb  mytimer;
  int msecTime;
  float sumF;
  VERTEX *v, *vn;
  static MRIS *SurfInit = NULL;
  static MRI *SrcInit = NULL;
  static int DoInit=1, frameInit=0, *nNbrs=NULL, *nNbrs0=NULL, *rip=NULL, *rip0=NULL, nNbrsMax=0;
  static float **pF=NULL, **pF0=NULL, *tF=NULL, *tF0=NULL;

  if(Gdiag_no > 0) printf("MRISsmoothMRIFastFrame()\n");

  if(DoInit)
  {
    if(Gdiag_no > 0)
    {
      printf("MRISsmoothMRIFastFrame() Init\n");
    }
    nvox = Src->width * Src->height * Src->depth;
    if (Surf->nvertices != nvox)
    {
      printf("ERROR: MRISsmoothMRIFastFrame(): Surf/Src dimension mismatch\n");
      return(1);
    }
    // Alloc arrays. If there are ripped vertices, then only rip
    // needs nvertices elements
    nNbrsMax = 12; // Should measure this, but overalloc does not hurt
    pF = (float **) calloc(Surf->nvertices*nNbrsMax,sizeof(float *));
    tF = (float *)  calloc(Surf->nvertices,sizeof(float));
    nNbrs = (int *) calloc(Surf->nvertices,sizeof(int));
    rip = (int *) calloc(Surf->nvertices,sizeof(int));
    pF0 = pF;
    tF0 = tF;
    rip0 = rip;
    nNbrs0 = nNbrs;
    SrcInit = Src;
    SurfInit = Surf;
    frameInit = frame;
    DoInit = 0;
  }
  if(Src != SrcInit)
  {
    printf("ERROR: Src and SrcInit do not agree\n");
    exit(1);
  }
  if(Surf != SurfInit)
  {
    printf("ERROR: Surf and SurfInit do not agree\n");
    exit(1);
  }
  if(frame != frameInit)
  {
    printf("ERROR: frame and frameInit do not agree\n");
    exit(1);
  }

  TimerStart(&mytimer) ;

  // Set up pointers for this call
  pF = pF0;
  rip = rip0;
  nNbrs = nNbrs0;
  for (vno = 0 ; vno < Surf->nvertices ; vno++)
  {
    v = &Surf->vertices[vno] ;
    if(IncMask && MRIgetVoxVal(IncMask,vno,0,0,0) < 0.5)
    {
      // Mask is inclusive, so look for out of mask
      // should exclude rips here too? Original does not.
      rip[vno] = 1;
      MRIFseq_vox(Src,vno,0,0,frame) = 0;
      continue ;
    }
    rip[vno] = 0;
    *pF++ = (float *)(&(MRIFseq_vox(Src,vno,0,0,frame)));
    nnbrs = Surf->vertices[vno].vnum;
    num = 1;
    for (nthnbr = 0 ; nthnbr < nnbrs ; nthnbr++)
    {
      nbrvno = Surf->vertices[vno].v[nthnbr];
      vn = &Surf->vertices[nbrvno] ;
      if(vn->ripflag)
      {
        continue ;
      }
      if(IncMask && MRIgetVoxVal(IncMask,nbrvno,0,0,0) < 0.5)
      {
        continue ;
      }
      *pF++ = (float *)(&(MRIFseq_vox(Src,nbrvno,0,0,frame)));
      num++ ;
    }
    *nNbrs++ = num; // num takes into account all rips/masks
  }

  // Step through the iterations
  for(nthstep = 0; nthstep < nSmoothSteps; nthstep++)
  {
    // Init pointers for this iteration
    pF  = pF0;
    rip = rip0;
    tF  = tF0;
    nNbrs = nNbrs0;
    // Loop through vertices, average nearest neighbors
    for (vno = 0 ; vno < Surf->nvertices ; vno++)
    {
      if(*rip++)
      {
        continue ;
      }
      sumF = *(*pF++);
      for(nthnbr = 0 ; nthnbr < (*nNbrs)-1 ; nthnbr++)
      {
        sumF += *(*pF++);
      }
      *tF++ = sumF/(*nNbrs);
      nNbrs++;
    }
    // Load up for the next step
    rip = rip0;
    tF  = tF0;
    for (vno = 0 ; vno < Surf->nvertices ; vno++)
    {
      if(*rip++)
      {
        continue ;
      }
      MRIsetVoxVal(Src,vno,0,0,frame, *tF++);
    }
  }

  msecTime = TimerStop(&mytimer) ;
  if(Gdiag_no > 0)
  {
    printf("MRISsmoothFast2() nsteps = %d, tsec = %g\n",nSmoothSteps,msecTime/1000.0);
    fflush(stdout);
  }

  return(0);
}
/*--------------------------------------------------------------*/
int MRISsmoothMRIFastCheck(int nSmoothSteps)
{
  char tmpstr[2000], *UFSS;
  MRIS *mris;
  MRI *src, *mri1, *mri2, *mask;
  int k,nerrs,c,r,s,f, cmax, rmax, smax, fmax;
  float val1, val2, diff,maxdiff;

  // Make sure to turn off override (restored later)
  UFSS = getenv("USE_FAST_SURF_SMOOTHER");
  setenv("USE_FAST_SURF_SMOOTHER","0",1);

  printf("MRISsmoothMRIFastCheck() nSmoothSteps = %d\n",nSmoothSteps);

  sprintf(tmpstr,"%s/subjects/fsaverage/surf/lh.white",getenv("FREESURFER_HOME"));
  printf("Reading surface %s\n",tmpstr);
  mris = MRISread(tmpstr);
  if(mris == NULL)
  {
    printf("ERROR: could not read %s\n",tmpstr);
    return(-1);
  }

  // Use 3 frames
  src = MRIrandn(mris->nvertices, 1, 1, 3, .5, 1, NULL);

  // Create mask
  mask = MRIconst(mris->nvertices, 1, 1, 1, 1.0, NULL);
  for(k=0; k < mris->nvertices-1; k++)
  {
    MRIsetVoxVal(mask,k,0,0,0, 0.0); // turn off mask
    mris->vertices[k+1].ripflag = 1; // rip a few
  }

  printf("Running slow smoother\n");
  mri1 = MRISsmoothMRI(mris, src, nSmoothSteps, mask, NULL);
  printf("Running fast smoother\n");
  mri2 = MRISsmoothMRIFast(mris, src, nSmoothSteps, mask, NULL);

  printf("Checking differences\n");
  nerrs = 0;
  cmax = 0;
  rmax = 0;
  smax = 0;
  fmax = 0;
  maxdiff = 0.0;
  for (c=0; c < src->width; c++)
  {
    for (r=0; r < src->height; r++)
    {
      for (s=0; s < src->depth; s++)
      {
        for (f=0; f < src->nframes; f++)
        {
          val1 = MRIgetVoxVal(mri1,c,r,s,f);
          val2 = MRIgetVoxVal(mri2,c,r,s,f);
          diff = val1-val2;
          if(fabs(maxdiff) < fabs(diff))
          {
            maxdiff = diff;
            cmax = c;
            rmax = r;
            smax = s;
            fmax = f;
          }
          if(!FZERO(diff))
          {
            nerrs++;
          }
        }
      }
    }
  }
  printf("nerrs = %d, maxdiff %f at %d %d %d %d\n",nerrs, maxdiff,cmax,rmax,smax,fmax);

  setenv("USE_FAST_SURF_SMOOTHER",UFSS,1);

  return(nerrs);
}






/*-----------------------------------------------------------------------
  MRISar1() - computes spatial AR1 at each vertex by averaging the AR1s
  within the neighborhood of a vertex. Note: does not try to take into
  account different distances between neighbors. Note: theoretical AR1
  for one smoothing step is 4/7=0.57.
  -----------------------------------------------------------------------*/
MRI *MRISar1(MRIS *surf, MRI *src, MRI *mask, MRI *ar1)
{
  int nnbrs, frame, vtx, nbrvtx, nthnbr, **crslut, c,r,s, nvox;
  int cnbr, rnbr,snbr, nnbrs_actual;
  float valvtx, valnbr, ar1sum, sumsqvtx, vtxvar, sumsqnbr, sumsqx, nbrvar;

  nvox = src->width * src->height * src->depth;
  if (surf->nvertices != nvox)
  {
    printf("ERROR: MRISar1: Surf/Src dimension mismatch.\n");
    return(NULL);
  }

  if (ar1 == NULL)
  {
    ar1 = MRIcloneBySpace(src, MRI_FLOAT, 1);
    if (ar1 == NULL)
    {
      printf("ERROR: could not alloc\n");
      return(NULL);
    }
  }

  //Build LUT to map from col,row,slice to vertex
  crslut = MRIScrsLUT(surf,src);

  for (vtx = 0; vtx < surf->nvertices; vtx++)
  {
    if (surf->vertices[vtx].ripflag)
    {
      continue;
    }

    c = crslut[0][vtx];
    r = crslut[1][vtx];
    s = crslut[2][vtx];
    if (mask) if (MRIgetVoxVal(mask,c,r,s,0) < 0.5)
      {
        continue;
      }

    nnbrs = surf->vertices[vtx].vnum;
    sumsqvtx = 0;
    for (frame = 0; frame < src->nframes; frame ++)
    {
      valvtx = MRIFseq_vox(src,c,r,s,frame);
      sumsqvtx += (valvtx*valvtx);
    }
    if (sumsqvtx == 0)
    {
      continue;  // exclude voxels with 0 variance
    }
    vtxvar = sumsqvtx/src->nframes;

    nnbrs_actual = 0;
    ar1sum = 0;
    for (nthnbr = 0; nthnbr < nnbrs; nthnbr++)
    {
      nbrvtx = surf->vertices[vtx].v[nthnbr];
      if (surf->vertices[nbrvtx].ripflag)
      {
        continue;
      }
      cnbr = crslut[0][nbrvtx];
      rnbr = crslut[1][nbrvtx];
      snbr = crslut[2][nbrvtx];
      if (mask) if (MRIgetVoxVal(mask,cnbr,rnbr,snbr,0) < 0.5)
        {
          continue;
        }
      sumsqnbr = 0;
      sumsqx   = 0;
      for (frame = 0; frame < src->nframes; frame ++)
      {
        valvtx = MRIFseq_vox(src,c,r,s,frame);
        valnbr = MRIFseq_vox(src,cnbr,rnbr,snbr,frame);
        sumsqnbr += (valnbr*valnbr);
        sumsqx   += (valvtx*valnbr);
      }
      if (sumsqnbr==0)
      {
        continue;
      }
      nbrvar = sumsqnbr/src->nframes;
      ar1sum += (sumsqx/src->nframes)/sqrt(vtxvar*nbrvar);
      nnbrs_actual ++;
    }/* end loop over neighbor */

    if (nnbrs_actual != 0) //bug fix
    {
      MRIFseq_vox(ar1,c,r,s,0) = (ar1sum/nnbrs_actual);
    }
  } /* end loop over vertex */

  MRIScrsLUTFree(crslut);
  return(ar1);
}
/*---------------------------------------------------------------
  MRIScrsLUT() - constructs a lookup table to quickly map from
  a vertex to the col, row, slice in an MRI struct, where the
  MRI struct has ncols*nrows*nslices = nvertices.
  See also MRIScrsLUTFee().
  ---------------------------------------------------------------*/
int **MRIScrsLUT(MRIS *surf, MRI *src)
{
  int **crslut,c,r,s,nvox,vtx;
  crslut = (int **) calloc(3,sizeof(int*));

  nvox = src->width * src->height * src->depth;
  if (surf->nvertices != nvox)
  {
    printf("ERROR: MRIScrsLUT: surf/src dimension mismatch.\n");
    return(NULL);
  }

  crslut[0] = (int *) calloc(nvox,sizeof(int));
  crslut[1] = (int *) calloc(nvox,sizeof(int));
  crslut[2] = (int *) calloc(nvox,sizeof(int));
  vtx = 0;
  for (s=0; s < src->depth; s++)
  {
    for (r=0; r < src->height; r++)
    {
      for (c=0; c < src->width; c++)
      {
        // Do columns fastest
        crslut[0][vtx] = c;
        crslut[1][vtx] = r;
        crslut[2][vtx] = s;
        vtx++;
      }
    }
  }
  return(crslut);
}
/*----------------------------------------------------------
  MRIScrsLUTFree() - frees memoary allocated by MRIScrsLUT.
  ----------------------------------------------------------*/
int MRIScrsLUTFree(int **crslut)
{
  free(crslut[0]);
  free(crslut[1]);
  free(crslut[2]);
  free(crslut);
  return(0);
}

/*-------------------------------------------------------------------
  MRISremoveRippedFromMask() - sets voxels in mask to 0 if corresponding
  vertex has been ripped.
  -------------------------------------------------------------------*/
MRI *MRISremoveRippedFromMask(MRIS *surf, MRI *mask, MRI *outmask)
{
  int c,r,s,vtx;
  outmask = MRIcopy(mask,outmask);
  vtx = 0;
  for (s=0; s < mask->depth; s++)
  {
    for (r=0; r < mask->height; r++)
    {
      for (c=0; c < mask->width; c++)
      {
        if (surf->vertices[vtx].ripflag)
        {
          MRIsetVoxVal(outmask,c,r,s,0,0.0);
        }
        vtx++;
      }
    }
  }
  return(outmask);
}
/*------------------------------------------------------------------
  MRISlabel2Mask() - creates a mask from the label by setting each
  voxel corresponding to a label point to 1 with the rest 0.
  ------------------------------------------------------------------*/
MRI *MRISlabel2Mask(MRIS *surf, LABEL *lb, MRI *mask)
{
  int vtxno, n;

  if (mask == NULL) // create mask as all 0s
  {
    mask = MRIconst(surf->nvertices,1,1,1,0,NULL);
  }

  for (n=0; n < lb->n_points; n++)
  {
    vtxno = lb->lv[n].vno;
    if(vtxno >= surf->nvertices)
    {
      printf("ERROR: MRISlabel2Mask(): label vertex %d is >= nvertices %d\n",
             vtxno, surf->nvertices);
      fflush(stdout);
      return(NULL);
    }
    MRIsetVoxVal(mask, vtxno,0,0,0, 1);
  }
  return(mask);
}


/*----------------------------------------------------------------------*/
int MRISrectifyCurvature(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->curv = fabs(v->curv) ;
  }
  mrisComputeCurvatureMinMax(mris) ;
  return(NO_ERROR) ;
}


#if 0
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static double
mrisAsynchronousTimeStep(MRI_SURFACE *mris, float momentum,
                         float delta_t, MHT *mht, float max_mag)
{
  static int direction = 1 ;
  double  mag, biggest_norm, scale ;
  int     vno, i, j ;
  VERTEX  *v ;
  static  int *vlist = NULL, *cropped ;
  static int nvertices = 0, ncropped = 0 ;

  if (mris->nvertices > nvertices)
  {
    if (vlist != NULL)
    {
      free(vlist) ;
    }
    vlist = (int *)calloc(mris->nvertices, sizeof(int)) ;
    cropped = (int *)calloc(mris->nvertices, sizeof(int)) ;
    nvertices = mris->nvertices ;
    if (!vlist || !cropped)
      ErrorExit
      (ERROR_NOMEMORY,
       "mrisAsynchronousTimeStep: could not allocate %d len buffers",
       nvertices) ;
  }

  /* take a step in the gradient direction modulated by momentum */
  if (mris->status == MRIS_RIGID_BODY)
  {
    mris->da = delta_t * mris->alpha + momentum * mris->da ;
    mris->db = delta_t * mris->beta + momentum * mris->db ;
    mris->dg = delta_t * mris->gamma + momentum * mris->dg ;
    MRISrotate(mris, mris, mris->da, mris->db, mris->dg) ;
  }
  else
  {
    /* build a permutation of the vertex numbers */
    MRISclearMarks(mris) ;
    for (i = 0 ; i < ncropped ; i++)
    {
      v = &mris->vertices[cropped[i]] ;
      v->marked = 1 ;
      vlist[i] = cropped[i] ;
    }

    markAllDistantConvex(mris, 4*max_mag) ; /* if distant, v->marked += 2 */
    for (vno = 0, i = ncropped ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->marked != 2)
      {
        continue ;  /* was cropped - already added */
      }
      vlist[ncropped] = vno ;
      ncropped++ ;
    }

    for (vno = 0, i = ncropped ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->marked)
      {
        continue ;  /* was cropped - already added */
      }
      vlist[i] = vno ;
      i++ ;
    }

    for (i = 0 ; i < mris->nvertices ; i++)
    {
      v = &mris->vertices[vlist[i]] ;
      if (v->marked)
      {
        continue ;  /* don't let this one be swapped */
      }
      j = randomNumber(0, mris->nvertices-1) ;
      if (mris->vertices[vlist[j]].marked)
      {
        continue ;
      }
      vno = vlist[i] ;
      vlist[i] = vlist[j] ;
      vlist[j] = vno ;
    }

    ncropped = 0 ;
    biggest_norm = 0.0 ;
    for (i = 0 ; i < mris->nvertices ; i++)
    {
      vno = vlist[i] ;
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      v->odx = delta_t * v->dx + momentum*v->odx ;
      v->ody = delta_t * v->dy + momentum*v->ody ;
      v->odz = delta_t * v->dz + momentum*v->odz ;
      mag = sqrt(v->odx*v->odx + v->ody*v->ody + v->odz*v->odz) ;
      if (mag > biggest_norm)
      {
        biggest_norm = mag ;
      }
    }
    scale = max_mag / biggest_norm ;
#define MIN_SCALE (1.0/15.0)
    if (scale < MIN_SCALE)
    {
      scale = MIN_SCALE ;
    }
    for (i = 0 ; i < mris->nvertices ; i++)
    {
      vno = vlist[i] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      v = &mris->vertices[vno] ;
      mag = sqrt(v->odx*v->odx + v->ody*v->ody + v->odz*v->odz) ;
#if 1
      if (mag > max_mag) /* don't let step get too big */
      {
        mag = max_mag / mag ;
        if (v->marked)
        {
          mag *= 2 ;
        }   /* move distant convex vertices
                          twice as far to avoid pinches */
      }
      else
      {
        mag = 1 ;
      }
#else
      if (mag * scale > max_mag)
      {
        mag = max_mag/mag ;
      }
      else
      {
        mag = scale ;
      }
#endif
      v->odx *= mag ;
      v->ody *= mag ;
      v->odz *= mag ;

      /* erase the faces this vertex is part of */
#if 0
      for (fno = 0 ; fno < v->num ; fno++)
      {
        mrisEraseFace(mris, mri_filled, v->f[fno]) ;
      }
#else
      if (mht)
      {
        MHTremoveAllFaces(mht, mris, v) ;
      }
#endif

      if (mht)
      {
        if (mrisLimitGradientDistance(mris, mht, vno) > 0)
        {
          if (vno == Gdiag_no)
          {
            DiagBreak() ;
          }
          cropped[ncropped++] = vno ;
        }
      }

      mag = sqrt(v->odx*v->odx + v->ody*v->ody + v->odz*v->odz) ;
      v->x += v->odx ;
      v->y += v->ody ;
      v->z += v->odz ;

      /* update distance-to-move (just approximate) */
      v->d -= mag ;
      if (v->d < 0)
      {
        v->d = 0 ;
      }

      if ((fabs(v->x) > 128.0f) ||
          (fabs(v->y) > 128.0f) ||
          (fabs(v->z) > 128.0f))
      {
        DiagBreak() ;
      }

      if (vno == Gdiag_no && 0)
      {
        float dist, dot, dx, dy, dz ;

        dx = v->x - v->origx ;
        dy = v->y - v->origy ;
        dz = v->z - v->origz ;
        dist = sqrt(dx*dx+dy*dy+dz*dz) ;
        dot = dx*v->nx + dy*v->ny + dz*v->nz ;
        fprintf
        (stdout,
         "%d: moving v %d by (%2.3f, %2.3f, %2.3f) dot=%2.2f-->"
         "(%2.1f, %2.1f, %2.1f)%s\n", i, vno, v->odx, v->ody, v->odz,
         v->odx*v->nx+v->ody*v->ny+v->odz*v->nz,
         v->x, v->y, v->z, v->marked ? " CROPPED" : "") ;
        fprintf
        (stdout,
         "n = (%2.1f,%2.1f,%2.1f), total dist=%2.3f, "
         "total dot = %2.3f\n",
         v->nx, v->ny, v->nz, dist, dot) ;
      }

      /* should this be done here????? (BRF) what about undoing step??? */
      v->dx = v->odx ;  /* for mrisTrackTotalDistances */
      v->dy = v->ody ;
      v->dz = v->odz ;

#if 0
      /* write the new face positions into the filled volume */
      for (fno = 0 ; fno < v->num ; fno++)
      {
        mrisFillFace(mris, mri_filled, v->f[fno]) ;
      }
#else
      if (mht)
      {
        MHTaddAllFaces(mht, mris, v) ;
      }
#endif

    }
  }

  direction *= -1 ;
  return(delta_t) ;
}

static int
markAllDistantConvex(MRI_SURFACE *mris, float min_dist)
{
  int   vno, n, num ;
  VERTEX *v, *vn ;
#if 0
  double nx, ny, nz, x, y, z, sx, sy, sz, nc ;
#endif

  for (num = vno = 0; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->d < min_dist)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

#if 0
    nx = v->nx ;
    ny = v->ny ;
    nz = v->nz ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
    sx = sy = sz = 0.0 ;

    for (n = 0; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      sx += vn->x - x;
      sy += vn->y - y;
      sz += vn->z - z;
    }
    nc = sx*nx+sy*ny+sz*nz;   /* projection onto normal */
    if (nc > 0)  /* convex */
    {
      v->marked = 2 ;
      num++ ;
    }
    else
    {
      v->marked = 0 ;
    }
#else
    v->marked += 2 ;
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->d > v->d)
      {
        v->marked -= 2 ;
        break ;
      }
    }

    if (v->marked >= 2)
    {
      num++ ;
    }
#endif

    if (vno == Gdiag_no)
      printf("vertex %d %sdistant and convex\n",
             Gdiag_no, v->marked ? "" : "NOT ") ;
  }

  printf("%d distant convex vertices found...\n", num) ;
  return(NO_ERROR) ;
}
#endif
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
static int
mrisAverageSignedGradients(MRI_SURFACE *mris, int num_avgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  dx, dy, dz, num, sigma, dot ;
  VERTEX *v, *vn ;
  MRI_SP *mrisp, *mrisp_blur ;

  if (num_avgs <= 0)
  {
    return(NO_ERROR) ;
  }

  if (Gdiag_no >= 0)
  {
    v = &mris->vertices[Gdiag_no] ;
    fprintf(stdout, "before averaging dot = %2.2f ",
            v->dx*v->nx+v->dy*v->ny+v->dz*v->nz) ;
  }
  if (0 && mris->status == MRIS_PARAMETERIZED_SPHERE)  /* use convolution */
  {
    sigma = sqrt((float)num_avgs) / 4.0 ;
    mrisp = MRISgradientToParameterization(mris, NULL, 1.0) ;
    mrisp_blur = MRISPblur(mrisp, NULL, sigma, -1) ;
    MRISgradientFromParameterization(mrisp_blur, mris) ;
    MRISPfree(&mrisp) ;
    MRISPfree(&mrisp_blur) ;
  }
  else for (i = 0 ; i < num_avgs ; i++)
    {
      for (vno = 0 ; vno < mris->nvertices ; vno++)
      {
        v = &mris->vertices[vno] ;
        if (v->ripflag)
        {
          continue ;
        }
        dx = v->dx ;
        dy = v->dy ;
        dz = v->dz ;
        pnb = v->v ;
        /*      vnum = v->v2num ? v->v2num : v->vnum ;*/
        vnum = v->vnum ;
        for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
        {
          vn = &mris->vertices[*pnb++] ; /* neighboring vertex pointer */
          if (vn->ripflag)
          {
            continue ;
          }
          dot = vn->dx * v->dx + vn->dy * v->dy + vn->dz*v->dz ;
          if (dot < 0)
          {
            continue ;  /* pointing in opposite directions */
          }

          num++ ;
          dx += vn->dx ;
          dy += vn->dy ;
          dz += vn->dz ;
#if 0
          if (vno == Gdiag_no)
          {
            float dot ;
            dot = vn->dx*v->dx + vn->dy*v->dy + vn->dz*v->dz ;
            if (dot < 0)
              fprintf(stdout,
                      "vn %d: dot = %2.3f, dx = (%2.3f, %2.3f, %2.3f)\n",
                      v->v[vnb], dot, vn->dx, vn->dy, vn->dz) ;
          }
#endif
        }
        num++ ;
        v->tdx = dx / num ;
        v->tdy = dy / num ;
        v->tdz = dz / num ;
      }
      for (vno = 0 ; vno < mris->nvertices ; vno++)
      {
        v = &mris->vertices[vno] ;
        if (v->ripflag)
        {
          continue ;
        }
        v->dx = v->tdx ;
        v->dy = v->tdy ;
        v->dz = v->tdz ;
      }
    }
  if (Gdiag_no >= 0)
  {
    float dot ;
    v = &mris->vertices[Gdiag_no] ;
    dot = v->nx*v->dx + v->ny*v->dy + v->nz*v->dz ;
    fprintf(stdout, " after dot = %2.2f (%2.3f, %2.3f, %2.3f)\n",dot, v->dx, v->dy, v->dz) ;
    if (fabs(dot) > 50)
    {
      DiagBreak() ;
    }
  }
  return(NO_ERROR) ;
}
#if 0
static int
mrisAverageWeightedGradients(MRI_SURFACE *mris, int num_avgs)
{
  int    vno, vlist[MAX_NBRS], nbrs, n, n2 ;
  float  nx, ny, nz, dx, dy, dz, sigma, wts[MAX_NBRS], total_wt, wt ;
  VERTEX *v, *vn, *vn2 ;
  MRI_SP *mrisp, *mrisp_blur ;

  if (num_avgs <= 0)
  {
    return(NO_ERROR) ;
  }

  sigma = sqrt((double)num_avgs) * M_PI / 2.0 ;
  if (Gdiag_no >= 0)
  {
    v = &mris->vertices[Gdiag_no] ;
    fprintf(stdout, "before averaging dot = %2.2f ",
            v->dx*v->nx+v->dy*v->ny+v->dz*v->nz) ;
  }
  if (0 && mris->status == MRIS_PARAMETERIZED_SPHERE)  /* use convolution */
  {
    sigma = sqrt((float)num_avgs) / 4.0 ;
    mrisp = MRISgradientToParameterization(mris, NULL, 1.0) ;
    mrisp_blur = MRISPblur(mrisp, NULL, sigma, -1) ;
    MRISgradientFromParameterization(mrisp_blur, mris) ;
    MRISPfree(&mrisp) ;
    MRISPfree(&mrisp_blur) ;
  }
  else
  {
    MRISclearMarks(mris) ;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      if (v->ripflag)
      {
        continue ;
      }

      nx = v->nx ;
      ny = v->ny ;
      nz = v->nz ;
      dx = v->dx ;
      dy = v->dy ;
      dz = v->dz ;

      /* find all 1-neighbors */
      nbrs = 1 ;
      vlist[0] = vno ;
      wts[0] = 1.0 ;
      for (n = 0  ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        if (vn->marked)
        {
          continue ;
        }
        vn->marked = 1 ;
        wt = vn->nx*nx + vn->ny*ny + vn->nz*nz ;
        if (wt < 0)
        {
          wt = 0 ;
        }
        vlist[nbrs] = v->v[n] ;
        wts[nbrs] = exp(-1.0/(2.0f*sigma*sigma))*wt ;
        nbrs++ ;
      }
      /* find all 2-neighbors */
      for (n = v->vnum ; n < v->vtotal ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        if (vn->marked || v->v[n] == vno)
        {
          continue ;
        }
        vn->marked = 2;
        wt = vn->nx*nx + vn->ny*ny + vn->nz*nz ;
        if (wt < 0)
        {
          wt = 0 ;
        }
        vlist[nbrs] = v->v[n] ;
        wts[nbrs] = exp(-4.0/(2.0f*sigma*sigma))*wt ;
        nbrs++ ;
      }
      /* find all 3-neighbors */
      for (n = v->vnum ; n < v->vtotal ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        if (vn->marked != 2)  /* a two-neighbor */
        {
          continue ;
        }
        for (n2 = 0 ; n2 < vn->vnum ; n2++)
        {
          vn2 = &mris->vertices[vn->v[n2]] ;
          if (vn2->marked || vn->v[n2] == vno)
          {
            continue ;
          }
          vn2->marked = 3 ;
          wt = vn2->nx*nx + vn2->ny*ny + vn2->nz*nz ;
          if (wt < 0)
          {
            wt = 0 ;
          }
          vlist[nbrs] = vn->v[n2] ;
          wts[nbrs] = exp(-9.0/(2.0f*sigma*sigma))*wt ;
          nbrs++ ;
        }
        for (n2 = vn->vnum ; n2 < vn->vtotal ; n2++)
        {
          vn2 = &mris->vertices[vn->v[n2]] ;
          if (vn2->marked || vn->v[n2] == vno)
          {
            continue ;
          }
          vn2->marked = 4 ;
          wt = vn2->nx*nx + vn2->ny*ny + vn2->nz*nz ;
          if (wt < 0)
          {
            wt = 0 ;
          }
          vlist[nbrs] = vn->v[n2] ;
          wts[nbrs] = exp(-16.0/(2.0f*sigma*sigma))*wt ;
          nbrs++ ;
        }
      }

      v->tdx = v->tdy = v->tdz = 0.0 ;
      for (total_wt = 0.0, n = 0 ; n < nbrs ; n++)
      {
        wt = wts[n] ;
        total_wt += wt ;
        vn = &mris->vertices[vlist[n]] ;
        if (vlist[n] == Gdiag_no || vlist[n] == Gx)
        {
          DiagBreak() ;
        }
        vn->marked = 0 ;
        v->tdx += wt * vn->dx ;
        v->tdy += wt * vn->dy ;
        v->tdz += wt * vn->dz ;
      }
      v->tdx /= total_wt ;
      v->tdy /= total_wt ;
      v->tdz /= total_wt ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      v->dx = v->tdx ;
      v->dy = v->tdy ;
      v->dz = v->tdz ;
    }
  }
  if (Gdiag_no >= 0)
  {
    float dot ;
    v = &mris->vertices[Gdiag_no] ;
    dot = v->nx*v->dx + v->ny*v->dy + v->nz*v->dz ;
    fprintf(stdout, " after dot = %2.2f (%2.3f, %2.3f, %2.3f)\n",dot, v->dx, v->dy, v->dz) ;
    if (fabs(dot) > 50)
    {
      DiagBreak() ;
    }
  }
  return(NO_ERROR) ;
}
#endif

#if 0
static int
mrisMarkSulcalVertices(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int     vno ;
  VERTEX  *v ;
  float   x, y, z ;
  double    val0, xw,yw,zw ;
  double  del0, dot ;

  MRISclearFlags(mris, VERTEX_SULCAL) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->val < 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x ;
    y = v->y ;
    z = v->z ;

    // MRIworldToVoxel(parms->mri_brain, x, y, z, &xw, &yw, &zw) ;
    MRISsurfaceRASToVoxelCached(mris, parms->mri_brain, x, y, z, &xw, &yw, &zw) ;
    MRIsampleVolume(parms->mri_brain, xw, yw, zw, &val0) ;
    dot = v->dx * v->nx + v->dy * v->ny + v->dz * v->nz ;

    del0 = v->val - val0 ;
    if (dot < 0 && del0 > 0)  /* too bright and moving inward */
    {
      v->flags |= VERTEX_SULCAL ;
      if (vno == Gdiag_no)
        printf("v %d: intensity %2.1f darker than "
               "target %2.1f - marked as sulcal\n",
               vno, val0, v->val) ;
    }
  }

  return(NO_ERROR) ;
}
static int
mrisUpdateSulcalGradients(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int     vno, num ;
  VERTEX  *v ;
  double  dot ;

  for (num = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->val < 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    if (v->flags & VERTEX_SULCAL)
    {
      dot = v->dx * v->nx + v->dy * v->ny + v->dz * v->nz ;
      if (dot > 0)  /* now moving outwards - take out normal component */
      {
        num++ ;
        v->dx -= dot*v->nx ;
        v->dy -= dot*v->ny ;
        v->dz -= dot*v->nz ;
        if (vno == Gdiag_no)
          printf
          ("v %d: removing normal component "
           "%2.3f to prevent sulcal crossing\n",
           vno, dot) ;
      }
    }
  }

  printf("%d vertices detected in sulcal-crossing\n", num) ;
  return(NO_ERROR) ;
}
#endif

int
MRISsetFlags(MRI_SURFACE *mris, int flags)
{
  int    vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].flags |= flags ;
  }
  return(NO_ERROR) ;
}

int
MRISclearFlags(MRI_SURFACE *mris, int flags)
{
  int    vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].flags &= (~flags) ;
  }
  return(NO_ERROR) ;
}

static int
mrisReadAsciiCurvatureFile(MRI_SURFACE *mris, const char *fname)
{
  FILE   *fp ;
  int    vno ;
  char   line[STRLEN], *cp ;
  VERTEX *v ;

  fp = fopen(fname, "r") ;
  if (!fp)
    ErrorReturn
    (ERROR_BADFILE,
     (ERROR_BADFILE, "%s could not open file %s.\n",
      mrisReadAsciiCurvatureFile, fname)) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    cp = fgetl(line, 100, fp) ;
    if (!cp)
    {
      break ;
    }
    if (sscanf(line, "%*d %*f %*f %*f %f\n", &v->curv) != 1)
      ErrorReturn
      (ERROR_BADFILE,
       (ERROR_BADFILE,
        "mrisReadAsciiCurvatureFile(%s): "
        "could not scan curvature from line '%s'",fname,line));
  }

  fclose(fp) ;
  return(NO_ERROR) ;
}

// expand the surface by "h" and create a volume
//which has "val" outside of this surface
unsigned long
MRISeraseOutsideOfSurface(float h,MRI* mri_dst,MRIS *mris,unsigned char val)
{
  int i,j,k,imnr;
  float x0,y0,z0,x1,y1,z1,x2,y2,z2,d0,d1,d2,dmax,u,v;
  float px,py,pz,px0,py0,pz0,px1,py1,pz1;
  int numu,numv,totalfilled,newfilled;
  double tx,ty,tz;
  unsigned long brainsize;

  int width, height,depth;
  MRI *mri_buff;

  width=mri_dst->width;
  height=mri_dst->height;
  depth=mri_dst->depth;

  mri_buff= MRIalloc(width, height, depth, MRI_UCHAR) ;

  for (k=0; k<mris->nvertices; k++)
  {
    // cache the values
    mris->vertices[k].tx=mris->vertices[k].x;
    mris->vertices[k].ty=mris->vertices[k].y;
    mris->vertices[k].tz=mris->vertices[k].z;

    // expand by h using normal
    mris->vertices[k].x +=h*mris->vertices[k].nx;
    mris->vertices[k].y +=h*mris->vertices[k].ny;
    mris->vertices[k].z +=h*mris->vertices[k].nz;
  }


  for (k=0; k<mris->nfaces; k++)
  {
    // calculate three vertices
    x0 =mris->vertices[mris->faces[k].v[0]].x;
    y0 =mris->vertices[mris->faces[k].v[0]].y;
    z0 =mris->vertices[mris->faces[k].v[0]].z;
    x1 =mris->vertices[mris->faces[k].v[1]].x;
    y1 =mris->vertices[mris->faces[k].v[1]].y;
    z1 =mris->vertices[mris->faces[k].v[1]].z;
    x2 =mris->vertices[mris->faces[k].v[2]].x;
    y2 =mris->vertices[mris->faces[k].v[2]].y;
    z2 =mris->vertices[mris->faces[k].v[2]].z;
    // calculate the sides
    d0 = sqrt(SQR(x1-x0)+SQR(y1-y0)+SQR(z1-z0));
    d1 = sqrt(SQR(x2-x1)+SQR(y2-y1)+SQR(z2-z1));
    d2 = sqrt(SQR(x0-x2)+SQR(y0-y2)+SQR(z0-z2));
    dmax = (d0>=d1&&d0>=d2)?d0:(d1>=d0&&d1>=d2)?d1:d2;
    numu = (int)(ceil(2*d0));
    numv = (int)(ceil(2*dmax));


    for (v=0; v<=numv; v++)
    {
      px0 = x0 + (x2-x0)*v/numv;
      py0 = y0 + (y2-y0)*v/numv;
      pz0 = z0 + (z2-z0)*v/numv;
      px1 = x1 + (x2-x1)*v/numv;
      py1 = y1 + (y2-y1)*v/numv;
      pz1 = z1 + (z2-z1)*v/numv;
      for (u=0; u<=numu; u++)
      {
        px = px0 + (px1-px0)*u/numu;
        py = py0 + (py1-py0)*u/numu;
        pz = pz0 + (pz1-pz0)*u/numu;

        // MRIworldToVoxel(mri_dst,px,py,pz,&tx,&ty,&tz);
        MRISsurfaceRASToVoxelCached(mris, mri_dst,px,py,pz,&tx,&ty,&tz);

        imnr=(int)(tz+0.5);
        j=(int)(ty+0.5);
        i=(int)(tx+0.5);
        if (i>=0 && i<width && j>=0 && j<height && imnr>=0 && imnr<depth)
        {
          MRIvox(mri_buff,i,j,imnr) = 255;
        }

      }
    }
  }

  MRIvox(mri_buff,1,1,1)= 64;
  totalfilled = newfilled = 1;
  while (newfilled>0)
  {
    newfilled = 0;
    for (k=0; k<depth; k++)
      for (j=0; j<height; j++)
        for (i=0; i<width; i++)
          if (MRIvox(mri_buff,i,j,k)==0)
            if (MRIvox(mri_buff,i,j,mri_buff->zi[k-1])==64||
                MRIvox(mri_buff,i,mri_buff->yi[j-1],k)==64||
                MRIvox(mri_buff,mri_buff->xi[i-1],j,k)==64)
            {
              MRIvox(mri_buff,i,j,k)= 64;
              newfilled++;
            }
    for (k=depth-1; k>=0; k--)
      for (j=height-1; j>=0; j--)
        for (i=width-1; i>=0; i--)
          if (MRIvox(mri_buff,i,j,k)==0)
            if (MRIvox(mri_buff,i,j,mri_buff->zi[k+1])==64||
                MRIvox(mri_buff,i,mri_buff->yi[j+1],k)==64||
                MRIvox(mri_buff,mri_buff->xi[i+1],j,k)==64)
            {
              MRIvox(mri_buff,i,j,k) = 64;
              newfilled++;
            }
    totalfilled += newfilled;
  }

  // modify mri_dst so that outside = 0
  brainsize=0;
  if (val==0)
    for (k=0; k<depth; k++)
      for (j=0; j<height; j++)
        for (i=0; i<width; i++)
        {
          if (MRIvox(mri_buff,i,j,k)==64)
          {
            MRIvox(mri_dst,i,j,k) = 0;
          }
          else
          {
            brainsize++;
          }
        }
  else
  {
    for (k=0; k<depth; k++)
      for (j=0; j<height; j++)
        for (i=0; i<width; i++)
        {
          if (MRIvox(mri_buff,i,j,k)!=64)
          {
            MRIvox(mri_dst,i,j,k) = val;
          }
          else
          {
            brainsize++;
          }
        }
  }
  // restore the surface
  for (k=0; k<mris->nvertices; k++)
  {
    mris->vertices[k].x=mris->vertices[k].tx;
    mris->vertices[k].y=mris->vertices[k].ty;
    mris->vertices[k].z=mris->vertices[k].tz;
  }
  // calculate the normals
  MRIScomputeNormals(mris);

  MRIfree(&mri_buff);
  return brainsize;
}

int
MRISmarkedSpringTerm(MRI_SURFACE *mris, double l_spring)
{
  int     vno, n, m ;
  VERTEX  *vertex, *vn ;
  float   sx, sy, sz, x, y, z ;

  if (FZERO(l_spring))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag || vertex->marked == 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = vertex->x ;
    y = vertex->y ;
    z = vertex->z ;

    sx = sy = sz = 0.0 ;

    n=0;
    for (m = 0 ; m < vertex->vnum ; m++)
    {
      vn = &mris->vertices[vertex->v[m]] ;
      if (!vn->ripflag)
      {
        sx += vn->x - x;
        sy += vn->y - y;
        sz += vn->z - z;
        n++;
      }
    }
    if (n>0)
    {
      sx = sx/n;
      sy = sy/n;
      sz = sz/n;
    }
    sx = l_spring*sx ;              /* move in normal direction */
    sy = l_spring*sy ;
    sz = l_spring*sz ;

    vertex->dx += sx ;
    vertex->dy += sy ;
    vertex->dz += sz ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d marked spring term:  (%2.3f, %2.3f, %2.3f)\n",
              vno, sx, sy, sz) ;
  }

  return(NO_ERROR) ;
}

int
MRISnormalSpringTermWithGaussianCurvature
(MRI_SURFACE *mris, double gaussian_norm, double l_spring)
{
  int     vno, n, m ;
  VERTEX  *vertex, *vn ;
  float   sx, sy, sz, x, y, z, scale, nc, nx, ny, nz ;

  if (FZERO(l_spring))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = vertex->x ;
    y = vertex->y ;
    z = vertex->z ;
    nx = vertex->nx ;
    ny = vertex->ny ;
    nz = vertex->nz ;

    sx = sy = sz = 0.0 ;

    n=0;
    for (m = 0 ; m < vertex->vnum ; m++)
    {
      vn = &mris->vertices[vertex->v[m]] ;
      if (!vn->ripflag)
      {
        sx += vn->x - x;
        sy += vn->y - y;
        sz += vn->z - z;
        n++;
      }
    }
    if (n>0)
    {
      sx = sx/n;
      sy = sy/n;
      sz = sz/n;
    }
    nc = sx*nx+sy*ny+sz*nz;   /* projection onto normal */
    sx = l_spring*nc*nx ;              /* move in normal direction */
    sy = l_spring*nc*ny ;
    sz = l_spring*nc*nz ;
    scale = pow(fabs(vertex->K), gaussian_norm) ;
    if (!finite(scale))
    {
      scale = 0 ;
    }
    ;
    if (scale > 1)
    {
      scale = 1 ;
    }
    scale *= l_spring ;
    sx *= scale ;              /* move in normal direction */
    sy *= scale ;
    sz *= scale ;

    vertex->dx += sx ;
    vertex->dy += sy ;
    vertex->dz += sz ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d Gaussian normal term:  (%2.3f, %2.3f, %2.3f)\n",
              vno, sx, sy, sz) ;
  }

  return(NO_ERROR) ;
}
int
MRISspringTermWithGaussianCurvature(MRI_SURFACE *mris,
                                    double gaussian_norm, double l_spring)
{
  int     vno, n, m ;
  VERTEX  *vertex, *vn ;
  float   sx, sy, sz, x, y, z, scale ;

  if (FZERO(l_spring))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vertex->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = vertex->x ;
    y = vertex->y ;
    z = vertex->z ;

    sx = sy = sz = 0.0 ;
    n=0;
    for (m = 0 ; m < vertex->vnum ; m++)
    {
      vn = &mris->vertices[vertex->v[m]] ;
      if (!vn->ripflag)
      {
        sx += vn->x - x;
        sy += vn->y - y;
        sz += vn->z - z;
        n++;
      }
    }
    if (n>0)
    {
      sx = sx/n;
      sy = sy/n;
      sz = sz/n;
    }
    scale = pow(fabs(vertex->K), gaussian_norm) ;
    if (!finite(scale))
    {
      scale = 0 ;
    }
    ;
    if (scale > 1)
    {
      scale = 1 ;
    }
    scale *= l_spring ;
    sx *= scale ;              /* move in normal direction */
    sy *= scale ;
    sz *= scale ;

    vertex->dx += sx ;
    vertex->dy += sy ;
    vertex->dz += sz ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d Gaussian normal term:  (%2.3f, %2.3f, %2.3f)\n",
              vno, sx, sy, sz) ;
  }

  return(NO_ERROR) ;
}


static int
mrisGraphLaplacian(MRI_SURFACE *mris, int vno, double *pdx, double *pdy, double *pdz, int which)
{
  VERTEX *v, *vn ;
  double lx, ly, lz, w, norm, dx, dy, dz, wtotal ;
  int    n ;

  v = &mris->vertices[vno] ;
  if (v->vnum == 0)
  {
    return(NO_ERROR) ;
  }
  w = 1.0 / (double)v->vnum ;
  for (wtotal = 0.0, lx = ly = lz = 0.0, n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;
    dx = (v->x - vn->x) ;
    dy = (v->y - vn->y) ;
    dz = (v->z - vn->z) ;
    switch (which)
    {
    default:
    case TAUBIN_UNIFORM_WEIGHTS:
      // w = 1/v->vnum above
      break ;
    case TAUBIN_INVERSE_WEIGHTS:
      norm = sqrt(dx*dx + dy*dy + dz*dz) ;

      if (!FZERO(norm))
      {
        w = 1.0/norm;
      }
      else
      {
        w = 1 ;
      }
      break ;
    case TAUBIN_EDGE_WEIGHTS:
      norm = sqrt(dx*dx + dy*dy + dz*dz) ;
      w = norm;
      break ;
    }

    wtotal += w ;
    lx += w * dx ;
    ly += w * dy ;
    lz += w * dz ;
  }
  *pdx = lx/wtotal ;
  *pdy = ly/wtotal ;
  *pdz = lz/wtotal ;

  return(NO_ERROR) ;
}

/* bigger values of lambda will give more smoothing. Lambda and Mu
   bigger K_bp will also yield more smoothing
#define Lambda .3
#define Mu     (1.0)/((K_bp)-1.0/Lambda)
*/
int
MRIStaubinSmooth(MRI_SURFACE *mris, int niters, double lambda, double mu, int which)
{
  int        n, vno ;
  double     dx, dy, dz ;
  VERTEX     *v ;

  if (lambda < 0 || lambda > 1 || mu >= -lambda)
  {
    ErrorReturn(ERROR_BADPARM, (ERROR_BADPARM, "MRIStaubinSmooth: mu < -lambda < 0 violated")) ;
  }

  dx = dy = dz = 0 ; // to get rid of compiler warning
  for (n = 0 ; n < niters ; n++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (v->ripflag)
      {
        v->tx = v->x ;
        v->ty = v->y ;
        v->tz = v->z ;
        continue ;
      }
      mrisGraphLaplacian(mris, vno, &dx, &dy, &dz, which) ;
      if (EVEN(n))
      {
        v->tx = v->x + lambda * dx ;
        v->ty = v->y + lambda * dy ;
        v->tz = v->z + lambda * dz ;
      }
      else
      {
        v->tx = v->x + mu * dx ;
        v->ty = v->y + mu * dy ;
        v->tz = v->z + mu * dz ;
      }
    }
    MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  }

  return(NO_ERROR) ;
}

int
MRISnormalTermWithGaussianCurvature(MRI_SURFACE *mris,double lambda)
{
  int     vno ;
  VERTEX  *v ;

  if (FZERO(lambda))
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    v->dx = -v->nx * v->K * lambda ;
    v->dy = -v->ny * v->K * lambda ;
    v->dz = -v->nz * v->K * lambda;
  }

  return(NO_ERROR) ;
}

static int
mrisComputeExpandwrapTerm(MRI_SURFACE *mris, MRI *mri_brain,
                          double  l_expandwrap)
{
  int    vno ;
  double   xw, yw, zw, x, y, z, val, dx, dy, dz ;
  VERTEX *v ;
  float  min_val, max_val, target_val, delta ;

  if (FZERO(l_expandwrap))
  {
    return(NO_ERROR) ;
  }

  MRIvalRange(mri_brain, &min_val, &max_val) ;
  target_val = (min_val + max_val) / 2 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    target_val = v->val ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw);
    MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
    delta = (val - target_val) ;
    dx = -delta * v->nx * l_expandwrap ;
    dy = -delta * v->ny * l_expandwrap ;
    dz = -delta * v->nz * l_expandwrap ;

    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d expandwrap term: (%2.3f, %2.3f, %2.3f), "
              "target %2.1f, MRI %2.1f, del=%2.1f, "
              "N=(%2.1f, %2.1f, %2.1f)\n",
              vno, dx, dy, dz, target_val, val, delta, v->nx, v->ny, v->nz) ;
  }
  return(NO_ERROR) ;
}

static double
mrisComputeExpandwrapError(MRI_SURFACE *mris, MRI *mri_brain,
                           double l_expandwrap, double target_radius)
{
  int    vno ;
  double   xw, yw, zw, x, y, z, val, dx, dy, dz, sse, error, dist ;
  VERTEX *v ;
  float  min_val, max_val, target_val, delta ;

  if (FZERO(l_expandwrap))
  {
    return(NO_ERROR) ;
  }

  mrisComputeSurfaceDimensions(mris);
  MRIvalRange(mri_brain, &min_val, &max_val) ;
  target_val = (min_val + max_val) / 2 ;
  for (sse = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    target_val = v->val ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw);
    MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
    delta = (val - target_val) ;
    if (val < 0.25*target_val)
    {
      dx = x - mris->xctr ;
      dy = y - mris->yctr ;
      dz = z - mris->zctr ;
      dist = sqrt(dx*dx + dy*dy + dz*dz) ;
      error = (target_radius-dist) ;
      sse += error*error ;
    }
    else
    {
      error = 0.0 ;
    }

    if (vno == Gdiag_no)
      fprintf
      (stdout,
       "v %d expandwrap error: %2.3f, target %2.1f, "
       "MRI %2.1f, del=%2.1f, \n",
       vno, error, target_val, val, delta) ;
  }
  return(sse) ;
}
static int
mrisComputeShrinkwrapTerm(MRI_SURFACE *mris,
                          MRI *mri_brain,
                          double  l_shrinkwrap)
{
  int    vno ;
  double   xw, yw, zw, x, y, z, val, dx, dy, dz ;
  VERTEX *v ;
  float  min_val, max_val, target_val, delta ;

  if (FZERO(l_shrinkwrap))
  {
    return(NO_ERROR) ;
  }

  MRIvalRange(mri_brain, &min_val, &max_val) ;
  target_val = (min_val + max_val) / 2 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    target_val = v->val ;
    x = v->x ;
    y = v->y ;
    z = v->z ;
    MRISsurfaceRASToVoxelCached(mris, mri_brain, x, y, z, &xw, &yw, &zw);
    MRIsampleVolume(mri_brain, xw, yw, zw, &val) ;
      
    delta = (val - target_val) ;

    dx = delta * v->nx * l_shrinkwrap ;
    dy = delta * v->ny * l_shrinkwrap ;
    dz = delta * v->nz * l_shrinkwrap ;

    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d shrinkwrap term: (%2.3f, %2.3f, %2.3f), "
              "target %2.1f, MRI %2.1f, del=%2.1f, "
              "N=(%2.1f, %2.1f, %2.1f)\n",
              vno, dx, dy, dz, target_val, val, delta, v->nx, v->ny, v->nz) ;
  }
  return(NO_ERROR) ;
}

static double
mrisComputeShrinkwrapError
(MRI_SURFACE *mris, MRI *mri_brain, double l_shrinkwrap)
{
#if 0
  static int iter = 100 ;
  int    vno ;
  double   xw, yw, zw, x, y, z, val ;
  VERTEX *v ;
  float  min_val, max_val, target_val, error ;
  double sse ;

  MRIvalRange(mri_brain, &min_val, &max_val) ;
  target_val = (min_val + max_val) / 2 ;
  sse = 0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    sse += iter ;
  }
  iter-- ;
  return(sse) ;
#else
  return(0.0) ;
#endif
}

/*-------------------------------------------------------------------
  MRISgaussianSmooth() - perform gaussian smoothing on a spherical
  surface. The gaussian is defined by stddev GStd and is truncated
  at TruncFactor stddevs. Note: this will change the val2bak of all
  the vertices. See also MRISspatialFilter() and MRISgaussianWeights().
  -------------------------------------------------------------------*/
MRI *MRISgaussianSmooth(MRIS *Surf, MRI *Src, double GStd, MRI *Targ,
                        double TruncFactor)
{
  int vtxno1, vtxno2;
  float val;
  MRI *SrcTmp, *GSum, *GSum2, *nXNbrsMRI;
  VERTEX *vtx1;
  double Radius, Radius2, dmax, GVar2, f, d, costheta, theta, g, dotprod;
  int n, err, nXNbrs, *XNbrVtxNo, frame;
  double *XNbrDotProd, DotProdThresh;
  double InterVertexDistAvg,InterVertexDistStdDev;
  double VertexRadiusAvg,VertexRadiusStdDev;


  if(Surf->nvertices != Src->width)
  {
    printf("ERROR: MRISgaussianSmooth: Surf/Src dimension mismatch\n");
    return(NULL);
  }

  if(Targ == NULL)
  {
    Targ = MRIallocSequence(Src->width, Src->height, Src->depth,
                            MRI_FLOAT, Src->nframes);
    if(Targ==NULL)
    {
      printf("ERROR: MRISgaussianSmooth: could not alloc\n");
      return(NULL);
    }
  }
  else
  {
    if(Src->width   != Targ->width  ||
        Src->height  != Targ->height ||
        Src->depth   != Targ->depth  ||
        Src->nframes != Targ->nframes)
    {
      printf("ERROR: MRISgaussianSmooth: output dimension mismatch\n");
      return(NULL);
    }
    if(Targ->type != MRI_FLOAT)
    {
      printf("ERROR: MRISgaussianSmooth: structure passed is not MRI_FLOAT\n");
      return(NULL);
    }
  }

  /* Make a copy in case it's done in place */
  SrcTmp = MRIcopy(Src,NULL);

  /* This is for normalizing */
  GSum = MRIallocSequence(Src->width, Src->height, Src->depth, MRI_FLOAT, 1);
  if (GSum==NULL)
  {
    printf("ERROR: MRISgaussianSmooth: could not alloc GSum\n");
    return(NULL);
  }

  GSum2 = MRIallocSequence(Src->width, Src->height, Src->depth, MRI_FLOAT, 1);
  if (GSum2==NULL)
  {
    printf("ERROR: MRISgaussianSmooth: could not alloc GSum2\n");
    return(NULL);
  }

  MRIScomputeMetricProperties(Surf);
  nXNbrsMRI =
    MRIallocSequence(Src->width, Src->height, Src->depth, MRI_FLOAT, 1);

  vtx1 = &Surf->vertices[0] ;
  Radius2 = (vtx1->x * vtx1->x) + (vtx1->y * vtx1->y) + (vtx1->z * vtx1->z);
  Radius  = sqrt(Radius2);
  dmax = TruncFactor*GStd; // truncate after TruncFactor stddevs
  GVar2 = 2*(GStd*GStd);
  f = pow(1/(sqrt(2*M_PI)*GStd),2.0); // squared for 2D
  DotProdThresh = Radius2*cos(dmax/Radius)*(1.0001);

  printf("Radius = %g, gstd = %g, dmax = %g, GVar2 = %g, f = %g, dpt = %g\n",
         Radius,GStd,dmax,GVar2,f,DotProdThresh);

  InterVertexDistAvg    = Surf->avg_vertex_dist;
  InterVertexDistStdDev = Surf->std_vertex_dist;
  VertexRadiusAvg = MRISavgVetexRadius(Surf, &VertexRadiusStdDev);

  printf("Total Area = %g \n",Surf->total_area);
  printf("Dist   = %g +/- %g\n",InterVertexDistAvg,InterVertexDistStdDev);
  printf("Radius = %g +/- %g\n",VertexRadiusAvg,VertexRadiusStdDev);

  /* Initialize */
  for (vtxno1 = 0; vtxno1 < Surf->nvertices; vtxno1++)
  {
    MRIFseq_vox(GSum,vtxno1,0,0,0)  = 0;
    MRIFseq_vox(GSum2,vtxno1,0,0,0) = 0;
    for (frame = 0; frame < Targ->nframes; frame ++)
    {
      MRIFseq_vox(Targ,vtxno1,0,0,frame) = 0;
    }
    Surf->vertices[vtxno1].val2bak = -1;
  }

  /* These are needed by MRISextendedNeighbors()*/
  XNbrVtxNo   = (int *) calloc(Surf->nvertices,sizeof(int));
  XNbrDotProd = (double *) calloc(Surf->nvertices,sizeof(double));

  printf("nvertices = %d\n",Surf->nvertices);
  for (vtxno1 = 0; vtxno1 < Surf->nvertices; vtxno1++)
  {
    nXNbrs = 0;
    err = MRISextendedNeighbors(Surf,vtxno1,vtxno1,DotProdThresh, XNbrVtxNo,
                                XNbrDotProd, &nXNbrs, Surf->nvertices,1);
    MRIFseq_vox(nXNbrsMRI,vtxno1,0,0,0) = nXNbrs;

    if(vtxno1%10000==0 && Gdiag_no > 0)
    {
      printf("vtxno1 = %d, nXNbrs = %d\n",vtxno1,nXNbrs);
      fflush(stdout);
    }

    for (n = 0; n < nXNbrs; n++)
    {
      vtxno2  = XNbrVtxNo[n];
      dotprod =  XNbrDotProd[n];
      costheta = dotprod/Radius2;

      // cos theta might be slightly > 1 due to precision
      if (costheta > +1.0)
      {
        costheta = +1.0;
      }
      if (costheta < -1.0)
      {
        costheta = -1.0;
      }

      // Compute the angle between the vertices
      theta = acos(costheta);

      /* Compute the distance bet vertices along the surface of the sphere */
      d = Radius * theta;

      /* Compute weighting factor for this distance */
      g = f*exp( -(d*d)/(GVar2) ); /* f not really nec */
      //ga = g * Surf->vertices[vtxno2].area;

      if(vtxno1 == 10000 && 1)
      {
        printf("%d %d %g %g %g %g %g\n",
               vtxno1,vtxno2,dotprod,costheta,theta,d,g);
        fflush(stdout);
      }

      //MRIFseq_vox(GSum,vtxno1,0,0,0)  += g;
      //MRIFseq_vox(GSum2,vtxno1,0,0,0) += (g*g);

      for (frame = 0; frame < Targ->nframes; frame ++)
      {
        val = g*MRIFseq_vox(SrcTmp,vtxno2,0,0,frame);
        MRIFseq_vox(Targ,vtxno1,0,0,frame) += val;
      }

    } /* end loop over vertex2 */

  } /* end loop over vertex1 */


  /* Normalize */
  if(0)
  {
    for (vtxno1 = 0; vtxno1 < Surf->nvertices; vtxno1++)
    {
      vtx1 = &Surf->vertices[vtxno1] ;
      g = MRIFseq_vox(GSum,vtxno1,0,0,0);
      MRIFseq_vox(GSum2,vtxno1,0,0,0) /= (g*g);

      for (frame = 0; frame < Targ->nframes; frame ++)
      {
        val = MRIFseq_vox(Targ,vtxno1,0,0,frame);
        MRIFseq_vox(Targ,vtxno1,0,0,frame) = val/g;
      }
    }
  }

  //MRIwrite(GSum,"gsum.mgh");
  //MRIwrite(GSum2,"gsum2.mgh");
  //MRIwrite(nXNbrsMRI,"nxnbrs.mgh");

  MRIfree(&SrcTmp);
  MRIfree(&GSum);
  MRIfree(&GSum2);
  MRIfree(&nXNbrsMRI);

  free(XNbrVtxNo);
  free(XNbrDotProd);

  return(Targ);
}

/*-------------------------------------------------------------------
  MRISextendedNeighbors() - read everything! Finds the set of
  "extended" neighbors of a given target vertex and a distance
  threshold. Call with CurVtxNo=TargVtxNo. There are other
  recursive calls where CurVtxNo!=TargVtxNothat.

  The distance metric is the dot product between the vectors
  pointing from the origin to the target and current vertices. For
  any given target vertex, the dot product must be greater than
  (NOT less than) the DotProdThresh to be included.

  XNbrVtxNo is the (already allocated) list of vertex numbers of
  vertices that are within threshold.

  XNbrDotProd is the (already allocated) list of dot products of
  vertices that are within threshold.

  nXNbrs is a pointer to the total number of vertices that are
  within threshold.

  nXNbrsMax is the maximum number allowed (ie, the allocation
  lengths of XNbrVtxNo and XNbrDotProd.

  NOTE: IMPORTANT!
  1. This really only works on the spherical surface.
  2. Assuming a spherical surface, the distance along the
  sphere between the two vertices can be computed as
  costheta = dotprod/(Radius^2);
  theta = acos(costheta);
  d = Radius * theta;
  This also allows you to work backwards to get a
  dot product threshold from a given distance threshold.
  3. Modifies vertex->val2bak. It is important that this
  be set to -1 for all vertices prior to the first
  call or before calling with the same target vertex
  again.
  4. It is expected that this will be run for each vertex
  on a surface, so care has been taken to keep the
  coputations light (eg, not allocating XNbrnVtxNo
  and XNbrnDotProd, using a dot product threshold
  instead of a distance threshold, not resetting val2bak).
  5. The extended neighborhood of a vertex includes itself.
  -------------------------------------------------------------------*/
int MRISextendedNeighbors(MRIS *SphSurf,int TargVtxNo, int CurVtxNo,
                          double DotProdThresh, int *XNbrVtxNo,
                          double *XNbrDotProd, int *nXNbrs,
                          int nXNbrsMax, int DistType)
{
  static int ncalls = 0;
  VERTEX *vtarg,*vcur;
  int nNNbrs, n, NbrVtxNo, err;
  double DotProd, dx,dy,dz;

  // Get the current vertex
  vcur  = &SphSurf->vertices[CurVtxNo] ;

  // Return if this vertex has been hit
  if( (int)vcur->val2bak == TargVtxNo )
  {
    return(0);
  }

  // Return if this vertex is ripped
  if(vcur->ripflag)
  {
    return(0);
  }

  // Keep track of the number of recursive calls
  if (CurVtxNo == TargVtxNo)
  {
    *nXNbrs = 0;
    ncalls = 0;
  }
  ncalls++;

  // Get the target vertex
  vtarg = &SphSurf->vertices[TargVtxNo] ;

  if(DistType == 1)
  {
    // DotProduct - dist along sphere
    // Compute the dot product between the two
    DotProd = (vtarg->x*vcur->x) + (vtarg->y*vcur->y) + (vtarg->z*vcur->z);
    DotProd = fabs(DotProd);
    //printf("c %d %d %d %g %d\n",ncalls,TargVtxNo,CurVtxNo,DotProd,*nXNbrs);
    if(DotProd <= DotProdThresh)
    {
      return(0);
    }
  }
  else
  {
    // Cartesian - dist squared along sphere (so thresh should be squared)
    dx = vtarg->x-vcur->x;
    dy = vtarg->y-vcur->y;
    dz = vtarg->z-vcur->z;
    DotProd = dx*dx + dy*dy + dz*dz;
    DotProd = fabs(DotProd);
    //printf("c %d %d %d %g %d\n",ncalls,TargVtxNo,CurVtxNo,DotProd,*nXNbrs);
    if(DotProd >= DotProdThresh)
    {
      return(0);
    }
  }

  // Check whether another neigbor can be added
  if(*nXNbrs >= nXNbrsMax-1)
  {
    return(1);
  }

  // OK, add this vertex as an extended neighbor
  XNbrVtxNo[*nXNbrs]    = CurVtxNo;
  XNbrDotProd[*nXNbrs]  = DotProd;
  (*nXNbrs)++;
  vcur->val2bak = TargVtxNo; // record a hit

  // Now, loop over the current nearest neighbors
  nNNbrs = SphSurf->vertices[CurVtxNo].vnum;
  for (n = 0; n < nNNbrs; n++)
  {
    NbrVtxNo = SphSurf->vertices[CurVtxNo].v[n];
    err = MRISextendedNeighbors(SphSurf, TargVtxNo, NbrVtxNo, DotProdThresh,
                                XNbrVtxNo, XNbrDotProd, nXNbrs, nXNbrsMax, DistType);
    if(err)
    {
      return(err);
    }
  }

  return(0);
}
/*--------------------------------------------------------------------------
  MRISgaussianWeights() - fills the weight (4th) row of the MRI dist
  struct.  dist is the distance between vertices as returned by
  MRISdistSphere().  The first 3 rows of dist correspond to: 0=actual
  number of extended neighbors, 1=vertex number of extended neighbors,
  2=distance along the sphere. The weight will be placed in the 4th
  row.  Each of the extended neighbrs is placed in a frame. The weights
  for a given vertex will be normalized so that the sum=1.
  --------------------------------------------------------------------------*/
int MRISgaussianWeights(MRIS *surf, MRI *dist, double GStd)
{
  int n,m,nXNbrs;
  double GVar2,f,gsum,d,g;

  GVar2 = 2*(GStd*GStd); /* twice the variance */
  f = 1/(sqrt(2*M_PI)*GStd);

  for (n=0; n < surf->nvertices; n++)
  {
    nXNbrs = MRIFseq_vox(dist,n,0,0,0); /*1st row is number of ext neighbors*/
    gsum = 0;
    for (m=0; m < nXNbrs; m++)
    {
      d = MRIFseq_vox(dist,n,2,0,m); /*3rd row is dist to ext neighbors*/
      g = f*exp( -(d*d)/(GVar2) );   /* gaussian weight */
      MRIFseq_vox(dist,n,3,0,m) = g; /*4th row is weight of  ext neighbors*/
      gsum += g;
    }
    /* Normalize */
    for (m=0; m < nXNbrs; m++)
    {
      MRIFseq_vox(dist,n,3,0,m) /= gsum;
    }
  }
  return(0);
}
/*-------------------------------------------------------------------
  MRISspatialFilter() - spatially fillters Src by computing the dot
  product of Src and the weights wdist. The wdist MRI struct must
  be as computed by MRISgaussianWeights() and MRISdistSphere(). It is
  assumed that the weights are already normalized.
  -------------------------------------------------------------------*/
MRI *MRISspatialFilter(MRI *Src, MRI *wdist, MRI *Targ)
{
  int n, nXNbrs, m, vtxno, frame;
  float w, val;
  MRI *SrcCopy = NULL;

  if (wdist->width != Src->width)
  {
    printf("ERROR: MRISspatialFilter: wdist/Src dimension mismatch\n");
    return(NULL);
  }

  /* Make a copy in case this is done in place */
  SrcCopy = MRIcopy(Src,NULL);

  // Set the target to 0
  Targ = MRIconst(Src->width,Src->height,Src->depth,Src->nframes,0,Targ);
  if (Targ==NULL)
  {
    printf("ERROR: MRISgaussianSmooth: Targ\n");
    return(NULL);
  }


  /* Loop thru each target vertex */
  for (n=0; n < Targ->width; n++)
  {
    nXNbrs = MRIFseq_vox(wdist,n,0,0,0); /*1st row is number of ext neighbors*/
    for (m=0; m < nXNbrs; m++)
    {
      vtxno =
        MRIFseq_vox(wdist,n,1,0,m); /*2nd row is the vtxno of ext neighbors*/
      w     =
        MRIFseq_vox(wdist,n,3,0,m); /*4th row is the weight of ext neighbors*/
      for (frame=0; frame < Targ->nframes; frame++)
      {
        val = w * MRIFseq_vox(SrcCopy,vtxno,0,0,frame);
        MRIFseq_vox(Targ,n,0,0,frame) += val;
      } /* frame */
    } /* neighbor */
  } /* primary vertex */

  MRIfree(&SrcCopy);
  return(Targ);
}

/*-------------------------------------------------------------------
  MRISdistSphere() - distance between two vertices on the sphere. The
  MRI structure returned is of size (nvertices,4,1,nXNbrsMax). Where
  nXNbrsMax is the maximum number of extended neighbors. The first 3
  rows correspond to: 0=actual number of extended neighbors for that
  vertex, 1=vertex number of extended neighbors, 2=distance along the
  sphere. The last row is free and can be used for computing
  weights. Each of the extended neighbors is placed in a frame. The
  extended neighborhood of a vertex includes itself. See also
  MRISgaussianWeights().
  -------------------------------------------------------------------*/
MRI *MRISdistSphere(MRIS *surf, double dmax)
{
  int vtxno;
  MRI *dist;
  double Radius, Radius2, d, costheta, theta;
  int n, err, *nXNbrs, nXNbrsMax;
  double *XNbrDotProd, DotProdThresh;
  int *XNbrVtxNoTmp, **XNbrVtxNo;
  float **XNbrDist;
  double VertexRadiusStdDev;

  // Create temp variables to hold info that will eventually
  // go into MRI dist
  nXNbrs  = (int *)calloc(surf->nvertices,sizeof(int));
  XNbrVtxNo = (int **)   calloc(surf->nvertices,sizeof(int*));
  XNbrDist  = (float **) calloc(surf->nvertices,sizeof(float*));

  // Compute the average radius of the sphere
  Radius = MRISavgVetexRadius(surf, &VertexRadiusStdDev);
  Radius2 = Radius*Radius; // Square of the radius
  printf("Radius = %g +/- %g\n",Radius,VertexRadiusStdDev);

  // Compute dot product threshold that corresponds to dmax
  // distance along the surface of the sphere.
  DotProdThresh = Radius2*cos(dmax/Radius)*(1.0001);

  /* These are needed by MRISextendedNeighbors()*/
  XNbrVtxNoTmp = (int *) calloc(surf->nvertices,sizeof(int));
  XNbrDotProd  = (double *) calloc(surf->nvertices,sizeof(double));

  /*-------- Loop through the vertices ------------------*/
  nXNbrsMax = 0;
  for (vtxno = 0; vtxno < surf->nvertices; vtxno++)
  {

    /* Get a count of the number of extended neighbors (including self)*/
    nXNbrs[vtxno] = 0;
    err =
      MRISextendedNeighbors(surf,vtxno,vtxno,DotProdThresh, XNbrVtxNoTmp,
                            XNbrDotProd, &(nXNbrs[vtxno]), surf->nvertices, 1);

    if (vtxno%1000==0)
    {
      // print something every 1000 vertices
      printf("vtxno = %d, nXNbrs = %d (Max=%d)\n",
             vtxno,nXNbrs[vtxno],nXNbrsMax);
      fflush(stdout);
    }

    /*Keep track of max*/
    if (nXNbrsMax < nXNbrs[vtxno])
    {
      nXNbrsMax = nXNbrs[vtxno];
    }

    // Alloc enough for this vertex
    XNbrDist[vtxno]  = (float*)calloc(nXNbrs[vtxno],sizeof(float));
    XNbrVtxNo[vtxno] = (int*)calloc(nXNbrs[vtxno],sizeof(int));

    // Can just copy vertex numbers
    memmove(XNbrVtxNo[vtxno],XNbrVtxNoTmp,nXNbrs[vtxno]*sizeof(int));

    /* Loop through the extended neighbors */
    for (n = 0; n < nXNbrs[vtxno]; n++)
    {

      // Compute the cos of the angle betweent the two vertices
      // based on the dot product between the two
      costheta = XNbrDotProd[n]/Radius2;

      // cos theta might be slightly > 1 due to precision
      if (costheta > +1.0)
      {
        costheta = +1.0;
      }
      if (costheta < -1.0)
      {
        costheta = -1.0;
      }

      // Compute the angle between the vertices
      theta = acos(costheta);

      /* Compute the distance bet vertices along the surface of the sphere */
      d = Radius * theta;
      XNbrDist[vtxno][n] = d;

    } /* end loop over vertex2 */

  } /* end loop over vertex1 */

  printf("nNbrsMax = %d\n",nXNbrsMax);

  free(XNbrVtxNoTmp);
  free(XNbrDotProd);

  /* Copy info into the dist structure */
  /*row 0=nXNbrs, 1=XNbrVtxNo, 2=XNbrDist, 3 = free */
  dist = MRIallocSequence(surf->nvertices, 4, 1, MRI_FLOAT, nXNbrsMax);

  for (vtxno = 0; vtxno < surf->nvertices; vtxno++)
  {
    MRIFseq_vox(dist,vtxno,0,0,0) = nXNbrs[vtxno];
    for (n = 0; n < nXNbrs[vtxno]; n++)
    {
      MRIFseq_vox(dist,vtxno,1,0,n) = XNbrVtxNo[vtxno][n];
      MRIFseq_vox(dist,vtxno,2,0,n) = XNbrDist[vtxno][n];
    }
    free(XNbrVtxNo[vtxno]);
    free(XNbrDist[vtxno]);
  }
  free(nXNbrs);

  return(dist);
}

///////////////////////////////////////////////////////////
// surfaceRASToSurfaceRAS routines
//
//
//        conformed  ------>   surfaceRAS   (c_(ras) = 0)   surface lives here
//          |                   |
//          |                   |   [ 1  Csrc ]
//          |                   |   [ 0  1    ]
//          V                   V
//         src     ------>     RAS  ( Csrc != 0 )
//          |                   |
//          |                   |
//          V                   V
//         dst    ------->     RAS  ( Ctal  ! = 0)
//          |                   |
//          |                   |   [ 1   - Ctal  ]
//          |                   |   [ 0       1   ]
//          V                   V
//     conformed   ------->  surfaceRAS (c_(ras) = 0 )
//            surface lives here for talairach space
//
MATRIX *surfaceRASToSurfaceRAS_(MRI *src, MRI *dst, LTA *lta)
{
  MATRIX *sRASToRAS=0;
  MATRIX *RASToSRAS=0;
  MATRIX *tmp = 0;
  MATRIX *res = 0;
  MATRIX *RASToRAS = 0;

  sRASToRAS = RASFromSurfaceRAS_(src);
  RASToSRAS = surfaceRASFromRAS_(dst);

  if (lta->type == LINEAR_RAS_TO_RAS)
  {
    tmp = MatrixMultiply(lta->xforms[0].m_L, sRASToRAS, NULL);
    res = MatrixMultiply(RASToSRAS, tmp, NULL);
    MatrixFree(&sRASToRAS);
    MatrixFree(&RASToSRAS);
    MatrixFree(&tmp);

    return res;
  }
  else if (lta->type == LINEAR_VOX_TO_VOX)
  {

    // just make sure
    if (!src->r_to_i__)
    {
      src->r_to_i__ = extract_r_to_i(src);
    }

    MATRIX *tmp2 = NULL;
    if (!dst->i_to_r__)
    {
      tmp2 = extract_i_to_r(dst);
      AffineMatrixAlloc( &(dst->i_to_r__) );
      SetAffineMatrix( dst->i_to_r__, tmp );
    }
    else
    {
      tmp2 = MatrixAlloc( 4, 4, MATRIX_REAL );
      GetAffineMatrix( tmp, dst->i_to_r__ );
    }

    // create ras_to_ras transform
    tmp = MatrixMultiply(lta->xforms[0].m_L, src->r_to_i__, NULL);
    RASToRAS = MatrixMultiply( tmp2, tmp, NULL);
    tmp = MatrixMultiply(RASToRAS, sRASToRAS, NULL);
    res = MatrixMultiply(RASToSRAS, tmp, NULL);

    MatrixFree(&RASToRAS);
    MatrixFree(&sRASToRAS);
    MatrixFree(&RASToSRAS);
    MatrixFree(&tmp);
    MatrixFree( &tmp2 );

    return res;
  }
  else
    ErrorExit
    (ERROR_BADPARM,
     "%s: xfm passed is neither of RAS-to-RAS type nor Vox-To-Vox type.",
     Progname) ;
  return 0;
}

MATRIX *getSRASToTalSRAS(LT *lt)
{
  MATRIX *RASFromSRAS = 0;
  MATRIX *sRASFromRAS = 0;
  MATRIX *tmpM = 0;
  MATRIX *SRASToTalSRAS = 0;

  // now calculate transform
  //  conformed -------> surfaceRAS
  //      |                  |
  //      V                  V  RASFromSRAS
  //     src     ------->   RAS
  //      |                  |   xfm
  //      V                  V
  //     tal    ------->   talRAS
  //      |                  |  sRASFromRAS
  //      V                  V
  //  conformed --------> surfaceRAS

  // must convert to RAS first
  RASFromSRAS = MatrixAlloc(4, 4, MATRIX_REAL);
  MatrixIdentity(4, RASFromSRAS);
  *MATRIX_RELT(RASFromSRAS, 1,4) = lt->src.c_r;
  *MATRIX_RELT(RASFromSRAS, 2,4) = lt->src.c_a;
  *MATRIX_RELT(RASFromSRAS, 3,4) = lt->src.c_s;

  sRASFromRAS = MatrixAlloc(4, 4, MATRIX_REAL);
  MatrixIdentity(4, sRASFromRAS);
  *MATRIX_RELT(sRASFromRAS, 1,4) = -lt->dst.c_r;
  *MATRIX_RELT(sRASFromRAS, 2,4) = -lt->dst.c_a;
  *MATRIX_RELT(sRASFromRAS, 3,4) = -lt->dst.c_s;

  tmpM = MatrixMultiply(lt->m_L, RASFromSRAS, NULL);
  SRASToTalSRAS = MatrixMultiply(sRASFromRAS, tmpM, NULL);

  MatrixFree(&RASFromSRAS);
  MatrixFree(&sRASFromRAS);
  MatrixFree(&tmpM);

  return SRASToTalSRAS;
}

// transform surface vertices to the dst volume surface
int
MRISsurf2surf(MRIS *mris, MRI *dst, LTA *lta)
{
  VECTOR *sX = 0;
  VECTOR *dX = 0;
  MATRIX *surf2surf = 0;
  MRI *src = 0;
  int i;
  int ltaNULL = 0;

  if (lta == NULL)
  {
    ltaNULL = 1;
    lta = LTAalloc(1, NULL);
    lta->type = LINEAR_RAS_TO_RAS;
    MatrixIdentity(4, lta->xforms[0].m_L);
    getVolGeom(dst, &lta->xforms[0].dst);
    getVolGeom(dst, &lta->inv_xforms[0].src);
    if (mris->vg.valid==1)
    {
      copyVolGeom(&mris->vg, &lta->xforms[0].src);
      copyVolGeom(&mris->vg, &lta->inv_xforms[0].dst);
    }
  }
  src =
    MRIallocHeader
    (mris->vg.width, mris->vg.height, mris->vg.depth, MRI_VOLUME_TYPE_UNKNOWN,1);
  if (mris->vg.valid ==0)
  {
    fprintf
    (stderr, "INFO: surface does not contain the volume geometry info\n");
    fprintf
    (stderr, "INFO: surf2surf conversion may be incorrect.\n");
  }
  useVolGeomToMRI(&mris->vg, src);

  sX = VectorAlloc(4, MATRIX_REAL);
  dX = VectorAlloc(4, MATRIX_REAL);
  surf2surf = surfaceRASFromSurfaceRAS_(dst, src, lta);
  // now get all the vertex points and change them to
  //    the corresponding dst surface vertices
  for (i = 0; i < mris->nvertices; i++)
  {
    V4_LOAD(sX,
            mris->vertices[i].x,
            mris->vertices[i].y,
            mris->vertices[i].z, 1.);
    MatrixMultiply(surf2surf, sX,  dX);
    mris->vertices[i].x = VECTOR_ELT(dX, 1);
    mris->vertices[i].y = VECTOR_ELT(dX, 2);
    mris->vertices[i].z = VECTOR_ELT(dX, 3);
  }
  // modify the geometry stored
  getVolGeom(dst, &mris->vg);
  // recalculate properties
  MRIScomputeNormals(mris);

  MRIfree(&src);
  src = 0;
  VectorFree(&sX);
  sX = 0;
  VectorFree(&dX);
  dX = 0;
  MatrixFree(&surf2surf);
  surf2surf = 0;
  if (ltaNULL==1)
  {
    LTAfree(&lta);
  }

  return 0;
}
// transform surface vertices positions (all of them) to the dst volume surface
int
MRISsurf2surfAll(MRIS *mris, MRI *dst, LTA *lta)
{
  VECTOR *sX = 0;
  VECTOR *dX = 0;
  MATRIX *surf2surf = 0;
  MRI *src = 0;
  int i;
  int ltaNULL = 0;

  if (lta == NULL)
  {
    ltaNULL = 1;
    lta = LTAalloc(1, NULL);
    lta->type = LINEAR_RAS_TO_RAS;
    MatrixIdentity(4, lta->xforms[0].m_L);
    getVolGeom(dst, &lta->xforms[0].dst);
    getVolGeom(dst, &lta->inv_xforms[0].src);
    if (mris->vg.valid==1)
    {
      copyVolGeom(&mris->vg, &lta->xforms[0].src);
      copyVolGeom(&mris->vg, &lta->inv_xforms[0].dst);
    }
  }
  src = MRIallocHeader(mris->vg.width, mris->vg.height, mris->vg.depth,
                       MRI_VOLUME_TYPE_UNKNOWN,1);
  if (mris->vg.valid ==0)
  {
    fprintf
    (stderr, "INFO: surface does not contain the volume geometry info\n");
    fprintf
    (stderr, "INFO: surf2surf conversion may be incorrect.\n");
  }
  useVolGeomToMRI(&mris->vg, src);
  if (mris->useRealRAS == 0)
  {
    dst->c_r = dst->c_a = dst->c_s = 0 ;
  }

  mris->useRealRAS = 1 ;
  sX = VectorAlloc(4, MATRIX_REAL);
  dX = VectorAlloc(4, MATRIX_REAL);
  surf2surf = surfaceRASFromSurfaceRAS_(dst, src, lta);
  // now get all the vertex points and change them to
  //    the corresponding dst surface vertices
  for (i = 0; i < mris->nvertices; i++)
  {
    // current
    V4_LOAD(sX,
            mris->vertices[i].x,
            mris->vertices[i].y,
            mris->vertices[i].z, 1.);
    MatrixMultiply(surf2surf, sX,  dX);
    mris->vertices[i].x = VECTOR_ELT(dX, 1);
    mris->vertices[i].y = VECTOR_ELT(dX, 2);
    mris->vertices[i].z = VECTOR_ELT(dX, 3);

    // original
    V4_LOAD(sX,
            mris->vertices[i].origx,
            mris->vertices[i].origy,
            mris->vertices[i].origz, 1.);
    MatrixMultiply(surf2surf, sX,  dX);
    mris->vertices[i].origx = VECTOR_ELT(dX, 1);
    mris->vertices[i].origy = VECTOR_ELT(dX, 2);
    mris->vertices[i].origz = VECTOR_ELT(dX, 3);

    // white
    V4_LOAD(sX,
            mris->vertices[i].whitex,
            mris->vertices[i].whitey,
            mris->vertices[i].whitez, 1.);
    MatrixMultiply(surf2surf, sX,  dX);
    mris->vertices[i].whitex = VECTOR_ELT(dX, 1);
    mris->vertices[i].whitey = VECTOR_ELT(dX, 2);
    mris->vertices[i].whitez = VECTOR_ELT(dX, 3);

    // pial
    V4_LOAD(sX,
            mris->vertices[i].pialx,
            mris->vertices[i].pialy,
            mris->vertices[i].pialz, 1.);
    MatrixMultiply(surf2surf, sX,  dX);
    mris->vertices[i].pialx = VECTOR_ELT(dX, 1);
    mris->vertices[i].pialy = VECTOR_ELT(dX, 2);
    mris->vertices[i].pialz = VECTOR_ELT(dX, 3);
  }
  // modify the geometry stored
  getVolGeom(dst, &mris->vg);
  // recalculate properties
  MRIScomputeNormals(mris);

  MRIfree(&src);
  src = 0;
  VectorFree(&sX);
  sX = 0;
  VectorFree(&dX);
  dX = 0;
  MatrixFree(&surf2surf);
  surf2surf = 0;
  if (ltaNULL==1)
  {
    LTAfree(&lta);
  }

  return 0;
}


/*--------------------------------------------------------
  MRISsetReadFrame() - sets frame to read when loading a "volume"
  with MRISreadValues().
  --------------------------------------------------------*/
void MRISsetReadFrame(int frame)
{
  mris_readval_frame = frame;
}
/*--------------------------------------------------------
  MRISgetReadFrame() - gets frame to read when loading a "volume"
  with MRISreadValues().
  --------------------------------------------------------*/
int MRISgetReadFrame(void)
{
  int frame=0;
  char *envframe;
  if (mris_readval_frame >=0)
  {
    return(mris_readval_frame);
  }
  envframe = getenv("MRIS_READVAL_FRAME");
  if (envframe == NULL)
  {
    return(0);
  }
  sscanf(envframe,"%d",&frame);
  return(frame);
}
int
MRISaddCommandLine(MRI_SURFACE *mris, char *cmdline)
{
  int i ;
  if (mris->ncmds >= MAX_CMDS)
    ErrorExit
    (ERROR_NOMEMORY,
     "MRISaddCommandLine: can't add cmd %s (%d)", cmdline, mris->ncmds) ;

  i = mris->ncmds++ ;
  mris->cmdlines[i] = (char *)calloc(strlen(cmdline)+1, sizeof(char)) ;
  strcpy(mris->cmdlines[i], cmdline) ;
  return(NO_ERROR) ;
}
int
MRISabsVals(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = fabs(v->val) ;
  }
  return(NO_ERROR) ;
}
int
MRISabsCurvature(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = fabs(v->curv) ;
  }
  return(NO_ERROR) ;
}
int
MRISsmoothFrames(MRI_SURFACE *mris, MRI *mri, int navgs)
{
  int frame ;

  for (frame = 0 ; frame < mri->nframes ; frame++)
  {
    MRISwriteFrameToValues(mris, mri, frame) ;
    MRISaverageVals(mris, navgs) ;
    MRISreadFrameFromValues(mris, mri, frame) ;
  }
  return(NO_ERROR) ;
}
int
MRISwriteFrameToValues(MRI_SURFACE *mris, MRI *mri, int frame)
{
  int    vno ;
  VERTEX *v ;

  if (mri->width != mris->nvertices)
    ErrorReturn(ERROR_BADPARM,
                (ERROR_BADPARM,
                 "MRISwriteFrameToValues: mri width %d != mris->nvertices %d",
                 mri->width, mris->nvertices)) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v->val = MRIgetVoxVal(mri, vno, 0, 0, frame) ;
  }
  return(NO_ERROR) ;

}
int
MRISreadFrameFromValues(MRI_SURFACE *mris, MRI *mri, int frame)
{
  int    vno ;
  VERTEX *v ;

  if (mri->width != mris->nvertices)
    ErrorReturn(ERROR_BADPARM,
                (ERROR_BADPARM,
                 "MRISreadFrameToValues: mri width %d != mris->nvertices %d",
                 mri->width, mris->nvertices)) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    MRIsetVoxVal(mri, vno, 0, 0, frame, v->val) ;
  }
  return(NO_ERROR) ;

}

static int mrisSmoothingTimeStep(MRI_SURFACE *mris, INTEGRATION_PARMS *parms) ;
int
MRISremoveOverlapWithSmoothing(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int    negative, old_neg, same = 0, min_neg, min_neg_iter, last_expand ;

  parms->dt = .99 ;
  parms->max_nbrs = 0 ;
  min_neg = negative = MRIScountNegativeTriangles(mris) ;
  min_neg_iter = 0 ;
  last_expand = 0 ;
  parms->t = parms->start_t ;
  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    if (!parms->fp)
    {
      sprintf
      (fname, "%s.%s.out",
       mris->hemisphere==RIGHT_HEMISPHERE ? "rh":"lh",parms->base_name);
      parms->fp = fopen(fname, "a") ;
      if (!parms->fp)
        ErrorExit(ERROR_NOFILE, "%s: could not open log file %s",
                  Progname, fname) ;
    }
  }
  while (negative > 0)
  {
    old_neg = negative ;

    if (Gdiag & DIAG_SHOW && (parms->t % 100 == 0) && parms->t > 0)
      printf("%03d: dt=%2.4f, %d negative triangles\n", parms->t, parms->dt,
             negative) ;
    if (parms->fp && parms->t % 100==0)
      fprintf(parms->fp, "%03d: dt=%2.4f, %d negative triangles\n", parms->t, parms->dt,
              negative) ;

    mrisSmoothingTimeStep(mris, parms) ;
    parms->t++; // advance time-step counter
    mrisProjectSurface(mris) ;
    MRIScomputeMetricProperties(mris) ;
    negative = MRIScountNegativeTriangles(mris) ;
    if (negative < min_neg)
    {
      min_neg = negative ;
      min_neg_iter = parms->t ;
    }
    else if ((((parms->t-min_neg_iter) % 10) == 0) && parms->t > min_neg_iter)
    {
      if (parms->dt > 0.01)
      {
        parms->dt *= 0.95 ;
      }
    }
    else if ((parms->t > min_neg_iter+50) && parms->t > last_expand+25)
    {
      if (parms->max_nbrs < 1)
      {
        parms->dt = 0.99 ;
        parms->max_nbrs++ ;
        printf("expanding nbhd size to %d\n", parms->max_nbrs) ;
      }
      //      parms->dt /= 2 ;
      last_expand = parms->t ;
      same = 0 ;
    }
    if (parms->t > min_neg_iter+1000)
    {
      printf("terminating loop due to lack of progress\n") ;
      break ;
    }
    if (old_neg == negative)
    {
      if (same++ > 25 && parms->max_nbrs < 1)
      {
        parms->max_nbrs++ ;
        parms->dt = 0.99 ;
        printf("expanding nbhd size to %d\n", parms->max_nbrs) ;
        last_expand = parms->t ;
        //        parms->dt /= 2 ;
        same = 0 ;
      }
    }
    else
    {
      same = 0 ;
    }
#if 0
    if (parms->t == parms->niterations/4)
    {
      parms->max_nbrs++ ;
      //      parms->dt /= 2 ;
      last_expand = parms->t ;
      parms->dt = 0.99 ;
      printf("expanding nbhd size to %d\n", parms->max_nbrs) ;
    }
    if (parms->t == parms->niterations/2)
    {
      parms->max_nbrs++ ;
      //      parms->dt /= 2 ;
      last_expand = parms->t ;
      printf("expanding nbhd size to %d\n", parms->max_nbrs) ;
      parms->dt = 0.99 ;
    }

    if (parms->t == 3*parms->niterations/4)
    {
      last_expand = parms->t ;
      //      parms->dt /= 2 ;
      parms->max_nbrs++ ;
      parms->dt = 0.99 ;
      printf("expanding nbhd size to %d\n", parms->max_nbrs) ;
    }
#endif

    if (parms->t-parms->start_t > parms->niterations)
    {
      break ;
    }
  }

  if (negative > 0)
  {
    printf("%03d: %d negative triangles\n", parms->t, negative) ;
  }
  if (parms->fp)
  {
    fclose(parms->fp) ;
    parms->fp = NULL ;
  }
  parms->t += parms->start_t ;
  parms->start_t = parms->t ;
  return(NO_ERROR) ;
}

static int
mrisSmoothingTimeStep(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int      vno, n, m, fno ;
  VERTEX   *v, *vn ;
  FACE     *face ;
  double   dx, dy, dz, x, y, z, max_dx, max_dy, max_dz ;

  MRIScomputeMetricProperties(mris) ;
  MRISclearMarks(mris) ;
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    face = &mris->faces[fno] ;
    if (face->area < 0)
    {
      for (n = 0 ; n < VERTICES_PER_FACE ; n++)
      {
        v = &mris->vertices[face->v[n]] ;
        v->area = -1 ;
        v->marked = 1 ;
      }
    }
  }

#if 0
  for (m = 0 ; m < parms->max_nbrs ; m++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->area <  0 || v->marked == 1)
      {
        continue ;
      }

      // check to see if it has a nbr that is marked
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        if (vn->marked == 1)
        {
          v->marked = 2 ;
          break ;
        }
      }
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->marked == 2)
      {
        v->marked = 1 ;
      }
    }
  }
#else
  MRISdilateMarked(mris, parms->max_nbrs) ;
#endif

  max_dx = max_dy = max_dz = 0 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked == 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;

    dx = dy = dz = 0.0 ;
    n=0;
    for (m = 0 ; m < v->vnum ; m++)
    {
      vn = &mris->vertices[v->v[m]] ;
      if (!vn->ripflag)
      {
        if (vno == Gdiag_no)
          fprintf(stdout, "v %d --> %d spring term:         (%2.3f, %2.3f, %2.3f)\n",
                  vno, v->v[m], vn->x-x, vn->y-y, vn->z-z) ;
        dx += vn->x - x;
        dy += vn->y - y;
        dz += vn->z - z;
        n++;
      }
    }
    if (n>0)
    {
      dx = dx/n;
      dy = dy/n;
      dz = dz/n;
    }

    v->dx = dx ;
    v->dy = dy ;
    v->dz = dz ;
    if (fabs(dx) > fabs(max_dx))
    {
      max_dx = dx ;
    }
    if (fabs(dy) > fabs(max_dy))
    {
      max_dy = dy ;
    }
    if (fabs(dz) > fabs(max_dz))
    {
      max_dz = dz ;
    }

    if (vno == Gdiag_no)
      fprintf(stdout, "v %d spring term:         (%2.3f, %2.3f, %2.3f)\n",
              vno, dx, dy, dz) ;
  }
  if (Gdiag & DIAG_SHOW && DIAG_VERBOSE_ON)
    printf("max delta = (%2.4f, %2.4f, %2.4f) [%2.3f]\n",
           max_dx, max_dy, max_dz, sqrt(SQR(max_dx)+SQR(max_dy)+SQR(max_dz))) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag || v->marked == 0)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v->x += v->dx * parms->dt ;
    v->y += v->dy * parms->dt ;
    v->z += v->dz * parms->dt ;
  }
  MRISclearMarks(mris) ;
  return(NO_ERROR) ;
}

int
MRISupsampleIco(MRI_SURFACE *mris, MRI_SURFACE *mris_new)
{
  int    vno ;
  VERTEX *vold, *vnew ;

  MRISclearMarks(mris_new) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vold = &mris->vertices[vno] ;
    vnew = &mris_new->vertices[vno] ;
    vnew->x = vold->x ;
    vnew->y = vold->y ;
    vnew->z = vold->z ;
    vnew->origx = vold->origx ;
    vnew->origy = vold->origy ;
    vnew->origz = vold->origz ;
    vnew->marked = 1 ;
  }
  MRISsoapBubbleVertexPositions(mris_new, 100) ;
  MRISsoapBubbleOrigVertexPositions(mris_new, 100) ;
  copyVolGeom(&mris->vg, &mris_new->vg);
  return(NO_ERROR) ;
}

int MRIScopyVolGeomFromMRI(MRI_SURFACE *mris, MRI *mri)
{
  VOL_GEOM *vg = &mris->vg ;

  vg->xsize = mri->xsize ;
  vg->ysize = mri->ysize ;
  vg->zsize = mri->zsize ;
  vg->x_r = mri->x_r ;
  vg->y_r = mri->y_r ;
  vg->z_r = mri->z_r ;
  vg->c_r = mri->c_r ;
  vg->x_a = mri->x_a ;
  vg->y_a = mri->y_a ;
  vg->z_a = mri->z_a ;
  vg->c_a = mri->c_a ;
  vg->x_s = mri->x_s ;
  vg->y_s = mri->y_s ;
  vg->z_s = mri->z_s ;
  vg->c_s = mri->c_s ;
  vg->width = mri->width ;
  vg->height = mri->height ;
  vg->depth = mri->depth ;
  vg->valid = 1 ;
  strcpy(vg->fname, mri->fname) ;
  return(NO_ERROR) ;
}

int
MRISremoveIntersections(MRI_SURFACE *mris)
{
  int     n, num, vno, writeit=0, old_num, nbrs, m ;
  VERTEX  *v ;

  n = 0 ;

  printf("removing intersecting faces\n") ;
  old_num = mris->nvertices ;
  nbrs = 1 ;
  while ((num = mrisMarkIntersections(mris)) > 0)
  {
    if (num >= old_num)  // couldn't remove any
    {
      // couldn't make any more progress with 1 nbrs, expand
      nbrs++ ;
      printf("expanding nbhd size to %d\n", nbrs);
    }

    for (m = 0 ; m <= nbrs ; m++)
    {
      MRISexpandMarked(mris) ;
    }
    old_num = num ;

    printf("%03d: %d intersecting\n", n, num) ;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      v->marked = !v->marked ;  // soap bubble will fix the marked ones
    }
    MRISsoapBubbleVertexPositions(mris, 5) ;
    if (writeit)
    {
      char fname[STRLEN] ;
      sprintf(fname, "%s.avg%03d",
              mris->hemisphere == RIGHT_HEMISPHERE ? "rh" : "lh",
              n) ;
      MRISwrite(mris, fname) ;
    }
    if (n++ > 100)
    {
      break ;
    }
  }

  return(NO_ERROR) ;
}

static int
mrisMarkIntersections(MRI_SURFACE *mris)
{
  MRIS_HASH_TABLE  *mht ;
  FACE             *f ;
  int              fno, n, num = 0 ;

  mht = MHTfillTable(mris, NULL) ;

  MRISclearMarks(mris) ;
  for (num = fno = 0 ; fno < mris->nfaces ; fno++)
  {
    if (MHTdoesFaceIntersect(mht, mris, fno))
    {
      num++ ;
      f = &mris->faces[fno] ;
      for (n = 0 ; n < VERTICES_PER_FACE ; n++)
      {
        mris->vertices[f->v[n]].marked = 1;
      }
    }
  }

  MHTfree(&mht) ;
  return(num) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISaverageMarkedVertexPositions(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  x, y, z, num ;
  VERTEX *v, *vn ;
  int    nmarked ;

  for (i = 0 ; i < navgs ; i++)
  {
    for (nmarked = vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 0)
      {
        continue ;
      }
      x = y = z = 0;
      num = 0;
      x = v->x ;
      y = v->y ;
      z = v->z ;
      num++ ;   /* account for central vertex */
      pnb = v->v ;
      vnum = v->vnum ;
      for (vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag) /* no valid data */
        {
          continue ;
        }
        num++ ;
        x += vn->x ;
        y += vn->y ;
        z += vn->z ;
      }
      v->tdx = x / num ;
      v->tdy = y / num ;
      v->tdz = z / num ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag || v->marked == 0)
      {
        continue ;
      }
      v->x = v->tdx ;
      v->y = v->tdy ;
      v->z = v->tdz ;
    }
  }
  return(NO_ERROR) ;
}
#if 0
static int
mrisSoapBubbleIntersectingDefects(MRI_SURFACE *mris)
{
  int      vno, num, vno2, n ;
  VERTEX   *v, *v2 ;

  /* coming in the v->marked field lists the defect #. If not part
     of a defect v->marked == -1.
  */
  MRIScopyMarkedToMarked2(mris) ;
  n = 0 ;
  while ((num = mrisMarkIntersections(mris)) > 0)
  {
    // mark all of each defect that has an intersection
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->marked)   // it is intersecting - mark the whole defect
      {
        if (v->marked2 >= 0)  // part of a defect
        {
          for (vno2 = 0 ; vno2 < mris->nvertices ; vno2++)
          {
            v2 = &mris->vertices[vno2] ;
            if (v2->marked2 == v->marked2)  // part of same defect
            {
              v2->marked = 1 ;
            }
          }
        }
      }
    }

    printf("%03d: %d intersecting\n", n, num) ;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      v->marked = !v->marked ;  // soap bubble will fix the marked ones
    }
    MRISsoapBubbleVertexPositions(mris, 5) ;
    if (n++ > 100)
    {
      break ;
    }
  }
  return(NO_ERROR) ;
}
#endif
int
MRIScopyMarkedToMarked2(MRI_SURFACE *mris)
{
  int      vno ;
  VERTEX   *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->marked2 = v->marked ;
  }
  return(NO_ERROR) ;
}

int
MRIScopyMarked2ToMarked(MRI_SURFACE *mris)
{
  int      vno ;
  VERTEX   *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->marked = v->marked2 ;
  }
  return(NO_ERROR) ;
}

int
MRIScopyMarkedToMarked3(MRI_SURFACE *mris)
{
  int      vno ;
  VERTEX   *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->marked3 = v->marked ;
  }
  return(NO_ERROR) ;
}

int
MRIScopyMarked3ToMarked(MRI_SURFACE *mris)
{
  int      vno ;
  VERTEX   *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->marked = v->marked3 ;
  }
  return(NO_ERROR) ;
}


/* assume that the mark is 1 */
int
MRISexpandMarked(MRI_SURFACE *mris)
{
  int      vno, n ;
  VERTEX   *v, *vn ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked==1)
    {
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        if (vn->marked == 0)
        {
          vn->marked = 2 ;
        }
      }
    }
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked == 2)
    {
      v->marked = 1 ;
    }
  }
  return(NO_ERROR) ;
}
// These are for backwards compatibility for when we don't want to fix
// the vertex area. Default is to fix, but this can be changed
// by setting to 0. fix_vertex_area is defined as "static int fix_vertex_area;"
// at the top of this file.
int MRISsetFixVertexAreaValue(int value)
{
  extern int fix_vertex_area;
  fix_vertex_area = value;
  return(fix_vertex_area);
}
int MRISgetFixVertexAreaValue(void)
{
  extern int fix_vertex_area;
  return(fix_vertex_area);
}
int
MRISsetCurvature(MRI_SURFACE *mris, float val)
{
  int  vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->curv = val ;
  }
  return(NO_ERROR) ;
}

int
MRIScomputeClassStatistics(MRI_SURFACE *mris,
                           MRI *mri,
                           float *pwhite_mean,
                           float *pwhite_std,
                           float *pgray_mean,
                           float *pgray_std)
{
  double    val, x, y, z, xw, yw, zw ;
  int     total_vertices, vno ;
  VERTEX  *v ;
  double    mean_white, mean_gray, std_white, std_gray, nsigma, gw_thresh  ;
  FILE    *fpwm, *fpgm ;

  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    fpwm = fopen("wm.dat", "w") ;
    fpgm = fopen("gm.dat", "w") ;
  }
  else
  {
    fpgm = fpwm = NULL ;
  }

  std_white = std_gray = mean_white = mean_gray = 0.0 ;
  for (total_vertices = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    total_vertices++ ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    x = v->x+1.0*v->nx ;
    y = v->y+1.0*v->ny ;
    z = v->z+1.0*v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xw, &yw, &zw);
    MRIsampleVolume(mri, xw, yw, zw, &val) ;
    if (fpgm)
    {
      fprintf(fpgm, "%d %2.1f %2.1f %2.1f %f\n", vno, xw, yw, zw, val) ;
    }
    mean_gray += val ;
    std_gray += (val*val) ;

    x = v->x-0.5*v->nx ;
    y = v->y-0.5*v->ny ;
    z = v->z-0.5*v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xw, &yw, &zw);
    MRIsampleVolume(mri, xw, yw, zw, &val) ;
    if (fpwm)
    {
      fprintf(fpwm, "%d %2.1f %2.1f %2.1f %f\n", vno, xw, yw, zw, val) ;
    }
    mean_white += val ;
    std_white += (val*val) ;
  }

  *pwhite_mean = mean_white /= (float)total_vertices ;
  *pwhite_std =
    std_white =
      sqrt(std_white / (float)total_vertices - mean_white*mean_white) ;
  *pgray_mean = mean_gray /= (float)total_vertices ;
  *pgray_std = std_gray =
                 sqrt(std_gray / (float)total_vertices - mean_gray*mean_gray) ;
  nsigma = (mean_gray-mean_white) / (std_gray+std_white) ;
  gw_thresh = mean_white + nsigma*std_white ;
  printf("white %2.1f +- %2.1f,    "
         "gray %2.1f +- %2.1f, G/W boundary at %2.1f\n",
         mean_white, std_white, mean_gray, std_gray, gw_thresh) ;

  if (fpwm)
  {
    fclose(fpgm) ;
    fclose(fpwm) ;
  }
  return(NO_ERROR) ;
}
int
MRIScomputeClassModes(MRI_SURFACE *mris,
                      MRI *mri,
                      float *pwhite_mode, float *pgray_mode, float *pcsf_mode)
{
  HISTOGRAM *h_white, *h_csf, *h_gray ;
  float      min_val, max_val ;
  int        nbins, b, vno, gray_peak, white_peak, csf_peak, bin ;
  VERTEX     *v ;
  double       val, x, y, z, xw, yw, zw ;

  MRIvalRange(mri, &min_val, &max_val) ;
  nbins = ceil(max_val - min_val) + 1 ;
  h_white = HISTOalloc(nbins) ;
  h_csf = HISTOalloc(nbins) ;
  h_gray = HISTOalloc(nbins) ;

  for (b = 0 ; b < nbins ; b++)
  {
    h_white->bins[b] = min_val + b ;
    h_csf->bins[b] = min_val + b ;
    h_gray->bins[b] = min_val + b ;
  }

  // use g/w boundary to compute gray and white histograms
  MRISsaveVertexPositions(mris, TMP_VERTICES) ;
  MRISrestoreVertexPositions(mris, WHITE_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

#define WM_SAMPLE_DIST 1.0
    x = v->x-WM_SAMPLE_DIST*v->nx ;
    y = v->y-WM_SAMPLE_DIST*v->ny ;
    z = v->z-WM_SAMPLE_DIST*v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xw, &yw, &zw) ;

    MRIsampleVolume(mri, xw, yw, zw, &val) ;
    bin = nint(val - min_val) ;
    if (bin < 0 || bin >= h_white->nbins)
    {
      DiagBreak() ;
    }
    h_white->counts[bin]++ ;

    x = v->x+1.0*v->nx ;
    y = v->y+1.0*v->ny ;
    z = v->z+1.0*v->nz ;
    MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xw, &yw, &zw) ;
    MRIsampleVolume(mri, xw, yw, zw, &val) ;
    bin = nint(val - min_val) ;
    if (bin < 0 || bin >= h_gray->nbins)
    {
      DiagBreak() ;
    }
    h_gray->counts[bin]++ ;
  }

  if (pcsf_mode)
  {
    MRISrestoreVertexPositions(mris, PIAL_VERTICES) ;
    MRIScomputeMetricProperties(mris) ;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }

      x = v->x-0.5*v->nx ;
      y = v->y-0.5*v->ny ;
      z = v->z-0.5*v->nz ;
      MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xw, &yw, &zw) ;
      if (MRIindexNotInVolume(mri, xw, yw, zw) == 0)
      {
        MRIsampleVolume(mri, xw, yw, zw, &val) ;
        bin = nint(val - min_val) ;
        if (bin < 0 || bin >= h_gray->nbins)
        {
          DiagBreak() ;
        }
        h_gray->counts[bin]++ ;
      }

      x = v->x+0.5*v->nx ;
      y = v->y+0.5*v->ny ;
      z = v->z+0.5*v->nz ;
      MRISsurfaceRASToVoxelCached(mris, mri, x, y, z, &xw, &yw, &zw) ;
      if (MRIindexNotInVolume(mri, xw, yw, zw) == 0)
      {
        MRIsampleVolume(mri, xw, yw, zw, &val) ;
        bin = nint(val - min_val) ;
        if (bin < 0 || bin >= h_csf->nbins)
        {
          DiagBreak() ;
        }
        if (bin == 68)
        {
          DiagBreak() ;
        }
        h_csf->counts[bin]++ ;
      }
    }
    HISTOclearZeroBin(h_csf) ;
    csf_peak = HISTOfindHighestPeakInRegion(h_csf, 0, h_csf->nbins) ;
    *pcsf_mode = h_csf->bins[csf_peak] ;
    if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
    {
      HISTOplot(h_csf, "csf.plt") ;
    }
  }

  HISTOclearZeroBin(h_white) ;
  HISTOclearZeroBin(h_gray) ;
  white_peak = HISTOfindHighestPeakInRegion(h_white, 0, h_white->nbins) ;
  gray_peak = HISTOfindHighestPeakInRegion(h_gray, 0, h_gray->nbins) ;
  *pwhite_mode = h_white->bins[white_peak] ;
  *pgray_mode = h_gray->bins[gray_peak] ;
  if (pcsf_mode)
    printf("intensity peaks found at WM=%d,    GM=%d,   CSF=%d\n",
           nint(*pwhite_mode), nint(*pgray_mode), nint(*pcsf_mode)) ;
  else
    printf("intensity peaks found at WM=%d,    GM=%d\n",
           nint(*pwhite_mode), nint(*pgray_mode)) ;
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    HISTOplot(h_white, "wm.plt") ;
    HISTOplot(h_gray, "gm.plt") ;
  }
  HISTOfree(&h_white) ;
  HISTOfree(&h_csf) ;
  HISTOfree(&h_gray) ;

  // back to initial state
  MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;
  return(NO_ERROR) ;
}

int
MRISrasToVoxel(MRI_SURFACE *mris,
               MRI *mri,
               double xs, double ys, double zs,
               double *pxv, double *pyv, double *pzv)
{
  return(MRISsurfaceRASToVoxelCached(mris, mri, xs, ys, zs, pxv, pyv, pzv));
}

int
MRISstoreRipFlags(MRI_SURFACE *mris)
{
  int    vno, fno ;
  VERTEX *v ;
  FACE   *f ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->oripflag = v->ripflag ;
  }
  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    f->oripflag = f->ripflag ;
  }
  return(NO_ERROR) ;
}

int
MRISrestoreRipFlags(MRI_SURFACE *mris)
{
  int    vno, fno ;
  VERTEX *v ;
  FACE   *f ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->ripflag = v->oripflag ;
  }

  for (fno = 0 ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    f->ripflag = f->oripflag ;
  }


  return(NO_ERROR) ;
}

/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISripMedialWall(MRI_SURFACE *mris)
{
  int     vno, med_index, unknown_index ;
  VERTEX  *v ;
  int     structure;

  printf("ripping medial wall...\n") ;
  CTABfindName(mris->ct, "Unknown", &unknown_index) ;
  CTABfindName(mris->ct, "Medial_wall", &med_index) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    CTABfindAnnotation(mris->ct, v->annotation, &structure);
    if (structure == unknown_index || structure == med_index)
    {
      v->ripflag = 1 ;
    }
  }
  MRISripFaces(mris) ;
  return(NO_ERROR) ;
}


/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRISzeroMedialWallCurvature(MRI_SURFACE *mris)
{
  int     vno, med_index, unknown_index ;
  VERTEX  *v ;
  int     structure;

  printf("erasing medial wall curvatures...\n") ;
  CTABfindName(mris->ct, "Unknown", &unknown_index) ;
  CTABfindName(mris->ct, "Medial_wall", &med_index) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    CTABfindAnnotation(mris->ct, v->annotation, &structure);
    if (structure == unknown_index || structure == med_index)
    {
      v->curv = 0 ;
    }
  }
  MRISripFaces(mris) ;
  return(NO_ERROR) ;
}


int
MRISvertexNormalInVoxelCoords(MRI_SURFACE *mris,
                              MRI *mri,
                              int vno,
                              double *pnx,
                              double *pny,
                              double *pnz)
{
  double  xv0, yv0, zv0, xv1, yv1, zv1, xw, yw, zw, norm, nx, ny, nz ;
  VERTEX  *v ;

  v = &mris->vertices[vno] ;
  MRISvertexToVoxel(mris, v, mri, &xv0, &yv0, &zv0) ;

  xw = v->x + v->nx ;
  yw = v->y + v->ny ;
  zw = v->z + v->nz ;
  MRISsurfaceRASToVoxelCached(mris, mri, xw, yw, zw, &xv1, &yv1, &zv1);

  nx = xv1-xv0 ;
  ny = yv1-yv0 ;
  nz = zv1-zv0 ;
  norm = sqrt(nx*nx + ny*ny + nz*nz) ;
  if (!FZERO(norm))
  {
    nx /= norm ;
    ny /= norm ;
    nz /= norm ;
  }
  *pnx = nx ;
  *pny = ny ;
  *pnz = nz ;

  return(NO_ERROR) ;
}



static int
enforce_links(MRI_SURFACE *mris)
{
  int         vno, vno2, n ;
  VERTEX      *v, *v2 ;
  VERTEX_INFO *vi ;

  vi = (VERTEX_INFO *)mris->user_parms ;
  if (vi == NULL)
  {
    return(NO_ERROR) ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    if (v->linked)
    {
      double odx, dx, ody, dy, odz, dz ;

      // compute average of all linked vertices
      odx = v->odx ;
      ody = v->ody ;
      odz = v->odz ;
      dx  =  v->dx ;
      dy = v->dy ;
      dz = v->dz ;
      for (n = 0 ; n < vi[vno].nlinks ; n++)
      {
        vno2 = vi[vno].linked_vno[n] ;
        v2 = &mris->vertices[vno2] ;
        odx += v2->odx ;
        ody += v2->ody ;
        odz += v2->odz ;
        dx += v2->dx  ;
        dy += v2->dy  ;
        dz += v2->dz ;
      }
      dx /= (double)(n+1) ;
      dy /= (double)(n+1) ;
      dz /= (double)(n+1) ;
      odx /= (double)(n+1) ;
      ody /= (double)(n+1) ;
      odz /= (double)(n+1) ;
      v->dx = dx ;
      v->dy = dy ;
      v->dz = dz ;
      v->odx = odx ;
      v->ody = ody ;
      v->odz = odz ;
      for (n = 0 ; n < vi[vno].nlinks ; n++)
      {
        vno2 = vi[vno].linked_vno[n] ;
        v2 = &mris->vertices[vno2] ;
        v2->dx = dx ;
        v2->dy = dy ;
        v2->dz = dz ;
        v2->odx = odx ;
        v2->ody = ody ;
        v2->odz = odz ;
      }
    }
  }

  return(NO_ERROR) ;
}

static int
enforce_link_positions(MRI_SURFACE *mris)
{
  int         vno, vno2, n ;
  VERTEX      *v, *v2 ;
  VERTEX_INFO *vi ;

  vi = (VERTEX_INFO *)mris->user_parms ;
  if (vi == NULL)
  {
    return(NO_ERROR) ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    if (v->linked)
    {
      double x, y, z ;

      // compute average of all linked vertices
      x  =  v->x ;
      y = v->y ;
      z = v->z ;
      for (n = 0 ; n < vi[vno].nlinks ; n++)
      {
        vno2 = vi[vno].linked_vno[n] ;
        v2 = &mris->vertices[vno2] ;
        x += v2->x ;
        y += v2->y ;
        z += v2->z ;
      }
      x /= (double)(n+1) ;
      y /= (double)(n+1) ;
      z /= (double)(n+1) ;
      v->x = x ;
      v->y = y ;
      v->z = z ;
      for (n = 0 ; n < vi[vno].nlinks ; n++)
      {
        vno2 = vi[vno].linked_vno[n] ;
        v2 = &mris->vertices[vno2] ;
        v2->x = x ;
        v2->y = y ;
        v2->z = z ;
      }
    }
  }
  return(NO_ERROR) ;
}

#if 0
static MRI_SP *
MRISPiterative_blur(MRI_SURFACE *mris,
                    MRI_SP *mrisp_src,
                    MRI_SP *mrisp_dst,
                    float sigma, int frame)
{
  int niter ;
  float *curvs = (float *)calloc(mris->nvertices, sizeof(float)) ;

  if (!mrisp_dst)
  {
    mrisp_dst = MRISPclone(mrisp_src) ;
  }
  mrisp_dst->sigma = sigma ;

  MRISextractCurvatureVector(mris, curvs) ;

  MRISfromParameterization(mrisp_src, mris, frame);

  niter = nint(sigma*sigma*M_PI/2) ;
  MRISaverageCurvatures(mris, niter) ;
  MRIStoParameterization(mris, mrisp_dst, 1, frame) ;

  MRISimportCurvatureVector(mris, curvs) ;
  free(curvs) ;
  return(mrisp_dst) ;
}
#endif
int
MRISripMarked(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked)
    {
      v->ripflag = 1 ;
    }
  }
  return(NO_ERROR) ;
}
int
MRISripUnmarked(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->marked == 0)
    {
      v->ripflag = 1 ;
    }
  }
  return(NO_ERROR) ;
}

// set all the marks to a user specified value INCLUDING RIPPED VERTICES!
int
MRISsetAllMarks(MRI_SURFACE *mris, int mark)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    v->marked = mark ;
  }
  return(NO_ERROR) ;
}
#include "diag.h"
int
MRISmakeDensityMap(MRI_SURFACE *mris, double resolution, double radius, int diag_no, MRI **pmri)
{
  MRI           *mri_interior ;
  int           x, y, z, vno, num, vradius, xmin, xmax, ymin, ymax, zmin, zmax ;
  VERTEX        *v ;
  double        dist, dx, dy, dz, sphere_volume ;
  double          xf, yf, zf ;

  mri_interior = MRISfillInterior(mris, resolution, NULL) ;
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    MRIwrite(mri_interior, "int.mgz") ;
  }

  if (diag_no >= 0)
  {
    *pmri = MRIclone(mri_interior, NULL) ;
  }

  vradius = radius / (MIN(MIN(mri_interior->xsize, mri_interior->ysize), mri_interior->zsize)) ;
  sphere_volume = vradius * vradius * vradius * M_PI * 4 / 3 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    MRISvertexToVoxel(mris, v, mri_interior, &xf, &yf, &zf) ;
    xmin = floor(xf-vradius) ;
    xmax = ceil(xf+vradius) ;
    ymin = floor(yf-vradius) ;
    ymax = ceil(yf+vradius) ;
    zmin = floor(zf-vradius) ;
    zmax = ceil(zf+vradius) ;
    for ( num = 0, x = xmin ; x <= xmax ; x++)
    {
      if (x < 0 || x >= mri_interior->width)
      {
        continue ;
      }
      for (y = ymin ; y <= ymax ; y++)
      {
        if (y < 0 || y >= mri_interior->height)
        {
          continue ;
        }
        for (z = zmin ; z <= zmax ; z++)
        {
          if (x == Gx && y == Gy && z == Gz)
          {
            DiagBreak() ;
          }
          if (z < 0 || z >= mri_interior->depth)
          {
            continue ;
          }
          dx = x-xf ;
          dy = y-yf ;
          dz = z-zf ;
          dist = sqrt(dx*dx + dy*dy + dz*dz) ;
          if (dist > vradius)
          {
            continue ;
          }
          if (MRIgetVoxVal(mri_interior, x, y, z, 0) > 0)
          {
            num++ ;
            if (vno == Gdiag_no)
            {
              MRIsetVoxVal(*pmri, x, y, z, 0, 1.0) ;
            }
          }
        }
      }
    }
    v->curv = (double)num/sphere_volume ;
  }

  return(NO_ERROR) ;
}

/*!
  \fn double MRIScomputeWhiteVolume(MRI_SURFACE *mris, MRI *mri_aseg, double resolution)
  \brief Computes surface-based white matter volume, excluding subcort
*/
double MRIScomputeWhiteVolume(MRI_SURFACE *mris, MRI *mri_aseg, double resolution)
{
  MRI    *mri_filled ;
  MATRIX *m_vox2vox ;
  double total_volume=0.0, vox_volume ;
  int    x, y, z, label, xa, ya, za ;
  VECTOR *v1, *v2 ;
  double   val ;

  // Create a volume with everything inside the surface set to 1
  mri_filled = MRISfillInterior(mris, resolution, NULL) ;
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    MRIwrite(mri_filled, "f.mgz") ;
  }
  m_vox2vox = MRIgetVoxelToVoxelXform(mri_filled, mri_aseg) ;
  v1 = VectorAlloc(4, MATRIX_REAL) ;
  v2 = VectorAlloc(4, MATRIX_REAL) ;
  VECTOR_ELT(v1, 4) = 1.0 ;
  VECTOR_ELT(v2, 4) = 1.0 ;
  vox_volume = mri_filled->xsize * mri_filled->ysize * mri_filled->zsize ;

  for (x = 0 ; x < mri_filled->width ; x++)
  {
    V3_X(v1) = x ;
    for (y = 0 ; y < mri_filled->height ; y++)
    {
      V3_Y(v1) = y ;
      for (z = 0 ; z < mri_filled->depth ; z++)
      {
        // Exclude voxel if not inside the surface
        val = MRIgetVoxVal(mri_filled, x, y, z, 0) ;
        if (FZERO(val))
        {
          continue ;
        }

        if (x == Gx && y == Gy && z == Gz)
        {
          DiagBreak() ;
        }
        V3_Z(v1) = z ;
        MatrixMultiply(m_vox2vox, v1, v2) ;
        xa = nint(V3_X(v2)) ;
        ya = nint(V3_Y(v2)) ;
        za = nint(V3_Z(v2)) ;
        if (xa < 0 || xa >= mri_aseg->width ||
            ya < 0 || ya >= mri_aseg->height ||
            za < 0 || za >= mri_aseg->depth)
        {
          ErrorPrintf(ERROR_BADPARM, "MRIScomputeWhiteVolume: src (%d, %d, %d) maps to (%d, %d, %d) - OOB",
                      x, y, z, xa, ya, za) ;
          continue ;
        }
        label = (int)MRIgetVoxVal(mri_aseg, xa, ya, za, 0) ;
        if (xa == Gx && ya == Gy && za == Gz)
        {
          DiagBreak() ;
        }
        switch (label)
        {
          // Note: {Left,Right}_Cerebral_Cortex are here to catch voxels on the edge
        case Left_Cerebral_Cortex:
        case Right_Cerebral_Cortex:
        case Left_Cerebral_White_Matter:
        case Right_Cerebral_White_Matter:
        case Left_WM_hypointensities:
        case Right_WM_hypointensities:
        case CC_Posterior:
        case CC_Mid_Posterior:
        case CC_Central:
        case CC_Mid_Anterior:
        case CC_Anterior:
          total_volume += vox_volume ;
          break ;
        }
      }
    }
  }

  MatrixFree(&m_vox2vox) ;
  MatrixFree(&v1) ;
  MatrixFree(&v2) ;
  MRIfree(&mri_filled) ;
  return(total_volume) ;
}
MRI *
MRISfillWhiteMatterInterior(MRI_SURFACE *mris, MRI *mri_aseg, MRI *mri_filled, double resolution,
                            int wm_val, int gm_val, int csf_val)
{
  MATRIX *m_vox2vox ;
  double  vox_volume ;
  int     x, y, z, label, xa, ya, za ;
  VECTOR  *v1, *v2 ;
  double    val ;

  mri_filled = MRISfillInterior(mris, resolution, mri_filled) ;
  MRIbinarize(mri_filled, mri_filled, 1, 0, wm_val) ;

  // This cras adjustment is now done in MRISfillInterior() DNG 7/8/08
  //mri_filled->c_r += mri_aseg->c_r ;
  //mri_filled->c_a += mri_aseg->c_a ;
  //mri_filled->c_s += mri_aseg->c_s ;
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    MRIwrite(mri_filled, "f.mgz") ;
  }
  m_vox2vox = MRIgetVoxelToVoxelXform(mri_filled, mri_aseg) ;
  v1 = VectorAlloc(4, MATRIX_REAL) ;
  v2 = VectorAlloc(4, MATRIX_REAL) ;
  VECTOR_ELT(v1, 4) = 1.0 ;
  VECTOR_ELT(v2, 4) = 1.0 ;
  vox_volume = mri_filled->xsize * mri_filled->ysize * mri_filled->zsize ;

  for (x = 0 ; x < mri_filled->width ; x++)
  {
    V3_X(v1) = x ;
    for (y = 0 ; y < mri_filled->height ; y++)
    {
      V3_Y(v1) = y ;
      for (z = 0 ; z < mri_filled->depth ; z++)
      {
        val = MRIgetVoxVal(mri_filled, x, y, z, 0) ;
        if (FZERO(val))
        {
          continue ;
        }
        if (x == Gx && y == Gy && z == Gz)
        {
          DiagBreak() ;
        }
        V3_Z(v1) = z ;
        MatrixMultiply(m_vox2vox, v1, v2) ;
        xa = nint(V3_X(v2)) ;
        ya = nint(V3_Y(v2)) ;
        za = nint(V3_Z(v2)) ;
        if (xa < 0 || xa >= mri_aseg->width ||
            ya < 0 || ya >= mri_aseg->height ||
            za < 0 || za >= mri_aseg->depth)
        {
          ErrorPrintf(ERROR_BADPARM, "MRIScomputeWhiteVolume: src (%d, %d, %d) maps to (%d, %d, %d) - OOB",
                      x, y, z, xa, ya, za) ;
          continue ;
        }
        label = (int)MRIgetVoxVal(mri_aseg, xa, ya, za, 0) ;
        if (xa == Gx && ya == Gy && za == Gz)
        {
          DiagBreak() ;
        }
        switch (label)
        {
        case Left_choroid_plexus:
        case Right_choroid_plexus:
        case Right_Lateral_Ventricle:
        case Left_Lateral_Ventricle:
        case Right_Inf_Lat_Vent:
        case Left_Inf_Lat_Vent:
          MRIsetVoxVal(mri_filled, x, y, z, 0, csf_val) ;  // ventricle
          break ;
        case Left_Cerebral_Cortex:
        case Right_Cerebral_Cortex:
        case Left_Cerebral_White_Matter:
        case Right_Cerebral_White_Matter:
        case Left_WM_hypointensities:
        case Right_WM_hypointensities:
        case CC_Posterior:
        case CC_Mid_Posterior:
        case CC_Central:
        case CC_Mid_Anterior:
        case CC_Anterior:
        case Brain_Stem:
          MRIsetVoxVal(mri_filled, x, y, z, 0, wm_val) ;  // white matter
          break ;
        case Left_Hippocampus:
        case Right_Hippocampus:
        case Left_Amygdala:
        case Right_Amygdala:
        case Left_Putamen:
        case Left_Pallidum:
        case Right_Putamen:
        case Right_Pallidum:
        case Left_Caudate:
        case Right_Caudate:
        case Left_Thalamus_Proper:
        case Right_Thalamus_Proper:
        case Left_Accumbens_area:
        case Right_Accumbens_area:
          MRIsetVoxVal(mri_filled, x, y, z, 0, gm_val) ;  // gray matter
          break ;
        }
      }
    }
  }

  MatrixFree(&m_vox2vox) ;
  MatrixFree(&v1) ;
  MatrixFree(&v2) ;
  return(mri_filled) ;
}
static int
mrisCheckSurfaceNbrs(MRI_SURFACE *mris)
{
  int    vno, n, n2, found ;
  VERTEX *v, *vn ;

  return(1) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;

    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      found = 0 ;
      for (n2 = 0 ; n2 < vn->vnum; n2++)
        if (vn->v[n2] == vno)
        {
          found = 1 ;
          break ;
        }
      if (found == 0)
      {
        DiagBreak() ;
        return(0) ;
      }
    }
  }
  return(1) ;
}

int
MRISbinarizeCurvature(MRI_SURFACE *mris, float thresh, float low, float high,
                      int use_abs)
{
  int     vno ;
  VERTEX  *v ;
  float   val ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    val = (use_abs ? fabs(v->curv) : v->curv) ;
    if (val < thresh)
    {
      v->curv = low ;
    }
    else
    {
      v->curv = v->curv < 0 ? -high : high ;
    }
  }

  return(NO_ERROR) ;
}
int
MRISthresholdCurvature(MRI_SURFACE *mris, float thresh, int use_abs)
{
  int     vno ;
  VERTEX  *v ;
  float   val ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    val = (use_abs ? fabs(v->curv) : v->curv) ;
    if (val < thresh)
    {
      v->curv = 0 ;
    }
  }

  return(NO_ERROR) ;
}

int
MRISthresholdValIntoMarked(MRI_SURFACE *mris, float thresh)
{
  int     vno ;
  VERTEX  *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->marked = v->val >= thresh ;
  }

  return(NO_ERROR) ;
}

// remove outliers in the v->curv field
int
MRIShistoThresholdCurvature(MRI_SURFACE *mris, float thresh_pct)
{
  double    min_curv, max_curv, curv_scale, total, thresh ;
  int       bin, zbin, nthresh = 0, vno ;
  HISTOGRAM *h_curv ;
  VERTEX    *vertex ;

  h_curv = HISTOalloc(1000) ;

  min_curv = 1000 ;
  max_curv = -1000 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (vertex->ripflag)
    {
      continue ;
    }
    if (vertex->curv > max_curv)
    {
      max_curv = vertex->curv ;
    }
    if (vertex->curv < min_curv)
    {
      min_curv = vertex->curv ;
    }
  }

  curv_scale = (h_curv->nbins-1)/(max_curv - min_curv);
  h_curv->bin_size = 1.0/curv_scale ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (vertex->ripflag)
    {
      continue ;
    }
    bin = nint(curv_scale * (vertex->curv - min_curv)) ;
    h_curv->counts[bin]++ ;
  }
  for (bin = 0 ; bin < h_curv->nbins ; bin++)
  {
    h_curv->bins[bin] = (bin / curv_scale) + min_curv ;
  }
  zbin = nint(curv_scale * (0.0-min_curv)) ;
  HISTOmakePDF(h_curv, h_curv) ;
  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    HISTOplot(h_curv, "curv.plt") ;
  }

  zbin = HISTOfindHighestPeakInRegion(h_curv, 0, h_curv->nbins) ;

  for (total = 0, bin = zbin ; bin < h_curv->nbins ; bin++)
  {
    total += h_curv->counts[bin] ;
  }
  thresh = thresh_pct*total ;
  for (total = 0, bin = zbin ; bin < h_curv->nbins-1 ; bin++)
  {
    total += h_curv->counts[bin] ;
    if (total > thresh)
    {
      break ;
    }
  }
  max_curv = h_curv->bins[bin] ;

  for (total = 0, bin = zbin ; bin > 0 ; bin--)
  {
    total += h_curv->counts[bin] ;
  }
  thresh = thresh_pct*total ;
  for (total = 0, bin = zbin ; bin > 0 ; bin--)
  {
    total += h_curv->counts[bin] ;
    if (total > thresh)
    {
      break ;
    }
  }
  min_curv = h_curv->bins[bin] ;


  mris->min_curv = 10000.0f ;
  mris->max_curv = -10000.0f ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vertex = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (vertex->ripflag)
    {
      continue ;
    }
    if (vertex->curv > max_curv)
    {
      vertex->curv = max_curv ;
      nthresh++ ;
    }
    if (vertex->curv < min_curv)
    {
      vertex->curv = min_curv ;
      nthresh++ ;
    }
    if (vertex->curv < mris->min_curv)
    {
      mris->min_curv = vertex->curv ;
    }
    if (vertex->curv > mris->max_curv)
    {
      mris->max_curv = vertex->curv ;
    }
  }

  HISTOfree(&h_curv) ;
  if (nthresh > 0)
    fprintf(stderr, "%d vertices thresholded to be in [%2.2f %2.2f]\n",
            nthresh, min_curv, max_curv) ;
  return(NO_ERROR) ;
}

static int
mrisComputeVariableSmoothnessCoefficients(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  VERTEX   *v ;
  int      vno ;
  float    vsmooth ;

  if (parms->vsmoothness == NULL)
  {
    return(NO_ERROR) ;
  }

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    v->val = parms->l_dist * parms->dist_error[vno] - parms->l_corr * parms->geometry_error[vno] ;
  }

#define VDELTA 0.005
  MRISaverageVals(mris, 64) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    vsmooth = parms->vsmoothness[vno] ;
    if (v->val > 0)
    {
      vsmooth += VDELTA ;
    }
    else
    {
      vsmooth -= VDELTA ;
    }
    vsmooth = MAX(0, vsmooth) ;
    vsmooth = MIN(1, vsmooth) ; // make it in [0 1]
    parms->vsmoothness[vno] = vsmooth ;
  }

  return(NO_ERROR) ;
}

// sets the RAS for a surface
// FUNDAMENTAL ASSUMPTION - all the vertices are created in voxel coordinates associated with srcMri
void
MRISsetVolumeForSurface(MRI_SURFACE* mris, MRI* srcMri)
{
  MRIScopyVolGeomFromMRI(mris, srcMri);
  MATRIX* matrix = surfaceRASFromVoxel_(srcMri);
  MRISmatrixMultiply( mris, matrix);
  MatrixFree(&matrix);
}
int
MRISsetVal2(MRI_SURFACE *mris, float val)
{
  VERTEX *v ;
  int     vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val2 = val ;
  }
  return(NO_ERROR) ;
}



MRI *
MRIScomputeDistanceToSurface(MRI_SURFACE *mris, MRI *mri_dist, float resolution)
{
  MRI    *mri_tmp, *mri_mask ;

  if (mri_dist != NULL)
  {
    mri_tmp = MRIclone(mri_dist, NULL) ;
  }
  else
  {
    mri_tmp = NULL ;  // will get allocated by MRISfillInterior
  }
  mri_tmp = MRISfillInterior(mris, resolution, mri_tmp) ;

#define PAD 10
  if (mri_dist == NULL)
  {
    mri_mask = MRIextractRegionAndPad(mri_tmp, NULL, NULL, PAD) ;
  }
  else
  {
    mri_mask = MRIcopy(mri_tmp, NULL) ;  // geometry specified by caller
  }
  mri_dist = MRIdistanceTransform(mri_mask, mri_dist, 1, nint(PAD/mri_mask->xsize),
                                  DTRANS_MODE_SIGNED, NULL) ;

  MRIfree(&mri_tmp) ;
  MRIfree(&mri_mask) ;
  return(mri_dist) ;
}
int
MRISclearMark2s(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->marked2 = 0 ;
  }
  return(NO_ERROR) ;
}

// Discrete Principle Curvature and Related vvvvvvvvvvvvvvvvvv

int
slprints(
  char*               apch_txt
)
{
  //
  // PRECONDITIONS
  //      o String <apch_txt> to print to stdout
  //
  // POSTCONDITIONS
  //      o Pre-pends a syslogd style prefix to <apch_txt>:
  //              <date> <hostname> <apch_txt>
  //

  struct tm *ptm_local;
  time_t        t;
  char          pch_hostname[255];
  size_t        len_hostname;
  char*         pch_timeMon             = NULL;
  char*         pch_time                = NULL;
  char          pch_output[65536];

  t = time(NULL);
  len_hostname  = 255;
  gethostname(pch_hostname, len_hostname);
  strcpy(pch_hostname, strtok(pch_hostname, "."));
  strcpy(pch_output, "");
  ptm_local     = localtime(&t);
  pch_timeMon   = strtok(asctime(ptm_local), "\n");
  pch_time              = strdup(pch_timeMon + 4);
  sprintf(pch_output, "%s %s",  pch_time, pch_hostname);
  sprintf(pch_output, "%s %s",  pch_output, apch_txt);
  printf("%s", pch_output);
  return strlen(pch_output);
}

void
cprints(
  char*   apch_left,
  char*   apch_right
)
{
  //
  // PRECONDITIONS
  //  o The length of each text string should be such that
  //    the string will "fit" into its column.
  //
  // POSTCONDITIONS
  //  o Column prints the left (action) and right (status)
  //    text strings in a formatted manner.
  //

  static char pch_right[16384];

  sprintf(pch_right, " [ %s ]\n", apch_right);
  if(strlen(apch_left))
  {
    fprintf(stderr, "%*s",  G_LC,   apch_left);
  }
  if(strlen(apch_right))
  {
    fprintf(stderr, "%*s",  G_RC,   pch_right);
  }
  fflush(stderr);
}

void
cprintd(
  char*   apch_left,
  int   a_right
)
{
  //
  // PRECONDITIONS
  //  o The length of each text string should be such that
  //    the string will "fit" into its column.
  //
  // POSTCONDITIONS
  //  o Column prints the left (action) and right (status)
  //    text strings in a formatted manner.
  //

  static char pch_right[16384];

  sprintf(pch_right, " [ %d ]\n", a_right);
  if(strlen(apch_left))
  {
    fprintf(stderr, "%*s",  G_LC,   apch_left);
  }
  else
  {
    fprintf(stderr, "%*s",  G_LC, " ");
  }
  fprintf(stderr, "%*s",  G_RC,   pch_right);
  fflush(stderr);
}

void
cprintf(
  char*   apch_left,
  float   af_right
)
{
  //
  // PRECONDITIONS
  //  o The length of each text string should be such that
  //    the string will "fit" into its column.
  //
  // POSTCONDITIONS
  //  o Column prints the left (action) and right (status)
  //    text strings in a formatted manner.
  //

  static char pch_right[16384];

  sprintf(pch_right, " [ %f ]\n", af_right);
  if(strlen(apch_left))
  {
    fprintf(stderr, "%*s",  G_LC,   apch_left);
  }
  else
  {
    fprintf(stderr, "%*s",  G_LC, " ");
  }
  fprintf(stderr, "%*s",  G_RC,   pch_right);
  fflush(stderr);
}


short
FACE_vertexIndex_find(
  FACE* pFace,
  int   avertex
)
{
  //
  // PRECONDITIONS
  // o <avertex> denotes a vertex number to lookup in the <pFace>.
  //
  // POSTCONDITIONS
  // o The vertex index (0, 1, 2) containing the <avertex> is returned
  //   or -1 if not found.
  //
  int   vertex      = 0;
  int   ret     = -1;
  for(vertex=0; vertex<VERTICES_PER_FACE; vertex++)
    if(pFace->v[vertex] == avertex)
    {
      ret = vertex;
    }
  return ret;
}

short
VECTOR_elementIndex_findNotEqual(
  VECTOR* apV,
  float af_searchTerm
)
{
  //
  // PRECONDITIONS
  //  o The <apV> is a column vector.
  //
  // POSTCONDITIONS
  //  o The index of the first element in <apV> that is not equal to
  //    the <af_searchTerm> is returned in the function name. If no
  //    hits are found, a '0' is returned.
  //  o NOTE that the first element index in the vector is '1', not
  //    zero (i.e. MatLAB convention).
  //

  int   i = 0;
  short b_ret = 0;
  for(i=0; i<apV->rows; i++)
    if(VECTOR_ELT(apV, i+1) != af_searchTerm)
    {
      b_ret   = i;
      break;
    }
  return b_ret;
}

short
VECTOR_elementIndex_find(
  VECTOR* apV,
  float af_searchTerm
)
{
  //
  // PRECONDITIONS
  //  o The <apV> is a column vector.
  //
  // POSTCONDITIONS
  //  o The index of the first element in <apV> that is equal to
  //    the <af_searchTerm> is returned in the function name. If no
  //    hits are found, a '0' is returned.
  //  o NOTE that the first element index in the vector is '1', not
  //    zero (i.e. MatLAB convention).
  //

  int   i = 0;
  short b_ret = 0;
  for(i=1; i<=apV->rows; i++)
    if(VECTOR_ELT(apV, i) == af_searchTerm)
    {
      b_ret   = i;
      break;
    }
  return b_ret;
}

short
MRIS_vertexProgress_print(
  MRIS* apmris,
  int   avertex,
  char* apch_message
)
{
  //
  // PRECONDITIONS
  //  o <avertex> is the current vertex being processed in a stream.
  //  o If <apch_message> is non-NULL, then prefix the progress bar
  //    with <apch_message> (and terminate progress bar with [ ok ]).
  //
  // POSTCONDITIONS
  //  o For every 5% of processed vertices a "#" is written to stderr
  //

  static int    totalVertices = 0;
  static int    fivePerc  = 0;

  totalVertices   = apmris->nvertices;
  fivePerc      = 0.05 * totalVertices;

  if(!avertex)
  {
    if(apch_message != NULL)
    {
      fprintf(stderr, "%*s", G_LC, apch_message);
    }
    fprintf(stderr, " [");
  }
  if(avertex%fivePerc == fivePerc-1)
  {
    fprintf(stderr, "#");
  }
  if(avertex == apmris->nvertices-1)
  {
    fprintf(stderr, "] ");
    if(apch_message != NULL)
    {
      fprintf(stderr, "%*s\n", 1, "[ ok ]");
    }
  }
  return 1;
}

int
FACE_vertexIndexAtMask_find(
  FACE* apFACE_I,
  VECTOR* apv_verticesCommon
)
{
  //
  // PRECONDITIONS
  //  o Called after <apv_verticesCommon> has been processed by
  //    VERTICES_commonInFaces_find().
  //
  // POSTCONDITIONS
  //  o The vertex index in <apFACE_I> corresponding to the '-1'
  //    in <apv_verticesCommon> is returned. For two bordering faces
  //    that share an edge defined by <apv_verticesCommon>, this function
  //    determines the index of the vertex that is *not* on this shared
  //    edge.
  //
  // HISTORY
  // 03 July 2007
  //  o Initial design and coding.
  //

  int   face    = 0;
  int   vertex    = 0;
  short b_inCommon  = 0;
  int   ret   = -1;

  for(face=0; face<3; face++)
  {
    vertex    = apFACE_I->v[face];
    b_inCommon  = VECTOR_elementIndex_find(apv_verticesCommon,
                                           (float) vertex);
    if(!b_inCommon)
    {
      ret = vertex;
      break;
    }
  }

  return ret;
}

short
VERTICES_commonInFaces_find(
  FACE* apFACE_I,
  FACE* apFACE_J,
  VECTOR* apv_verticesCommon
)
{
  //
  // PRECONDITIONS
  //  o The <apFACE>s must be triangles with 3 vertices each.
  //  o It is assumed (but not mandatory) that the FACES share
  //    at least one common vertex - or more often a common
  //    edge, i.e. two common vertices.
  //  o The <apv_uncommon> VECTOR's memory must be managed by the
  //    caller, i.e. created and freed, and should be a 3x1 VECTOR.
  //
  // POSTCONDITIONS
  //  o The number of vertices that are in common between the two
  //    faces are returned in the function name. This can be either
  //    (0, 1, 2, 3).
  //  o The indices of the common vertices are returned in
  //    apv_verticesCommon. This is a three element vector, with each
  //    element corresponding to a common vertex. Vertex indices that
  //    are not common between the two faces have a -1.
  //

  int   i   = 0;
  int   j     = 0;
  int   k   = 0;
  char* pch_function  = "VERTICES_commonInFaces_find";
  short b_hit   = 0;
  float f_val   = -1.;

  if(apv_verticesCommon->rows != 3 || apv_verticesCommon->cols !=1)
  {
    ErrorExit(-1, "%s: Return VECTOR must be 3x1.\n", pch_function);
  }
  V3_LOAD(apv_verticesCommon, -1, -1, -1);

  for(i=0; i<3; i++)
  {
    b_hit   = 0;
    f_val = -1.;
    for(j=0; j<3; j++)
    {
      if(apFACE_J->v[j] == apFACE_I->v[i])
      {
        b_hit = 1;
      }
    }
    if(b_hit)
    {
      f_val = apFACE_I->v[i];
      VECTOR_ELT(apv_verticesCommon, ++k) = f_val;
    }
  }
  return k;
}

short
FACES_Hcurvature_determineSign(
  MRIS* apmris,
  FACE* apFACE_O,
  FACE* apFACE_I
)
{
  //
  // PRECONDITIONS
  //  o Typically called from MRIS_Hcurvature_determineSign()
  //  o apFACE_I and apFACE_J are geometric neighbouring faces
  //    about a given vertex.
  //
  // POSTCONDITIONS
  //  o If the faces "diverge", i.e. have face normals that point "away"
  //    from each other, then the curvature sign return is -1.
  //  o If the faces "converge", i.e. have face normals that point "toward"
  //    each other, then the curvature sign return is +1
  //
  // HISTORY
  //  02 July 2007
  //  o Initial design and coding.
  //

  static int  calls     = 0;
  char* pch_function    = "FACES_Hcurvature_determineSign";
  int   ret     = 0;
  int   vertexO     = -1;
  int   vertexI     = -1;
  VERTEX* pVERTEX_O   = NULL;
  VERTEX* pVERTEX_I   = NULL;
  VECTOR* pv_O      = NULL; // Coords of 1st common vertex
  VECTOR* pv_normalO    = NULL; // Normal for face O
  VECTOR* pv_OnO      = NULL; // pv_O + normal
  VECTOR* pv_I      = NULL; // Coords of 2nd common vertex
  VECTOR* pv_normalI    = NULL; // Normal for face I
  VECTOR* pv_InI      = NULL; // pv_I + normal
  VECTOR* pv_connectOI    = NULL; // vector connecting normals
  VECTOR* pv_commonVertices = NULL; // Vector housing vertices that
  // are common between two
  // neighbouring faces.
  int   commonVertices    = 0;  // number of vertices in common
  // between two faces
  float f_distNormal    = 0;
  float f_distAntiNormal  = 0;
  int   sign      = -1;

  pv_commonVertices = VectorAlloc(3, MATRIX_REAL);
  pv_I    = VectorAlloc(3, MATRIX_REAL);
  pv_O    = VectorAlloc(3, MATRIX_REAL);
  pv_normalI    = VectorAlloc(3, MATRIX_REAL);
  pv_normalO    = VectorAlloc(3, MATRIX_REAL);
  pv_InI    = VectorAlloc(3, MATRIX_REAL);
  pv_OnO    = VectorAlloc(3, MATRIX_REAL);
  pv_connectOI  = VectorAlloc(3, MATRIX_REAL);

  commonVertices  = VERTICES_commonInFaces_find(apFACE_O, apFACE_I,
                    pv_commonVertices
                                               );
  if(commonVertices!=2)
    ErrorExit(-4,
              "%s: During call %d, the passed faces do not share an edge",
              pch_function, calls);

  vertexO   = FACE_vertexIndexAtMask_find(apFACE_O, pv_commonVertices);
  vertexI   = FACE_vertexIndexAtMask_find(apFACE_I, pv_commonVertices);
  pVERTEX_O   = &apmris->vertices[vertexO];
  pVERTEX_I   = &apmris->vertices[vertexI];
  V3_LOAD(pv_O, pVERTEX_O->x, pVERTEX_O->y, pVERTEX_O->z);
  V3_LOAD(pv_I, pVERTEX_I->x, pVERTEX_I->y, pVERTEX_I->z);
  V3_LOAD(pv_normalO, apFACE_O->nx, apFACE_O->ny, apFACE_O->nz);
  V3_LOAD(pv_normalI, apFACE_I->nx, apFACE_I->ny, apFACE_I->nz);

  for(sign = 1; sign >= -1; sign-=2)
  {
    V3_SCALAR_MUL(pv_normalO, sign, pv_normalO);
    V3_SCALAR_MUL(pv_normalI, sign, pv_normalI);
    V3_ADD(pv_O, pv_normalO, pv_OnO);
    V3_ADD(pv_I, pv_normalI, pv_InI);
    V3_SUBTRACT(pv_OnO, pv_InI, pv_connectOI);

    if(sign == 1)
    {
      f_distNormal  = V3_LEN(pv_connectOI);
    }
    else
    {
      f_distAntiNormal = V3_LEN(pv_connectOI);
    }
  }

  ret = (f_distNormal < f_distAntiNormal) ? +1 : -1;

  VectorFree(&pv_O);
  VectorFree(&pv_normalO);
  VectorFree(&pv_OnO);
  VectorFree(&pv_I);
  VectorFree(&pv_normalI);
  VectorFree(&pv_InI);
  VectorFree(&pv_connectOI);
  VectorFree(&pv_commonVertices);
  calls++;
  return ret;
}

int
VERTEX_faceAngles_determine(
  MRIS* apmris,
  int   avertex,
  VECTOR* apv_angle
)
{
  //
  // PRECONDITIONS
  //  o <apmris> is a valid surface.
  //  o <apVERTEX> is a vertex to analyze.
  //
  // POSTCONDITIONS
  //  o The angle between each face in the <apex> normal
  //    is determined and returned in <apv_angle>.
  //  o The caller is responsible for clearing the memory allocated to
  //    <apv_angle>!
  //  o The number of faces processed (i.e. size of the <apv_angle
  //    vector) is returned in the function name.
  //
  // HISTORY
  //  30 July 2007
  //  o Initial design and coding.
  //

  char*   pch_function  = "VERTEX_faceAngles_determine";
  int     nfaces    = -1;
  float   f_angle   = 0.;
  float   f_lenApexNormal = 0.;
  float   f_lenFaceNormal = 0.;
  float   f_lenNormals  = 0.;
  float   f_acosArg = 0.;
  float   f_dot   = 0.;

  int     face    = 0;
  static int    calls   = 0;
  static VECTOR*  pv_faceNormal = NULL;
  static VECTOR*  pv_apexNormal = NULL;

  VERTEX*   pVERTEX_apex  = NULL;
  FACE*   pFACE_side  = NULL;

  if(!calls)
  {
    pv_faceNormal = VectorAlloc(3, MATRIX_REAL);
    pv_apexNormal = VectorAlloc(3, MATRIX_REAL);
  }
  pVERTEX_apex  = &apmris->vertices[avertex];
  nfaces    = pVERTEX_apex->num;
  VECTOR_ELT(pv_apexNormal, 1)  = pVERTEX_apex->nx;
  VECTOR_ELT(pv_apexNormal, 2)  = pVERTEX_apex->ny;
  VECTOR_ELT(pv_apexNormal, 3)  = pVERTEX_apex->nz;
  f_lenApexNormal     = V3_LEN(pv_apexNormal);

  for(face=0; face<nfaces; face++)
  {
    pFACE_side    = &apmris->faces[pVERTEX_apex->f[face]];
    VECTOR_ELT(pv_faceNormal, 1)  = pFACE_side->nx;
    VECTOR_ELT(pv_faceNormal, 2)  = pFACE_side->ny;
    VECTOR_ELT(pv_faceNormal, 3)  = pFACE_side->nz;
    f_lenFaceNormal     = V3_LEN(pv_faceNormal);
    f_lenNormals      = f_lenApexNormal * f_lenFaceNormal;
    f_dot       = V3_DOT(pv_apexNormal, pv_faceNormal);
    errno       = 0;
//  feclearexcept(FE_ALL_EXCEPT);
    f_acosArg     = f_dot / f_lenNormals;
    // Check on the bounds of the acos argument. Without this bounds check,
    // it is quite possible to have 'nan' acos results, especially on 64-bit
    // builds.
    if(f_acosArg > 1.)
    {
      f_acosArg   = 1.0;
    }
    if(f_acosArg < -1.)
    {
      f_acosArg   = -1.0;
    }
    f_angle       = acos(f_acosArg);
    if(errno)
    {
      f_angle     = 0.;
      printf("%s: acos error - angle set to zero for vertex = %d, face = %d.\n",
             pch_function, avertex, face);
    }
    VECTOR_ELT(apv_angle, face+1) = f_angle;
  }
  calls++;
  return face;
}

int
VERTEX_faceMinMaxAngles_determine(
  MRIS* apmris,
  int   avertex,
  int*  ap_minIndex,
  float*  apf_minAngle,
  int*  ap_maxIndex,
  float*  apf_maxAngle
)
{
  //
  // PRECONDITIONS
  //  o <apmris> is a valid surface.
  //  o <apVERTEX> is a vertex to analyze.
  //
  // POSTCONDITIONS
  //  o For the given <avertex>, the minimum and maximum
  //    face angles and their indices are returned in the
  //    argument pointers.
  //  o The number of faces is returned in the function name.
  //
  // HISTORY
  //  31 July 2007
  //  o Initial design and coding.
  //

  char* pch_function    = "VERTEX_faceMinMaxAngles_determine";
  int   face      = 0;  // Face index counte
  int   nfaces      = 0;  // Number of faces at <avertex>
  float f_faceAngle   = 0.; // Actual face angle
  VECTOR*   pv_faceAngles   = NULL; // vector containing angles
  // between each face normal
  // and apex normal
  VERTEX* pVERTEX     = NULL;

  // Determine the angles between each face and the vertex normal;
  //  find the min/max angles and indices
  pVERTEX   = &apmris->vertices[avertex];
  nfaces    = pVERTEX->num;
  pv_faceAngles = VectorAlloc(nfaces, MATRIX_REAL);
  nfaces    = VERTEX_faceAngles_determine(apmris, avertex,
                                          pv_faceAngles);
  if(!nfaces)
  {
    ErrorExit(-4, "%s: error with determining face angles.", pch_function);
  }
  f_faceAngle   = VECTOR_ELT(pv_faceAngles, 1);
  *apf_minAngle = f_faceAngle;
  *apf_maxAngle = f_faceAngle;
  for(face=1; face<nfaces; face++)
  {
    f_faceAngle = VECTOR_ELT(pv_faceAngles, face+1);  // base 1 index
    if(f_faceAngle < *apf_minAngle)
    {
      *apf_minAngle = f_faceAngle;
      *ap_minIndex  = face;
    }
    if(f_faceAngle > *apf_maxAngle)
    {
      *apf_maxAngle = f_faceAngle;
      *ap_maxIndex  = face;
    }
  }
  VectorFree(&pv_faceAngles);
  return face;
}

int
signum_eval(
  float af
)
{
  //
  // PRECONDITIONS
  //  o <af> is an input float.
  //
  // POSTCONDITIONS
  //  o if <af> < 0, a -1 is returned, else +1 is returned
  //

  return af<0 ? -1 : 1;
}

int
MRIS_Hcurvature_determineSign(
  MRIS* apmris
)
{
  //
  // NOTE
  //  This function is obsolete and should not be used! Mean curvature (H)
  //  determination is now done directly when processing faces and normal
  //  angles.
  //
  // PRECONDITIONS
  //  o <apmris> is a valid surface.
  //  o MRIS_facesAtVertices_reorder()
  //
  // POSTCONDITIONS
  //  o The face geometry at each vertex is examined, and the orientation
  //    of each face relative to its neighbor is determined as either
  //    converging (-) or diverging (+).
  //  o If the sum of each convergence/divergence is determined to be
  //    negative, the vertex is marked as diverging; otherwise it is
  //    marked as converging.
  //  o Convergence is indicated with pVERTEX->undefval=-1; divergence
  //    is marked with pVERTEX->undefval=1
  //
  // HISTORY
  //  02 July 2007
  //  o Initial design and coding.
  //

  int   vertex      = 0;
  int   face      = 0;
  int   nfaces      = 0;
  VERTEX* pVERTEX     = NULL;
  int   ret     = 1;
  int   signSum     = 0;
  FACE* pFACE_I;
  FACE* pFACE_J;

  for(vertex=0; vertex<apmris->nvertices; vertex++)
  {
    MRIS_vertexProgress_print(apmris, vertex,
                              "Determining H sign for vertex faces...");
    pVERTEX     = &apmris->vertices[vertex];
    nfaces      = pVERTEX->num;
    signSum     = 0;
    for(face=0; face<nfaces; face++)
    {
      pFACE_I   = &apmris->faces[pVERTEX->f[face]];
      pFACE_J   = &apmris->faces[pVERTEX->f[(face+1)%nfaces]];
      signSum   += FACES_Hcurvature_determineSign(apmris, pFACE_I, pFACE_J);
    }
    pVERTEX->undefval = (signSum >= 0) ? 1 : -1;
  }
  return ret;
}

int
MRIS_facesAtVertices_reorder(
  MRIS* apmris
)
{
  //
  // PRECONDITIONS
  //  o <apmris> is a valid surface.
  //
  // POSTCONDITIONS
  //  o The 'f' FACE array at each vertex has its indices reordered
  //    so that bordering face indices index (i) and index (i+1)
  //    correspond to the actual geometric order of the faces about
  //    each vertex.
  //  o Note that the 'f' FACE array is changed at each vertex by
  //    this function.
  //
  // HISTORY
  //  02 July 2007
  //  o Initial design and coding.
  //

  int   vertex      = 0;
  int   face      = 0;
  int   nfaces      = 0;
  int   orderedIndex    = -1;
  int   orderedFace   = -1;
  VECTOR* pv_geometricOrderIndx = NULL;
  VECTOR* pv_logicalOrderFace = NULL;
  VERTEX* pVERTEX     = NULL;
  int   ret     = 1;
  char* pch_function    = "MRIS_facesAtVertices_reorder";

  DebugEnterFunction(( pch_function ));
  fprintf(stderr, "\n");
  for(vertex=0; vertex<apmris->nvertices; vertex++)
  {
    MRIS_vertexProgress_print(apmris, vertex,
                              "Determining geometric order for vertex faces...");
    pVERTEX     = &apmris->vertices[vertex];
    nfaces      = pVERTEX->num;
    pv_geometricOrderIndx = VectorAlloc(nfaces, MATRIX_REAL);
    pv_logicalOrderFace = VectorAlloc(nfaces, MATRIX_REAL);
    FACES_aroundVertex_reorder(apmris, vertex, pv_geometricOrderIndx);
    for(face=0; face<nfaces; face++)
    {
      VECTOR_ELT(pv_logicalOrderFace, face+1) = pVERTEX->f[face];
    }
    for(face=0; face<nfaces; face++)
    {
      orderedIndex  = VECTOR_ELT(pv_geometricOrderIndx, face+1);
      orderedFace   = VECTOR_ELT(pv_logicalOrderFace, orderedIndex+1);
      pVERTEX->f[face]  = orderedFace;
    }
    VectorFree(&pv_geometricOrderIndx);
    VectorFree(&pv_logicalOrderFace);
  }
  xDbg_PopStack();
  return ret;
}

int
MRIScomputeGeometricProperties(
  MRIS* apmris
)
{
  //
  // PRECONDITIONS
  //  o Needs to be called before computing discrete curvatures.
  //
  // POSTCONDITIONS
  //  o The face array at each vertex is re-ordered in a geometric sense.
  //  o Each pair of bordering faces at each vertex are processed to
  //    to determine overall convexity/concavity of "node".
  //
  // HISTORY
  // 03 July 2007
  //  o Initial design and coding.
  //

  int ret = 0;
  ret   = MRIS_facesAtVertices_reorder(apmris);
  return ret;
}

short
FACES_aroundVertex_reorder(
  MRIS* apmris,
  int   avertex,
  VECTOR* pv_geometricOrder
)
{
  //
  // PRECONDITIONS
  //  o <avertex> is a valid vertex on the surface.
  //  o <pll_faces> should not be allocated.
  //
  // POSTCONDITIONS
  //  o The face indices about vertex <avertex>, starting with face 0
  //    are returned in geometric order in the <pv_geometricOrder> vector.
  //    By geometric order is implied that the "next" index denotes
  //    the next face that directly borders the current face.
  //  o The number of connected faces is returned in the function name, or
  //    0 is there is some error.
  //
  // HISTORY
  //  25 June 2007
  //  o Initial design and coding.
  //

  char* pch_function  = "FACES_aroundVertex_reorder";
  VERTEX* pVERTEX;
  int   nfaces    = 0;
  int*  pFaceIndex  = NULL;
  int   packedCount = 1;
  int   i   = 0;
  int   I   = 0;
  int   j   = 0;
  int   k     = 0;
  FACE* pFACE_I;
  FACE* pFACE_J;
  VECTOR* pv_commonVertices = NULL; // Vector housing vertices that
  // are common between two
  // neighbouring faces.
  int   commonVertices    = 0;  // number of vertices in common
  // between two faces
  short b_borderFound   = 0;

  pv_commonVertices = VectorAlloc(3, MATRIX_REAL);
  pVERTEX   = &apmris->vertices[avertex];
  nfaces    = pVERTEX->num;
  pFaceIndex    = pVERTEX->f;

  DebugEnterFunction(( pch_function ));

  if(!nfaces)
  {
    fprintf(stderr,
            "\n\nFATAL ERROR encountered in function ''%s'.\nMesh structural error. Vertex %d has no faces.\n\n",
            pch_function, avertex);
    exit(1);
  }

  for(i=1; i<=nfaces; i++)
  {
    VECTOR_ELT(pv_geometricOrder, i)= -1;
    pFACE_I = &apmris->faces[pFaceIndex[i-1]];
  }
  VECTOR_ELT(pv_geometricOrder, 1)  = 0;
  for(i=0; i<nfaces; i++)
  {
    if(packedCount == nfaces)
    {
      break;
    }
    I = VECTOR_ELT(pv_geometricOrder, i+1);
    pFACE_I = &apmris->faces[pFaceIndex[I]];
    for(j=0; j<nfaces; j++)
    {
      k       = (i+j) % nfaces;
      pFACE_J   = &apmris->faces[pFaceIndex[k]];
      commonVertices  = VERTICES_commonInFaces_find(pFACE_I, pFACE_J,
                        pv_commonVertices
                                                   );
      if(commonVertices==2)
      {
        if(!VECTOR_elementIndex_find(pv_geometricOrder, k))
        {
          VECTOR_ELT(pv_geometricOrder, i+2) = k;
          b_borderFound   = 1;
          packedCount++;
          break;
        }
      }
    }
  }
  if(packedCount != nfaces)
    ErrorExit(-4, "%s: packed / faces mismatch; vertex = %d, faces = %d, packed = %d",
              pch_function, avertex, nfaces, packedCount);
  VectorFree(&pv_commonVertices);
  xDbg_PopStack();
  return 1;
}

float
FACES_angleNormal_find(
  MRIS* apmris,
  FACE* apFACE_I,
  FACE* apFACE_J
)
{
  //
  // PRECONDITIONS
  //  o The <apFACE>s should be triangles with 3 vertices each.
  //  o It is assumed (but not mandatory) that the FACES share
  //    at least one common vertex - or more often a common
  //    edge, i.e. two common vertices.
  //
  // POSTCONDITIONS
  //  o The angle between the normals on each FACE is returned.
  //

  static int      calls   = 0;  // Used for vector allocation
  static VECTOR*  pv_faceNormalI  = NULL; // Normal vector for face I
  static VECTOR*  pv_faceNormalJ  = NULL; // Normal vector for face J
  static VECTOR*  pv_crossIJ    = NULL; // Cross product of input vectors
  float     f_faceNormalIlen  = 0.; // Length of face normal I
  float     f_faceNormalJlen  = 0.; // Length of face normal J
  float     f_faceNormalIJlen = 0.; // Face normal length product
  float     f_angleNormalIJ = 0.; // Angle between face normals
  float     f_acosArg   = 0.; // Dot product arguments
  float     f_dot   = 0.; // Dot product
  short     sign    = 1;  // Angle "sign"
  char*     pch_function  = "FACES_angleNormal_find";

  DebugEnterFunction(( "%s", pch_function));
  if(!calls)
  {
    pv_faceNormalI  = VectorAlloc(3, MATRIX_REAL);
    pv_faceNormalJ  = VectorAlloc(3, MATRIX_REAL);
    pv_crossIJ  = VectorAlloc(3, MATRIX_REAL);
  }
  V3_LOAD(pv_faceNormalI, apFACE_I->nx, apFACE_I->ny, apFACE_I->nz);
  V3_LOAD(pv_faceNormalJ, apFACE_J->nx, apFACE_J->ny, apFACE_J->nz);
  f_faceNormalIlen  = V3_LEN(pv_faceNormalI);
  f_faceNormalJlen  = V3_LEN(pv_faceNormalJ);
  if(f_faceNormalIlen > 1.0001 || f_faceNormalJlen > 1.0001 )
    ErrorExit(-4, "%s: face normal not unit length -- Ni: %f, Nj: %f\n",
              pch_function, f_faceNormalIlen, f_faceNormalJlen);
  f_faceNormalIJlen = f_faceNormalIlen * f_faceNormalJlen;
  f_dot   = V3_DOT(pv_faceNormalI, pv_faceNormalJ);
  sign    = FACES_Hcurvature_determineSign(apmris, apFACE_I, apFACE_J);
  f_acosArg   = f_dot / f_faceNormalIJlen;
  // Check on the bounds of the acos argument. Without this bounds check,
  //  it is quite possible to have 'nan' acos results, especially on 64-bit
  //  builds.
  if(f_acosArg > 1.)
  {
    f_acosArg = 1.0;
  }
  if(f_acosArg < -1.)
  {
    f_acosArg = -1.0;
  }
  f_angleNormalIJ = acosf(f_acosArg) * sign;
  calls++;
  xDbg_PopStack();
  return f_angleNormalIJ;
}

float
FACES_commonEdgeLength_find(
  MRIS* apmris,
  FACE* apFACE_I,
  FACE* apFACE_J
)
{
  //
  // PRECONDITIONS
  //  o The <apFACE>s should be triangles with 3 vertices each.
  //  o The FACES share a common edge.
  //  o The FACES are not the same.
  //
  // POSTCONDITIONS
  //  o Length of common edge is returned.
  //  o If common vertices != 2, then function ErrorExits.
  //

  static int        calls   = 0;
  char*       pch_function  = "FACES_commonEdgeLength_find";
  VERTEX*       pVERTEX_O   = NULL; // Common vertex O
  VERTEX*       pVERTEX_I   = NULL; // Common vertex I
  static VECTOR*    pVECTOR_O   = NULL; // Common vertex O cart. coords
  static VECTOR*    pVECTOR_I   = NULL; // Common vertex I cart. coords
  static VECTOR*    pVECTOR_edgeVoVi  = NULL; // Edge Vo->Vi
  static VECTOR*    pv_commonVertices = NULL; // Vector housing vertices that
  // are common between two
  // neighbouring faces.
  int         commonVertices  = 0;  // number of vertices in common
  // between two faces
  float       f_edgeLength  = 0.; // Length of edge v->vI

  DebugEnterFunction(( "%s", pch_function));
  if(!calls)
  {
    pv_commonVertices = VectorAlloc(3, MATRIX_REAL);
    pVECTOR_O   = VectorAlloc(3, MATRIX_REAL);
    pVECTOR_I   = VectorAlloc(3, MATRIX_REAL);
    pVECTOR_edgeVoVi  = VectorAlloc(3, MATRIX_REAL);
  }
  commonVertices  = VERTICES_commonInFaces_find(
                      apFACE_I,
                      apFACE_J,
                      pv_commonVertices
                    );
  if(commonVertices != 2)
    ErrorExit(-4,
              "%s: No common edge found! <commonVertices> = %d\n",
              pch_function, commonVertices);

  pVERTEX_O   = &apmris->vertices[(int)VECTOR_ELT(pv_commonVertices, 1)];
  pVERTEX_I   = &apmris->vertices[(int)VECTOR_ELT(pv_commonVertices, 2)];

  V3_LOAD(pVECTOR_O, pVERTEX_O->x, pVERTEX_O->y, pVERTEX_O->z);
  V3_LOAD(pVECTOR_I, pVERTEX_I->x, pVERTEX_I->y, pVERTEX_I->z);
  V3_SUBTRACT(pVECTOR_I, pVECTOR_O, pVECTOR_edgeVoVi);
  f_edgeLength  = V3_LEN(pVECTOR_edgeVoVi);
  calls++;
  xDbg_PopStack();
  return(f_edgeLength);
}

short
MRIS_discreteKH_compute(
  MRIS*     apmris
)
{
  //
  // PRECONDITIONS
  //  o A valid SURFACE with computed triangle properties.
  //
  // POSTCONDITIONS
  //  o The discrete K and H curvatures at each vertex are
  //    computed.
  //

  char* pch_function    = "MRIS_discreteKH_compute";

  VECTOR* pv_geometricOrder = NULL; // Geometrically ordered faces
  VERTEX* pVertex     = NULL; // Each vertex in surface
  int         vertex      = 0;  // Vertex index number
  FACE* pFACE_I     = NULL; // Face I with vertex apex
  FACE* pFACE_J     = NULL; // Face I+1 with vertex apex
  int   face      = 0;  // face counter
  int   faceI     = 0;  // face I index
  int   faceJ     = 0;  // face J index
  int   nfaces      = 0;  // total number of faces
  int*  pFaceIndex    = NULL; // face index array at vertex
  int   angleIndex    = -1; // angle index
  float f_faceAreaSum   = 0.; // area about vertex
  float f_angleDeficitSum = 0.; // angle deficit about vertex
  float f_angleNormalIJ   = 0.; // angle between normals
  float f_angleNormalIJSum  = 0.; // sum angle between normals
  float f_edgeLength    = 0.; // Length of edge v->vI
  double  f_K     = 0.; // Gaussian curvature at vertex
  double  f_H     = 0.; // Mean curvature at vertex
  float f_Kmin      = 0.;
  float f_Kmax      = 0.;
  float f_Hmin      = 0.;
  float f_Hmax      = 0.;
  float f_Ktotal    = 0.;

  DebugEnterFunction(( "%s", pch_function));
  for (vertex = 0 ; vertex < apmris->nvertices ; vertex++)
  {
    MRIS_vertexProgress_print(apmris, vertex,
                              "Determining KH curvatures...");
    f_faceAreaSum   = 0.;
    f_angleDeficitSum = 0.;
    f_angleNormalIJSum  = 0.;
    pVertex     = &apmris->vertices[vertex];
    nfaces      = pVertex->num;
    pFaceIndex    = pVertex->f;
    pv_geometricOrder = VectorAlloc(nfaces, MATRIX_REAL);
    for(face=0; face<nfaces; face++)
    {
      faceI   = face;
      faceJ   = (face+1)%nfaces;

      pFACE_I   =  &apmris->faces[pFaceIndex[faceI]];
      pFACE_J   =  &apmris->faces[pFaceIndex[faceJ]];

      f_angleNormalIJ = FACES_angleNormal_find(apmris, pFACE_I, pFACE_J);
      f_edgeLength  = FACES_commonEdgeLength_find(
                        apmris,
                        pFACE_I,
                        pFACE_J
                      );
      f_faceAreaSum   += pFACE_I->area;
      angleIndex    =  FACE_vertexIndex_find(pFACE_I, vertex);
      if(angleIndex == -1)
        ErrorExit(-4,
                  "%s:\n\tangleIndex lookup failure for vertex %d, face %d",
                  pch_function, vertex, face);
      f_angleDeficitSum += pFACE_I->angle[angleIndex];
      f_angleNormalIJSum  += f_angleNormalIJ*f_edgeLength;
    }
    VectorFree(&pv_geometricOrder);
    pv_geometricOrder = NULL;
    f_K = 3/f_faceAreaSum   * (2*M_PI - f_angleDeficitSum);
    f_H = 0.75/f_faceAreaSum * f_angleNormalIJSum;
    apmris->vertices[vertex].K  = f_K;
    apmris->vertices[vertex].H  = f_H;
    if(!vertex)
    {
      f_Kmin = f_Kmax = f_K;
      f_Hmin = f_Hmax = f_H;
    }
    if(f_K > f_Kmax)
    {
      f_Kmax = f_K;
    }
    if(f_K < f_Kmin)
    {
      f_Kmin = f_K;
    }
    if(f_H > f_Hmax)
    {
      f_Hmax = f_H;
    }
    if(f_H < f_Hmin)
    {
      f_Hmin = f_H;
    }
    f_Ktotal += f_K * pVertex->area;
  }
  apmris->Kmax  = f_Kmax;
  apmris->Kmin  = f_Kmin;
  apmris->Hmax  = f_Hmax;
  apmris->Hmin  = f_Hmin;
  apmris->Ktotal  = f_Ktotal;
  xDbg_PopStack();
  return(NO_ERROR);
}

short
MRIS_discretek1k2_compute(
  MRIS*     apmris,
  short     ab_signedPrinciples
)
{
  //
  // PRECONDITIONS
  //  o A valid SURFACE with computed triangle properties.
  //  o A valid K and H at each vertex.
  //
  // POSTCONDITIONS
  //  o The discrete K and H curvatures at each vertex are
  //    computed.
  //  o If <ab_signedPrinciples> is true, then k1 and k2
  //    are assigned according to signed size, and not
  //    f_abs(..) size.
  //

  char* pch_function  = "MRIS_discretek1k2_compute";
  VERTEX* pVERTEX   = NULL;
  float f_k1    = 0.;
  float f_k2    = 0.;
  float f_A   = 0.;
  float f_B   = 0.;
  float f_delta   = 0.;
  float f_K   = 0.;
  float f_H   = 0.;
  int   vertex    = 0;
  int   deltaViolations = 0;

  for (vertex = 0 ; vertex < apmris->nvertices ; vertex++)
  {
    MRIS_vertexProgress_print(apmris, vertex,
                              "Determining k1k2 curvatures...");
    pVERTEX     = &apmris->vertices[vertex];
    f_K = pVERTEX->K;
    f_H = pVERTEX->H;
    f_delta = f_H*f_H - f_K;
    if(f_delta<0)
    {
      deltaViolations++;
      f_delta = 0.;
    }
    if(f_delta < 0)
      ErrorExit(-4, "%s: f_delta = %f, vertex = %d, f_K = %f, f_H = %f\n",
                pch_function, f_delta, vertex, f_K, f_H
               );
    f_A = f_H + sqrt(f_delta);
    f_B = f_H - sqrt(f_delta);
    if(!ab_signedPrinciples)
    {
      f_k1  = fabs(f_A) >= fabs(f_B) ? f_A : f_B;
      f_k2  = fabs(f_A) <= fabs(f_B) ? f_A : f_B;
    }
    else
    {
      f_k1  = f_A >= f_B ? f_A : f_B;
      f_k2  = f_A <= f_B ? f_A : f_B;
    }
    pVERTEX->k1 = f_k1;
    pVERTEX->k2 = f_k2;
  }
  if(deltaViolations)
  {
    cprintd("deltaViolations", deltaViolations);
  }
  return(NO_ERROR);
}

short
MRIScomputeSecondFundamentalFormDiscrete(
  MRIS*     apmris,
  short     ab_signedPrinciples
)
{
  int   retKH, retk1k2;

  retKH = 1;
  retk1k2 = 1;
  MRIScomputeTriangleProperties(apmris);
  MRIScomputeGeometricProperties(apmris);
  retKH = MRIS_discreteKH_compute(apmris);
  retk1k2 = MRIS_discretek1k2_compute(apmris, ab_signedPrinciples);
  return(retKH | retk1k2);
}

int
MRISscaleCurvature(
  MRI_SURFACE*  apmris,
  float     af_scale)
{
  //
  // POSTCONDITIONS
  // o Each curvature value in apmris is scaled by:
  //
  //    (curv-f_mean)*<af_scale> + f_mean
  //
  //   where f_mean is the mean of all the surface curvatures
  //

  VERTEX*   pvertex;
  int   vno;
  int   vtotal;
  double  f_mean;

  for (f_mean = 0.0, vtotal = vno = 0 ; vno < apmris->nvertices ; vno++)
  {
    pvertex = &apmris->vertices[vno] ;
    if (pvertex->ripflag)
    {
      continue ;
    }
    vtotal++ ;
    f_mean += pvertex->curv ;
  }
  f_mean /= (double)vtotal ;

  for (vno = 0 ; vno < apmris->nvertices ; vno++)
  {
    pvertex = &apmris->vertices[vno] ;
    if (pvertex->ripflag)
    {
      continue;
    }
    pvertex->curv = (pvertex->curv - f_mean) * af_scale + f_mean ;
  }
  return(NO_ERROR);
}

// Discrete Principle Curvature and Related ^^^^^^^^^^^^^^^^^^


int
MRISsurfaceRASToVoxel(MRI_SURFACE *mris, MRI *mri, double r, double a, double s,
                      double *px, double *py, double *pz)
{
  MATRIX  *m_sras2vox = NULL ;
  MATRIX *m_sras2ras, *m_ras2vox ;
  static VECTOR *v1 = NULL, *v2  ;
  MRI *mri_tmp ;

  if ( v1 == NULL)
  {
    v1 = VectorAlloc(4, MATRIX_REAL) ;
    v2 = VectorAlloc(4, MATRIX_REAL) ;
    VECTOR_ELT(v1, 4) = 1.0 ;
    VECTOR_ELT(v2, 4) = 1.0 ;
  }
  if (mris->vg.valid)
  {
    mri_tmp = MRIallocHeader(mris->vg.width, mris->vg.height, mris->vg.depth, MRI_UCHAR,1) ;
    MRIcopyVolGeomToMRI(mri_tmp, &mris->vg) ;
    m_sras2ras =  RASFromSurfaceRAS_(mri_tmp) ;
    MRIfree(&mri_tmp) ;
  }
  else // no valid geom - assume it came from provided volume
  {
    m_sras2ras =  RASFromSurfaceRAS_(mri) ;
  }

  m_ras2vox = MRIgetRasToVoxelXform(mri) ;
  m_sras2vox = MatrixMultiply(m_ras2vox, m_sras2ras, NULL) ;

  V3_X(v1) = r ;
  V3_Y(v1) = a ;
  V3_Z(v1) = s ;
  MatrixMultiply(m_sras2vox, v1, v2) ;
  *px = V3_X(v2) ;
  *py = V3_Y(v2) ;
  *pz = V3_Z(v2) ;
  MatrixFree(&m_ras2vox) ;
  MatrixFree(&m_sras2ras) ;
  MatrixFree(&m_sras2vox);
  return(NO_ERROR) ;
}


/*!
  \fn int MRISsurfaceRASToVoxelCached(MRI_SURFACE *mris, MRI *mri,
        double r, double a, double s,
        double *px, double *py, double *pz)
  \brief Computes voxel coordinates of a given surface RAS. Not safe
    for parallel applications because it caches intermediate data. Note:
    surfaceRAS is the same as tkRegRAS
  \param mris - surface (only used to get MRI struct)
  \param mri - defines target voxel space
  \param r, a, s - surface coordinates
  \param px, py, pz - pointers to col, rowl, and slice in mri (output)
*/
int MRISsurfaceRASToVoxelCached(MRI_SURFACE *mris, MRI *mri,
                                double r, double a, double s,
                                double *px, double *py, double *pz)
{
  static VECTOR *v1 = NULL, *v2  ;

  if (v1 == NULL)   // only allocate vectors once
  {
    v1 = VectorAlloc(4, MATRIX_REAL) ;
    v2 = VectorAlloc(4, MATRIX_REAL) ;
    VECTOR_ELT(v1, 4) = 1.0 ;
    VECTOR_ELT(v2, 4) = 1.0 ;
  }

  if(MRIcompareHeaders(mris->mri_sras2vox, mri))   // a different volume then previously used
  {
    if(mris->m_sras2vox)
    {
      MatrixFree(&mris->m_sras2vox) ;  // free it so it will be recomputed
    }
    if(mris->mri_sras2vox)
    {
      MRIfree(&mris->mri_sras2vox) ;
    }
    // Header of MRI whose voxel coordinates are going to be computed
    mris->mri_sras2vox = MRIcopyHeader(mri, NULL) ;
  }

  // recompute surface ras to vox transform
  if(mris->m_sras2vox == NULL)
  {
    // Get surface ras to scanner ras
    MRI *mri_tmp ;
    MATRIX *m_sras2ras, *m_ras2vox ;
    if(mris->vg.valid)
    {
      // Use VOL_GEOM struct (MRI) that is internal to MRIS if valid
      // (this is usually that of orig.mgz) Good for freeview, but for
      // this to work, the passed mri must share a scanner RAS with
      // mris->vg.
      mri_tmp = MRIallocHeader(mris->vg.width, mris->vg.height, mris->vg.depth, MRI_UCHAR,1) ;
      MRIcopyVolGeomToMRI(mri_tmp, &mris->vg) ;
      m_sras2ras =  RASFromSurfaceRAS_(mri_tmp) ;
      MRIfree(&mri_tmp) ;
    }
    else
    {
      // Use geometry from MRI struct passed with function
      // Function should reduce to inv(Vox2TkRegRAS)*SurfRAS
      m_sras2ras =  RASFromSurfaceRAS_(mri) ;
    }
    // Scanner RAS to Vox for passed MRI
    m_ras2vox = MRIgetRasToVoxelXform(mri) ;
    // SurfRAS2Vox = ScanRAS-To-Vox * SurfRAS-To-ScanRAS
    mris->m_sras2vox = MatrixMultiply(m_ras2vox, m_sras2ras, NULL) ;
    MatrixFree(&m_sras2ras) ;
    MatrixFree(&m_ras2vox) ;
  }

  V3_X(v1) = r ;
  V3_Y(v1) = a ;
  V3_Z(v1) = s ;
  MatrixMultiply(mris->m_sras2vox, v1, v2) ;
  *px = V3_X(v2) ;
  *py = V3_Y(v2) ;
  *pz = V3_Z(v2) ;
  return(NO_ERROR) ;
}

int
MRISsurfaceRASFromVoxel(MRI_SURFACE *mris, MRI *mri, double x, double y, double z,
                        double *pr, double *pa, double *ps)
{
  MATRIX  *m_sras2vox = NULL ;
  MATRIX  *m_vox2sras = NULL ;
  MATRIX *m_sras2ras, *m_ras2vox ;
  static VECTOR *v1 = NULL, *v2  ;
  MRI *mri_tmp ;

  if ( v1 == NULL)
  {
    v1 = VectorAlloc(4, MATRIX_REAL) ;
    v2 = VectorAlloc(4, MATRIX_REAL) ;
    VECTOR_ELT(v1, 4) = 1.0 ;
    VECTOR_ELT(v2, 4) = 1.0 ;
  }
  if (mris->vg.valid)
  {
    mri_tmp = MRIallocHeader(mris->vg.width, mris->vg.height, mris->vg.depth, MRI_UCHAR,1) ;
    MRIallocHeader(mris->vg.width, mris->vg.height, mris->vg.depth, MRI_UCHAR,1) ;
    MRIcopyVolGeomToMRI(mri_tmp, &mris->vg) ;
    m_sras2ras =  RASFromSurfaceRAS_(mri_tmp) ;
    MRIfree(&mri_tmp) ;
  }
  else // no valid geom - assume it came from provided volume
  {
    m_sras2ras =  RASFromSurfaceRAS_(mri) ;
  }

  m_ras2vox = MRIgetRasToVoxelXform(mri) ;
  m_sras2vox = MatrixMultiply(m_ras2vox, m_sras2ras, NULL) ;
  m_vox2sras = MatrixInverse(m_sras2vox, NULL) ;

  V3_X(v1) = x ;
  V3_Y(v1) = y ;
  V3_Z(v1) = z ;
  MatrixMultiply(m_vox2sras, v1, v2) ;
  *pr = V3_X(v2) ;
  *pa = V3_Y(v2) ;
  *ps = V3_Z(v2) ;
  MatrixFree(&m_ras2vox) ;
  MatrixFree(&m_sras2ras) ;
  MatrixFree(&m_sras2vox);
  MatrixFree(&m_vox2sras) ;
  return(NO_ERROR) ;
}
// note that this is *NOT* safe for parallel implementations
int
MRISsurfaceRASFromVoxelCached(MRI_SURFACE *mris, MRI *mri, double x, double y,
                              double z, double *pr, double *pa, double *ps)
{
  static MATRIX  *m_vox2sras = NULL ;
  static VECTOR *v1, *v2  ;

  if (m_vox2sras == NULL)
  {
    MRI *mri_tmp ;
    MATRIX *m_sras2ras, *m_ras2vox ;
    MATRIX  *m_sras2vox = NULL ;

    if (mris->vg.valid)
    {
      mri_tmp = MRIallocHeader(mris->vg.width, mris->vg.height, mris->vg.depth, MRI_UCHAR,1) ;
      MRIcopyVolGeomToMRI(mri_tmp, &mris->vg) ;
      m_sras2ras =  RASFromSurfaceRAS_(mri_tmp) ;
      MRIfree(&mri_tmp) ;
    }
    else
    {
      m_sras2ras =  RASFromSurfaceRAS_(mri) ;
    }

    m_ras2vox = MRIgetRasToVoxelXform(mri) ;
    m_sras2vox = MatrixMultiply(m_ras2vox, m_sras2ras, NULL) ;
    m_vox2sras = MatrixInverse(m_sras2vox, NULL) ;
    v1 = VectorAlloc(4, MATRIX_REAL) ;
    v2 = VectorAlloc(4, MATRIX_REAL) ;
    VECTOR_ELT(v1, 4) = 1.0 ;
    VECTOR_ELT(v2, 4) = 1.0 ;
    MatrixFree(&m_sras2vox) ;
    MatrixFree(&m_ras2vox) ;
    MatrixFree(&m_sras2ras) ;
  }
  V3_X(v1) = x ;
  V3_Y(v1) = y ;
  V3_Z(v1) = z ;
  MatrixMultiply(m_vox2sras, v1, v2) ;
  *pr = V3_X(v2) ;
  *pa = V3_Y(v2) ;
  *ps = V3_Z(v2) ;
  return(NO_ERROR) ;
}
/*-----------------------------------------------------
  Parameters:

  Returns value:

  Description
  ------------------------------------------------------*/
int
MRIScomputeNormal(MRIS *mris, int which, int vno, double *pnx, double *pny, double *pnz)
{
  float snorm[3], norm[3] ;
  VERTEX *v ;
  int    n, num ;

  v = &mris->vertices[vno] ;

  norm[0]=norm[1]=norm[2]=0.0;
  snorm[0]=snorm[1]=snorm[2]=0.0;
  for (num = n=0; n<v->num; n++) if (!mris->faces[v->f[n]].ripflag)
    {
      num++ ;
      switch (which)
      {
      case CURRENT_VERTICES:
        mrisNormalFace(mris, v->f[n], (int)v->n[n],snorm);
        break ;
      case ORIGINAL_VERTICES:
        mrisOrigNormalFace(mris, v->f[n], (int)v->n[n],snorm);
        break ;
      case WHITE_VERTICES:
        mrisWhiteNormalFace(mris, v->f[n], (int)v->n[n],snorm);
        break ;
      case PIAL_VERTICES:
        mrisPialNormalFace(mris, v->f[n], (int)v->n[n],snorm);
        break ;
      default:
        ErrorExit(ERROR_BADPARM, "MRIScomputeNormal: which = %d not supported", which) ;
        break ;
      }
      norm[0] += snorm[0];
      norm[1] += snorm[1];
      norm[2] += snorm[2];
    }
  if (!num)
  {
    return(ERROR_BADPARM) ;
  }
  mrisNormalize(norm);
  *pnx = norm[0] ;
  *pny = norm[1] ;
  *pnz = norm[2] ;
  return(NO_ERROR) ;
}
static double
mrisComputeSurfaceRepulsionEnergy(MRI_SURFACE *mris, double l_repulse, MHT *mht)
{
  int     vno, max_vno, i ;
  float   dx, dy, dz, x, y, z, sx, sy, sz,norm[3],dot;
  float   max_scale, max_dot ;
  double  scale, sse ;
  VERTEX  *v, *vn ;
  MHBT    *bucket ;
  MHB     *bin ;

  if (FZERO(l_repulse))
  {
    return(NO_ERROR) ;
  }

  for (sse = 0.0, vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    x = v->x ;
    y = v->y ;
    z = v->z ;
    bucket = MHTgetBucket(mht, x, y, z) ;
    if (!bucket)
    {
      continue ;
    }
    bin = bucket->bins ;
    sx = sy = sz = 0.0 ;
    max_dot = max_scale = 0.0 ;
    max_vno = 0 ;
    for (i = 0 ; i < bucket->nused ; i++, bin++)
    {
      vn = &mris->vertices[bin->fno] ;
      if (bin->fno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (vn->ripflag)
      {
        continue ;
      }
      dx = x - vn->origx ;
      dy = y - vn->origy ;
      dz = z - vn->origz ;
      mrisComputeOrigNormal(mris, bin->fno, norm) ;
      dot = dx*norm[0] + dy*norm[1] + dz*norm[2] ;
      if (dot > 1)
      {
        continue ;
      }
      if (dot < 0 && vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (dot > MAX_NEG_RATIO)
      {
        dot = MAX_NEG_RATIO ;
      }
      else if (dot < -MAX_NEG_RATIO)
      {
        dot = -MAX_NEG_RATIO ;
      }
#if 0
      scale = l_repulse / (1.0+exp(NEG_AREA_K*dot)) ;
#else
      scale = l_repulse*pow(1.0-(double)dot,4.0) ;
#endif
      if (scale > max_scale)
      {
        max_scale = scale ;
        max_vno = bin->fno ;
        max_dot = dot ;
      }
      sx += (scale*v->nx) ;
      sy += (scale*v->ny) ;
      sz += (scale*v->nz) ;
    }

    sse += (sx*sx + sy*sy + sz*sz) ;
    if (vno == Gdiag_no)
      fprintf(stdout, "v %d inside repulse energy %2.3f\n",
              vno, (sx*sx + sy*sy + sz*sz)) ;
  }
  return(sse) ;
}


// average the stats on the surface, and propagate marks
// outwards to new non-zero locations
int
MRISaverageMarkedStats(MRI_SURFACE *mris, int navgs)
{
  int    i, vno, vnb, *pnb, vnum ;
  float  val, num ;
  VERTEX *v, *vn ;

  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (v->ripflag)
      {
        continue ;
      }
      val = v->stat ;
      pnb = v->v ;
      vnum = v->vnum ;
      for (num = 0.0f, vnb = 0 ; vnb < vnum ; vnb++)
      {
        vn = &mris->vertices[*pnb++]; /* neighboring vertex pointer */
        if (vn->ripflag)
        {
          continue ;
        }
        num++ ;
        val += vn->stat ;
      }
      num++ ;  /*  account for central vertex */
      v->tdx = val / num ;
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (vno == Gdiag_no)
      {
        DiagBreak() ;
      }
      if (v->ripflag)
      {
        continue ;
      }
      v->stat = v->tdx ;
      if (v->marked == 0 && !FZERO(v->stat))
      {
        v->marked = 2 ;
      }
      if (FZERO(v->stat))
      {
        DiagBreak() ;
      }
    }
  }
  return(NO_ERROR) ;
}


void UpdateMRIS(MRI_SURFACE *mris, const char *fname)
{
  mrisFindNeighbors(mris);
  mrisComputeVertexDistances(mris);
  if (fname)
  {
    mrisReadTransform(mris, fname);
  }
  mris->radius = MRISaverageRadius(mris);
  MRIScomputeMetricProperties(mris);
  MRISstoreCurrentPositions(mris);
}
/*
  use MARS code from Mert and Thomas to compute the distance at each point on the surface
  to the boundary of a label.

  The distances will be returned in the vertex->val field.
*/

#include "MARS_DT_Boundary.h"
int
MRISdistanceTransform(MRI_SURFACE *mris,LABEL *area, int mode)
{
  int    *vertices, *vertNbrs, vno, max_nbrs, j, index ;
  double *cost, *vertDists ;
  VERTEX *v ;

  cost = (double *)calloc(mris->nvertices, sizeof(double)) ;
  if (cost == NULL)
  {
    ErrorExit(ERROR_NOMEMORY, "MRISdistanceTransform: could not allocate %d cost array\n", mris->nvertices) ;
  }
  vertices = (int *)calloc(mris->nvertices, sizeof(int)) ;
  if (vertices == NULL)
  {
    ErrorExit(ERROR_NOMEMORY, "MRISdistanceTransform: could not allocate %d vertex array\n", mris->nvertices) ;
  }

  for (vno = max_nbrs = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    //    if (v->ripflag)
    // continue ;
    if (v->vnum > max_nbrs)
    {
      max_nbrs = v->vnum ;
    }
  }
  vertNbrs = (int *)calloc(mris->nvertices*max_nbrs, sizeof(int)) ;
  if (vertNbrs == NULL)
    ErrorExit(ERROR_NOMEMORY, "MRISdistanceTransform: could not allocate nbrs (%d x %d) array\n",
              mris->nvertices, max_nbrs) ;
  vertDists = (double *)calloc(mris->nvertices*max_nbrs, sizeof(double)) ;
  if (vertDists == NULL)
    ErrorExit(ERROR_NOMEMORY, "MRISdistanceTransform: could not allocate dist (%d x %d) array\n",
              mris->nvertices, max_nbrs) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak();
    }
    //    if (v->ripflag)
    //      continue ;
    for (j = 0 ; j < v->vnum ; j++)
    {
      //      if (mris->vertices[v->v[j]].ripflag)
      // continue ;
      index = index_2D_array(j, vno, max_nbrs) ;
      vertDists[index] = v->dist[j] ;
      vertNbrs[index] = v->v[j]+1 ;  // nbrs is 1-based
    }
  }

#if 0
  if (area->lv[0].vno == Gdiag_no)
  {
    FILE *fp ;
    fp = fopen("test.log", "w") ;
    v = &mris->vertices[16156] ;
    fprintf(fp, "vno %d:\n", (int)(v-mris->vertices)) ;
    for (j = 0 ; j < v->vnum ; j++)
    {
      //      if (mris->vertices[v->v[j]].ripflag)
      // continue ;
      index = index_2D_array(j, vno, max_nbrs) ;
      fprintf(fp, "vno %d, index %d, j %d, dist %2.4f, nbr %d\n", v->v[j], index, j, v->dist[j], v->v[j]+1) ;
      vertDists[index] = v->dist[j] ;
      vertNbrs[index] = v->v[j]+1 ;  // nbrs is 1-based
    }

    v = &mris->vertices[16244] ;
    fprintf(fp, "vno %d:\n", (int)(v-mris->vertices)) ;
    for (j = 0 ; j < v->vnum ; j++)
    {
      //      if (mris->vertices[v->v[j]].ripflag)
      // continue ;
      index = index_2D_array(j, vno, max_nbrs) ;
      fprintf(fp, "vno %d, index %d, j %d, dist %2.4f, nbr %d\n", v->v[j], index, j, v->dist[j], v->v[j]+1) ;
      vertDists[index] = v->dist[j] ;
      vertNbrs[index] = v->v[j]+1 ;  // nbrs is 1-based
    }
    fclose(fp) ;
  }
#endif

  for (vno = 0 ; vno < area->n_points ; vno++)
    if (area->lv[vno].vno >= 0 && area->lv[vno].deleted == 0)
    {
      vertices[area->lv[vno].vno] = 1 ;
    }
  if (mode == DTRANS_MODE_INSIDE) // mark exterior and compute distance from it
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      vertices[vno] = !vertices[vno] ;
    }
  }

  // compute outside distances
  MARS_DT_Boundary(vertices, mris->nvertices, max_nbrs, vertNbrs, vertDists, cost) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].val = cost[vno] ;  // distance to inside points
  }

  if (mode == DTRANS_MODE_SIGNED || mode == DTRANS_MODE_UNSIGNED)
  {
    // compute distance to interior points
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      vertices[vno] = !vertices[vno] ;  // 1=in exterior, 0=in interior
    }
    MARS_DT_Boundary(vertices, mris->nvertices, max_nbrs, vertNbrs, vertDists, cost) ;
    for (vno = 0 ; vno < mris->nvertices ; vno++)
      if (cost[vno] > 0)
      {
        mris->vertices[vno].val = mode == DTRANS_MODE_SIGNED ? -cost[vno] : cost[vno] ;
      }
  }

  free(vertices) ;
  free(cost) ;
  free(vertDists) ;
  free(vertNbrs) ;
  return(NO_ERROR) ;
}
/*
  assumes v->val has the distances for label1 and v->val2 has the distances
  for label 2, computed using MRISdistanceTransform
*/
double
MRIScomputeHausdorffDistance(MRI_SURFACE *mris, int mode)
{
  double   hdist = 0, d, dist ;
  int      vno, n, num ;
  VERTEX   *v, *vn ;

  // assume mode is symmetric mean for now
  for (num = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    for (n = 0 ; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->ripflag)
      {
        continue ;
      }
      // look for zero crossings in val
      if (vn->val * v->val < 0) // different signs - compute location of 0 between them
      {
        // compute distance of '0' point from v to vn
        if (vn->val < 0)
        {
          dist = -vn->val / (-vn->val + v->val) ; // fraction of way
          dist = 1-dist ;  // measure from v not vn
        }
        else
        {
          dist = -v->val / (-v->val + vn->val) ;  // fraction of way
        }
        d = dist*fabs(v->val2) + (1-dist)*fabs(vn->val2) ;  // compute val2 at this point
        num++ ;
        hdist += d ;
      }

      // look for zero crossings in val2
      if (vn->val2 * v->val2 < 0) // different signs - compute location of 0 between them
      {
        // compute distance of '0' point from v to vn
        if (vn->val2 < 0)
        {
          dist = -vn->val2 / (-vn->val2 + v->val2) ; // fraction of way
          dist = 1-dist ;  // measure from v not vn
        }
        else
        {
          dist = -v->val2 / (-v->val2 + vn->val2) ;  // fraction of way
        }
        num++ ;
        d = dist*fabs(v->val) + (1-dist)*fabs(vn->val) ;  // compute val2 at this point
        hdist += d ;
      }
    }
  }
  if (num > 0)
  {
    hdist /= num ;
  }


  return(hdist) ;
}


int
MRIScomputeAllDistances(MRI_SURFACE *mris)
{
  VERTEX *v, *vn ;
  int    vno, n, nvalid, *old_v, vno2, done = 0 ;
  LABEL  *area ;

  if (Gdiag & DIAG_SHOW)
  {
    fprintf(stdout, "\ncomputing complete distance matrix...\n") ;
  }
  area = LabelAlloc(1, NULL, NULL) ;

  MRIScomputeMetricProperties(mris) ;
  nvalid = MRISvalidVertices(mris) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }

    if ((Gdiag & DIAG_SHOW) && (++done % (nvalid/20)) == 0)
    {
      fprintf(stdout, "%%%1.0f done\n",
              100.0f*(float)done / (float)nvalid) ;
      fflush(stdout) ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    area->lv[0].vno = vno ;
    area->n_points = 1 ;
    MRISdistanceTransform(mris, area, DTRANS_MODE_UNSIGNED) ;
    if (v->dist_orig)
    {
      free(v->dist_orig) ;
    }
    if (v->dist)
    {
      free(v->dist) ;
    }
    old_v = v->v ;
    v->dist_orig = (float *)calloc(nvalid-1, sizeof(float)) ;
    v->dist = (float *)calloc(nvalid-1, sizeof(float)) ;
    v->v = (int *)calloc(nvalid-1, sizeof(int) );
    if (!v->v || !v->dist || !v->dist_orig)
      ErrorExit(ERROR_NOMEMORY,
                "MRIScomputeAllDistances: could not allocate %d-sized arrays",
                nvalid-1) ;
    memmove(v->v, old_v, v->vtotal*sizeof(v->v[0])) ;
    free(old_v) ;
    MRISclearMarks(mris) ;
    v->marked = 1 ;  // don't add self to list
    // read out first vtotal nbrs
    for (n = 0 ; n < v->vtotal ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      v->dist[n] = v->dist_orig[n] = vn->val;  // v->dist will be restored by caller
      vn->marked = 1 ;
    }
    // now read out rest
    for (vno2 = 0 ; vno2 < mris->nvertices ; vno2++)
    {
      vn = &mris->vertices[vno2] ;
      if (vn->ripflag || vn->marked)
      {
        continue ;
      }
      v->dist[n] = v->dist_orig[n] = vn->val;
      v->v[n++] = vno2 ;
      vn->marked = 1 ;
    }
    v->vtotal = nvalid-1 ;
    if (vno == Gdiag_no)
    {
      char fname[STRLEN] ;
      sprintf(fname, "vno%d.mgz", vno) ;
      MRISwriteValues(mris, fname) ;

      for (n = vno2 = 0 ; vno2 < mris->nvertices ; vno2++)
      {
        vn = &mris->vertices[vno2] ;
        if (vn->marked)
        {
          int m, found ;
          n++ ;
          for (found = m = 0 ; m < v->vtotal ; m++)
            if (v->v[m] == vno2)
            {
              found = 1 ;
              break ;
            }
          if (found == 0 && vno2 != vno)
          {
            DiagBreak() ;
          }
        }
      }
    }
  }
  LabelFree(&area) ;
  return(NO_ERROR) ;
}

int
MRISsetValues(MRI_SURFACE *mris, float val)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno];
    if (v->ripflag)
    {
      continue ;
    }
    v->val = val;
  }
  return(NO_ERROR) ;
}
int
MRISaddToValues(MRI_SURFACE *mris, float val)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno];
    if (v->ripflag)
    {
      continue ;
    }
    v->val += val;
  }
  return(NO_ERROR) ;
}

LABEL *
MRISannotation_to_label(MRI_SURFACE *mris, int annot_index)
{
  int    vno, nv, annot ;
  VERTEX *v ;
  LABEL  *area ;

  CTABannotationAtIndex(mris->ct, annot_index, &annot) ;
  for (nv = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (v->annotation == annot)
    {
      nv++ ;
    }
  }
  if (nv == 0)
  {
    return(NULL) ;
  }
  area = LabelAlloc(nv, NULL, mris->ct->entries[annot_index]->name);
  for (nv = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (v->annotation == annot)
    {
      area->lv[nv].vno = vno ;
      area->n_points++ ;
      nv++ ;
    }
  }
  return(area) ;
}
#include "histo.h"
HISTOGRAM *
MRISgetHistogram(MRI_SURFACE *mris, int nbins, int field)
{
  int       vno, bin ;
  VERTEX    *v ;
  double    fmin, fmax, bin_size, val ;
  HISTOGRAM *h ;

  fmin = 1e10;
  fmax = -fmin ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    switch (field)
    {
    default:
      ErrorExit(ERROR_BADPARM, "MRISgetHistogram: unknown field %d", field) ;
    case SCLV_VAL:
      val = (v)->val;
      break;
    case SCLV_VAL2:
      val = v->val2 ;
      break ;
    case SCLV_VALBAK:
      val = v->valbak ;
      break ;
    case SCLV_VAL2BAK:
      val = v->val2bak ;
      break ;
    case SCLV_VALSTAT:
      val = v->stat ;
      break ;
    case SCLV_IMAG_VAL:
      val = v->imag_val ;
      break ;
    case SCLV_MEAN:
      val = v->mean ;
      break ;
    case SCLV_MEAN_IMAG:
      val = v->mean_imag ;
      break ;
    case SCLV_STD_ERROR:
      val = v->std_error ;
      break ;
    }
    if (val < fmin)
    {
      fmin = val ;
    }
    if (val > fmax)
    {
      fmax = val ;
    }
  }
  if (nbins < 0)
  {
    nbins = 1000;
  }
  h = HISTOalloc(nbins) ;
  if (fmax == fmin)
  {
    bin_size = 1 ;
  }
  else
  {
    bin_size = (fmax - fmin) / ((float)h->nbins-1) ;
  }
  h->bin_size = bin_size ;
  h->min = fmin ;
  h->max = fmax ;
  for (bin = 0 ; bin < h->nbins ; bin++)
  {
    h->bins[bin] = bin*h->bin_size + h->min ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    switch (field)
    {
    default:
      ErrorExit(ERROR_BADPARM, "MRISgetHistogram: unknown field %d", field) ;
    case SCLV_VAL:
      val = (v)->val;
      break;
    case SCLV_VAL2:
      val = v->val2 ;
      break ;
    case SCLV_VALBAK:
      val = v->valbak ;
      break ;
    case SCLV_VAL2BAK:
      val = v->val2bak ;
      break ;
    case SCLV_VALSTAT:
      val = v->stat ;
      break ;
    case SCLV_IMAG_VAL:
      val = v->imag_val ;
      break ;
    case SCLV_MEAN:
      val = v->mean ;
      break ;
    case SCLV_MEAN_IMAG:
      val = v->mean_imag ;
      break ;
    case SCLV_STD_ERROR:
      val = v->std_error ;
      break ;
    }
    bin = HISTOvalToBinDirect(h, val) ;
    h->counts[bin]++ ;
  }
  return(h) ;
}
#include "mrishash.h"

#define MAX_DIST 10
int
MRISmeasureDistanceBetweenSurfaces(MRI_SURFACE *mris, MRI_SURFACE *mris2, int signed_dist)
{
  int    vno ;
  VERTEX *v1, *v2 ;
  MRIS_HASH_TABLE *mht ;
  double           dx, dy, dz ;

  mht = MHTfillVertexTableRes(mris2, NULL, CURRENT_VERTICES, MAX_DIST) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v1 = &mris->vertices[vno] ;
    if (v1->ripflag)
    {
      continue ;
    }
    v2 = MHTfindClosestVertex(mht, mris2, v1) ;
    if (v2 == NULL)
    {
      v1->curv = MAX_DIST ;
      continue ;
    }
    dx = v1->x-v2->x ;
    dy = v1->y-v2->y ;
    dz = v1->z-v2->z ;
    v1->curv = sqrt(dx*dx + dy*dy + dz*dz) ;
    if (signed_dist)
    {
      double dot ;

      dot = dx*v1->nx + dy*v1->ny + dz*v1->nz ;
      if (dot < 0)
      {
        v1->curv *= -1 ;
      }
    }
  }

  MHTfree(&mht) ;
  return(NO_ERROR) ;
}

int
MRISwriteCoordsToIco(MRI_SURFACE *mris, MRI_SURFACE *mris_ico, int which_vertices)
{
  MHT    *mht ;
  int    vno, fno, debug ;
  VERTEX *v ;
  FACE   *face ;
  double  fdist ;
  float   x, y, z;

  mht = MHTfillTableAtResolution(mris, NULL, CANONICAL_VERTICES, 1.0) ;

  for (vno = 0 ; vno < mris_ico->nvertices ; vno++)
  {
    v = &mris_ico->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }

    MHTfindClosestFaceGeneric(mht, mris, v->cx, v->cy, v->cz, 1000, -1, 1, &face, &fno, &fdist) ;
    if (face == NULL)
    {
      DiagBreak() ;
      continue ;
    }
    debug = (face->v[0] == Gdiag_no || face->v[1] == Gdiag_no || face->v[2] == Gdiag_no) ;
    MRISsampleFaceCoordsCanonical(mht, mris, v->cx,v->cy, v->cz, which_vertices, &x, &y, &z);
    if (debug)
    {
      printf("ico vertex %d, coords = (%2.2f, %2.2f, %2.2f)\n", vno, x, y, z) ;
    }
    switch (which_vertices)
    {
    case PIAL_VERTICES:
      v->pialx = x ;
      v->pialy = y ;
      v->pialz = z ;
      break ;
    default:
      ErrorExit(ERROR_UNSUPPORTED, "%s: unsupported vertex set %d",__MYFUNCTION__, which_vertices) ;
      break ;
    }
  }
  MHTfree(&mht) ;
  return(NO_ERROR) ;
}

int
MRISvertexCoord2XYZ_float (VERTEX * v, int which, float  *x, float  *y, float  *z)
{
  switch (which)
  {
  case ORIGINAL_VERTICES  :
    *x = v->origx;
    *y = v->origy;
    *z = v->origz;
    break;
  case TMP_VERTICES       :
    *x = v->tx;
    *y = v->ty;
    *z = v->tz;
    break;
  case CANONICAL_VERTICES :
    *x = v->cx;
    *y = v->cy;
    *z = v->cz;
    break;
  case CURRENT_VERTICES   :
    *x = v->x;
    *y = v->y;
    *z = v->z;
    break;
  case INFLATED_VERTICES  :
    *x = v->infx ;
    *y = v->infy ;
    *z = v->infz ;
    break;
  case PIAL_VERTICES      :
    *x = v->pialx;
    *y = v->pialy;
    *z = v->pialz;
    break;
  case TMP2_VERTICES      :
    *x = v->tx2;
    *y = v->ty2;
    *z = v->tz2;
    break;
  case FLATTENED_VERTICES     :
    *x = v->fx;
    *y = v->fy;
    *z = v->fz;
    break ;
  case WHITE_VERTICES     :
    *x = v->whitex;
    *y = v->whitey;
    *z = v->whitez;
    break;
  default:
  case GOOD_VERTICES      :
    ErrorExit(ERROR_UNSUPPORTED, "MRISvertexCoord2XYZ_double: unsupported which %d", which) ;
    break;
  }
  return(NO_ERROR) ;
}
int
MRISvertexCoord2XYZ_double (VERTEX * v, int which, double  *x, double  *y, double  *z)
{
  switch (which)
  {
  default:
  case GOOD_VERTICES      :
    ErrorExit(ERROR_UNSUPPORTED, "MRISvertexCoord2XYZ_double: unsupported which %d", which) ;
    break;
  case ORIGINAL_VERTICES  :
    *x = (double)v->origx;
    *y = (double)v->origy;
    *z = (double)v->origz;
    break;
  case TMP_VERTICES       :
    *x = (double)v->tx;
    *y = (double)v->ty;
    *z = (double)v->tz;
    break;
  case CANONICAL_VERTICES :
    *x = (double)v->cx;
    *y = (double)v->cy;
    *z = (double)v->cz;
    break;
  case CURRENT_VERTICES   :
    *x = (double)v->x;
    *y = (double)v->y;
    *z = (double)v->z;
    break;
  case INFLATED_VERTICES  :
    *x = (double)v->infx ;
    *y = (double)v->infy ;
    *z = (double)v->infz ;
    break;
  case PIAL_VERTICES      :
    *x = (double)v->pialx;
    *y = (double)v->pialy;
    *z = (double)v->pialz;
    break;
  case TMP2_VERTICES      :
    *x = (double)v->tx2;
    *y = (double)v->ty2;
    *z = (double)v->tz2;
    break;
  case FLATTENED_VERTICES     :
    *x = (double)v->fx;
    *y = (double)v->fy;
    *z = (double)v->fz;
    break ;
  case WHITE_VERTICES     :
    *x = (double)v->whitex;
    *y = (double)v->whitey;
    *z = (double)v->whitez;
    break;
  }
  return(NO_ERROR) ;
}
int
MRISsampleFaceCoordsCanonical(MHT *mht, MRI_SURFACE *mris, float x, float y, float z, int which,
                              float *px, float *py, float *pz)
{
  float    xv, yv, zv ;
  double   lambda[3], fdist, norm ;
  int      n, ret = NO_ERROR, fno ;
  FACE     *face ;
  VERTEX   *v ;

  norm = sqrt(x*x + y*y + z*z) ;
  if (!FEQUAL(norm, mris->radius))  // project point onto sphere
  {
    DiagBreak();
    project_point_onto_sphere(x, y, z, mris->radius, &x, &y, &z) ;
  }

  xv = yv = zv = 0.0 ; // to get rid of mac warnings
  MHTfindClosestFaceGeneric(mht, mris, x, y, z, 8, 8, 1, &face, &fno, &fdist) ;
  if (fno < 0)
  {
    DiagBreak() ;
    MHTfindClosestFaceGeneric(mht, mris, x, y, z, 1000, -1, -1, &face, &fno, &fdist) ;
    lambda[0] = lambda[1] = lambda[2] = 1.0/3.0;
  }
  else
  {
    ret = face_barycentric_coords(mris, fno, CANONICAL_VERTICES, x, y, z, &lambda[0], &lambda[1], &lambda[2]) ;
  }

  *px = *py = *pz = 0 ;
  for (n = 0  ; n < VERTICES_PER_FACE ; n++)
  {
    v = &mris->vertices[face->v[n]] ;
    MRISvertexCoord2XYZ_float(v, which, &xv, &yv, &zv) ;
    *px += lambda[n]*xv ;
    *py += lambda[n]*yv ;
    *pz += lambda[n]*zv ;
  }

  return(ret) ;
}


#if 1
static int
mris_project_point_into_face(MRI_SURFACE *mris, FACE *face, int which, double x, double y, double z,
                             double *px, double *py, double *pz)
{
  double point[3], V0[3], V1[3], V2[3], proj[3] ;

  point[0] = x ;
  point[1] = y ;
  point[2] = z ;
  switch (which)
  {
  default:
    ErrorExit(ERROR_BADPARM, "mris_project_point_into_face: which %d not supported", which) ;
    break ;
  case FLATTENED_VERTICES:
    V0[0] = mris->vertices[face->v[0]].fx ;
    V0[1] = mris->vertices[face->v[0]].fy ;
    V0[2] = mris->vertices[face->v[0]].fz ;
    V1[0] = mris->vertices[face->v[1]].fx ;
    V1[1] = mris->vertices[face->v[1]].fy ;
    V1[2] = mris->vertices[face->v[1]].fz ;
    V2[0] = mris->vertices[face->v[2]].fx ;
    V2[1] = mris->vertices[face->v[2]].fy ;
    V2[2] = mris->vertices[face->v[2]].fz ;
    break ;
  case CURRENT_VERTICES:
    V0[0] = mris->vertices[face->v[0]].x ;
    V0[1] = mris->vertices[face->v[0]].y ;
    V0[2] = mris->vertices[face->v[0]].z ;
    V1[0] = mris->vertices[face->v[1]].x ;
    V1[1] = mris->vertices[face->v[1]].y ;
    V1[2] = mris->vertices[face->v[1]].z ;
    V2[0] = mris->vertices[face->v[2]].x ;
    V2[1] = mris->vertices[face->v[2]].y ;
    V2[2] = mris->vertices[face->v[2]].z ;
    break ;
  case PIAL_VERTICES:
    V0[0] = mris->vertices[face->v[0]].pialx ;
    V0[1] = mris->vertices[face->v[0]].pialy ;
    V0[2] = mris->vertices[face->v[0]].pialz ;
    V1[0] = mris->vertices[face->v[1]].pialx ;
    V1[1] = mris->vertices[face->v[1]].pialy ;
    V1[2] = mris->vertices[face->v[1]].pialz ;
    V2[0] = mris->vertices[face->v[2]].pialx ;
    V2[1] = mris->vertices[face->v[2]].pialy ;
    V2[2] = mris->vertices[face->v[2]].pialz ;
    break ;
  case CANONICAL_VERTICES:
    V0[0] = mris->vertices[face->v[0]].cx ;
    V0[1] = mris->vertices[face->v[0]].cy ;
    V0[2] = mris->vertices[face->v[0]].cz ;
    V1[0] = mris->vertices[face->v[1]].cx ;
    V1[1] = mris->vertices[face->v[1]].cy ;
    V1[2] = mris->vertices[face->v[1]].cz ;
    V2[0] = mris->vertices[face->v[2]].cx ;
    V2[1] = mris->vertices[face->v[2]].cy ;
    V2[2] = mris->vertices[face->v[2]].cz ;
    break ;
  }

  project_point_to_plane(point, V0, V1, V2, proj, NULL, NULL) ;
  *px = proj[0] ;
  *py = proj[1] ;
  *pz = proj[2] ;

  return(NO_ERROR) ;
}
#endif

int
face_barycentric_coords(MRI_SURFACE *mris, int fno, int which_vertices,
                        double cx, double cy, double cz, double *pl1, double *pl2, double *pl3)
{
  double l1, l2, l3, x, y, x1, x2, x3, y1, y2, y3, e1[3], e2[3] ;
  FACE   *face = &mris->faces[fno] ;
  double  V0[3], V1[3], V2[3], point[3], proj[3], detT ;
  int     ret = 0 ;

  switch (which_vertices)
  {
  default:
    ErrorExit(ERROR_BADPARM, "mris_project_point_into_face: which %d not supported", which_vertices) ;
    break ;
  case FLATTENED_VERTICES:
    V0[0] = mris->vertices[face->v[0]].fx ;
    V0[1] = mris->vertices[face->v[0]].fy ;
    V0[2] = mris->vertices[face->v[0]].fz ;
    V1[0] = mris->vertices[face->v[1]].fx ;
    V1[1] = mris->vertices[face->v[1]].fy ;
    V1[2] = mris->vertices[face->v[1]].fz ;
    V2[0] = mris->vertices[face->v[2]].fx ;
    V2[1] = mris->vertices[face->v[2]].fy ;
    V2[2] = mris->vertices[face->v[2]].fz ;
    break ;
  case CURRENT_VERTICES:
    V0[0] = mris->vertices[face->v[0]].x ;
    V0[1] = mris->vertices[face->v[0]].y ;
    V0[2] = mris->vertices[face->v[0]].z ;
    V1[0] = mris->vertices[face->v[1]].x ;
    V1[1] = mris->vertices[face->v[1]].y ;
    V1[2] = mris->vertices[face->v[1]].z ;
    V2[0] = mris->vertices[face->v[2]].x ;
    V2[1] = mris->vertices[face->v[2]].y ;
    V2[2] = mris->vertices[face->v[2]].z ;
    break ;
  case PIAL_VERTICES:
    V0[0] = mris->vertices[face->v[0]].pialx ;
    V0[1] = mris->vertices[face->v[0]].pialy ;
    V0[2] = mris->vertices[face->v[0]].pialz ;
    V1[0] = mris->vertices[face->v[1]].pialx ;
    V1[1] = mris->vertices[face->v[1]].pialy ;
    V1[2] = mris->vertices[face->v[1]].pialz ;
    V2[0] = mris->vertices[face->v[2]].pialx ;
    V2[1] = mris->vertices[face->v[2]].pialy ;
    V2[2] = mris->vertices[face->v[2]].pialz ;
    break ;
  case CANONICAL_VERTICES:
    V0[0] = mris->vertices[face->v[0]].cx ;
    V0[1] = mris->vertices[face->v[0]].cy ;
    V0[2] = mris->vertices[face->v[0]].cz ;
    V1[0] = mris->vertices[face->v[1]].cx ;
    V1[1] = mris->vertices[face->v[1]].cy ;
    V1[2] = mris->vertices[face->v[1]].cz ;
    V2[0] = mris->vertices[face->v[2]].cx ;
    V2[1] = mris->vertices[face->v[2]].cy ;
    V2[2] = mris->vertices[face->v[2]].cz ;
    break ;
  }
  point[0] = cx ;
  point[1] = cy ;
  point[2] = cz ;
  if (project_point_to_plane(point, V0, V1, V2, proj, e1, e2) < 0)
  {
    if (pl1)
    {
      *pl1 = *pl2 = *pl3 = 1/3 ;
    }
    return(-3) ;
  }
  x = DOT(proj, e1) ;
  y = DOT(proj, e2) ;
  x1 = DOT(V0, e1) ;
  x2 = DOT(V1, e1) ;
  x3 = DOT(V2, e1) ;
  y1 = DOT(V0, e2) ;
  y2 = DOT(V1, e2) ;
  y3 = DOT(V2, e2) ;
  detT = (x1-x3) * (y2-y3) - (y1-y3) * (x2-x3) ;
  if (DZERO(detT))
  {
    if (pl1)
    {
      *pl1 = *pl2 = *pl3 = 1/3 ;
    }
    DiagBreak() ;
    return(-2) ;
  }

  l1 = ((y2 - y3)*(x-x3) + (x3-x2)*(y-y3)) / detT ;
  l2 = ((y3 - y1)*(x-x3) + (x1-x3)*(y-y3)) / detT ;
  l3 = (1 - l1 - l2) ;

  if (pl1)
  {
    *pl1 = l1 ;
    *pl2 = l2 ;
    *pl3 = l3 ;
  }

  if (l1 > 0 && l1 < 1 && l2 > 0 && l2 < 1 && l3 > 0 && l3 < 1)
  {
    ret = 1 ;  // interior to the triangle
  }
  else
  {
    float l1d, l2d, l3d ;

    l1d = MIN(l1-0, 1-l1) ;
    l2d = MIN(l2-0, 1-l2) ;
    l3d = MIN(l3-0, 1-l3) ;
    if ((l1d < 0 && !FZERO(l1d)) ||
        (l2d < 0 && !FZERO(l2d)) ||
        (l3d < 0 && !FZERO(l3d)))
    {
      ret = -1 ;  // outside triangle
    }
    else
    {
      ret = 0 ;  // on  boundary of triangle
    }
  }
  return(ret) ;
}


int
MRISsampleFaceCoords(MRI_SURFACE *mris, int fno, double x, double y, double z, int which_coords, int which_barycentric, float *px, float *py, float *pz)
{
  float    xv, yv, zv ;
  double   lambda[3] ;
  int      n, ret ;
  FACE     *face ;
  VERTEX   *v ;

  face = &mris->faces[fno] ;

  xv = yv = zv = 0.0 ; // to get rid of mac warnings
  ret = face_barycentric_coords(mris, fno, which_barycentric, x, y, z, &lambda[0], &lambda[1], &lambda[2]) ;
  if (ret < 0)
  {
    lambda[0] = lambda[1] = lambda[2] = 1.0/3.0 ;
  }

  *px = *py = *pz = 0 ;
  for (n = 0  ; n < VERTICES_PER_FACE ; n++)
  {
    v = &mris->vertices[face->v[n]] ;
    MRISvertexCoord2XYZ_float(v, which_coords, &xv, &yv, &zv) ;
    *px += lambda[n]*xv ;
    *py += lambda[n]*yv ;
    *pz += lambda[n]*zv ;
  }

  return(ret) ;
}
double
MRISsampleFace(MRI_SURFACE *mris, int fno, int which, double x, double y, double z, double val0, double val1, double val2)
{
  float    xv, yv, zv ;
  double   lambda[3], val ;
  int      n, ret ;
  FACE     *face ;
  VERTEX   *v ;

  face = &mris->faces[fno] ;

  xv = yv = zv = 0.0 ; // to get rid of mac warnings
  ret = face_barycentric_coords(mris, fno, which, x, y, z, &lambda[0], &lambda[1], &lambda[2]) ;

  val = 0.0 ;
  for (n = 0  ; n < VERTICES_PER_FACE ; n++)
  {
    v = &mris->vertices[face->v[n]] ;
    MRISvertexCoord2XYZ_float(v, which, &xv, &yv, &zv) ;
    switch (n)
    {
    default:
    case 0:
      val +=  lambda[0]*val0 ;
      break ;
    case 1:
      val +=  lambda[1]*val1 ;
      break ;
    case 2:
      val +=  lambda[2]*val2 ;
      break ;
    }
  }

  return(val) ;
}
int
MRISsampleFaceNormal(MRI_SURFACE *mris, int fno, double x, double y, double z, float *px, float *py, float *pz)
{
  float    d, dtotal, dx, dy, dz, xc, yc, zc ;
  int      n ;
  FACE     *face ;
  VERTEX   *v ;

  face = &mris->faces[fno] ;

  xc = yc = zc = 0.0 ; // to get rid of mac warnings
  for (dtotal = 0.0, n = 0  ; n < VERTICES_PER_FACE ; n++)
  {
    v = &mris->vertices[face->v[n]] ;
    MRISvertexCoord2XYZ_float(v, CANONICAL_VERTICES, &dx, &dy, &dz) ;
    dx -= x ;
    dy -= y ;
    dz -= z ;
    d = sqrt(dx*dx + dy*dy + dz*dz) ;
    if (d < 0)
    {
      continue ;
    }
    dtotal += d ;
  }

  *px = *py = *pz = 0 ;
  for (n = 0  ; n < VERTICES_PER_FACE ; n++)
  {
    v = &mris->vertices[face->v[n]] ;
    MRISvertexCoord2XYZ_float(v, CANONICAL_VERTICES, &dx, &dy, &dz) ;
    dx -= x ;
    dy -= y ;
    dz -= z ;
    d = sqrt(dx*dx + dy*dy + dz*dz) ;
    d = 1-(2*d)/dtotal;

    if (d < 0)
    {
      continue ;
    }
    *px += d*v->nx ;
    *py += d*v->ny ;
    *pz += d*v->nz ;
  }


  return(NO_ERROR) ;
}

int
MRISminimizeThicknessFunctional(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, float max_thick)
{
  int         vno, navgs = 5 ;
  VERTEX      *v ;
  double      ending_sse ;

  //  parms->integration_type = INTEGRATE_MOMENTUM ;
  //  parms->integration_type = INTEGRATE_LM_SEARCH ;
  parms->flags |= IPFLAG_NOSCALE_TOL ;  // don't scale tol down with decreasing # of averages
  parms->niterations = 10000 ;
  parms->projection = PROJECT_ELLIPSOID ;

  MRIScomputeSurfaceNormals(mris, WHITE_VERTICES, navgs) ;  // will be used in normal term

  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
  {
    //    int  n ;
    char fname[STRLEN], base_name[STRLEN];
    FileNameRemoveExtension(mris->fname, base_name) ;
#if 0
    for (n = 0 ; n < 100 ; n+=5)
    {
      MRIScomputeSurfaceNormals(mris, WHITE_VERTICES, n) ;  // will be used in normal term
      sprintf(fname, "%s.wnormals.a%3.3d.%s.mgz", base_name, n, parms->base_name) ;
      printf("writing normals to %s\n", fname) ;
      MRISwriteWhiteNormals(mris, fname) ;
    }
#endif
    sprintf(fname, "%s.wnormals.a%3.3d.%s.mgz", base_name, navgs, parms->base_name) ;
    printf("writing smoothed white matter surface normals to %s\n", fname) ;
    MRISwriteWhiteNormals(mris, fname) ;
  }

  MRISstoreMetricProperties(mris) ;
  //  mris->status = MRIS_SPHERE ;
  mris->mht = parms->mht = (void *)MHTfillTableAtResolution(mris, NULL, CANONICAL_VERTICES, 1.0); // to lookup closest face

  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;

    sprintf(fname, "%s.%s.out",
            mris->hemisphere == RIGHT_HEMISPHERE ? "rh" : "lh",
            parms->base_name);
    if (!parms->fp)
    {
      if (!parms->start_t)
      {
        parms->fp = fopen(fname, "w") ;
      }
      else
      {
        parms->fp = fopen(fname, "a") ;
      }

      if (!parms->fp)
        ErrorExit(ERROR_NOFILE, "MRISunfold: could not open log file %s\n",
                  fname) ;
    }
    mrisLogIntegrationParms(parms->fp, mris,parms) ;
  }

  /*
    the first time through if we don't care about negative vertices, start things
    out with min dist (which will cause negative triangles)
  */
#if 1 // NJS: else code causes mris_expand test failure Aug2012
  MRISrestoreVertexPositions(mris, CANONICAL_VERTICES) ; // start with pial coord of this vtx
#else
#if 1
  if (parms->start_t == 0)  // && parms->remove_neg == 0
  {
    MRISfindClosestPialVerticesCanonicalCoords(mris, mris->nsize) ;
  }
  else
#endif
    MRISrestoreVertexPositions(mris, CANONICAL_VERTICES) ; // start with pial coord of this vtx
  mris->status = MRIS_SPHERE ;
#endif
  MRIScomputeSecondFundamentalForm(mris) ;
  MRISrestoreRipFlags(mris) ;
  mrisClearMomentum(mris) ;
  mrisIntegrationEpoch(mris, parms, 0) ;
  parms->niterations = 150 ;
  if (parms->remove_neg)
  {
    MRISremoveOverlapWithSmoothing(mris,parms) ;
  }
  ending_sse = MRIScomputeSSE(mris, parms) ;
  printf("ending sse = %f\n", ending_sse) ;

  // compute thickness and put it in v->curv field
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    float   xw, yw, zw, xp, yp, zp, thick ;

    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      v->tx = v->whitex ;
      v->ty = v->whitey ;
      v->tz = v->whitez ;
      continue ;
    }
    MRISvertexCoord2XYZ_float(v, WHITE_VERTICES, &xw, &yw, &zw) ;
    MRISsampleFaceCoordsCanonical((MHT *)(parms->mht), mris, v->x,v->y,v->z, PIAL_VERTICES, &xp, &yp, &zp);
    thick = sqrt(SQR(xp-xw) + SQR(yp-yw) + SQR(zp-zw)) ;
    v->curv = thick ;
    v->tx = xp ;
    v->ty = yp ;
    v->tz = zp ;
  }

  {
    MHT *mht = ((MHT *)(parms->mht)) ;
    MHTfree(&mht) ;
    parms->mht = NULL;
  }
  return(NO_ERROR) ;
}

MRI *
MRISlaplacian(MRI_SURFACE *mris, MRI *mri_cmatrix, double inner_width, double outer_width)
{
  int    vno, vno2, i, num, n ;
  VERTEX *v, *vn ;
  MRI    *mri_laplacian ;
  double val0, val1, rms ;

  mri_laplacian = MRIalloc(mris->nvertices, 1, 1, MRI_FLOAT) ;
  if (mri_laplacian == NULL)
  {
    ErrorExit(ERROR_NOMEMORY, "MRISlaplacian: could not allocate laplacian struct");
  }

  for (vno= 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    rms = 0.0 ;
    num = 0 ;
    for (n = 0 ; n < v->vtotal; n++)
    {
      vno2 = v->v[n];
      vn = &mris->vertices[vno2] ;
      for (i = 0 ; i < mri_cmatrix->nframes ; i++)
      {
        val0 = MRIgetVoxVal(mri_cmatrix, vno, 0, 0, i) ;
        val1 = MRIgetVoxVal(mri_cmatrix, vno2, 0, 0, i) ;
        rms += (val0 - val1) * (val0 - val1) ;
      }
    }
    rms = sqrt(rms / (v->vtotal * mri_cmatrix->nframes)) ;
    MRIsetVoxVal(mri_laplacian, vno, 0, 0, 0, rms);
  }

  return(mri_laplacian) ;
}
double
MRISsampleValue(MRI_SURFACE *mris, FACE *f, double xp, double yp, double zp,
                int which, MRI *mri_vals)
{
  double val, x[VERTICES_PER_FACE], y[VERTICES_PER_FACE],
         dx1, dy1, dx2, dy2, e1x, e1y, e1z, e2x, e2y, e2z, x0, y0, a0, a1, a2,
         val0, val1, val2;
  int    n ;
  VERTEX *v ;

  e1x = e2x = e1y = e2y = e1z = e2z = 0.0 ;
  for (n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    v = &mris->vertices[f->v[n]] ;
    e1x += v->e1x ;
    e1y += v->e1y ;
    e1z += v->e1z ;
    e2x += v->e2x ;
    e2y += v->e2y ;
    e2z += v->e2z ;
  }

  for (n = 0 ; n < VERTICES_PER_FACE ; n++)
  {
    v = &mris->vertices[f->v[n]] ;
    x[n] = v->x*e1x + v->y*e1y + v->z*e1z ;
    y[n] = v->x*e2x + v->y*e2y + v->z*e2z ;
  }
  x0 = xp*e1x + yp*e1y + zp*e1z ;
  y0 = xp*e2x + yp*e2y + zp*e2z ;

  dx1 = x[1]-x0 ;
  dy1 = y[1]-y0 ;
  dx2 = x[2]-x0 ;
  dy2 = y[2]-y0;
  a0 = 0.5*fabs(dx1*dy2 - dx1*dx2) ;

  dx1 = x[0]-x0 ;
  dy1 = y[0]-y0 ;
  dx2 = x[2]-x0 ;
  dy2 = y[2]-y0;
  a1 = 0.5*fabs(dx1*dy2 - dx1*dx2) ;

  dx1 = x[0]-x0 ;
  dy1 = y[0]-y0 ;
  dx2 = x[1]-x0 ;
  dy2 = y[1]-y0;
  a2 = 0.5*fabs(dx1*dy2 - dx1*dx2) ;

  val0 = MRIgetVoxVal(mri_vals, f->v[0], 0, 0, 0) ;
  val1 = MRIgetVoxVal(mri_vals, f->v[1], 0, 0, 0) ;
  val2 = MRIgetVoxVal(mri_vals, f->v[2], 0, 0, 0) ;

  a0 /= (a0+a1+a2) ;
  a1 /= (a0+a1+a2) ;
  a2 /= (a0+a1+a2) ;
  val = a0*val0 + a1+val1 + a2*val2 ;
  return(val) ;
}

#ifdef FS_CUDA
static INTEGRATION_PARMS *mrisCloneIP(INTEGRATION_PARMS *parms)
{
  /* this needs some work to check whether this is successful */
  INTEGRATION_PARMS *rval = malloc(sizeof(INTEGRATION_PARMS));

  memcpy(rval,parms,sizeof(INTEGRATION_PARMS));
  return rval;
}

static void mrisDeleteIP(INTEGRATION_PARMS *parms)
{
  if(parms != NULL)
  {
    free(parms);
  }
}
#endif /* FS_CUDA */

int
MRIScomputeSurfaceNormals(MRI_SURFACE *mris, int which, int navgs)
{
  int     vno, n, i ;
  VERTEX  *v, *vn ;
  double  nx=0.0, ny=0.0, nz=0.0, norm=0.0 ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    MRIScomputeNormal(mris, which, vno, &nx, &ny, &nz) ;
    switch (which)
    {
    default:
    case CURRENT_VERTICES:
      v->nx = nx ;
      v->ny = ny ;
      v->nz = nz ;
      break ;
    case WHITE_VERTICES:
      v->wnx = nx ;
      v->wny = ny ;
      v->wnz = nz ;
      break ;
    case PIAL_VERTICES:
      v->pnx = nx ;
      v->pny = ny ;
      v->pnz = nz ;
      break ;
    case ORIGINAL_VERTICES:
      v->onx = nx ;
      v->ony = ny ;
      v->onz = nz ;
      break ;
    }
  }
  for (i = 0 ; i < navgs ; i++)
  {
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      switch (which)
      {
      default:
      case CURRENT_VERTICES:
        nx = v->nx ;
        ny = v->ny ;
        nz = v->nz ;
        break ;
      case WHITE_VERTICES:
        nx = v->wnx ;
        ny = v->wny ;
        nz = v->wnz ;
        break ;
      case PIAL_VERTICES:
        nx = v->pnx ;
        ny = v->pny ;
        nz = v->pnz ;
        break ;
      case ORIGINAL_VERTICES:
        nx = v->onx ;
        ny = v->ony ;
        nz = v->onz ;
        break ;
      }
      v->tdx = nx ;
      v->tdy = ny ;
      v->tdz = nz ;
      for (n = 0 ; n < v->vnum ; n++)
      {
        vn = &mris->vertices[v->v[n]] ;
        if (vn->ripflag)
        {
          continue ;
        }
        switch (which)
        {
        default:
        case CURRENT_VERTICES:
          nx = vn->nx ;
          ny = vn->ny ;
          nz = vn->nz ;
          break ;
        case WHITE_VERTICES:
          nx = vn->wnx ;
          ny = vn->wny ;
          nz = vn->wnz ;
          break ;
        case PIAL_VERTICES:
          nx = vn->pnx ;
          ny = vn->pny ;
          nz = vn->pnz ;
          break ;
        case ORIGINAL_VERTICES:
          nx = vn->onx ;
          ny = vn->ony ;
          nz = vn->onz ;
          break ;
        }
        v->tdx += nx ;
        v->tdy += ny ;
        v->tdz += nz ;
      }
      norm = sqrt(v->tdx * v->tdx + v->tdy * v->tdy + v->tdz*v->tdz) ;
      if (!FZERO(norm))
      {
        v->tdx /= norm ;
        v->tdy /= norm ;
        v->tdz /= norm ;
      }
    }
    for (vno = 0 ; vno < mris->nvertices ; vno++)
    {
      v = &mris->vertices[vno] ;
      if (v->ripflag)
      {
        continue ;
      }
      switch (which)
      {
      default:
      case CURRENT_VERTICES:
        v->nx = v->tdx ;
        v->ny = v->tdy ;
        v->nz = v->tdz ;
        break ;
      case WHITE_VERTICES:
        v->wnx = v->tdx ;
        v->wny = v->tdy ;
        v->wnz = v->tdz ;
        break ;
      case PIAL_VERTICES:
        v->pnx = v->tdx ;
        v->pny = v->tdy ;
        v->pnz = v->tdz ;
        break ;
      case ORIGINAL_VERTICES:
        v->onx = v->tdx ;
        v->ony = v->tdy ;
        v->onz = v->tdz ;
        break ;
      }
    }
  }

  return(NO_ERROR) ;
}

static double
mrisRmsDistanceError(MRI_SURFACE *mris)
{
  INTEGRATION_PARMS parms;
  double rms ;

  memset(&parms, 0, sizeof(parms)) ;
  parms.l_location = 1 ;
  rms = mrisComputeTargetLocationError(mris, &parms);
  return(sqrt(rms / MRISvalidVertices(mris))) ;
}
int
MRISscaleVertexCoordinates(MRI_SURFACE *mris, double scale)
{
  VERTEX  *v ;
  int     vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->x *= scale ;
    v->y *= scale ;
    v->z *= scale ;
  }
  return(NO_ERROR) ;
}
int
MRISstoreTangentPlanes(MRI_SURFACE *mris, int which_vertices)
{
  VERTEX  *v ;
  int     vno ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->pe1x = v->e1x ;
    v->pe1y = v->e1y ;
    v->pe1z = v->e1z ;
    v->pe2x = v->e2x ;
    v->pe2y = v->e2y ;
    v->pe2z = v->e2z ;
  }
  return(NO_ERROR) ;
}
int
MRISrepositionSurface(MRI_SURFACE *mris, MRI *mri, int *target_vnos, float *target_vals, int nv, int nsize, double sigma, int flags)
{
  int               vno, n ;
  INTEGRATION_PARMS parms ;
  VERTEX            *v ;

  printf("flags = %x, size = %ld\n", flags, (long)sizeof(flags)) ;

  memset(&parms, 0, sizeof(parms)) ;
  parms.fill_interior = 0 ;
  parms.projection = NO_PROJECTION ;
  parms.tol = 1e-4 ;
  parms.dt = 0.5f ;
  parms.base_dt = .1 ;
  parms.l_spring = 1.0f ;
  parms.l_curv = 1.0 ;
  parms.l_intensity = 0.2 ;
  parms.l_spring = 0.0f ;
  parms.l_curv = 1.0 ;
  parms.l_intensity = 0.2 ;
  parms.l_tspring = 1.0f ;
  parms.l_nspring = 0.5f ;

  parms.flags |= flags ;
  if (flags & IPFLAG_FORCE_GRADIENT_IN)
  {
    parms.grad_dir = -1 ;
    printf("forcing gradient in\n") ;
  }
  else if (flags & IPFLAG_FORCE_GRADIENT_IN)
  {
    parms.grad_dir= 1 ;
    printf("forcing gradient out\n") ;
  }
  parms.niterations = 0 ;
  parms.write_iterations = 0 /*WRITE_ITERATIONS */;
  parms.integration_type = INTEGRATE_MOMENTUM ;
  parms.momentum = 0.0 /*0.8*/ ;
  parms.dt_increase = 1.0 /* DT_INCREASE */;
  parms.dt_decrease = 0.50 /* DT_DECREASE*/ ;
  parms.error_ratio = 50.0 /*ERROR_RATIO */;
  /*  parms.integration_type = INTEGRATE_LINE_MINIMIZE ;*/
  parms.l_surf_repulse = 0.0 ;
  parms.l_repulse = 5 ;
  parms.niterations = 100 ;
  sprintf(parms.base_name, "nudge") ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].ripflag = 1 ;
  }
  for (n = 0 ; n < nv ; n++)
  {
    mris->vertices[target_vnos[n]].ripflag = 0 ;
  }
  MRISerodeRipped(mris, nsize) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    v->val = target_vals[0] ;
    v->val2 = sigma ;
    v->marked = 1 ;
  }

  MRISpositionSurface(mris, mri, mri, &parms) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].ripflag = 0 ;
  }
  return(NO_ERROR) ;
}
int MRISrepositionSurfaceToCoordinate(MRI_SURFACE *mris, MRI *mri, int target_vno,
                                      float tx,
                                      float ty,
                                      float tz,
                                      int nsize, double sigma, int flags)
{
  int               vno ;
  INTEGRATION_PARMS parms ;
  VERTEX            *v ;
  double            xv, yv, zv, val ;

#define SCALE .01

  printf("MRISrepositionSurfaceToCoordinate(%d, %f, %f, %f, %d, %f, %x)\n",target_vno,tx,ty,tz,nsize,sigma,flags);
  memset(&parms, 0, sizeof(parms)) ;
  parms.fill_interior = 0 ;
  parms.projection = NO_PROJECTION ;
  parms.tol = 1e-4 ;
  parms.n_averages = sigma*sigma*M_PI/2 ;
  parms.dt = 0.5f ;
  parms.base_dt = .1 ;
  parms.l_spring = SCALE*1.0f ;
  parms.l_curv = SCALE*1.0 ;
  parms.l_location = 10 ;
  parms.flags = flags ;
  parms.l_spring = 0.0f ;
  parms.l_intensity = 0*SCALE*0.2 ;
  parms.l_tspring = SCALE*.1f ;
  parms.l_nspring = SCALE*0.5f ;

  parms.niterations = 0 ;
  parms.write_iterations = 0 /*WRITE_ITERATIONS */;
  parms.integration_type = INTEGRATE_MOMENTUM ;
  parms.momentum = 0.0 /*0.8*/ ;
  parms.dt_increase = 1.0 /* DT_INCREASE */;
  parms.dt_decrease = 0.50 /* DT_DECREASE*/ ;
  parms.error_ratio = 50.0 /*ERROR_RATIO */;
  /*  parms.integration_type = INTEGRATE_LINE_MINIMIZE ;*/
  parms.l_surf_repulse = 0.0 ;
//  parms.l_repulse = SCALE*5 ;
  parms.niterations = 100 ;
  sprintf(parms.base_name, "nudge") ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].ripflag = 1 ;
  }
  mris->vertices[target_vno].ripflag = 0 ;
#if 0
  for (n = 0 ; n < nv ; n++)
  {
    mris->vertices[target_vnos[n]].ripflag = 0 ;
  }
#endif
  MRISerodeRipped(mris, nsize) ;
  v = &mris->vertices[target_vno] ;
  v->targx = tx ;
  v->targy = ty ;
  v->targz = tz ;
  v->val2 = sigma ;
  MRISsurfaceRASToVoxelCached(mris, mri, tx, ty, tz, &xv, &yv, &zv) ;
  MRIsampleVolume(mri, xv, yv, zv, &val) ;
  printf("volume @ (%2.1f, %2.1f, %2.1f) = %2.1f\n", xv, yv, zv, val) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    VERTEX *v, *vn ;

    vn = &mris->vertices[vno] ;
    if (vn->ripflag == 0)
    {
      vn->val = val ;
      if (vno != target_vno)  // give it a target which maintains its relative position
      {
        v = &mris->vertices[target_vno] ;
        vn->targx = tx + (vn->x-v->x) ;
        vn->targy = ty + (vn->y-v->y) ;
        vn->targz = tz + (vn->z-v->z) ;
        printf("setting target for vertex %d to (%2.1f %2.1f %2.1f)\n", vno, vn->targx, vn->targy, vn->targz) ;
      }
    }
  }

  /*
  Gdiag |= DIAG_SHOW ;
  Gdiag_no = target_vno ;
  */

  MRISpositionSurface(mris, mri, mri, &parms) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    mris->vertices[vno].ripflag = 0 ;
  }
  return(NO_ERROR) ;
}

static int
mrisProjectOntoSurface(MRI_SURFACE *mris, int which_vertices)
{
  int  vno, fno ;
  double px, py, pz, fdist ;
  FACE   *face ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    MHTfindClosestFaceGeneric((MHT *)(mris->mht), mris, v->x, v->y, v->z, 8.0, 8, 1, &face, &fno, &fdist);
    if (face == NULL || fdist > 0.5)  // current coord doesn't project easily into a nearby face
    {
      double lambda[3], xv, yv, zv, norm ;
      int    n ;

      // no projection in this call - it will find a face
      MHTfindClosestFaceGeneric((MHT *)(mris->mht), mris, v->x, v->y, v->z, 1000, -1, -1, &face,&fno,&fdist);

      // crop barycentric coords to [0 1] so that it is in face (on border) and recompute coords
      face_barycentric_coords(mris, fno, which_vertices, v->x, v->y, v->z,
                              &lambda[0], &lambda[1], &lambda[2]) ;

      for (n = 0  ; n < VERTICES_PER_FACE ; n++)
      {
        if (lambda[n] < 0)
        {
          lambda[n] = 0 ;
        }
      }

      norm = VLEN(lambda) ;
      if (FZERO(norm))
      {
        lambda[0] = 1.0 ;  // arbitrary choice to handle pathological case
      }
      else
      {
        SCALAR_MUL(lambda, 1.0/norm, lambda) ;
      }
      lambda[2] = 1 - (lambda[0] + lambda[1]) ;
      if (lambda[2] < 0)
      {
        DiagBreak() ;
        lambda[2] = 0 ;
        lambda[1] = 1 - lambda[0] ;
        if (lambda[1] < 0)
        {
          lambda[1] = 0 ;
          lambda[0] = 1 ;
        }
      }
      px = py = pz = 0.0 ;
      for (n = 0  ; n < VERTICES_PER_FACE ; n++)
      {
        VERTEX *vn ;
        vn = &mris->vertices[face->v[n]] ;
        MRISvertexCoord2XYZ_double(vn, which_vertices, &xv, &yv, &zv) ;
        px += lambda[n]*xv ;
        py += lambda[n]*yv ;
        pz += lambda[n]*zv ;
      }
      if (vno == Gdiag_no)
      {
        printf("v %d:  lambda = (%2.2f %2.2f %2.2f)\n", vno, lambda[0], lambda[1], lambda[2]) ;
      }
    }
    else
    {
      mris_project_point_into_face(mris, face, which_vertices, v->x, v->y, v->z, &px, &py, &pz) ;
    }

    if (vno == Gdiag_no)
      printf("v %d: (%2.2f %2.2f %2.2f) projected to (%2.2f %2.2f %2.2f), delta = (%2.2f %2.2f %2.2f)\n",
             vno, v->x, v->y, v->z, px, py, pz, v->x-px, v->y-py, v->z-pz) ;
    v->x = px ;
    v->y = py ;
    v->z = pz ;
    if (face_barycentric_coords(mris, fno, which_vertices, v->x, v->y, v->z, NULL,NULL,NULL) <0)
    {
      DiagBreak() ;
    }
  }

  return(NO_ERROR) ;
}

int
MRISlogOdds(MRI_SURFACE *mris, LABEL *area, double slope)
{
  int    vno ;
  VERTEX *v ;
  double p ;

  MRISdistanceTransform(mris, area, DTRANS_MODE_SIGNED) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    p = v->val ;
    if (p < 0)
    {
      p = 0 ;
    }
    p = exp(-p*slope) ;
    v->val = p ;
  }
  return(NO_ERROR) ;
}
int
MRISextractVertexCoords(MRI_SURFACE *mris, float *locations[3], int which)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    switch (which)
    {
    case TARGET_VERTICES:
      locations[0][vno] = v->targx ;
      locations[1][vno] = v->targy ;
      locations[2][vno] = v->targz ;
      break ;
    case WHITE_VERTICES:
      locations[0][vno] = v->whitex ;
      locations[1][vno] = v->whitey ;
      locations[2][vno] = v->whitez ;
      break ;
    case LAYERIV_VERTICES:
      locations[0][vno] = v->l4x ;
      locations[1][vno] = v->l4y ;
      locations[2][vno] = v->l4z ;
      break ;
    case PIAL_VERTICES:
      locations[0][vno] = v->pialx ;
      locations[1][vno] = v->pialy ;
      locations[2][vno] = v->pialz ;
      break ;
    case INFLATED_VERTICES:
      locations[0][vno] = v->infx ;
      locations[1][vno] = v->infy ;
      locations[2][vno] = v->infz ;
      break ;
    case FLATTENED_VERTICES:
      locations[0][vno] = v->fx ;
      locations[1][vno] = v->fy ;
      locations[2][vno] = v->fz ;
      break ;
    case CANONICAL_VERTICES:
      locations[0][vno] = v->cx ;
      locations[1][vno] = v->cy ;
      locations[2][vno] = v->cz ;
      break ;
    case ORIGINAL_VERTICES:
      locations[0][vno] = v->origx ;
      locations[1][vno] = v->origy ;
      locations[2][vno] = v->origz ;
      break ;
    case TMP2_VERTICES:
      locations[0][vno] = v->tx2 ;
      locations[1][vno] = v->ty2 ;
      locations[2][vno] = v->tz2 ;
      break ;
    default:
    case TMP_VERTICES:
      locations[0][vno] = v->tx ;
      locations[1][vno] = v->ty ;
      locations[2][vno] = v->tz ;
      break ;
    }
  }
  return(NO_ERROR) ;
}

int
MRISimportVertexCoords(MRI_SURFACE *mris, float *locations[3], int which)
{
  int     vno, nvertices ;
  VERTEX  *v ;

  nvertices = mris->nvertices ;
  for (vno = 0 ; vno < nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    switch (which)
    {
    case LAYERIV_VERTICES:
      v->l4x = locations[0][vno] ;
      v->l4y = locations[1][vno] ;
      v->l4z = locations[2][vno] ;
      break ;
    case TARGET_VERTICES:
      v->targx = locations[0][vno] ;
      v->targy = locations[1][vno] ;
      v->targz = locations[2][vno] ;
      break ;
    case WHITE_VERTICES:
      v->whitex = locations[0][vno] ;
      v->whitey = locations[1][vno] ;
      v->whitez = locations[2][vno] ;
      break ;
    case PIAL_VERTICES:
      v->pialx = locations[0][vno] ;
      v->pialy = locations[1][vno] ;
      v->pialz = locations[2][vno] ;
      break ;
    case INFLATED_VERTICES:
      v->infx = locations[0][vno] ;
      v->infy = locations[1][vno] ;
      v->infz = locations[2][vno] ;
      break ;
    case FLATTENED_VERTICES:
      v->fx = locations[0][vno] ;
      v->fy = locations[1][vno] ;
      v->fz = locations[2][vno] ;
      break ;
    case CANONICAL_VERTICES:
      v->cx = locations[0][vno] ;
      v->cy = locations[1][vno] ;
      v->cz = locations[2][vno] ;
      break ;
    case ORIGINAL_VERTICES:
      v->origx = locations[0][vno] ;
      v->origy = locations[1][vno] ;
      v->origz = locations[2][vno] ;
      break ;
    case TMP2_VERTICES:
      v->tx2 = locations[0][vno] ;
      v->ty2 = locations[1][vno] ;
      v->tz2 = locations[2][vno] ;
      break ;
    default:
    case TMP_VERTICES:
      v->tx = locations[0][vno] ;
      v->ty = locations[1][vno] ;
      v->tz = locations[2][vno] ;
      break ;
    }
  }
  return(NO_ERROR) ;
}

int
MRIStrinarizeCurvature(MRI_SURFACE *mris, float trinarize_thresh)
{
  int    vno ;
  VERTEX *v ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (v->curv < -trinarize_thresh)
    {
      v->curv = -1 ;
    }
    else if (v->curv > trinarize_thresh)
    {
      v->curv = 1 ;
    }
    else
    {
      v->curv = 0 ;
    }
  }
  return(NO_ERROR) ;
}

int
MRIScountTotalNeighbors(MRI_SURFACE *mris, int nsize)
{
  int      vno, total_nbrs ;
  VERTEX   *v ;

  for (total_nbrs = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    switch (nsize)
    {
    case 0:
      total_nbrs++ ;
      break ;
    case 1:
      total_nbrs += v->vnum ;
      break ;
    case 2:
      total_nbrs += v->v2num ;
      break ;
    case 3:
      total_nbrs += v->v3num ;
      break ;
    default:
      ErrorExit(ERROR_UNSUPPORTED, "MRIScountNeighbors(%d): max nbhd size = 3", nsize) ;
    }
  }
  return(total_nbrs) ;
}

static int
mrisScaleTimeStepByCurvature(MRI_SURFACE *mris)
{
  int    vno ;
  VERTEX *v ;
  float  scale ;

  return(0) ;  // disabled
  MRIScomputeSecondFundamentalForm(mris) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }
    if (v->ripflag)
    {
      continue ;
    }
    if (v->H < 1)
    {
      continue ;
    }
    scale = 1.0 + (v->H-1.0)/10.0;
    if (vno == Gdiag_no)
    {
      printf("scaling vertex %d gradient by %2.2f\n", vno, scale) ;
    }
    v->odx *= scale ;
    v->ody *= scale ;
    v->odz *= scale ;
  }

  return(NO_ERROR) ;
}

int
MRIScountMarked(MRI_SURFACE *mris, int mark_threshold)
{
  int    vno, total_marked ;
  VERTEX *v ;

  for (total_marked = vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (v->marked >= mark_threshold)
    {
      total_marked++ ;
    }
  }

  return(total_marked) ;
}

int
MRISprintVertexStats(MRI_SURFACE *mris, int vno, FILE *fp, int which_vertices)
{
  double mn, d ;
  int    n, num ;
  VERTEX *v, *vn ;
  float  x0, y0, z0, x, y, z, dx, dy, dz ;

  if (vno < 0)
  {
    return(NO_ERROR) ;
  }
  x0 = y0 = z0 = x = y = z = 0 ;
  v = &mris->vertices[vno] ;
  MRISvertexCoord2XYZ_float(v, which_vertices, &x0, &y0, &z0) ;
  printf("vertex %d spacing for %s surface\n", vno,
         which_vertices == ORIGINAL_VERTICES ? "orig" :
         which_vertices == CURRENT_VERTICES ? "current" :
         which_vertices == WHITE_VERTICES ? "white" : "unknown") ;
  for (mn = 0.0, num = n = 0 ; n < v->vnum ; n++)
  {
    vn = &mris->vertices[v->v[n]] ;
    if (vn->ripflag)
    {
      printf("nbr %d = %d is ripped\n", n, v->v[n]) ;
      continue ;
    }
    num++ ;
    MRISvertexCoord2XYZ_float(vn, which_vertices, &x, &y, &z) ;
    dx = x-x0 ;
    dy = y-y0 ;
    dz = z-z0 ;
    d = sqrt(dx*dx + dy*dy + dz*dz) ;
    printf("\tvn %d: %d = %2.3f mm distant\n", n, v->v[n], d) ;
    mn += d ;
  }
  printf("\tmean = %2.3f\n", mn/(double)num) ;

  return(NO_ERROR) ;
}

static int
mrisCreateLikelihoodHistograms(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int      x, y, z, wlabel, plabel ;
  VECTOR   *v_brain, *v_hires ;
  MATRIX   *m_hires_to_brain ;
  MRI      *mri_pial ;
  double   xv, yv, zv, val, dist ;

  if (parms->mri_white == NULL)  // white isn't moving, so only have to do it once
  {
    parms->mri_white = MRIupsampleN(parms->mri_brain, NULL, 3) ;
    MRISsaveVertexPositions(mris, TMP_VERTICES) ;
    MRISrestoreVertexPositions(mris, WHITE_VERTICES) ;
    MRISfillInterior(mris, parms->mri_white->xsize, parms->mri_white) ;
    MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  }
  mri_pial = MRIclone(parms->mri_white, NULL) ;
  MRISfillInterior(mris, mri_pial->xsize, mri_pial) ;
  if (parms->mri_labels == NULL)
  {
    parms->mri_labels = MRIclone(parms->mri_white, NULL) ;
  }
  parms->mri_dist = MRIdistanceTransform(mri_pial, parms->mri_dist, 1, 5/mri_pial->xsize, DTRANS_MODE_SIGNED, NULL) ;


  parms->h_wm = HISTOinit(parms->h_wm, 256, 0, 255) ;
  parms->h_gm = HISTOinit(parms->h_gm, 256, 0, 255) ;
  parms->h_nonbrain = HISTOinit(parms->h_nonbrain, 256, 0, 255) ;
  m_hires_to_brain = MRIgetVoxelToVoxelXform(parms->mri_labels, parms->mri_brain) ;

  v_brain = VectorAlloc(4, MATRIX_REAL) ;
  v_hires = VectorAlloc(4, MATRIX_REAL) ;
  VECTOR_ELT(v_brain, 4) = VECTOR_ELT(v_hires, 4) = 1.0 ;
  for (x = 0 ; x < mri_pial->width; x++)
  {
    V3_X(v_hires) = x ;
    for (y = 0 ; y < mri_pial->height ; y++)
    {
      V3_Y(v_hires) = y ;
      for (z = 0 ; z < mri_pial->height ; z++)
      {
        V3_Z(v_hires) = z ;
        MatrixMultiply(m_hires_to_brain, v_hires, v_brain) ;
        xv = V3_X(v_brain) ;
        yv = V3_Y(v_brain) ;
        zv = V3_Z(v_brain) ;
        if (MRIindexNotInVolume(parms->mri_brain, xv, yv, zv))
        {
          val = 0 ;
        }
        else
        {
          MRIsampleVolume(parms->mri_brain, xv, yv, zv, &val) ;
        }


        wlabel = MRIgetVoxVal(parms->mri_white, x, y, z, 0) ;
        plabel = MRIgetVoxVal(mri_pial, x, y, z, 0) ;
        dist = MRIgetVoxVal(parms->mri_dist, x, y, z, 0) ;
        if (dist > 3)
        {
          continue ;  // don't consider the millions of voxels far from the surface
        }

        if (wlabel)
        {
          MRIsetVoxVal(parms->mri_labels, x, y, z, 0, MRI_WHITE_INTERIOR) ;
          HISTOaddSample(parms->h_wm, val, 0, 255) ;
        }
        else if (plabel)
        {
          MRIsetVoxVal(parms->mri_labels, x, y, z, 0, MRI_PIAL_INTERIOR) ;
          HISTOaddSample(parms->h_gm, val, 0, 255) ;
        }
        else
        {
          MRIsetVoxVal(parms->mri_labels, x, y, z, 0, MRI_NONBRAIN) ;
          HISTOaddSample(parms->h_nonbrain, val, 0, 255) ;
        }
      }
    }
  }
  HISTOmakePDF(parms->h_nonbrain, parms->h_nonbrain) ;
  HISTOmakePDF(parms->h_wm, parms->h_wm) ;
  HISTOmakePDF(parms->h_gm, parms->h_gm) ;
  MatrixFree(&m_hires_to_brain) ;
  MatrixFree(&v_brain) ;
  MatrixFree(&v_hires) ;
  MRIfree(&mri_pial) ;
  return(NO_ERROR) ;
}
MRI_SURFACE *
MRISconcat(MRI_SURFACE *mris1, MRI_SURFACE *mris2, MRI_SURFACE *mris)
{
  int    vno, n ;
  int    fno ;
  VERTEX *v, *vo ;
  FACE   *f, *fo ;

  if (mris == NULL)
    mris = MRISalloc(mris1->nvertices+mris2->nvertices, mris1->nfaces+mris2->nfaces) ;

  for (vno = 0 ; vno < mris1->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    vo = &mris1->vertices[vno] ;
    memmove(v, vo, sizeof(VERTEX)) ;
    v->v = (int *)calloc(vo->vtotal, sizeof(int)) ;
    if (v->v == NULL)
      ErrorExit(ERROR_NOMEMORY, "MRISconcat: could not allocate %dth vertex array", vno) ;
    for (n = 0 ; n < v->vtotal ; n++)
      v->v[n] = vo->v[n] ;
    v->f = (int *)calloc(vo->num, sizeof(int)) ;
    if (v->f == NULL)
      ErrorExit(ERROR_NOMEMORY, "MRISconcat: could not allocate %dth face array", vno) ;
    for (n = 0 ; n < v->vtotal ; n++)
      v->f[n] = vo->f[n] ;
  }

  for (fno = 0 ; fno < mris1->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    fo = &mris1->faces[fno] ;
    memmove(f, fo, sizeof(FACE)) ;
  }
  for (vno = mris1->nvertices ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    vo = &mris2->vertices[vno-mris1->nvertices] ;
    memmove(v, vo, sizeof(VERTEX)) ;
    v->v = (int *)calloc(vo->vtotal, sizeof(int)) ;
    if (v->v == NULL)
      ErrorExit(ERROR_NOMEMORY, "MRISconcat: could not allocate %dth vertex array", vno) ;
    for (n = 0 ; n < v->vtotal ; n++)
      v->v[n] = vo->v[n]+mris1->nvertices ;
    v->f = (int *)calloc(vo->num, sizeof(int)) ;
    if (v->f == NULL)
      ErrorExit(ERROR_NOMEMORY, "MRISconcat: could not allocate %dth face array", vno) ;
    for (n = 0 ; n < v->num ; n++)
      v->f[n] = vo->f[n]+mris1->nfaces ;
  }
  for (fno = mris1->nfaces ; fno < mris->nfaces ; fno++)
  {
    f = &mris->faces[fno] ;
    fo = &mris2->faces[fno-mris1->nfaces] ;
    for (n = 0 ; n < VERTICES_PER_FACE ; n++)
      f->v[n] = fo->v[n]+mris1->nvertices ;
  }

  if (mris1->hemisphere != mris2->hemisphere)
    mris->hemisphere = BOTH_HEMISPHERES ;
  else
    mris->hemisphere = mris1->hemisphere ;
  mris->type = mris1->type ;
  mris->nsize = mris1->nsize ;
  MRISsetNeighborhoodSize(mris, mris->nsize) ;

  memmove(&mris->vg, &mris1->vg, sizeof(mris1->vg)) ;
  MRIScomputeMetricProperties(mris) ;
  MRIScomputeSecondFundamentalForm(mris) ;
  strcpy(mris->fname, mris1->fname) ;
  
  return(mris) ;
}

#define WM_VAL  1
#define GM_VAL  2
#define CSF_VAL 3

MRI *
MRIcomputeLaminarVolumeFractions(MRI_SURFACE *mris, double resolution, MRI *mri_src, MRI *mri_fractions)
{
  int     width, height, depth, nvox ;
  MRI    *mri_layers, *mri_interior_pial, *mri_tmp ;
  MATRIX *m_vox2vox ;
  static MRI *mri_interior_wm = NULL ;
#if 0
  MATRIX *m_tmp, *m_src_vox2ras, *m_layers_vox2ras, *m_trans ;
  double trans[4] ;
#endif

  MRISsaveVertexPositions(mris, TMP2_VERTICES) ;

  nvox = nint(MAX(MAX((mri_src->xsize/resolution), (mri_src->ysize/resolution)), 
		  (mri_src->zsize/resolution))) ;
  if (Gdiag & DIAG_VERBOSE_ON)
    printf("packing each voxel with %d voxels to compute laminar fractions\n", (int)pow(nvox,3)) ;
  width = (int)ceil(mri_src->width * nvox);  
  height = (int)ceil(mri_src->height * nvox) ;
  depth = (int)ceil(mri_src->depth * nvox) ;
#if 0
  mri_layers = MRIalloc(width, height, depth, MRI_UCHAR) ;
  MRIsetResolution(mri_layers, resolution, resolution, resolution) ;
  mri_layers->xstart = mri_src->xstart ; mri_layers->xend = mri_src->xend ;
  mri_layers->ystart = mri_src->ystart ; mri_layers->yend = mri_src->yend ;
  mri_layers->zstart = mri_src->zstart ; mri_layers->zend = mri_src->zend ;
  mri_layers->x_r = mri_src->x_r ; mri_layers->x_a = mri_src->x_a ; mri_layers->x_s = mri_src->x_s ;
  mri_layers->y_r = mri_src->y_r ; mri_layers->y_a = mri_src->y_a ; mri_layers->y_s = mri_src->y_s ;
  mri_layers->z_r = mri_src->z_r ; mri_layers->z_a = mri_src->z_a ; mri_layers->z_s = mri_src->z_s ;
  mri_layers->c_r = mri_src->c_r ; mri_layers->c_a = mri_src->c_a ; mri_layers->c_s = mri_src->c_s ;
  MRIreInitCache(mri_layers) ; 
  // compute vox2ras for highres by vox2vox low->high and vox2ras of low
  m_vox2vox = MRIgetVoxelToVoxelXform(mri_src, mri_layers) ;  // v2v low->high
  trans[0] = (nvox-1.0)/2.0 ; trans[1] = (nvox-1.0)/2.0 ; trans[2] = (nvox-1.0)/2.0 ;
  m_trans = MatrixAllocTranslation(4, trans) ;
  m_tmp = MatrixMultiply(m_trans, m_vox2vox, NULL) ;   // correct vox2vox low->high
  MatrixFree(&m_vox2vox) ; m_vox2vox = MatrixInverse(m_tmp, NULL) ; 
  if (Gdiag & DIAG_VERBOSE_ON)
  {
    printf("correct high->low vox2vox\n") ;
    MatrixPrint(stdout, m_vox2vox) ;
  }
  m_src_vox2ras = MRIgetVoxelToRasXform(mri_src) ;  // lowres vox2ras
  m_layers_vox2ras = MatrixMultiply(m_src_vox2ras, m_vox2vox, NULL) ;

  if (Gdiag & DIAG_VERBOSE_ON)
  {
    printf("hires vox2ras:\n") ;
    MatrixPrint(stdout, m_layers_vox2ras) ;
    printf("lowres vox2ras:\n") ;
    MatrixPrint(stdout, m_src_vox2ras) ;
  }
  MRIsetVoxelToRasXform(mri_layers, m_layers_vox2ras) ;
  MatrixFree(&m_layers_vox2ras) ; MatrixFree(&m_src_vox2ras) ; MatrixFree(&m_vox2vox) ;
  MatrixFree(&m_trans) ; MatrixFree(&m_tmp) ;
#else
  mri_layers = MRIupsampleN(mri_src, NULL, nvox);
#endif

  mri_interior_pial = MRIclone(mri_layers, NULL) ;
  if (mri_interior_wm == NULL)
  {
    MRISrestoreVertexPositions(mris, WHITE_VERTICES) ; MRIScomputeMetricProperties(mris) ;
    MRISfillInterior(mris, resolution, mri_layers) ;
    mri_interior_wm = MRIcopy(mri_layers, NULL) ;
  }
  else
    MRIcopy(mri_interior_wm, mri_layers) ;

  MRISrestoreVertexPositions(mris, PIAL_VERTICES) ; MRIScomputeMetricProperties(mris) ;
  MRISfillInterior(mris, resolution, mri_interior_pial) ;
  
  mri_tmp = MRInot(mri_layers, NULL) ;
  MRIand(mri_interior_pial, mri_tmp, mri_tmp, 1) ;
  MRIreplaceValuesOnly(mri_tmp, mri_tmp, 1, GM_VAL) ; 
  MRIcopyLabel(mri_tmp, mri_layers, GM_VAL) ;
  MRIfree(&mri_tmp) ;
  MRIreplaceValuesOnly(mri_layers, mri_layers, 0, CSF_VAL) ;
  m_vox2vox = MRIgetVoxelToVoxelXform(mri_layers, mri_src) ;
  if (mri_fractions == NULL)
  {
    mri_fractions = 
      MRIallocSequence(mri_src->width, mri_src->height, mri_src->depth, MRI_FLOAT, 3) ;
    MRIcopyHeader(mri_src, mri_fractions) ;
  }
  MRIcomputeVolumeFractions(mri_src, m_vox2vox, mri_layers, mri_fractions) ;
  MatrixFree(&m_vox2vox) ; MRIfree(&mri_layers) ;  MRIfree(&mri_interior_pial) ;
  MRISrestoreVertexPositions(mris, TMP2_VERTICES) ;
  MRIScomputeMetricProperties(mris) ;
  return(mri_fractions) ;
}


static double
mrisComputeHistoNegativeLikelihood(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  double   likelihood, entropy ;
  int      x, y, z, label ;
  VECTOR   *v_brain, *v_hires ;
  MATRIX   *m_brain_to_hires ;
  double   xv, yv, zv, val, pval ;

  if (DZERO(parms->l_histo))
    return(NO_ERROR) ;

  mrisCreateLikelihoodHistograms(mris, parms) ;

  v_brain = VectorAlloc(4, MATRIX_REAL) ;
  v_hires = VectorAlloc(4, MATRIX_REAL) ;
  VECTOR_ELT(v_brain, 4) = VECTOR_ELT(v_hires, 4) = 1.0 ;
  m_brain_to_hires = MRIgetVoxelToVoxelXform(parms->mri_brain, parms->mri_labels) ;
  for (likelihood = 0, x = 0 ; x < parms->mri_brain->width; x++)
  {
    V3_X(v_brain) = x ;
    for (y = 0 ; y < parms->mri_brain->height ; y++)
    {
      V3_Y(v_brain) = y ;
      for (z = 0 ; z < parms->mri_brain->height ; z++)
      {
        V3_Z(v_brain) = z ;
        MatrixMultiply(m_brain_to_hires, v_brain, v_hires) ;
        xv = V3_X(v_hires) ;
        yv = V3_Y(v_hires) ;
        zv = V3_Z(v_hires) ;
        if (MRIindexNotInVolume(parms->mri_labels, xv, yv, zv))
        {
          label = MRI_NONBRAIN ;
        }
        else
        {
          label = MRIgetVoxVal(parms->mri_labels, nint(xv), nint(yv), nint(zv), 0) ;
        }

        val = MRIgetVoxVal(parms->mri_brain, x, y, z, 0) ;
        switch (label)
        {
        default:
        case MRI_NONBRAIN:
          pval = HISTOgetCount(parms->h_nonbrain, val) ;
          break ;
        case MRI_WHITE_INTERIOR:
          pval = HISTOgetCount(parms->h_wm, val) ;
          break ;
        case MRI_PIAL_INTERIOR:
          pval = HISTOgetCount(parms->h_gm, val) ;
          break ;
        }
        likelihood += pval ;
      }
    }
  }

  entropy = HISTOgetEntropy(parms->h_nonbrain) + HISTOgetEntropy(parms->h_gm) ;
  MatrixFree(&v_brain) ;
  MatrixFree(&v_hires) ;
  MatrixFree(&m_brain_to_hires) ;

  return(entropy) ;
}

static int
mrisComputeHistoTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  int      vno ;
  VERTEX   *v ;
  double   xv, yv, zv, val, p, dx, dy, dz, d, d2, x, y, z, best_d, best_p ;
  int      num ;

  if (DZERO(parms->l_histo))
    return(NO_ERROR) ;

  mrisCreateLikelihoodHistograms(mris, parms) ;

  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (v->ripflag)
    {
      continue ;
    }
    if (vno == Gdiag_no)
    {
      DiagBreak() ;
    }

    best_p = 0 ;
    best_d = 0 ;
    for (d = -2 ; d < .2 ; d += .1)
    {
      for (num = 0, p = 0, d2 = -2 ; d2 < .2 ; d2 += .1)
      {
        x = v->x + d2*v->nx ;
        y = v->y + d2*v->ny ;
        z = v->z + d2*v->nz ;
        MRISsurfaceRASToVoxelCached(mris, parms->mri_brain, x, y, z, &xv,&yv,&zv) ;
        MRIsampleVolume(parms->mri_brain, xv, yv, zv, &val) ;
        if (d2 < d)
        {
          p += HISTOgetCount(parms->h_gm, val) ;
        }
        else
        {
          p += HISTOgetCount(parms->h_nonbrain, val) ;
        }
        num++ ;
      }
      p /= num ;
      if (p > best_p)
      {
        best_p = p ;
        best_d = d ;
      }
    }

    dx = v->nx*best_d*parms->l_histo ;
    dy = v->ny*best_d*parms->l_histo ;
    dz = v->nz*best_d*parms->l_histo ;
    if (vno == Gdiag_no)
    {

      printf("histoTerm for v %d: val = %2.1f, optimal distance=%2.3f, p = %f moving by (%2.3f, %2.3f, %2.3f), dot = %2.3f\n",
             vno, val, best_d, best_p, dx, dy, dz, dx*v->nx+ dy*v->ny+ dz*v->nz) ;

      DiagBreak() ;
      if (Gx < 0)
      {
	Gx = x ; Gy = y ; Gz = z ;
      }
    }
    v->dx += dx ;
    v->dy += dy ;
    v->dz += dz ;
  }
  return(NO_ERROR) ;
}
static double
vlst_loglikelihood(MRI_SURFACE *mris, MRI *mri, int vno, double displacement, VOXEL_LIST *vl, HISTOGRAM *hin, HISTOGRAM *hout)
{
  double   ll = 0.0, dot, dx, dy, dz, pval, dist, Ig, Ic, gm_frac, out_frac ;
  int      i ;
  float    val ;
  VERTEX   *v ;
  double     xs, ys, zs ;

  v = &mris->vertices[vno] ;
  xs = v->x + displacement*v->nx ;
  ys = v->y + displacement*v->ny ;
  zs = v->z + displacement*v->nz ;
  for (i = 0 ; i < vl->nvox ; i++)
  {
    dx = vl->xd[i]-xs ; dy = vl->yd[i]-ys ; dz = vl->zd[i]-zs ; 
    dist = sqrt(dx*dx + dy*dy + dz*dz) ;
    dot = dx*v->nx + dy*v->ny + dz*v->nz ;
    val = MRIgetVoxVal(mri, vl->xi[i], vl->yi[i], vl->zi[i], 0) ;
    if (dist < .5) // distance to center<.5 --> distance to edge <1
    {
      if (dot > 0)
      {
	out_frac = dist+.5 ;
	gm_frac = 1-out_frac ;
      }
      else
      {
	gm_frac = dist+.5 ;
	out_frac = 1-gm_frac ;
      }
      for (pval = 0.0, Ig = 0 ; Ig <= 256 ; Ig++)
      {
	Ic = (val - gm_frac*Ig) / out_frac ;
	pval += HISTOgetCount(hout, Ic) * HISTOgetCount(hin, Ig) ;
      }
    }
    else if (dot > 0)  // outside surface
      pval = HISTOgetCount(hout, val) ;
    else         // inside the surface
      pval = HISTOgetCount(hin, val) ;
    if (DZERO(pval))
      pval = 1e-10 ;
    ll += -log(pval) ;
  }
  
  return(ll) ;
}

#if 0
static double
vlst_loglikelihood2D(MRI_SURFACE *mris, MRI *mri, int vno, double displacement, VOXEL_LIST *vl, HISTOGRAM2D *hin, HISTOGRAM2D *hout)
{
  double   ll = 0.0, dot, dx, dy, dz, pval, dist, Ig, Ic, gm_frac, out_frac ;
  int      i ;
  float    val ;
  VERTEX   *v ;
  double     xs, ys, zs ;

  v = &mris->vertices[vno] ;
  xs = v->x + displacement*v->nx ; ys = v->y + displacement*v->ny ; zs = v->z + displacement*v->nz ;
  for (i = 0 ; i < vl->nvox ; i++)
  {
    dx = vl->xd[i]-xs ; dy = vl->yd[i]-ys ; dz = vl->zd[i]-zs ; 
    dist = sqrt(dx*dx + dy*dy + dz*dz) ;
    dot = dx*v->nx + dy*v->ny + dz*v->nz ;
    val = MRIgetVoxVal(mri, vl->xi[i], vl->yi[i], vl->zi[i], 0) ;
    if (dist < .5) // distance to center<.5 --> distance to edge <1
    {
      if (dot > 0)
      {
	out_frac = dist+.5 ;
	gm_frac = 1-out_frac ;
      }
      else
      {
	gm_frac = dist+.5 ;
	out_frac = 1-gm_frac ;
      }
      for (pval = 0.0, Ig = 0 ; Ig <= 256 ; Ig++)
      {
	Ic = (val - gm_frac*Ig) / out_frac ;
	pval += HISTO2DgetCount(hout, Ic, dot) * HISTO2DgetCount(hin, Ig, dot) ;
      }
    }
    else if (dot > 0)  // outside surface
      pval = HISTO2DgetCount(hout, val, dot) ;
    else         // inside the surface
      pval = HISTO2DgetCount(hin, val, dot) ;
    if (DZERO(pval))
      pval = 1e-10 ;
    ll += -log(pval) ;
  }
  
  return(ll) ;
}
#else
static double
vlst_loglikelihood2D(MRI_SURFACE *mris, MRI *mri, int vno, double displacement, VOXEL_LIST *vl, HISTOGRAM2D *h, FILE *fp)
{
  double   ll = 0.0, dot, dx, dy, dz, pval, dist ;
  int      i ;
  float    val ;
  VERTEX   *v ;
  double     xs, ys, zs ;

  if (fp)
    fprintf(fp, "%f ", displacement) ;

  v = &mris->vertices[vno] ;
  xs = v->x + displacement*v->nx ; ys = v->y + displacement*v->ny ; zs = v->z + displacement*v->nz ;
  for (i = 0 ; i < vl->nvox ; i++)
  {
    dx = vl->xd[i]-xs ; dy = vl->yd[i]-ys ; dz = vl->zd[i]-zs ; 
    dist = sqrt(dx*dx + dy*dy + dz*dz) ;
    dot = dx*v->nx + dy*v->ny + dz*v->nz ;
    val = MRIgetVoxVal(mri, vl->xi[i], vl->yi[i], vl->zi[i], 0) ;
    pval = HISTO2DgetCount(h, val, dot) ;
    if (DZERO(pval))
      pval = 1e-10 ;
    if (fp)
      fprintf(fp, "%d %2.2f %2.2f ", (int)val, dot, -log(pval)) ;
    ll += -log(pval) ;
  }
  
  if (fp)
    fprintf(fp, "\n") ;
  return(ll) ;
}
#endif
static VOXEL_LIST **
vlst_alloc(MRI_SURFACE *mris, int max_vox)
{
  int        vno ;
  VOXEL_LIST **vl ;

  vl = (VOXEL_LIST **)calloc(mris->nvertices, sizeof(VOXEL_LIST *)) ;
  if (vl == NULL)
    ErrorExit(ERROR_NOMEMORY, "vlst_alloc(%d): could not allocate vl array", max_vox) ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    vl[vno] = VLSTalloc(max_vox) ;
    if (vl[vno] == NULL)
      ErrorExit(ERROR_NOMEMORY, "vlst_alloc(%d): could not allocate list for vno %d",
		max_vox, vno) ;
    vl[vno]->nvox = 0 ;
  }
  return(vl) ;
}
static int 
vlst_free(MRI_SURFACE *mris, VOXEL_LIST ***pvl)
{
  VOXEL_LIST **vl = *pvl ;
  int        vno ;

  *pvl = NULL ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
    VLSTfree(&vl[vno]) ;
  free(vl) ;
  return(NO_ERROR) ;
}

#if 1
static int
vlst_enough_data(MRI_SURFACE *mris, int vno, VOXEL_LIST *vl, double displacement)
{
  double   dot, dx, dy, dz ;
  int      i, nin, nout ;
  VERTEX   *v ;
  double     xs, ys, zs ;

  v = &mris->vertices[vno] ;
  xs = v->x + displacement*v->nx ; 
  ys = v->y + displacement*v->ny ;
  zs = v->z + displacement*v->nz ;
  for (nin = nout = i = 0 ; i < vl->nvox ; i++)
  {
    dx = vl->xd[i]-xs ; dy = vl->yd[i]-ys ; dz = vl->zd[i]-zs ; 
    dot = dx*v->nx + dy*v->ny + dz*v->nz ;
    if (dot > 0)  // outside surface
      nout++ ;
    else         // inside the surface
      nin++ ;
  }
  return((nout >= 2 && nin >= 2) || (nout >= 10 && nin >= 1) || (nout+nin>4)) ;
}
#endif

#define MAX_VOXELS 1500
#define MAX_DISPLACEMENT 5
#define DISPLACEMENT_DELTA .1


static double
mrisComputeNegativeLogPosterior(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, int *pnvox)
{
  MRI       *mri  = parms->mri_brain ;
  double    sse = 0.0, ll, wm_frac, gm_frac, out_frac, Ig, Ic, pval ;
  float     vmin, vmax, val ;
  HISTOGRAM *hin, *hout ;
  int       x, y, z, nvox, label ;
  MRI        *mri_ll = NULL ;
  static double last_sse = 0.0 ;

  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;
    mri_ll = MRIcloneDifferentType(mri, MRI_FLOAT) ;
    sprintf(fname, "%s.vfrac.%4.4d.mgz", parms->base_name, parms->t) ;
    MRIwrite(parms->mri_volume_fractions, fname) ;
  }

  MRIvalRange(mri, &vmin, &vmax) ;
  if (mri->type == MRI_UCHAR)
  {
    vmin = 0 ; vmax = 255 ;
  }
  if (parms->hgm == NULL)
  {
    printf("creating intensity histograms\n") ;
    parms->hgm = hin = HISTOinit(parms->hgm, 256, (double)vmin, (double)vmax) ;
    parms->hout = hout = HISTOinit(parms->hout, 256, (double)vmin,  (double)vmax) ;
    MRISclearMarks(mris) ;
    
    // build histogram estimates of PDFs of interior and exterior of ribbon
    for (x = 0 ; x < mri->width; x++)
      for (y = 0 ; y < mri->height; y++)
	for (z = 0 ; z < mri->depth; z++)
	{
	  if (Gx == x && Gy == y && Gz == z)
	    DiagBreak() ;
	  if (Gx2 == x && Gy2 == y && Gz2 == z)
	    DiagBreak() ;
	  val = MRIgetVoxVal(mri, x, y, z, 0) ;
	  if (FZERO(val))
	    continue ;
	  
	  wm_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 0) ;
	  gm_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 1) ;
	  out_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 2) ;
	  if (parms->mri_aseg)
	  {
	    label = MRIgetVoxVal(parms->mri_aseg, x, y, z, 0) ;
	    if (FZERO(gm_frac) && IS_CORTEX(label))  // aseg thinks it is but outside ribbon - ambiguous
	      continue ;
	  }
	  HISTOaddFractionalSample(hout, val, 0, 0, out_frac) ;
	  HISTOaddFractionalSample(hin, val, 0, 0, gm_frac) ;
	}
    
    HISTOmakePDF(hin, hin) ;
    HISTOmakePDF(hout, hout) ;
    if (Gdiag & DIAG_WRITE)
    {
      char fname[STRLEN] ;
      sprintf(fname, "hin.%s.%3.3d.plt", parms->base_name, parms->t) ;
      HISTOplot(hin, fname) ; 
      sprintf(fname, "hout.%s.%3.3d.plt", parms->base_name, parms->t) ;
      HISTOplot(hout, fname) ;
    }
  }
  else // use previously computed ones
  {
    hin = parms->hgm ;
    hout = parms->hout ;
  }

  for (sse = 0.0, nvox = x = 0 ; x < mri->width; x++)
    for (y = 0 ; y < mri->height; y++)
      for (z = 0 ; z < mri->depth; z++)
      {
	if (Gx == x && Gy == y && Gz == z)
	  DiagBreak() ;
	if (Gx2 == x && Gy2 == y && Gz2 == z)
	  DiagBreak() ;
	val = MRIgetVoxVal(mri, x, y, z, 0) ;
	if (FZERO(val))
	  continue ;
	wm_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 0) ;
	if (wm_frac > 0)
	  continue ;

	gm_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 1) ;
	out_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 2) ;

	if (FZERO(out_frac))   // all gm
	  pval = HISTOgetCount(hin, val) ;
	else if (FZERO(gm_frac))
	  pval = HISTOgetCount(hout, val) ;
	else  // partial volume voxel
	{
	  for (pval = 0.0, Ig = 0 ; Ig <= 256 ; Ig++)
	  {
	    Ic = (val - gm_frac*Ig) / out_frac ;
	    pval += HISTOgetCount(hout, Ic) * HISTOgetCount(hin, Ig) ;
	  }
	}
	
	if (pval > 1 || pval < 0)
	  DiagBreak() ;
	if (DZERO(pval))
	  pval = 1e-20 ;
	ll = -log10(pval) ;
	sse += ll ;
	nvox++ ;
	if (mri_ll)
	  MRIsetVoxVal(mri_ll, x, y, z, 0, ll) ;
	if (Gx == x && Gy == y && Gz == z)
	  printf("voxel(%d, %d, %d) = %d, vfracs = (%2.1f, %2.1f, %2.1f), ll = %2.1f\n",
		 x, y, z, nint(val), wm_frac, gm_frac, out_frac, ll) ;
      }

  if (!FZERO(last_sse) && sse > last_sse)
    DiagBreak() ;
  if (mri_ll)
  {
    char fname[STRLEN] ;
    sprintf(fname, "%s.ll.%4.4d.mgz", parms->base_name, parms->t) ;
    printf("writing log likelihood volume to %s\n", fname) ;
    MRIwrite(mri_ll, fname) ;
    MRIfree(&mri_ll) ;
  }
//  HISTOfree(&hin) ; HISTOfree(&hout) ; 
  if (pnvox)
    *pnvox = nvox ;
  if (Gdiag_no >= 0)
    printf("E_logPosterior, %3.3d: %.1f (nvox=%d)\n", parms->t, sse, nvox) ;

  last_sse = sse ; // diagnostics
  return(sse) ;
}

static int
vlst_add_to_list(VOXEL_LIST *vl_src, VOXEL_LIST *vl_dst) 
{
  int  i ;

  for (i = 0 ; i < vl_src->nvox ; i++)
    VLSTaddUnique(vl_dst, vl_src->xi[i], vl_src->yi[i], vl_src->zi[i], vl_src->xd[i], vl_src->yd[i], vl_src->zd[i]) ;
    
  return(NO_ERROR) ;
}
static int
mrisComputePosteriorTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  MRI       *mri  = parms->mri_brain ;
  static MRI *mri_white_dist ;
  FILE      *fp ;
  double    dist, xs, ys, zs, dn, best_dn, best_ll, ll ;
  float     vmin, vmax, val, wdist ;
  HISTOGRAM *hin, *hout ;
  int       x, y, z, vno, n ;
  VECTOR    *v1, *v2 ;
  MATRIX    *m_vox2vox ;
  MHT       *mht ;
  VERTEX    *v, *vn ;
  VOXEL_LIST **vl, **vl2 ;

  if (FZERO(parms->l_map))
    return(NO_ERROR) ;

  vl = vlst_alloc(mris, MAX_VOXELS) ;
  vl2 = vlst_alloc(mris, MAX_VOXELS) ;

  hin = parms->hgm ; hout = parms->hout ;  // created in mrisComputeNegativeLogPosterior

  if (mri_white_dist == NULL)
  {
    MRISsaveVertexPositions(mris, TMP_VERTICES) ;
    MRISrestoreVertexPositions(mris, WHITE_VERTICES) ;
    mri_white_dist = MRIScomputeDistanceToSurface(mris, NULL, 0.5) ;
    MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  }
  mht = MHTfillVertexTableRes(mris, NULL, CURRENT_VERTICES, 10);

  m_vox2vox = MRIgetVoxelToVoxelXform(mri, mri_white_dist) ;
  v1 = VectorAlloc(4, MATRIX_REAL) ; v2 = VectorAlloc(4, MATRIX_REAL) ;
  VECTOR_ELT(v1,4) = 1.0; VECTOR_ELT(v2,4) = 1.0;

  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
    MRIwrite(mri_white_dist, "wd.mgz") ;

  MRIvalRange(mri, &vmin, &vmax) ;
  if (mri->type == MRI_UCHAR)
  {
    vmin = 0 ; vmax = 255 ;
  }
  MRISclearMarks(mris) ;

  // build histogram estimates of PDFs of interior and exterior of ribbon
  for (x = 0 ; x < mri->width; x++)
    for (y = 0 ; y < mri->height; y++)
      for (z = 0 ; z < mri->depth; z++)
      {
	val = MRIgetVoxVal(mri, x, y, z, 0) ;
	if (FZERO(val))
	  continue ;
	V3_X(v1) = x ; V3_Y(v1) = y ; V3_Z(v1) = z ;
	MatrixMultiply(m_vox2vox, v1, v2) ;

	if (MRIindexNotInVolume(mri_white_dist, V3_X(v2), V3_Y(v2), V3_Z(v2)))
	  continue ;
	wdist = MRIgetVoxVal(mri_white_dist, V3_X(v2), V3_Y(v2), V3_Z(v2), 0) ;
	if (wdist < 0)
	  continue ;

	// add this voxel to the list of voxels of the vertex it is closest to
	MRIvoxelToSurfaceRAS(mri, x, y, z, &xs, &ys, &zs) ;
	MHTfindClosestVertexGeneric(mht, mris,  xs, ys, zs, 10, 4, &v, &vno, &dist) ;
	if (v == NULL)
	  continue ;
	if (vno == Gdiag_no)
	  DiagBreak() ;
	v->marked++ ;
	VLSTadd(vl[vno], x, y, z, xs, ys, zs) ;
      }

  // find vertices that don't have enough data and pool across nbrs
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
      DiagBreak() ;
    vlst_add_to_list(vl[vno], vl2[vno]) ;
    if (v->ripflag || vlst_enough_data(mris, vno, vl[vno], 0.0))
      continue ;
    for (n = 0; n < v->vnum ; n++)
    {
      if (vl2[vno]->nvox + vl[v->v[n]]->nvox >= vl2[vno]->max_vox)
	break ;
      vlst_add_to_list(vl[v->v[n]], vl2[vno]) ;
    }
    v->marked = vl[vno]->nvox ;
  }

  vlst_free(mris, &vl) ; vl = vl2 ;
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
      DiagBreak() ;
    if (v->ripflag || v->marked == 0)
      continue ;
    if (vlst_enough_data(mris, vno, vl[vno], 0.0) == 0)
    {
      v->marked = 0 ;
      continue ;
    }

    if (vno == Gdiag_no)
    {
      char fname[STRLEN] ;
      sprintf(fname, "vno%d.%d.l.dat", vno, parms->t) ;
      fp = fopen(fname, "w") ;
    }
    else
      fp = NULL ;
    best_ll = -1e10 ; best_dn = 0 ;
    for (dn = -MAX_DISPLACEMENT ; dn <= MAX_DISPLACEMENT ; dn += DISPLACEMENT_DELTA)
    {
      ll = -vlst_loglikelihood(mris, mri, vno, dn, vl[vno], hin, hout) ;
      if (devIsnan(ll))
	DiagBreak() ;
      if (fp)
	fprintf(fp, "%f %f\n", dn, ll) ;
      if (ll > best_ll)
      {
	best_dn = dn ;
	best_ll = ll ;
      }
    }
    if (fp)
      fclose(fp) ;

#if 1
    if (fabs(best_dn) > MAX_MOVEMENT)
      best_dn = MAX_MOVEMENT*best_dn / fabs(best_dn) ;
#endif
    if (vno == Gdiag_no)
    {
      int i ;
      char fname[STRLEN] ;
      double dx, dy, dz, dist, dot, pin, pout ;

      sprintf(fname, "vno%d.%d.vox.l.dat", vno, parms->t) ;
      fp = fopen(fname, "w") ;

      for (i = 0 ; i < vl[vno]->nvox ; i++)
      {
	val = MRIgetVoxVal(mri, vl[vno]->xi[i], vl[vno]->yi[i], vl[vno]->zi[i], 0) ;
	dx = vl[vno]->xd[i]-v->x ; dy = vl[vno]->yd[i]-v->y ; dz = vl[vno]->zd[i]-v->z ;
	dist = dx*dx + dy*dy + dz*dz ;
	pin = HISTOgetCount(hin, val) ; pout = HISTOgetCount(hout, val) ;
	dot = dx*v->nx + dy*v->ny + dz*v->nz ;
	if (dot <0)
	  dist *= -1 ;
	fprintf(fp, "%d %d %d %d %d %f %f %f %f\n",
		vno, i, vl[vno]->xi[i], vl[vno]->yi[i], vl[vno]->zi[i], val, dist, pin, pout) ;
      }
      fclose(fp) ;

      printf("l_map: vno %d, best displacement %2.3f, ll = %2.3f, D = (%2.3f, %2.3f, %2.3f)\n",  
	     vno, best_dn, best_ll, 
	     best_dn * v->nx * parms->l_map,
	     best_dn * v->ny * parms->l_map,
	     best_dn * v->nz * parms->l_map) ;
      DiagBreak() ;
    }
    v->dx += best_dn * v->nx * parms->l_map ;
    v->dy += best_dn * v->ny * parms->l_map ;
    v->dz += best_dn * v->nz * parms->l_map ;
    v->d = best_dn ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    int    num ;
    double dn = 0.0 ;

    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
      DiagBreak() ;
    if (v->marked > 0)  // already estimated
      continue ;
    for (n = num = 0; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->marked == 0)
	continue ;
      num++ ;
      dn += vn->d ;
    }
    if (num > 0)
    {
      dn /= num ;
      v->dx += dn * v->nx * parms->l_map ;
      v->dy += dn * v->ny * parms->l_map ;
      v->dz += dn * v->nz * parms->l_map ;
      v->d = dn ;
      if (vno == Gdiag_no)
	printf("l_map: vno %d, soap bubble displacement %2.3f, D = (%2.3f, %2.3f, %2.3f)\n",  
	       vno, dn, dn * v->nx * parms->l_map, dn * v->ny * parms->l_map,
	       dn * v->nz * parms->l_map) ;
    }
  }

  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN], path[STRLEN] ;

    FileNamePath(mris->fname, path) ;
    sprintf(fname, "%s/%s.%d.dist.mgz", path, mris->hemisphere == LEFT_HEMISPHERE ? "lh" : 
	    mris->hemisphere == BOTH_HEMISPHERES ? "both" : "rh", parms->t) ;
    MRISwriteD(mris, fname) ;
    DiagBreak() ;
  }
  MHTfree(&mht) ;
//  HISTOfree(&hin) ; HISTOfree(&hout) ; 
  VectorFree(&v1) ; VectorFree(&v2) ; MatrixFree(&m_vox2vox) ;
  vlst_free(mris, &vl) ;
  return(NO_ERROR) ;
}

#if 0
static double
mrisComputeNegativeLogPosterior2D(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, int *pnvox)
{
  MRI       *mri  = parms->mri_brain ;
  double    sse = 0.0, ll, wm_frac, gm_frac, out_frac, Ig, Ic, pval, dist ;
  float     vmin, vmax, val ;
  HISTO2D   *hin, *hout ;
  int       x, y, z, nvox, label ;
  MRI        *mri_ll = NULL ;
  static double last_sse = 0.0 ;
  HISTOGRAM2D *hs ;

  if (parms->mri_dtrans == NULL)
    MRIScomputeDistanceToSurface(mris, NULL, parms->resolution) ;

  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;
    mri_ll = MRIcloneDifferentType(mri, MRI_FLOAT) ;
    sprintf(fname, "%s.vfrac.%4.4d.mgz", parms->base_name, parms->t) ;
    MRIwrite(parms->mri_volume_fractions, fname) ;
  }

  MRIvalRange(mri, &vmin, &vmax) ;
  if (mri->type == MRI_UCHAR)
  {
    vmin = 0 ; vmax = 255 ;
  }
  if (parms->h2d_gm == NULL)
  {
    printf("creating 2D intensity histograms\n") ;
    parms->h2d_gm = hin = HISTO2Dinit(parms->h2d_gm, 256, 256, (double)vmin, (double)vmax, -10, 10) ;
    parms->h2d_out = hout = HISTO2Dinit(parms->h2d_out, 256, 256, (double)vmin,  (double)vmax, -10, 10) ;
    MRISclearMarks(mris) ;
    
    // build histogram estimates of PDFs of interior and exterior of ribbon
    for (x = 0 ; x < mri->width; x++)
      for (y = 0 ; y < mri->height; y++)
	for (z = 0 ; z < mri->depth; z++)
	{
	  if (Gx == x && Gy == y && Gz == z)
	    DiagBreak() ;
	  if (Gx2 == x && Gy2 == y && Gz2 == z)
	    DiagBreak() ;
	  val = MRIgetVoxVal(mri, x, y, z, 0) ;
	  if (FZERO(val))
	    continue ;

	  dist = MRIgetVoxVal(parms->mri_dtrans, x, y, z, 0) ;
	  wm_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 0) ;
	  gm_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 1) ;
	  out_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 2) ;
	  if (parms->mri_aseg)
	  {
	    label = MRIgetVoxVal(parms->mri_aseg, x, y, z, 0) ;
	    if (FZERO(gm_frac) && IS_CORTEX(label))  // aseg thinks it is but outside ribbon - ambiguous
	      continue ;
	  }
	  HISTO2DaddFractionalSample(hout, val, dist, 0, 0, 0, 0, out_frac) ;
	  HISTO2DaddFractionalSample(hin, val, dist, 0, 0, 0, 0, gm_frac) ;
	}
    if (Gdiag & DIAG_WRITE)
    {
      char fname[STRLEN] ;
      HISTOGRAM2D *hs ;

      hs = HISTO2DsoapBubbleZeros(hin, NULL, 10) ;
      sprintf(fname, "hin.%s.%3.3d.plt", parms->base_name, parms->t) ;
      printf("writing histogram %s\n", fname) ;
      HISTO2Dwrite(hin, fname) ;
      sprintf(fname, "hin.%s.%3.3d.soap.plt", parms->base_name, parms->t) ;
      printf("writing histogram %s\n", fname) ;
      HISTO2Dwrite(hs, fname) ;
      HISTO2Dfree(&hs) ;

      hs = HISTO2DsoapBubbleZeros(hout, NULL, 10) ;
      HISTO2Dfree(&hs) ;
    }

    HISTO2DmakePDF(hin, hin) ;
    HISTO2DmakePDF(hout, hout) ;
    hs = HISTO2Dsmooth(hin, NULL, 5) ;
    if (Gdiag & DIAG_WRITE)
    {
      char fname[STRLEN] ;
      sprintf(fname, "hin.%s.%3.3d.plt", parms->base_name, parms->t) ;
      HISTO2Dwrite(hin, fname) ; 
      sprintf(fname, "hin.%s.%3.3d.smooth.plt", parms->base_name, parms->t) ;
      HISTO2Dwrite(hs, fname) ; 
    }
    HISTO2Dfree(&hin) ; hin = parms->h2d_gm = hs ;

    hs = HISTO2Dsmooth(hout, NULL, 5) ;
    if (Gdiag & DIAG_WRITE)
    {
      char fname[STRLEN] ;
      sprintf(fname, "hout.%s.%3.3d.plt", parms->base_name, parms->t) ;
      HISTO2Dwrite(hout, fname) ; 
      sprintf(fname, "hout.%s.%3.3d.smooth.plt", parms->base_name, parms->t) ;
      HISTO2Dwrite(hs, fname) ; 
    }
    HISTO2Dfree(&hout) ; hout = parms->h2d_out = hs ;
    

    if (Gx > 0)
    {
      int b1, b2 ;
      float wm_frac, gm_frac, out_frac, val, cin, cout ;

      x = Gx ; y = Gy ; z = Gz ;
      dist = MRIgetVoxVal(parms->mri_dtrans, x, y, z, 0) ;
      wm_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 0) ;
      gm_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 1) ;
      out_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 2) ;
      val = MRIgetVoxVal(mri, x, y, z, 0) ;
      b1 = HISTO2DfindBin1(hin, val) ;
      b2 = HISTO2DfindBin2(hin, dist) ;
      cin = HISTO2DgetCount(hin, val, dist) ;
      cout = HISTO2DgetCount(hout, val, dist) ;
      printf("voxel (%d, %d, %d) - vfracts (%2.1f, %2.1f, %2.1f) = %2.0f, dist=%2.1f, bin=%d,%d, cin=%f, cout=%f\n",
	     Gx, Gy, Gz, wm_frac, gm_frac, out_frac, val, dist, b1, b2, cin, cout) ;
      
      DiagBreak() ;
    }
  }
  else // use previously computed ones
  {
    hin = parms->h2d_gm ;
    hout = parms->h2d_out ;
  }

  for (sse = 0.0, nvox = x = 0 ; x < mri->width; x++)
    for (y = 0 ; y < mri->height; y++)
      for (z = 0 ; z < mri->depth; z++)
      {
	if (Gx == x && Gy == y && Gz == z)
	  DiagBreak() ;
	if (Gx2 == x && Gy2 == y && Gz2 == z)
	  DiagBreak() ;
	val = MRIgetVoxVal(mri, x, y, z, 0) ;
	if (FZERO(val))
	  continue ;
	wm_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 0) ;
	if (wm_frac > 0)
	  continue ;

	gm_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 1) ;
	out_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 2) ;
	dist = MRIgetVoxVal(parms->mri_dtrans, x, y, z, 0) ;

	if (FZERO(out_frac))   // all gm
	  pval = HISTO2DgetCount(hin, val, dist) ;
	else if (FZERO(gm_frac))
	  pval = HISTO2DgetCount(hout, val, dist) ;
	else  // partial volume voxel
	{
	  for (pval = 0.0, Ig = 0 ; Ig <= 256 ; Ig++)
	  {
	    Ic = (val - gm_frac*Ig) / out_frac ;
	    pval += HISTO2DgetCount(hout, Ic, dist) * HISTO2DgetCount(hin, Ig, dist) ;
	  }
	}
	
	if (pval > 1 || pval < 0)
	  DiagBreak() ;
	if (DZERO(pval))
	  pval = 1e-20 ;
	ll = -log10(pval) ;
	sse += ll ;
	nvox++ ;
	if (mri_ll)
	  MRIsetVoxVal(mri_ll, x, y, z, 0, ll) ;
	if (Gx == x && Gy == y && Gz == z)
	  printf("voxel(%d, %d, %d) = %d, vfracs = (%2.1f, %2.1f, %2.1f), ll = %2.1f\n",
		 x, y, z, nint(val), wm_frac, gm_frac, out_frac, ll) ;
      }

  if (!FZERO(last_sse) && sse > last_sse)
    DiagBreak() ;
  if (mri_ll)
  {
    char fname[STRLEN] ;
    sprintf(fname, "%s.ll.%4.4d.mgz", parms->base_name, parms->t) ;
    printf("writing log likelihood volume to %s\n", fname) ;
    MRIwrite(mri_ll, fname) ;
    MRIfree(&mri_ll) ;
  }
//  HISTOfree(&hin) ; HISTOfree(&hout) ; 
  if (pnvox)
    *pnvox = nvox ;
  if (Gdiag_no >= 0)
    printf("E_logPosterior, %3.3d: %.1f (nvox=%d)\n", parms->t, sse, nvox) ;

  last_sse = sse ; // diagnostics
  return(sse) ;
}

static int
mrisComputePosterior2DTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  MRI       *mri  = parms->mri_brain ;
  static MRI *mri_white_dist ;
  FILE      *fp ;
  double    dist, xs, ys, zs, dn, best_dn, best_ll, ll ;
  float     vmin, vmax, val, wdist ;
  HISTO2D   *hin, *hout ;
  int       x, y, z, vno, n ;
  VECTOR    *v1, *v2 ;
  MATRIX    *m_vox2vox ;
  MHT       *mht ;
  VERTEX    *v, *vn ;
  VOXEL_LIST **vl, **vl2 ;

  if (FZERO(parms->l_map2d))
    return(NO_ERROR) ;
  vl = vlst_alloc(mris, MAX_VOXELS) ;
  vl2 = vlst_alloc(mris, MAX_VOXELS) ;

  hin = parms->h2d_gm ; hout = parms->h2d_out ;  // created in mrisComputeNegativeLogPosterior2D

  if (mri_white_dist == NULL)
  {
    MRISsaveVertexPositions(mris, TMP_VERTICES) ;
    MRISrestoreVertexPositions(mris, WHITE_VERTICES) ;
    mri_white_dist = MRIScomputeDistanceToSurface(mris, NULL, 0.5) ;
    MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  }
  mht = MHTfillVertexTableRes(mris, NULL, CURRENT_VERTICES, 10);

  m_vox2vox = MRIgetVoxelToVoxelXform(mri, mri_white_dist) ;
  v1 = VectorAlloc(4, MATRIX_REAL) ; v2 = VectorAlloc(4, MATRIX_REAL) ;
  VECTOR_ELT(v1,4) = 1.0; VECTOR_ELT(v2,4) = 1.0;

  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
    MRIwrite(mri_white_dist, "wd.mgz") ;

  MRIvalRange(mri, &vmin, &vmax) ;
  if (mri->type == MRI_UCHAR)
  {
    vmin = 0 ; vmax = 255 ;
  }
  MRISclearMarks(mris) ;

  // build histogram estimates of PDFs of interior and exterior of ribbon
  for (x = 0 ; x < mri->width; x++)
    for (y = 0 ; y < mri->height; y++)
      for (z = 0 ; z < mri->depth; z++)
      {
	val = MRIgetVoxVal(mri, x, y, z, 0) ;
	if (FZERO(val))
	  continue ;
	V3_X(v1) = x ; V3_Y(v1) = y ; V3_Z(v1) = z ;
	MatrixMultiply(m_vox2vox, v1, v2) ;

	if (MRIindexNotInVolume(mri_white_dist, V3_X(v2), V3_Y(v2), V3_Z(v2)))
	  continue ;
	wdist = MRIgetVoxVal(mri_white_dist, V3_X(v2), V3_Y(v2), V3_Z(v2), 0) ;
	if (wdist < 0)
	  continue ;

	// add this voxel to the list of voxels of the vertex it is closest to
	MRIvoxelToSurfaceRAS(mri, x, y, z, &xs, &ys, &zs) ;
	MHTfindClosestVertexGeneric(mht, mris,  xs, ys, zs, 10, 4, &v, &vno, &dist) ;
	if (v == NULL)
	  continue ;
	if (vno == Gdiag_no)
	  DiagBreak() ;
	v->marked++ ;
	VLSTadd(vl[vno], x, y, z, xs, ys, zs) ;
      }

  // find vertices that don't have enough data and pool across nbrs
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
      DiagBreak() ;
    vlst_add_to_list(vl[vno], vl2[vno]) ;
    if (v->ripflag || vlst_enough_data(mris, vno, vl[vno], 0.0))
      continue ;
    for (n = 0; n < v->vnum ; n++)
    {
      if (vl2[vno]->nvox + vl[v->v[n]]->nvox >= vl2[vno]->max_vox)
	break ;
      vlst_add_to_list(vl[v->v[n]], vl2[vno]) ;
    }
    v->marked = vl[vno]->nvox ;
  }

  vlst_free(mris, &vl) ; vl = vl2 ;
  m_vox2vox = MRIgetVoxelToVoxelXform(mri, parms->mri_dtrans) ; // dist to pial surface
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
      DiagBreak() ;
    if (v->ripflag || v->marked == 0)
      continue ;
    if (vlst_enough_data(mris, vno, vl[vno], 0.0) == 0)
    {
      v->marked = 0 ;
      continue ;
    }

    if (vno == Gdiag_no)
    {
      char fname[STRLEN] ;
      sprintf(fname, "vno%d.%d.l.dat", vno, parms->t) ;
      fp = fopen(fname, "w") ;
    }
    else
      fp = NULL ;
    best_ll = -1e10 ; best_dn = 0 ;
    for (dn = -MAX_DISPLACEMENT ; dn <= MAX_DISPLACEMENT ; dn += DISPLACEMENT_DELTA)
    {
      if (fp)
	fprintf(fp, "%f ", dn) ;
      ll = -vlst_loglikelihood2D(mris, mri, vno, dn, vl[vno], hin, hout, fp) ;
      if (fp)
	fprintf(fp, "\n") ;
      if (devIsnan(ll))
	DiagBreak() ;
      if (fp)
	fprintf(fp, "%f %f\n", dn, ll) ;
      if (ll > best_ll)
      {
	best_dn = dn ;
	best_ll = ll ;
      }
    }
    if (fp)
      fclose(fp) ;

//#undef MAX_MOVEMENT
//#define MAX_MOVEMENT 1
    
#if 1
    if (fabs(best_dn) > MAX_MOVEMENT)
      best_dn = MAX_MOVEMENT*best_dn / fabs(best_dn) ;
#endif
    if (vno == Gdiag_no)
    {
      int i ;
      char fname[STRLEN] ;
      double dx, dy, dz, dist, dot, pin, pout ;

      sprintf(fname, "vno%d.%d.vox.l.dat", vno, parms->t) ;
      fp = fopen(fname, "w") ;

      for (i = 0 ; i < vl[vno]->nvox ; i++)
      {
	val = MRIgetVoxVal(mri, vl[vno]->xi[i], vl[vno]->yi[i], vl[vno]->zi[i], 0) ;
	dx = vl[vno]->xd[i]-v->x ; dy = vl[vno]->yd[i]-v->y ; dz = vl[vno]->zd[i]-v->z ;
	dist = dx*dx + dy*dy + dz*dz ;
	dot = dx*v->nx + dy*v->ny + dz*v->nz ;
	if (dot <0)
	  dist *= -1 ;
	pin = HISTO2DgetCount(hin, val, dot) ; pout = HISTO2DgetCount(hout, val, dot) ;
	fprintf(fp, "%d %d %d %d %d %f %f %f %f\n",
		vno, i, vl[vno]->xi[i], vl[vno]->yi[i], vl[vno]->zi[i], val, dist, pin, pout) ;
      }
      fclose(fp) ;

      printf("l_map: vno %d, best displacement %2.3f, ll = %2.3f, D = (%2.3f, %2.3f, %2.3f)\n",  
	     vno, best_dn, best_ll, 
	     best_dn * v->nx * parms->l_map2d,
	     best_dn * v->ny * parms->l_map2d,
	     best_dn * v->nz * parms->l_map2d) ;
      DiagBreak() ;
    }
    v->dx += best_dn * v->nx * parms->l_map2d ;
    v->dy += best_dn * v->ny * parms->l_map2d ;
    v->dz += best_dn * v->nz * parms->l_map2d ;
    v->d = best_dn ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    int    num ;
    double dn = 0.0 ;

    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
      DiagBreak() ;
    if (v->marked > 0)  // already estimated
      continue ;
    for (n = num = 0; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->marked == 0)
	continue ;
      num++ ;
      dn += vn->d ;
    }
    if (num > 0)
    {
      dn /= num ;
      v->dx += dn * v->nx * parms->l_map2d ;
      v->dy += dn * v->ny * parms->l_map2d ;
      v->dz += dn * v->nz * parms->l_map2d ;
      v->d = dn ;
      if (vno == Gdiag_no)
	printf("l_map: vno %d, soap bubble displacement %2.3f, D = (%2.3f, %2.3f, %2.3f)\n",  
	       vno, dn, dn * v->nx * parms->l_map2d, dn * v->ny * parms->l_map2d,
	       dn * v->nz * parms->l_map2d) ;
    }
  }

  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN], path[STRLEN] ;

    FileNamePath(mris->fname, path) ;
    sprintf(fname, "%s/%s.%d.dist.mgz", path, mris->hemisphere == LEFT_HEMISPHERE ? "lh" : 
	    mris->hemisphere == BOTH_HEMISPHERES ? "both" : "rh", parms->t) ;
    MRISwriteD(mris, fname) ;
    DiagBreak() ;
  }
  MHTfree(&mht) ;
//  HISTOfree(&hin) ; HISTOfree(&hout) ; 
  VectorFree(&v1) ; VectorFree(&v2) ; MatrixFree(&m_vox2vox) ;
  vlst_free(mris, &vl) ;
  return(NO_ERROR) ;
}
#else
static double
mrisComputeNegativeLogPosterior2D(MRI_SURFACE *mris, INTEGRATION_PARMS *parms, int *pnvox)
{
  MRI       *mri  = parms->mri_brain ;
  MHT       *mht ;
  double    sse = 0.0, ll, wm_frac, pval, dist, vdist, xs, ys, zs ;
  float     vmin, vmax, val ;
  int       x, y, z, nvox, label, xd, yd, zd, vno ;
  VERTEX    *v ;
  MRI       *mri_ll = NULL ;
  static double last_sse = 0.0 ;
  HISTOGRAM2D *hs ;
  MATRIX      *m_vox2vox ;
  VECTOR      *v1, *v2 ;

  mht = MHTfillVertexTableRes(mris, NULL, CURRENT_VERTICES, 10);

  if (parms->mri_dtrans == NULL)
  {
    int nvox ;
    MRI *mri_tmp ;

    nvox = nint(MAX(MAX((mri->xsize/parms->resolution), (mri->ysize/parms->resolution)), 
		    (mri->zsize/parms->resolution))) ;
    mri_tmp = MRIcloneDifferentType(mri, MRI_FLOAT) ;
    parms->mri_dtrans =  MRIupsampleN(mri_tmp, NULL, nvox);
    MRIfree(&mri_tmp) ;
    MRIScomputeDistanceToSurface(mris, parms->mri_dtrans, parms->resolution) ;
    if (parms->t > 0)
      DiagBreak() ;
    DiagBreak() ;
  }

  m_vox2vox = MRIgetVoxelToVoxelXform(mri, parms->mri_dtrans) ;
  v1 = VectorAlloc(4, MATRIX_REAL) ; v2 = VectorAlloc(4, MATRIX_REAL) ;
  VECTOR_ELT(v1,4) = 1.0; VECTOR_ELT(v2,4) = 1.0;

  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN] ;
    mri_ll = MRIcloneDifferentType(mri, MRI_FLOAT) ;
    sprintf(fname, "%s.vfrac.%4.4d.mgz", parms->base_name, parms->t) ;
    MRIwrite(parms->mri_volume_fractions, fname) ;
  }

  MRIvalRange(mri, &vmin, &vmax) ;
  if (mri->type == MRI_UCHAR)
  {
    vmin = 0 ; vmax = 255 ;
  }

  if (parms->h2d == NULL)
  {
    printf("creating 2D intensity histograms\n") ;
    parms->h2d = HISTO2Dinit(parms->h2d, 128, 101, (double)vmin, (double)vmax, -10, 10) ;
    MRISclearMarks(mris) ;
    
    // build histogram estimates of PDFs of interior and exterior of ribbon
    for (x = 0 ; x < mri->width; x++)
      for (y = 0 ; y < mri->height; y++)
	for (z = 0 ; z < mri->depth; z++)
	{
	  if (Gx == x && Gy == y && Gz == z)
	    DiagBreak() ;
	  if (Gx2 == x && Gy2 == y && Gz2 == z)
	    DiagBreak() ;
	  val = MRIgetVoxVal(mri, x, y, z, 0) ;
	  wm_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 0) ;
	  if (wm_frac > 0)
	    continue ;

	  V3_X(v1) = x ; V3_Y(v1) = y ; V3_Z(v1) = z ;
	  MatrixMultiply(m_vox2vox, v1, v2) ; xd = nint(V3_X(v2)) ; yd = nint(V3_Y(v2)) ; zd = nint(V3_Z(v2)) ;
	  if (MRIindexNotInVolume(parms->mri_dtrans, xd, yd, zd))
	    continue ;
	  dist = MRIgetVoxVal(parms->mri_dtrans, xd, yd, zd, 0) ;
	  if (FZERO(val) && (dist > 1 || dist < 0))  // don't allow 0s inside ribbon or too far out
	    continue ;
	  if (FZERO(val)) 
	    continue ;
	  if (FZERO(val) && dist < 0)
	    DiagBreak() ;

	  // update distance with continuum measure
	  MRIvoxelToSurfaceRAS(mri, x, y, z, &xs, &ys, &zs) ;
	  MHTfindClosestVertexGeneric(mht, mris,  xs, ys, zs, 10, 4, &v, &vno, &vdist) ;
	  if (v != NULL)  // compute distance from surface in normal direction
	  {
	    double dx, dy, dz ;

	    dx = xs-v->x ; dy = ys-v->y ;  dz = zs-v->z ; 
	    dist = dx*v->nx + dy*v->ny + dz*v->nz ;
	  }

	  if (parms->mri_aseg)
	  {
	    label = MRIgetVoxVal(parms->mri_aseg, x, y, z, 0) ;
	    if (dist>1 && IS_CORTEX(label))  // aseg thinks it is but outside ribbon - ambiguous
	      continue ;
	  }
	  HISTO2DaddSample(parms->h2d, val, dist, 0, 0, 0, 0) ;
	}
    if (Gdiag & DIAG_WRITE)
    {
      char fname[STRLEN] ;

      sprintf(fname, "h.%s.%3.3d.plt", parms->base_name, parms->t) ;
      printf("writing histogram %s\n", fname) ;
      HISTO2Dwrite(parms->h2d, fname) ;
    }

//    hs = HISTO2DsoapBubbleZeros(parms->h2d, NULL, 100) ;
    hs = HISTO2DmakePDF(parms->h2d, NULL) ;
    if (Gdiag & DIAG_WRITE)
    {
      char fname[STRLEN] ;
      sprintf(fname, "h.%s.%3.3d.pdf.plt", parms->base_name, parms->t) ;
      printf("writing histogram %s\n", fname) ;
      HISTO2Dwrite(hs, fname) ; 
    }
//    HISTO2DsmoothBins2(hs, parms->h2d, 5) ;
    if (parms->h2d_out)
      HISTO2Dfree(&parms->h2d_out) ;
    parms->h2d_out = HISTO2DsmoothAnisotropic(hs, NULL, .25, 1) ;
    HISTO2Dsmooth(hs, parms->h2d, 1) ;
    HISTO2DmakePDF(parms->h2d_out, hs) ;
    if (Gdiag & DIAG_WRITE)
    {
      char fname[STRLEN] ;
      sprintf(fname, "h.%s.%3.3d.pdf.smooth.plt", parms->base_name, parms->t) ;
      printf("writing histogram %s\n", fname) ;
      HISTO2Dwrite(hs, fname) ; 
    }
    HISTO2Dfree(&parms->h2d) ; parms->h2d = hs ;

    if (Gx > 0)
    {
      int b1, b2 ;
      float val, c ;

      x = Gx ; y = Gy ; z = Gz ;
      V3_X(v1) = x ; V3_Y(v1) = y ; V3_Z(v1) = z ;
      MatrixMultiply(m_vox2vox, v1, v2) ; xd = nint(V3_X(v2)) ; yd = nint(V3_Y(v2)) ; zd = nint(V3_Z(v2)) ;
      if (MRIindexNotInVolume(parms->mri_dtrans, xd, yd, zd))
	dist = 10 ;
      else
	dist = MRIgetVoxVal(parms->mri_dtrans, xd, yd, zd, 0) ;
      val = MRIgetVoxVal(mri, x, y, z, 0) ;
      b1 = HISTO2DfindBin1(parms->h2d, val) ;
      b2 = HISTO2DfindBin2(parms->h2d, dist) ;
      c = HISTO2DgetCount(parms->h2d, val, dist) ;
      printf("voxel (%d, %d, %d) = %2.0f, dist=%2.2f, bin=%d,%d, count=%f\n",
	     Gx, Gy, Gz, val, dist, b1, b2, c) ;
      
      DiagBreak() ;
    }
  }
  else // use previously computed ones
  {
  }

  for (sse = 0.0, nvox = x = 0 ; x < mri->width; x++)
    for (y = 0 ; y < mri->height; y++)
      for (z = 0 ; z < mri->depth; z++)
      {
	if (Gx == x && Gy == y && Gz == z)
	  DiagBreak() ;
	if (Gx2 == x && Gy2 == y && Gz2 == z)
	  DiagBreak() ;
	val = MRIgetVoxVal(mri, x, y, z, 0) ;
	wm_frac = MRIgetVoxVal(parms->mri_volume_fractions, x, y, z, 0) ;
	if (wm_frac > 0)
	  continue ;

	V3_X(v1) = x ; V3_Y(v1) = y ; V3_Z(v1) = z ;
	MatrixMultiply(m_vox2vox, v1, v2) ; xd = nint(V3_X(v2)) ; yd = nint(V3_Y(v2)) ; zd = nint(V3_Z(v2)) ;
	if (MRIindexNotInVolume(parms->mri_dtrans, xd, yd, zd))
	  dist = 10 ;
	else
	  dist = MRIgetVoxVal(parms->mri_dtrans, xd, yd, zd, 0) ;
	if (FZERO(val) && dist > 1)
	  continue ;
	if (FZERO(val))
	  continue ;
	if (FZERO(val))
	  DiagBreak() ;

	pval = HISTO2DgetCount(parms->h2d, val, dist) ;
	if (pval > 1 || pval < 0)
	  DiagBreak() ;
	if (DZERO(pval))
	  pval = 1e-20 ;
	ll = -log10(pval) ;
	if (!finite(ll))
	  DiagBreak() ;
	sse += ll ;
	nvox++ ;
	if (mri_ll)
	  MRIsetVoxVal(mri_ll, x, y, z, 0, ll) ;
	if (Gx == x && Gy == y && Gz == z)
	{
	  printf("voxel(%d, %d, %d) = %d, dist=%2.2f, ll = %2.1f, bins = %d, %d\n", x, y, z, nint(val), dist, ll, HISTO2DfindBin1(parms->h2d,val), HISTO2DfindBin2(parms->h2d, dist)) ;
	}
      }

  if (!FZERO(last_sse) && sse > last_sse)
    DiagBreak() ;
  if (mri_ll)
  {
    char fname[STRLEN] ;
    sprintf(fname, "%s.ll.%4.4d.mgz", parms->base_name, parms->t) ;
    printf("writing log likelihood volume to %s\n", fname) ;
    MRIwrite(mri_ll, fname) ;
    MRIfree(&mri_ll) ;
  }
//  HISTOfree(&hin) ; HISTOfree(&hout) ; 
  if (pnvox)
    *pnvox = nvox ;
  if (Gdiag_no >= 0)
    printf("E_logPosterior, %3.3d: %.1f (nvox=%d)\n", parms->t, sse, nvox) ;

  MHTfree(&mht) ;
  MatrixFree(&m_vox2vox) ; VectorFree(&v1) ; VectorFree(&v2) ;
  last_sse = sse ; // diagnostics
  return(sse) ;
}

static int
mrisComputePosterior2DTerm(MRI_SURFACE *mris, INTEGRATION_PARMS *parms)
{
  MRI       *mri  = parms->mri_brain ;
  static MRI *mri_white_dist ;
  FILE      *fp, *fp2 ;
  double    dist, xs, ys, zs, dn, best_dn, best_ll, ll ;
  float     vmin, vmax, val, wdist ;
  int       x, y, z, vno, n ;
  VECTOR    *v1, *v2 ;
  MATRIX    *m_vox2vox ;
  MHT       *mht ;
  VERTEX    *v, *vn ;
  VOXEL_LIST **vl, **vl2 ;

  if (FZERO(parms->l_map2d))
    return(NO_ERROR) ;
  vl = vlst_alloc(mris, MAX_VOXELS) ;
  vl2 = vlst_alloc(mris, MAX_VOXELS) ;

  if (mri_white_dist == NULL)
  {
    MRISsaveVertexPositions(mris, TMP_VERTICES) ;
    MRISrestoreVertexPositions(mris, WHITE_VERTICES) ;
    mri_white_dist = MRIScomputeDistanceToSurface(mris, NULL, 0.5) ;
    MRISrestoreVertexPositions(mris, TMP_VERTICES) ;
  }
  mht = MHTfillVertexTableRes(mris, NULL, CURRENT_VERTICES, 10);

  m_vox2vox = MRIgetVoxelToVoxelXform(mri, mri_white_dist) ;
  v1 = VectorAlloc(4, MATRIX_REAL) ; v2 = VectorAlloc(4, MATRIX_REAL) ;
  VECTOR_ELT(v1,4) = 1.0; VECTOR_ELT(v2,4) = 1.0;

  if (Gdiag & DIAG_WRITE && DIAG_VERBOSE_ON)
    MRIwrite(mri_white_dist, "wd.mgz") ;

  MRIvalRange(mri, &vmin, &vmax) ;
  if (mri->type == MRI_UCHAR)
  {
    vmin = 0 ; vmax = 255 ;
  }
  MRISclearMarks(mris) ;

  // find set of voxels that are closest to each vertex
  for (x = 0 ; x < mri->width; x++)
    for (y = 0 ; y < mri->height; y++)
      for (z = 0 ; z < mri->depth; z++)
      {
	val = MRIgetVoxVal(mri, x, y, z, 0) ;
	V3_X(v1) = x ; V3_Y(v1) = y ; V3_Z(v1) = z ;
	MatrixMultiply(m_vox2vox, v1, v2) ;

	if (MRIindexNotInVolume(mri_white_dist, V3_X(v2), V3_Y(v2), V3_Z(v2)))
	  continue ;
	wdist = MRIgetVoxVal(mri_white_dist, V3_X(v2), V3_Y(v2), V3_Z(v2), 0) ;
	if (wdist < 0)
	  continue ;

	// add this voxel to the list of voxels of the vertex it is closest to
	MRIvoxelToSurfaceRAS(mri, x, y, z, &xs, &ys, &zs) ;
	MHTfindClosestVertexGeneric(mht, mris,  xs, ys, zs, 10, 4, &v, &vno, &dist) ;
	if (v == NULL)
	  continue ;
	if (FZERO(val) && dist > 1)
	  continue ;
	if (vno == Gdiag_no)
	  DiagBreak() ;
	v->marked++ ;
	VLSTadd(vl[vno], x, y, z, xs, ys, zs) ;
	if (x == Gx && y == Gy && z == Gz)
	{
	  printf("voxel (%d, %d, %d) --> vertex %d\n", x, y, z, vno) ;
	  if (Gdiag_no < 0)
	  {
	    printf("setting Gdiag_no to %d\n", vno) ;
	    Gdiag_no = vno ;
	  }
	}
      }

  if (Gdiag_no >= 0)
    printf("%d nearest voxels found to vertex %d\n", vl[Gdiag_no]->nvox, Gdiag_no) ;

  // find vertices that don't have enough data and pool across nbrs
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
      DiagBreak() ;
    vlst_add_to_list(vl[vno], vl2[vno]) ;
    if (v->ripflag || vlst_enough_data(mris, vno, vl[vno], 0.0))
      continue ;
    for (n = 0; n < v->vnum ; n++)
    {
      if (vl2[vno]->nvox + vl[v->v[n]]->nvox >= vl2[vno]->max_vox)
	break ;
      vlst_add_to_list(vl[v->v[n]], vl2[vno]) ;
    }
    v->marked = vl2[vno]->nvox ;
    if (vno == Gdiag_no)
      printf("%d total voxels found close to vertex %d after nbr adding\n", 
	     vl2[vno]->nvox, vno) ;
  }

  vlst_free(mris, &vl) ; vl = vl2 ;
  m_vox2vox = MRIgetVoxelToVoxelXform(mri, parms->mri_dtrans) ; // dist to pial surface
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
      DiagBreak() ;
    if (v->ripflag || v->marked == 0)
      continue ;
    if (vlst_enough_data(mris, vno, vl[vno], 0.0) == 0)
    {
      v->marked = 0 ;
      continue ;
    }

    if (vno == Gdiag_no)
    {
      char fname[STRLEN] ;
      sprintf(fname, "vno%d.%d.l.dat", vno, parms->t) ;
      fp = fopen(fname, "w") ;
      sprintf(fname, "vno%d.%d.l.vals.dat", vno, parms->t) ;
      fp2 = fopen(fname, "w") ;
    }
    else
      fp = fp2 = NULL ;
    best_ll = -1e10 ; best_dn = 0 ;
    if (fp2)
    {
      int i ;
      float dot, dx, dy, dz, val ;
      char fname[STRLEN] ;

      for (i = 0 ; i < vl[vno]->nvox ; i++)
      {
	val = MRIgetVoxVal(mri, vl[vno]->xi[i], vl[vno]->yi[i], vl[vno]->zi[i], 0) ;
	dx = vl[vno]->xd[i]-v->x ; dy = vl[vno]->yd[i]-v->y ; dz = vl[vno]->zd[i]-v->z ;
	dot = dx*v->nx + dy*v->ny + dz*v->nz ;
	fprintf(fp2, "%d %d %d %f %f\n", vl[vno]->xi[i], vl[vno]->yi[i], vl[vno]->zi[i], dot, val) ;
      }
      fclose(fp2) ;
      sprintf(fname, "vno%d.%d.l.good.dat", vno, parms->t) ;
      fp2 = fopen(fname, "w") ;
    }
    for (dn = -MAX_DISPLACEMENT ; dn <= MAX_DISPLACEMENT ; dn += DISPLACEMENT_DELTA)
    {
      ll = -vlst_loglikelihood2D(mris, mri, vno, dn, vl[vno], parms->h2d, fp2) ;
      if (devIsnan(ll))
	DiagBreak() ;
      if (fp)
	fprintf(fp, "%f %f\n", dn, ll) ;
      if (ll > best_ll)
      {
	best_dn = dn ;
	best_ll = ll ;
      }
    }
    if (fp)
      fclose(fp) ;
    if (fp2)
      fclose(fp2) ;

    if (vno == Gdiag_no && parms->h2d_out != NULL)  // diags
    {
      char fname[STRLEN] ;
      double best_dn = 0, best_ll = -1e10 ; 
      sprintf(fname, "vno%d.%d.l.bad.dat", vno, parms->t) ;
      fp = fopen(fname, "w") ;
      for (dn = -MAX_DISPLACEMENT ; dn <= MAX_DISPLACEMENT ; dn += DISPLACEMENT_DELTA)
      {
	ll = -vlst_loglikelihood2D(mris, mri, vno, dn, vl[vno], parms->h2d_out, fp) ;
	if (devIsnan(ll))
	  DiagBreak() ;
	if (ll > best_ll)
	{
	  best_dn = dn ;
	  best_ll = ll ;
	}
      }
      fclose(fp) ;
    }

#undef MAX_MOVEMENT
#define MAX_MOVEMENT 1
    
    if (vno == Gdiag_no)
    {
      int i ;
      char fname[STRLEN] ;
      double dx, dy, dz, dist, dot, p ;

      sprintf(fname, "vno%d.%d.vox.l.dat", vno, parms->t) ;
      fp = fopen(fname, "w") ;

      for (i = 0 ; i < vl[vno]->nvox ; i++)
      {
	val = MRIgetVoxVal(mri, vl[vno]->xi[i], vl[vno]->yi[i], vl[vno]->zi[i], 0) ;
	dx = vl[vno]->xd[i]-v->x ; dy = vl[vno]->yd[i]-v->y ; dz = vl[vno]->zd[i]-v->z ;
	dist = dx*dx + dy*dy + dz*dz ;
	dot = dx*v->nx + dy*v->ny + dz*v->nz ;
	if (dot <0)
	  dist *= -1 ;
	p = HISTO2DgetCount(parms->h2d, val, dot) ; 
	fprintf(fp, "%d %d %d %d %d %f %f %f\n",
		vno, i, vl[vno]->xi[i], vl[vno]->yi[i], vl[vno]->zi[i], val, dist, p) ;
      }
      fclose(fp) ;

      printf("l_map: vno %d, best displacement %2.3f, ll = %2.3f, D = (%2.3f, %2.3f, %2.3f)\n",  
	     vno, best_dn, best_ll, 
	     best_dn * v->nx * parms->l_map2d,
	     best_dn * v->ny * parms->l_map2d,
	     best_dn * v->nz * parms->l_map2d) ;
      DiagBreak() ;
    }
#if 1
    if (fabs(best_dn) > MAX_MOVEMENT)
    {
      best_dn = MAX_MOVEMENT*best_dn / fabs(best_dn) ;
      if (vno == Gdiag_no)
	printf("cropping displacement to %2.3f\n", best_dn) ;
    }
#endif
    v->dx += best_dn * v->nx * parms->l_map2d ;
    v->dy += best_dn * v->ny * parms->l_map2d ;
    v->dz += best_dn * v->nz * parms->l_map2d ;
    v->d = best_dn ;
  }
  for (vno = 0 ; vno < mris->nvertices ; vno++)
  {
    int    num ;
    double dn = 0.0 ;

    v = &mris->vertices[vno] ;
    if (vno == Gdiag_no)
      DiagBreak() ;
    if (v->marked > 0)  // already estimated
      continue ;
    for (n = num = 0; n < v->vnum ; n++)
    {
      vn = &mris->vertices[v->v[n]] ;
      if (vn->marked == 0)
	continue ;
      num++ ;
      dn += vn->d ;
    }
    if (num > 0)
    {
      dn /= num ;
      v->dx += dn * v->nx * parms->l_map2d ;
      v->dy += dn * v->ny * parms->l_map2d ;
      v->dz += dn * v->nz * parms->l_map2d ;
      v->d = dn ;
      if (vno == Gdiag_no)
	printf("l_map: vno %d, soap bubble displacement %2.3f, D = (%2.3f, %2.3f, %2.3f)\n",  
	       vno, dn, dn * v->nx * parms->l_map2d, dn * v->ny * parms->l_map2d,
	       dn * v->nz * parms->l_map2d) ;
    }
  }

  if (Gdiag & DIAG_WRITE)
  {
    char fname[STRLEN], path[STRLEN] ;

    FileNamePath(mris->fname, path) ;
    sprintf(fname, "%s/%s.%d.dist.mgz", path, mris->hemisphere == LEFT_HEMISPHERE ? "lh" : 
	    mris->hemisphere == BOTH_HEMISPHERES ? "both" : "rh", parms->t) ;
    MRISwriteD(mris, fname) ;
    DiagBreak() ;
  }
  MHTfree(&mht) ;
//  HISTOfree(&hin) ; HISTOfree(&hout) ; 
  VectorFree(&v1) ; VectorFree(&v2) ; MatrixFree(&m_vox2vox) ;
  vlst_free(mris, &vl) ;
  return(NO_ERROR) ;
}
#endif
