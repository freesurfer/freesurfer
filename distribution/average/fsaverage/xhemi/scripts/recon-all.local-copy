#! /bin/tcsh -f

#
# recon-all
#
# script to run all of the reconstruction routines
#
# Original Author: Doug Greve
# CVS Revision Info:
#    $Author: ltirrell $
#    $Date: 2015/11/06 19:32:20 $
#    $Revision: 1.552 $
#
# Copyright Â© 2011-2015 The General Hospital Corporation (Boston, MA) "MGH"
#
# Terms and conditions for use, reproduction, distribution and contribution
# are found in the 'FreeSurfer Software License Agreement' contained
# in the file 'LICENSE' found in the FreeSurfer distribution, and here:
#
# https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense
#
# Reporting: freesurfer@nmr.mgh.harvard.edu
#
#

#
umask 002;

set VERSION = '$Id: recon-all,v 1.552 2015/11/06 19:32:20 ltirrell Exp $';
set ProgName = `basename $0`;
set FullProgName = `readlink -f $0`;
set inputargs = ($argv);
set subjid = ();
set hemilist = (lh rh);
set mailuser = ();
set WaitForFile = ();
set nWaitsMax  = 1000;
set WaitSleep =  1m;
set NotifyFile = ();
set PrintHelp = 0;
set LF = ();
set LF_DEFAULT_NAME = recon-all.log;
set SF = ();
set SF_DEFAULT_NAME = recon-all-status.log;
set CF = ();
set CF_DEFAULT_NAME = recon-all.cmd;
set AppendLog    = 1;
set AppendStatus = 1;
set DoTime = 0;
if($?SET_FS_CMD_TIMING) set DoTime = 1;
set fs_time = "";
set ErrorFile = /dev/null
set cmd = ();

set tcsh61706 = (`tcsh --version | grep "6\.17\.06"`)
if ("$tcsh61706" != "") then
    echo ""
    echo "WARNING: tcsh v6.17.06 has an exit code bug! Please update tcsh!"
    echo ""
    # workaround to force expected behavior:
    set anyerror
endif

set Force = 0;
set DoCleanCSDF  = 0;
set DoCleanCW256 = 0;
set DoCleanTal   = 0;
set DoCleanLta   = 0;
set DoCleanCP    = 0;
set DoCleanTWM   = 0;
set DoCleanSeed  = 0;
set DoCleanPFH   = 0;
set DoCleanBM    = 0;
set DoCleanBFSE  = 0;
set DoCleanASeg  = 0;
set DoCleanWM    = 0;
set DoCleanXopts = 0;
set DoCleanT2    = 0;
set DoCleanFLAIR = 0;
set DoSuperClean = 0;

set DoShowEdits  = 0;

set InputList = ();

# parameter defaults (most can be overriden with flags)
set XOptsFile = ();
set XOptsClean = 0; # Delete a pre-existing xopts file
set XOptsUse   = 1; # Use a pre-existing xopts file (default '1': always use)
set XOptsOverwrite = 0; # Overwrite a pre-existing xopts file
set ControlPointsFile = ();
set TWMControlPointsFile = ();
set PonsSeedCRS = (); # SeedCRS center of pons for mri_fill #
set CCSeedCRS = ();   # SeedCRS center of corpus callosum for mri_fill #
set RHSeedCRS = ();   # SeedCRS point in the right hemi wm for mri_fill #
set LHSeedCRS = ();   # SeedCRS point in the left  hemi wm for mri_fill #

set UseMincMritotal = 0; # if 1, then use the BIC-MNI mritotal tal reg tools
set DoTalairachUseNu = 0; # if 1, use nu.mgz as input to talairach stage
set UseYa3tTalAtlas = 0; # if 1, use 3T18yoSchwartz young-adult 3T atlas
                         # for tal_avi (recommended as 3T default by Avi S.)
set CustomTalAtlas = ""; # -custom-tal-atlas <name of atlas in average dir>

set DoNuMakeUchar = 1; # if 1, then run mri_nu_correct.mni using talairach.xfm
                       # to run mri_make_uchar to correct histogram problem
set UseMaskNuCorrect = 0; # if 1, nu_correct runs with -mask brainmask.mgz
set DilateMaskNuCorrect = (); # grow nu_correct mask by this amount

set WaterShed = 1;      # 0=no WS, 1= WS normal, 2 = WS only, 3 = WS+1st
set WSLess    = 0;      # Shrinks skull surface
set WSMore    = 0;      # Expands skull surface
set WSPctPreFlood = (); # Pre-flooding height
set WSSeedPoint = ();   # C R S
set WSAtlas     = 0;    # 0=don't use atlas, 1=use atlas (for skull strip)
set WSGcaAtlas  = 1;    # 1=use GCA atlas and registration to do skull strip
set WSUseTalXfm = 0;    # 1=use talairach.xfm instead of talairach_with_skull
                        # to do atlas alignment during mri_watershed
set WSCopy = 0;         # Simply copy input to output ignoring other opts, 
                        # for when brain is already stripped
set DoGcut = 0;         # 1=run mri_gcut after mri_watershed
set ConformMin = 0;     # 1=conformed to min dimension
set ConformKeepDC = 0;  # Keep volume direction cosines when conforming
set HiRes = 0;          # 1=hires option (conformed to min dimension)
set Norm3dIters = ();   # passed as -n to *both* mri_normalize runs
set NormMaxGrad = 1;    # passed as -g to *both* mri_normalize runs
set Norm1_b = ();       # passed as -b to the *first* mri_normalize only
set Norm1_n = ();       # passed as -n to the *first* mri_normalize only
set Norm2_b = ();       # passed as -b to the *second* mri_normalize only
set Norm2_n = ();       # passed as -n to the *second* mri_normalize only
set WMSeg_wlo = ();  # from -seg-ghi and -seg-wlo, passed to mri_segment
set WMSeg_ghi = ();  #                             and mris_make_surfaces
set FixWithGA = 1;   # for topology fixer
set FixDiagOnly = 0; # for topology fixer
set RmNeckRadius = 25;  # used by mri_remove_neck
set UseCAAlign = (-align); # flag added to mri_ca_label
set UseCAAlignAfter = (-align-after); # flag added to mri_ca_register
set UseAseg  = 1 # when set to 0 (using -noaseg),then aseg.presurf.mgz not used
                 # nor is ?h.cortex.label (which originates through the aseg)
set NoAsegInorm2 = 0 # when set to 1 (using -noaseg-inorm2), then aseg.presurf
                     # is not used during the 2nd mri_normalize step
set UseNoNeg = 0 # if 1, add '-remove_negative 1' to mris_sphere,mris_register
set NoThicken = 0 # if 1, add '-thicken 0' to mri_segment
set UnCompress = 0    # if 1, add '-uncompress' to mri_ca_reg
set BigVentricles = 0 # if 1, add '-bigventricles' to mri_ca_reg.
                      # else, add '-nobigventricles'
set DoSecondPassRenorm = 0 # if 1, add -secondpassrenorm to mri_ca_register
set UseOldTopoFix = 1 # if 1, use mris_fix_topology instead of mris_topo_fixer
set UseNewTopoFix = 0 # if 1, use mris_topo_fixer instead of mris_fix_topology
set NoRandomness = 1 # if 1, seed critical binaries with identical seeds, to
                     # ensure consistency in surface creation. otherwise, the
                     # default is to seed with current time and date,
                     # resulting in slightly different surfaces each run.
                     # affects: mris_smooth, mris_sphere, mris_topology_fixer,
                     # mris_topo_fixer, mris_ca_label,
                     # mri_robust_template (1st-base-call-only)
set RngSeed = 1234   # seed for random number generator, used only when
                     # -norandomness flag is used, and can be overriden by
                     # the flag -rng-seed <seed>
set DoMultiStrip = 0 # if 1, then multiple instances of mri_watershed and
                     # mri_em_register are run in order to determine the best
                     # skull-strip
set IsMPRAGE = 0     # if 1, then -mprage added to mri_normalize/segment
set IsWashuMPRAGE = 0 # if 1, then -washu_mprage added to mri_normalize/segment
set DoConformWidth256 = 0 # if 1, then conform to 256^3 during
                          # the mri_convert -conform step
set NoNormMGZ = 0; # set to 1 when -nosubcortseg or -noaseg flag is used,
                   # which causes norm.mgz not to used during inorm2 step
set NoWMSA = 0;      # if 1, then -nowmsa flag is added to mri_ca_label
set TH3Flag = 1;   #  turns on new vertex-wise volume calc for mris_anat_stats and ?h.volume
set DoQdecCache = 0; # if 1, then create smoothed fsaverage surface files
set measurelist = ( thickness area area.pial volume curv sulc \
                    white.K white.H jacobian_white w-g.pct.mgh )
                     # ^ these are the files smoothed by DoQdecCache (-qcache)
set UserMeasureList = 0; # if 1, then 'measurelist' gets -measure args
set measuredir = (); # for specifying an alternate path to measure files
set fwhmlist = ( 0 5 10 15 20 25 ) # see DoQdecCache
set target = fsaverage # see DoQdecCache
set SmoothCortexOnly = 1; # For -qcache. smooths only within ?h.cortex.label

set DoMakefile = 0; # if 1, run make -f recon-all.makefile $(MakefileTarget)
set MakefileTarget = () # argument to recon-all -make
set DoLabelV1 = 0; # if 1, create V1 label from O.Hinds V1 prediction atlas
set DoRobustMotionCor = 1; # if 1, then use mri_robust_template for motion cor
set mc_robust_template_avg_arg = 1; # when using mri_robust_template for motion
                     # correction, construct template from: 0 Mean, 1 Median
set UseCuda = 0; # if 1 (-use-cuda), then use GPU versions of tools:
                 # mri_em_register_cuda, mri_ca_register_cuda,
                 # mris_inflate_cuda, mris_sphere_cuda
set GetCuda = 0; # if 1 (-get-cuda) then print cuda info and exit
set PialNoAparc = 0; # if 1 (-pial-noaparc), then add -noaparc flag to
                     # mris_make_surfaces to bypass usage of parcellation
set UseCPsWithCaNorm = 0 # -canorm-usecps enable control points with ca_norm
set DoT2pial = 0; # if 1, mris_make_surfaces refines pial using T2
set T2max = ();
set DoFLAIRpial = 0; # if 1, mris_make_surfaces refines pial using FLAIR

# set multi-threaded stuff to single-threaded/cpu for cluster politeness.
# various binaries (em_reg, ca_reg, mris_sphere) have OpenMP enabled code.
# -openmp <num_threads> allows specifying more threads.
# to support -make, where recon-all is re-entrant, look for FS_OMP_NUM_THREADS
if ($?FS_OMP_NUM_THREADS) then
  setenv OMP_NUM_THREADS $FS_OMP_NUM_THREADS # var declared in -openmp
else
  setenv OMP_NUM_THREADS 1 # default is one thread, -openmp will override
endif
# hippocampal subfields processing uses ITK threading
setenv ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS 1 # -itkthreads <num_threads>
set DoParallel = 0; # if 1, then run with -openmp 4 and -itkthreads 4, 
                    # and run rh/lh stages in parallel

# Longitudinal processing:
set longitudinal = 0;    # if 1, will run the longitudinal scheme
set longbaseid = ();
set tpNid = ();
set longbasetotpN_regfile = ();   # reg file to align longbase to current subj
set UseConcatLtaTal = 0; # if 1, use mri_concatenate_lta during tal creation
set UseLongbaseCtrlVol = 0;   # if 1, use ctrl volume of longbase in norm step
set UseLongbaseWMedits = 0;   # if 1, xfer wm edits from base (default is cross)
set UseAsegFusion = 1; # if 0, dont create 'fused' asegs from timepoints
set DoCreateBaseSubj = 0; # if 1, create the 'base' subject used in longitud
set BaseSubjInvol = (orig.mgz); # -base-invol allows using some other file
set BaseSubjsList = (); # subject set grabbed from -base-tp args
set BaseSubjsListFname = (base-tps); # file containing BaseSubjsList
set robust_template_avg_arg = 1; # construct template from: 0 Mean, 1 Median
set DoNuIntensityCor3T = 0; # if 1, use Zheng, Chee, Zagorodnov params for 3T
set DoAddTp = 0; # if 1, then 'fake'-add this timepoint to long subj set
set DoAffineBase = 0; # if 1, allow affine when creating base (fix calibration)
set UseCubic = 0; # if 1, use cubic spline when mri_convert does conform step
set UseFixMtl = 0; # if 1, add -fix_mtl flag to make_surfaces

# Hippocampal subfields:
set DoHippoSF_T1 = 0;  # if 1, run hippo subfield seg, exvivo atlas (only T1)
set DoHippoSF_T1T2 = 0;# if 1, run hippo subfield seg, exvivo atlas (T1 and T2)
set DoHippoSF_T2 = 0;  # if 1, run hippo subfield seg, exvivo atlas (only T2)
set T2volHippoSF = ();

# Brainstem substructures
set DoBSsubst = 0;

# For defacing, as found in:
# $FREESURFER_HOME/average/
set brain_template = talairach_mixed_with_skull.gca
set face_template  = face.gca

# For subcortical segmentation
set GCA      = RB_all_2015-08-04.gca; # RB_all_2014-08-21.gca
set GCASkull = RB_all_withskull_2014-08-21.gca
set GCADIR   = "${FREESURFER_HOME}/average"
set GCAOutputName = ();
set GCARegIterations = ();
set GCARegTol  = ();

# For cortical registration, as found in $AvgCurvTifPath/$hemi.$AvgCurvTif
set AvgCurvTifPath = "${FREESURFER_HOME}/average"
set AvgCurvTif = average.curvature.filled.buckner40.tif

# Desikan-Killiany cortical parcellation atlas (-cortparc), as found in:
# $FREESURFER_HOME/average/$hemi.$GCS
# The 2009-03-04 atlas contains the insula label.
# The 2010-03-25 atlas has a different color for temporalpole (the old
# color was gray, which looked like the default tksurfer surface color).
set OLD_OLD_GCS = curvature.buckner40.filled.desikan_killiany.2007-06-20.gcs
set OLD_GCS = curvature.buckner40.filled.desikan_killiany.2009-03-04.gcs
set GCS = curvature.buckner40.filled.desikan_killiany.2010-03-25.gcs
set GCSDIR = "${FREESURFER_HOME}/average"

# Christophe Destrieux cortical parcellation atlas (-cortparc2):
set OLD_OLD_DESTRIEUX_GCS = atlas2002_simple.gcs
set OLD_OLD_DESTRIEUX_NAME = a2002s
set OLD_DESTRIEUX_GCS = atlas2005_simple.gcs
set OLD_DESTRIEUX_NAME = a2005s
set DESTRIEUX_GCS = destrieux.simple.2009-07-29.gcs
set DESTRIEUX_NAME = a2009s

# Mindboggle cortical parcellation atlas (-cortparc3):
set DKTATLAS40_GCS = DKTatlas40.gcs
set DKTATLAS40_NAME = DKTatlas40

# Initialization method for BBR
set BBRInit = coreg; # others are spm, header, rr, best

# Set this to 0 to do everything but run the command.
# This is good for debugging.
set RunIt = 1;

set PatchDir = ();

# print versions and exit
set DoVersionsOnly = 0;

#----- Volume -----------#
set DoConvertInput   = 0;
set DoConvertT2Input = 0;
set DoConvertFlairInput = 0;
set DoCreateBaseInput = 0;
set DoMotionCor      = 0;
set DoDeface         = 0;
set DoNuIntensityCor = 0;
set DoTalairach      = 0;
set DoTalCheck       = 0;
set DoNormalization  = 0;
set DoNormalization2 = 0;
set DoMaskBFS        = 0;
set UseControlPoints = 0;
set UseTWMControlPoints = 0;
set DoSkullStrip     = 0;
set DoSegmentation   = 0;
set DoGCAReg         = 0;
set DoCARegInv       = 0;
set DoCANormalize    = 0;
set DoCAReg          = 0;
set DoRemoveNeck     = 0;
set DoSkullLTA       = 0;
set DoCALabel        = 0;
set DoASegMerge      = 0;
set DoFill           = 0;
#----- Surface -----------#
set DoTessellate     = 0;
set SvInitOrigSurf   = 0;
set DoSmooth1        = 0;
set DoInflate1       = 0;
set DoQSphere        = 0;
set DoFix            = 0;
set DoSmooth2        = 0;
set DoInflate2       = 0;
set DoCurvHK         = 0;
set DoCurvStats      = 0;
set DoSphere         = 0;
set DoSurfReg        = 0;
set SurfRegToSubj    = ();
set DoJacobianWhite  = 0;
set DoJacobianDist0  = 0;
set DoContraSurfReg  = 0;
set DoContraSurfRegWithinSubject = 0;
set DoAvgCurv        = 0;
set DoMorphRGB       = 0;
set DoWhiteSurfs     = 0;
set DoCortParc       = 0;
set DoCortParc2      = 0;
set DoCortParc3      = 0;
set DoPialSurfs      = 0;
set DoPctSurfCon     = 0;
set DoSurfVolume     = 0;
set DoParcStats      = 0;
set DoParcStats2     = 0;
set DoParcStats3     = 0;
set DoLocalGyriIndex = 0;
set DoBaLabels       = 0;
set DoLabelExvivoEC  = 0;
# ----------- Surface and Volume -----------#
set DoCortRibbonVolMask = 0;
set DoRelabelHypos   = 0;
set DoAParc2ASeg     = 0;
set DoAPas2ASeg      = 0;
set DoSegStats       = 0;
set DoWMParc         = 0;
set DoAParcASegStats = 0;

set DoVnoMatchCheck  = 0;

set DoIsRunning  = 1;
set IsRunningFile  = ();
set DoneFile = ();

setenv LANG C # Required by MNI tool

# -------------------------------------------------- #
set argv0 = ($argv); # make a copy
set PWD = pwd;
# better yet, make sure the real pwd is used:
if ( -e /bin/pwd ) set PWD = /bin/pwd
if($#argv == 0) goto usage_exit;
set n = `echo $argv | egrep -e -help | wc -l`
if($n != 0) then
  set PrintHelp = 1;
  goto usage_exit;
endif
set n = `echo $argv | egrep -e -version | wc -l`
if($n != 0) then
  cat $FREESURFER_HOME/build-stamp.txt
  exit 0;
endif

goto parse_args;
parse_args_return:
goto check_params;
check_params_return:

set StartTime = `date`;
set tSecStart = `date '+%s'`;

# This allows the user to require that the build stamp be
# consistent from one recon-all invocation to the next.
# Good for frozen versions.
if($?REQUIRE_FS_MATCH == 0) setenv REQUIRE_FS_MATCH 0
#echo "REQUIRE_FS_MATCH $REQUIRE_FS_MATCH"
set bstampfile0 = $FREESURFER_HOME/build-stamp.txt
mkdir -p $SUBJECTS_DIR/$subjid/scripts
set bstampfile  = $SUBJECTS_DIR/$subjid/scripts/build-stamp.txt
if(-e $bstampfile0) then
  if(! -e $bstampfile) cp $bstampfile0 $bstampfile
  set bstamp0 = `cat $bstampfile0`
  set bstamp  = `cat $bstampfile`
  if("$bstamp0" != "$bstamp") then
    if($REQUIRE_FS_MATCH) then
      echo "ERROR: FreeSurfer build stamps do not match"
      echo "Subject Stamp: $bstamp"
      echo "Current Stamp: $bstamp0"
      exit 1;
    else
      echo "INFO: FreeSurfer build stamps do not match"
    endif
  endif
  echo "Subject Stamp: $bstamp"
  echo "Current Stamp: $bstamp0"
endif
rm -f $SUBJECTS_DIR/$subjid/scripts/patchdir.txt
if($#PatchDir) echo "$PatchDir" > $SUBJECTS_DIR/$subjid/scripts/patchdir.txt
cp $bstampfile0 $SUBJECTS_DIR/$subjid/scripts/lastcall.build-stamp.txt

if ($DoMakefile) then
  setenv RECONALL_MAKE_SUBJECT $subjid
  set make_flags=( $MakefileTarget )
  if ( ! $RunIt) set make_flags=( -n $make_flags )
  echo "Subject '$subjid': make $make_flags"
  make -f $FREESURFER_HOME/bin/recon-all.makefile ${make_flags}
  set makestatus=($status)
  unsetenv RECONALL_MAKE_SUBJECT
  exit ($makestatus)
endif

if ($DoTime) then
  fs_time ls >& /dev/null
  if ( ! $status) set fs_time=(fs_time)
endif

echo "INFO: SUBJECTS_DIR is $SUBJECTS_DIR"

# Get "True" FS HOME
pushd $FREESURFER_HOME > /dev/null
set freesurfer_home_true = `pwd`;
popd > /dev/null
echo "Actual FREESURFER_HOME $freesurfer_home_true"

set DateString = "`date '+%y%m%d%H%M'`"

# -superclean deletes everything except contents of mri/orig
if($DoSuperClean) then
  echo "super-cleaning..."
  set cmd = (rm -Rfv \
    $subjdir/bem \
    $subjdir/label \
    $subjdir/scripts \
    $subjdir/src \
    $subjdir/stats \
    $subjdir/surf \
    $subjdir/tmp \
    $subjdir/touch \
    $subjdir/trash \
    $subjdir/mri/transforms)
  echo "$cmd"
  if($RunIt) $cmd
  set cmd = (rm -v $subjdir/mri/* $subjdir/mri/.xdebug*)
  echo "$cmd"
  if($RunIt) $cmd
endif

cd $subjdir # This variable is set in check_params
mkdir -p mri scripts surf tmp label touch stats touch src trash bem
mkdir -p mri/transforms mri/transforms/bak mri/orig
set touchdir = $subjdir/touch

# Create cmd and env files from scratch
if(! $DoVersionsOnly) then
  set CF = ($subjdir/scripts/$CF_DEFAULT_NAME)
  # rm -f $CF, let it accumulate commands
  echo "\n\n#---------------------------------" >> $CF
  echo "# New invocation of recon-all `date` " >> $CF
  # Create a separate file for the env
  set ENVF = $subjdir/scripts/recon-all.env
  if(-e $ENVF) mv $ENVF $ENVF.bak
  date                                     >> $ENVF
  echo "FREESURFER_HOME $FREESURFER_HOME"  >> $ENVF
  echo "Actual FREESURFER_HOME $freesurfer_home_true"  >> $ENVF
  pwd                                      >> $ENVF
  echo "setenv SUBJECTS_DIR $SUBJECTS_DIR" >> $ENVF
  echo $inputargs                          >> $ENVF
  uname -a                                 >> $ENVF
  echo ""                                  >> $ENVF
  limit                                    >> $ENVF
  echo ""                                  >> $ENVF
  printenv                                 >> $ENVF
endif

if($DoVersionsOnly) then
  if (-e /dev/stdout) then
    set LF = /dev/stdout
    set SF = /dev/stdout
  else
    set LF = /dev/null
    set SF = /dev/null
  endif
endif

# ------------ Create the log file --------------- #
if($#LF == 0) then
  set LF = ($subjdir/scripts/$LF_DEFAULT_NAME)
  if(-e $LF) then
    ls -l $LF
    if(! $AppendLog) then
      mv $LF $LF.old
    else
      # if running using -make, then dont bother with repeated info dumps
      if ($?RECONALL_MAKE_SUBJECT) goto skip_new_invo
      echo "\n\n"  >> $LF
      echo "New invocation of recon-all "  >> $LF
      echo "\n\n"  >> $LF
    endif
  endif
else
  if(-e $LF) then
    if ($?RECONALL_MAKE_SUBJECT) goto skip_new_invo
    echo "\n\n"  >> $LF
    echo "New invocation of recon-all "  >> $LF
    echo "\n\n"  >> $LF
  endif
endif
skip_new_invo:

date >> $LF
$PWD >> $LF
echo $0 >> $LF
echo $inputargs >> $LF
# if running using -make, then dont bother with repeated info dumps
if ($?RECONALL_MAKE_SUBJECT) goto skip_all_info
echo "subjid $subjid" >> $LF
echo "setenv SUBJECTS_DIR $SUBJECTS_DIR" >> $LF
echo "FREESURFER_HOME $FREESURFER_HOME" >> $LF
echo "Actual FREESURFER_HOME $freesurfer_home_true" >> $LF
if (-e $FREESURFER_HOME/build-stamp.txt) then
  echo "build-stamp.txt: `cat $FREESURFER_HOME/build-stamp.txt`" >> $LF
endif
uname -a | tee -a $LF
limit >> $LF
if (-e /usr/bin/free) then
  echo "" >> $LF
  /usr/bin/free >> $LF
  echo "" >> $LF
endif
if ("`uname -s`" == "Darwin") then
  echo "" >> $LF
  /usr/bin/top -l 1 | grep PhysMem >> $LF
  echo "" >> $LF
endif
if($?PBS_JOBID) then
  # If the job has been submitted to launchpad, get jobid
  echo "pbsjob $PBS_JOBID"  >> $LF
endif

## gather all versions here
echo "########################################" >> $LF
echo "program versions used" >> $LF
echo $VERSION                >> $LF
mri_motion_correct.fsl -version >> $LF
if (-e $FREESURFER_HOME/bin/flirt.fsl) flirt.fsl -version >> $LF
talairach_avi --version >> $LF
tkregister2_cmdl --all-info >> $LF
nu_correct -version >> $LF
mri_make_uchar -all-info >> $LF
mri_normalize -all-info >> $LF
mri_watershed -all-info >> $LF
mri_gcut -all-info >> $LF
mri_segment -all-info >> $LF
mri_label2label -all-info >> $LF
mri_em_register -all-info >> $LF
mri_ca_normalize -all-info >> $LF
mri_ca_register -all-info >> $LF
mri_ca_label -all-info >> $LF
mri_pretess -all-info >> $LF
mri_fill -all-info >> $LF
mri_tessellate -all-info >> $LF
mri_concatenate_lta -all-info >> $LF
mri_normalize_tp2 -all-info >> $LF
mris_smooth -all-info >> $LF
mris_inflate -all-info >> $LF
mris_curvature -all-info >> $LF
mris_sphere -all-info >> $LF
mris_fix_topology -all-info >> $LF
mris_topo_fixer -all-info >> $LF
mris_ca_label -all-info >> $LF
mris_euler_number -all-info >> $LF
mris_make_surfaces -all-info >> $LF
mris_register -all-info >> $LF
mris_volmask --all-info >> $LF
mris_anatomical_stats -all-info >> $LF
mrisp_paint -all-info >> $LF
mris_curvature_stats -all-info >> $LF
if(-e .xdebug_mris_curvature_stats) rm -f .xdebug_mris_curvature_stats
mris_calc -all-info >> $LF
if(-e .xdebug_mris_calc) rm -f .xdebug_mris_calc
mri_robust_register -all-info >> $LF
mri_robust_template -all-info >> $LF
mri_and -all-info >> $LF
mri_or -all-info >> $LF
mri_fuse_segmentations -all-info >> $LF
mri_segstats -all-info >> $LF
mri_relabel_hypointensities -all-info >> $LF

echo "#######################################" >> $LF
echo "GCADIR $GCADIR" >> $LF
echo "GCA $GCA" >> $LF
echo "GCASkull $GCASkull" >> $LF
echo "AvgCurvTif $AvgCurvTif" >> $LF
echo "GCSDIR $GCSDIR" >> $LF
echo "GCS $GCS" >> $LF
echo "#######################################" >> $LF
skip_all_info:

if($DoVersionsOnly) exit 0;

# Delete the error file. This is created when error_exit is run.
set ErrorFile = $subjdir/scripts/recon-all.error
rm -f $ErrorFile
# Delete the done file. This is created when recon-all exits normally
if($#DoneFile == 0) then
  set DoneFile = $subjdir/scripts/recon-all.done
  rm -f $DoneFile
endif

# ------------ Create the IsRunning File --------- #
if($DoIsRunning) then
  set IsRunningLH   = $subjdir/scripts/IsRunning.lh
  set IsRunningRH   = $subjdir/scripts/IsRunning.rh
  set IsRunningLHRH = $subjdir/scripts/IsRunning.lh+rh
  set bailfile = ();
  if($#hemilist == 1) then
    set hemi = $hemilist;
    set IsRunningFile = $subjdir/scripts/IsRunning.$hemi
    if(-e $IsRunningLHRH) set bailfile = $IsRunningLHRH
  else
    set IsRunningFile = $subjdir/scripts/IsRunning.lh+rh
    if(-e $IsRunningLH)   set bailfile = $IsRunningLH
    if(-e $IsRunningRH)   set bailfile = $IsRunningRH
  endif
  if(-e $IsRunningFile) set bailfile = $IsRunningFile
  if($#bailfile) then
    echo ""
    echo "ERROR: it appears that recon-all is already running"
    echo "for $subjid based on the presence of $bailfile. It could"
    echo "also be that recon-all was running at one point but"
    echo "died in an unexpected way. If it is the case that there"
    echo "is a process running, you can kill it and start over or"
    echo "just let it run. If the process has died, you should type:"
    echo ""
    echo "rm $bailfile"
    echo ""
    echo "and re-run. Or you can add -no-isrunning to the recon-all"
    echo "command-line. The contents of this file are:"
    echo "----------------------------------------------------------"
    cat  $bailfile
    echo "----------------------------------------------------------"
    exit 1;
  endif
  echo "------------------------------" > $IsRunningFile
  echo "SUBJECT $subjid" >> $IsRunningFile
  echo "HEMI    $hemilist"  >> $IsRunningFile
  echo "DATE `date`"     >> $IsRunningFile
  echo "USER $user"      >> $IsRunningFile
  echo "HOST `hostname`" >> $IsRunningFile
  echo "PROCESSID $$ "   >> $IsRunningFile
  echo "PROCESSOR `uname -m`" >> $IsRunningFile
  echo "OS `uname -s`"       >> $IsRunningFile
  uname -a         >> $IsRunningFile
  echo $VERSION    >> $IsRunningFile
  if($?PBS_JOBID) then
    echo "pbsjob $PBS_JOBID"  >> $IsRunningFile
  endif
endif

# ------- Check FREESURFER_HOME consistency --------------#
set CSDF = $subjdir/scripts/csurfdir
if($DoCleanCSDF) rm -vf $CSDF
if(-e $CSDF) then
  set tmp = `cat $CSDF`;
  if($tmp != $FREESURFER_HOME) then
   echo "INFO: current FREESURFER_HOME does not match that of previous processing." \
     | tee -a $LF
   echo "    Current: $FREESURFER_HOME" | tee -a $LF
   echo "    Previous: $tmp" | tee -a $LF
   sleep 1;
  endif
endif

# --------------- Create the status file ---------------- #
if($#SF == 0) then
  set SF = ($subjdir/scripts/$SF_DEFAULT_NAME)
  if(-e $SF) then
    if(! $AppendStatus) then
       mv $SF $SF.old
    else
      echo "\n\n"  >> $SF
      echo "New invocation of recon-all "  >> $SF
      echo "\n\n"  >> $SF
    endif
  endif
else
  if(-e $SF) then
    echo "\n\n"  >> $SF
    echo "New invocation of recon-all "  >> $SF
    echo "\n\n"  >> $SF
  endif
endif
echo "status file for recon-all" >> $SF
date >> $SF

# Put a copy of myself (this script) in the scripts dir
cp -v $FullProgName $subjdir/scripts/recon-all.local-copy

# Wait for a file to appear #
if($#WaitForFile != 0) then
  echo "Waiting for $WaitForFile" |& tee -a $SF |& tee -a $LF
  echo "  WaitSleep $WaitSleep" |& tee -a $SF |& tee -a $LF
  echo "  nWaitsMax $nWaitsMax" |& tee -a $SF |& tee -a $LF
  @ nWaits = 1;
  while(! -e $WaitForFile && $nWaits < $nWaitsMax)
    sleep $WaitSleep;
    @ nWaits = $nWaits + 1;
  end
  if(! -e $WaitForFile ) then
    echo "ERROR: timed out waiting for $WaitForFile"
    goto error_exit;
  endif
  echo "Finished Waiting `date`" |& tee -a $SF |& tee -a $LF
endif

if( ! $RunIt) then
  echo "INFO: -dontrun flag is in effect, so subsequent commands" |& tee -a $LF
  echo "may not have accurate arguments!" |& tee -a $LF
endif


#------------         --------------#
##-----------  -clean --------------#
#------------         --------------#
if($DoCleanSeed) then
  set cmd = ("mv -f $subjdir/scripts/seed-*.crs.man.dat $subjdir/trash");
  echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanCW256) then
  set cmd = (mv -f $subjdir/tmp/cw256 $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanTal) then
  set cmd = (mv -f $subjdir/mri/transforms/talairach.xfm $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
  set cmd = (mv -f $subjdir/mri/orig_nu.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanLta) then
  set cmd = ("mv -f $subjdir/mri/transforms/*.lta $subjdir/trash")
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanPFH) then
  set cmd = (mv -f $subjdir/mri/optimal_preflood_height $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
  set cmd = (mv -f $subjdir/mri/optimal_skullstrip_invol $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanBM) then
  set cmd = (mv -f $subjdir/mri/brainmask.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanASeg) then
  set cmd = (mv -f $subjdir/mri/aseg.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
  set cmd = (mv -f $subjdir/mri/aseg.presurf.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
  set cmd = (mv -f $subjdir/mri/aseg.manedit.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanWM) then
  set cmd = (mv -f $subjdir/mri/wm.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
  set cmd = (mv -f $subjdir/mri/wm.seg.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanCP) then
  set cmd = (mv -f $subjdir/tmp/control.dat $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanTWM) then
  set cmd = (mv -f $subjdir/tmp/twm.dat $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanBFSE) then
  set cmd = (mv -f $subjdir/mri/brain.finalsurfs.manedit.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanXopts) then
  set cmd = (mv -f $subjdir/scripts/expert-options $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanT2) then
  set mdir = $subjdir/mri
  set flist = ($mdir/T2.mgz $mdir/transforms/T2raw.lta $mdir/transforms/T2raw.auto.lta)
  foreach f ($flist)
    if(-e $f) then
      set cmd = (mv -f $f $subjdir/trash)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd  |& tee -a $LF
    endif
  end
endif
if($DoCleanFLAIR) then
  set mdir = $subjdir/mri
  set flist = ($mdir/FLAIR.mgz $mdir/transforms/FLAIRraw.lta $mdir/transforms/FLAIRraw.auto.lta)
  foreach f ($flist)
    if(-e $f) then
      set cmd = (mv -f $f $subjdir/trash)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd  |& tee -a $LF
    endif
  end
endif


#------------ Handle Seed Points for Fill/Cut, and Watershed ---------------#
set seedfile = $subjdir/scripts/seed-pons.crs.man.dat
if($#PonsSeedCRS) then
  echo "# Manually specified seed CRS for Pons" > $seedfile
  echo $PonsSeedCRS >>  $seedfile
endif
if(-e $seedfile) set PonsSeedCRS = `cat $seedfile | grep -v \#`
set seedfile = $subjdir/scripts/seed-cc.crs.man.dat
if($#CCSeedCRS) then
  echo "# Manually specified seed CRS for CC" > $seedfile
  echo $CCSeedCRS >>  $seedfile
endif
if(-e $seedfile) set CCSeedCRS = `cat $seedfile | grep -v \#`
set seedfile = $subjdir/scripts/seed-lh.crs.man.dat
if($#LHSeedCRS) then
  echo "# Manually specified seed CRS for LH" > $seedfile
  echo $LHSeedCRS >>  $seedfile
endif
if(-e $seedfile) set LHSeedCRS = `cat $seedfile | grep -v \#`
set seedfile = $subjdir/scripts/seed-rh.crs.man.dat
if($#RHSeedCRS) then
  echo "# Manually specified seed CRS for RH" > $seedfile
  echo $RHSeedCRS >>  $seedfile
endif
if(-e $seedfile) set RHSeedCRS = `cat $seedfile | grep -v \#`

set seedfile = $subjdir/scripts/seed-ws.crs.man.dat
if($#WSSeedPoint) then
  echo "# Manually specified seed CRS for watershed" > $seedfile
  echo $WSSeedPoint >>  $seedfile
endif
if(-e $seedfile) set WSSeedPoint = `cat $seedfile | grep -v \#`

#------------ Control Points for Intensity Normalization -----------#
set ControlPointsFile = $subjdir/tmp/control.dat
if(-e $ControlPointsFile) then
  set UseControlPoints = 1;
endif

#------------ Control Points for Registration -----------#
set DefaultTWMControlPointsFile = $subjdir/tmp/twm.dat
if( $UseTWMControlPoints ) then
  #copy twmfile to $subjdir/tmp/twm.dat:
  set cmd = (mkdir -p ${subjdir}/tmp)
  echo "\n $cmd"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  set cmd = (cp -vf ${TWMControlPointsFile} $DefaultTWMControlPointsFile)
  echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd |& tee -a $LF
  if($status) goto error_exit;
  set TWMControlPointsFile = $DefaultTWMControlPointsFile
else
  if (-e $DefaultTWMControlPointsFile) then
    set UseControlPoints = 1;
    set TWMControlPointsFile = $DefaultTWMControlPointsFile
  endif
endif

#----                      ----#
#---- Conform Width to 256 ----#
##---         -cw256       ----#
if( $DoConformWidth256) then
  echo "-cw256 option is now persistent (remove with -clean-cw256)" \
    |& tee -a $LF
  touch $subjdir/tmp/cw256
endif

#-----------              -----------#
##----------  -show-edits -----------#
#-----------              -----------#
# discover which edits a user has made, list them, and if volume edits were
# made, create a file which shows them (using mri_compile_edits)
if($DoShowEdits) then
  @ edit_count = 0;
  echo "-----------------------------------------------" |& tee -a $LF
  echo "Subject $subjid has the following edits..." |& tee -a $LF

  # control points
  if(-e $ControlPointsFile) then
    @ edit_count = $edit_count + 1;
    set num_cps = (`grep numpoints $ControlPointsFile | awk '{print $2}'`)
    echo "$num_cps control points declared in file $ControlPointsFile" |& tee -a $LF
  endif

  # seeds
  set seedfile = $subjdir/scripts/seed-pons.crs.man.dat
  if(-e $seedfile) then
    @ edit_count = $edit_count + 1;
    echo "Manually specified seed CRS for Pons in file $seedfile" |& tee -a $LF
  endif
  set seedfile = $subjdir/scripts/seed-cc.crs.man.dat
  if($#CCSeedCRS) then
    @ edit_count = $edit_count + 1;
    echo "Manually specified seed CRS for CC in file $seedfile" |& tee -a $LF
  endif
  set seedfile = $subjdir/scripts/seed-lh.crs.man.dat
  if($#LHSeedCRS) then
    @ edit_count = $edit_count + 1;
    echo "Manually specified seed CRS for LH in file $seedfile" |& tee -a $LF
  endif
  set seedfile = $subjdir/scripts/seed-rh.crs.man.dat
  if($#RHSeedCRS) then
    @ edit_count = $edit_count + 1;
    echo "Manually specified seed CRS for RH in file $seedfile" |& tee -a $LF
  endif

  set seedfile = $subjdir/scripts/seed-ws.crs.man.dat
  if($#WSSeedPoint) then
    @ edit_count = $edit_count + 1;
    echo "Manually specified seed CRS for watershed in file $seedfile" \
        |& tee -a $LF
  endif

  # expert opts
  if($#XOptsFile != 0) then
    if (-e $XOptsFile) then
      @ edit_count = $edit_count + 1;
      echo "Expert options declared in file $XOptsFile" |& tee -a $LF
    endif
  endif

  # talairach.xfm
  set xfm = $subjdir/mri/transforms/talairach.xfm
  set xfma = $subjdir/mri/transforms/talairach.auto.xfm
  if(-e $xfm && -e $xfma) then
    diff $xfm $xfma >& /dev/null
    if($status) then
      @ edit_count = $edit_count + 1;
      echo "The talairach.xfm file appears to have been edited" |& tee -a $LF
   endif
  endif

  # cw256
  if(-e $subjdir/tmp/cw256) then
    @ edit_count = $edit_count + 1;
    echo "Conform-width (reduce FOV) to 256 is enabled" |& tee -a $LF
  endif

  # volume edits, as determined by mri_compile_edits:
  # brainmask.mgz, aseg.presurf.mgz, brain.finalsurfs.mgz, wm.mgz, brain.mgz
  set compile_edits=($subjdir/tmp/compile_edits)
  set cmd = (mri_compile_edits ${subjid} $subjdir/mri/edits.mgz)
  if($RunIt) then
    if ( -e $compile_edits) rm -f $compile_edits
    $cmd |& tee -a $LF |& tee -a $compile_edits
    set vol_edits=(`grep mri_compile_edits_found $compile_edits | awk '{print $1}'`)
    if($#vol_edits != 0) then
      @ edit_count = $edit_count + $vol_edits;
    endif
  endif

  # summarize
  echo "$edit_count edits were found for subject $subjid" |& tee -a $LF

endif


#-----------               -----------#
#-----------  Longitudinal -----------#
##---------- -long and -tp ----------#
#-----------               -----------#
if($longitudinal) then
  # if adding a new timepoint was requested by -addtp flag
  if($DoAddTp) then
    echo "Adding $tpNid as timepoint to base $longbaseid" |& tee -a $LF
    set cmd=(mri_add_new_tp $longbaseid $tpNid)
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif

  # init regfile variable with map cross_tp to base:
  # used later in many places
  set tpNtobase_regfile = ${longbasedir}/mri/transforms/${tpNid}_to_${longbaseid}.lta

  # map control.dat file from the cross-sectional data for this subj
  if ( -e ${SUBJECTS_DIR}/${tpNid}/tmp/control.dat && ! $UseLongbaseCtrlVol ) then
    # only if it does not already exist:
    if ( ! -e ${subjdir}/tmp/control.dat ) then
      set cmd = (mkdir -p ${subjdir}/tmp)
      echo "\n $cmd"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      set cmd = (mri_map_cpdat -in ${SUBJECTS_DIR}/${tpNid}/tmp/control.dat)
      set cmd = ($cmd -out ${subjdir}/tmp/control.dat)
      set cmd = ($cmd -lta $tpNtobase_regfile)
      echo " $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
      set UseControlPoints = 1;
    endif
  endif
endif


#-----------                  -----------#
#----------- Convert T1 Input -----------#
##----------    -i <file>     -----------#
#-----------                  -----------#
if($#InputList != 0) then
  @ nth = 1;
  foreach InputVol ($InputList)

    # sanity-check: make sure each input has the same dimensions
    if ($nth == 1) then
      # assume first input has 'correct' dimensions
      set firstInput = ($InputVol)
      set rows = `mri_info --nrows $InputVol |& tail -n 1`
      set cols = `mri_info --ncols $InputVol |& tail -n 1`
      set slices = `mri_info --nslices $InputVol |& tail -n 1`
    else
      # check subsequent against the first input
      set nrows = `mri_info --nrows $InputVol |& tail -n 1`
      set ncols = `mri_info --ncols $InputVol |& tail -n 1`
      set nslices = `mri_info --nslices $InputVol |& tail -n 1`
      if (($nrows != $rows) || \
          ($ncols != $cols) || \
          ($nslices != $slices)) then
        echo "ERROR: inputs have mismatched dimensions!" |& tee -a $LF
        echo "$firstInput is" |& tee -a $LF
        echo "$rows x $cols x $slices while" |& tee -a $LF
        echo "$InputVol is" |& tee -a $LF
        echo "$nrows x $ncols x $nslices" |& tee -a $LF
        goto error_exit;
      endif
    endif

    set nthid = `printf %03d.mgz $nth`
    set cmd = (mri_convert $InputVol $subjdir/mri/orig/$nthid)
    $PWD |& tee -a $LF
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    @ nth = $nth + 1;
  end
endif


#-----------                          -----------#
#----------- Input T2 or FLAIR images -----------#
##---------- -T2 <file> -FLAIR <file> -----------#
#-----------                          -----------#
if ($DoConvertT2Input || $DoConvertFlairInput) then

  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# T2/FLAIR Input `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF

  if ($DoConvertT2Input) then
    set cmd = (mri_convert \
        --no_scale 1 \
        $InputT2Vol \
        $subjdir/mri/orig/T2raw.mgz)
    $PWD |& tee -a $LF
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

  if ($DoConvertFlairInput) then
    set cmd = (mri_convert \
        --no_scale 1 \
        $InputFlairVol \
        $subjdir/mri/orig/FLAIRraw.mgz)
    $PWD |& tee -a $LF
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

endif


#-------------                                                 ------------#
#------------- Longitudinal 'base' subject input file creation ------------#
##------------                   -base                         ------------#
#-------------                                                 ------------#
if ($DoCreateBaseInput && $DoCreateBaseSubj) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Longitudinal Base Subject Creation `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  if ($#BaseSubjsList == 0) then
    echo "ERROR: must specify subjects for base subject using -base-tp" \
      |& tee -a $LF
    goto error_exit;
  endif
  cd $subjdir > /dev/null
  $PWD |& tee -a $LF
  if($RunIt) rm -f ${BaseSubjsListFname};
  set subjInVols=();
  set normInVols=();
  set ltaXforms=();
  set lta1forms=();
  set ltaAforms=();
  set headInVols=();
  set geodiff=0;
  foreach s ($BaseSubjsList)
    if($RunIt) echo "${s}" >> ${BaseSubjsListFname};
    set normInVols = ($normInVols ${SUBJECTS_DIR}/${s}/mri/norm.mgz)
    set headInVols = ($headInVols ${SUBJECTS_DIR}/${s}/mri/T1.mgz)
    set subjInVols = ($subjInVols ${SUBJECTS_DIR}/${s}/mri/${BaseSubjInvol})
    set ltaname = ${s}_to_${subjid}.lta
    set ltaXforms = ($ltaXforms ${subjdir}/mri/transforms/${ltaname})
    set lta1forms = ($lta1forms ${subjdir}/mri/transforms/${s}_to_${subjid}_norm.lta)
    set ltaAforms = ($ltaAforms ${subjdir}/mri/transforms/${s}_to_${subjid}_affine.lta)

    # check if geometry differs across time
    if ( "$s" != "$BaseSubjsList[1]" ) then
      set cmd = (  mri_diff --notallow-pix --notallow-geo \
                       ${SUBJECTS_DIR}/$s/mri/rawavg.mgz \
                       ${SUBJECTS_DIR}/$BaseSubjsList[1]/mri/rawavg.mgz )
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if($status) set geodiff = 1;
      endif
    endif
  end

  if ( "$geodiff" == "1" ) then
    echo "\n*******************************************************************************" |& tee -a $LF
    echo "WARNING: Image parameters differ across time, maybe due to aquisition changes?" |& tee -a $LF
    echo "         Consistent changes in, e.g., resolution can potentially bias a " |& tee -a $LF
    echo "         longitudinal study! You can check image parameters by running mri_info" |& tee -a $LF
    echo "         on each input image. Will continue in 10 seconds ..." |& tee -a $LF
    echo "*******************************************************************************\n" |& tee -a $LF
    sleep 10
  endif

  if ($#BaseSubjsList == 1) then
    # if only a single time point, create fake 'base' by making the image upright
    # this assures that also subjects with a single time point get processes as the other
    # subjects in the longitudinal stream

    # 1. make the norm upright (base space)
    set cmd = ( make_upright $normInVols[1] \
        ${subjdir}/mri/norm_template.mgz $ltaXforms[1] )
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif

    # 2. create the upright orig volume
    set cmd = ( mri_convert -rt cubic \
        -at $ltaXforms[1] $subjInVols[1] ${subjdir}/mri/orig.mgz )
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif

  else #more than 1 time point:

    # create the 'mean/median' norm volume:
    set cmd = (mri_robust_template --mov ${normInVols})
    if ($DoAffineBase) then
      # this is only initial rigid reg
      set cmd = ($cmd --lta ${lta1forms})
      set cmd = ($cmd --template ${subjdir}/mri/norm1_template.mgz)
    else
      # this is final rigid reg
      set cmd = ($cmd --lta ${ltaXforms})
      set cmd = ($cmd --template ${subjdir}/mri/norm_template.mgz)
    endif
    set cmd = ($cmd --average ${robust_template_avg_arg})
    set cmd = ($cmd --sat 4.685 )
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif

    if ($DoAffineBase) then
      # use registration on norm.mgz to initialize affine reg on full head imgs:
      set cmd = (mri_robust_template --mov ${headInVols})
      set cmd = ($cmd --lta ${ltaAforms})
      set cmd = ($cmd --average ${robust_template_avg_arg})
      set cmd = ($cmd --template ${subjdir}/mri/head_template.mgz)
      set cmd = ($cmd --sat 4.685 )
      set cmd = ($cmd --ixforms ${lta1forms})
      set cmd = ($cmd --affine)
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
      # use affine reg to init rigid reg on norm.mgz (fine tuning)
      # not sure if it is really necessary
      set cmd = (mri_robust_template --mov ${normInVols})
      set cmd = ($cmd --lta ${ltaXforms})
      set cmd = ($cmd --average ${robust_template_avg_arg})
      set cmd = ($cmd --template ${subjdir}/mri/norm_template.mgz)
      set cmd = ($cmd --sat 4.685 )
      set cmd = ($cmd --ixforms ${ltaAforms})
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    endif

    # create the 'mean/median' input (orig) volume:
    set cmd = (mri_robust_template --mov ${subjInVols})
    set cmd = ($cmd --average ${robust_template_avg_arg})
    set cmd = ($cmd --ixforms ${ltaXforms})
    set cmd = ($cmd --noit)
    set cmd = ($cmd --template ${subjdir}/mri/orig.mgz)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif

  endif # more than one time point

  # now create the inverse transforms
  cd $subjdir/mri/transforms > /dev/null
  $PWD |& tee -a $LF
  foreach s ($BaseSubjsList)
    set cmd = (mri_concatenate_lta -invert1)
    set cmd = ($cmd ${s}_to_${subjid}.lta)
    set cmd = ($cmd identity.nofile)
    set cmd = ($cmd ${subjid}_to_${s}.lta)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  end
  touch $touchdir/base.touch
endif


#-----------             -------------#
##---------- AUTORECON 1 -------------#
#-----------             -------------#


#-----------                            -----------#
#----------- Motion Correct and Average -----------#
##----------        -motioncor          -----------#
#-----------                            -----------#
if($DoMotionCor) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# MotionCor `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF

  if ($longitudinal) then
    # longitudinal processing to create orig.mgz:

    # in order to create orig.mgz in LONG we need at least 001.mgz in CROSS:
    if ( ! -e ${SUBJECTS_DIR}/${tpNid}/mri/orig/001.mgz ) then
      echo "ERROR: no CROSS run data found in ${SUBJECTS_DIR}/${tpNid}/mri/orig/. Make sure to" \
        |& tee -a $LF
      echo "have a volume called 001.mgz there." |& tee -a $LF
      echo "If you have a second run of data call it 002.mgz, etc." \
        |& tee -a $LF
      echo "See also: http://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/Conversion" \
        |& tee -a $LF
      goto error_exit;
    endif

    # use orig/00?.mgz from cross:
    set CrossList = `ls ${SUBJECTS_DIR}/${tpNid}/mri/orig/[0-9][0-9][0-9].mgz`;
    set origvol = $subjdir/mri/orig.mgz
    set rawvol  = $subjdir/mri/rawavg.mgz

    if($#CrossList == 1) then
      # if only single input, directly resample to base space
      set cmd = (mri_convert -at $tpNtobase_regfile -odt uchar)
      set cmd = ($cmd -rt cubic)
      set cmd = ($cmd ${SUBJECTS_DIR}/${tpNid}/mri/orig/001.mgz)
      set cmd = ($cmd ${origvol})
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
      # also create rawavg (usually float) image
      set cmd = (mri_convert -at $tpNtobase_regfile )
      set cmd = ($cmd -rt cubic)
      set cmd = ($cmd ${SUBJECTS_DIR}/${tpNid}/mri/orig/001.mgz)
      set cmd = ($cmd ${rawvol})
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
      goto motioncor_post_process
    endif

    # if ltas and iscales exist in cross, copy them over
    set CrossLtas = `ls ${SUBJECTS_DIR}/${tpNid}/mri/orig/[0-9][0-9][0-9].lta`;
    set CrossIscales = `ls ${SUBJECTS_DIR}/${tpNid}/mri/orig/[0-9][0-9][0-9]-iscale.txt`;
    if ( $#CrossLtas > 0 ) then
      # check if one lta for each mgz:
      # here we could better check if really each 00?.mgz has its own 00?.lta in future
      if ( $#CrossList != $#CrossLtas ) then
        echo "ERROR: Orig 00?.mgz runs and number of 00?.lta files must agree in" \
         |& tee -a $LF
        echo "${SUBJECTS_DIR}/${tpNid}/mri/orig/" \
         |& tee -a $LF
        goto error_exit;
      endif
      #copy ltas:
      cd $subjdir/mri/
      set cmd = (cp -vf ${CrossLtas})
      set cmd = ($cmd orig/)
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
      #copy iscales if available:
      if ($#CrossIscales > 0) then
        # here we could better check if really each 00?.mgz has its own iscale file in future
        if ( $#CrossList != $#CrossIscales ) then
          echo "ERROR: Orig 00?.mgz runs and number of 00?-iscale.txt files must agree in" \
            |& tee -a $LF
          echo "${SUBJECTS_DIR}/${tpNid}/mri/orig/" \
            |& tee -a $LF
          goto error_exit;
        endif
        cd $subjdir/mri/
        set cmd = (cp -vf ${CrossIscales})
        set cmd = ($cmd orig/)
        echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
        if($RunIt) $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    else
      # else the ltas don't exist (maybe because 5.0 or fsl was used,
      # they are created by 5.1+ in cross sectional stream)
      # if more than one input, re-receate the ltas:
      if($#CrossList > 1) then
        # set output names for ltas and iscales in long dir
        set LongLtas = ""
        set LongIscales = ""
        foreach nthid ($CrossList)
          set nthname=`basename $nthid .mgz`
          set nthdir=$subjdir/mri/orig
          set nthlta=${nthdir}/${nthname}.lta
          set LongLtas=($LongLtas $nthlta)
          set LongIscales=($LongIscales $nthdir/${nthname}-iscale.txt)
        end
        # perform motion correction again to obtain the ltas (but in long dir, don't touch cross):
        set rawavg  = $subjdir/mri/rawavg.mgz
        # the output rawavg in long will be ignored and not used for anything
        # except maybe debugging, we only need the ltas and iscales!
        set cmd = (mri_robust_template)
        set cmd = ($cmd --mov ${CrossList})
        set cmd = ($cmd --average 1)
        set cmd = ($cmd --template ${rawavg})
        set cmd = ($cmd --satit)
        set cmd = ($cmd --inittp 1)
        set cmd = ($cmd --fixtp)
        set cmd = ($cmd --noit)
        set cmd = ($cmd --iscale)
        set cmd = ($cmd --iscaleout $LongIscales)
        set cmd = ($cmd --subsample 200)
        set cmd = ($cmd --lta $LongLtas)
        echo "#-----------------------------------------------"
        $PWD |& tee -a $LF
        echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
        if($RunIt) then
          $fs_time $cmd |& tee -a $LF
          if($status) goto error_exit;
        endif
        # better get rid of rawavg to avoid confusion
        # as it is not in the base/long space, but in 001.mgz space
        set cmd = (rm -f $rawavg )
        echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
        if($RunIt) then
          $fs_time $cmd |& tee -a $LF
          if($status) goto error_exit;
        endif

      else
        # we should never get here, this case hase been dealt with above
        echo Only single run - should not get here
        goto error_exit;
      endif
    endif

    # now we have the ltas in long (current tp : subjdir)
    set LongLtas = `ls $subjdir/mri/orig/[0-9][0-9][0-9].lta`;
    set LongIscales = `ls $subjdir/mri/orig/[0-9][0-9][0-9]-iscale.txt`;

    # concat ltas (e.g. 002 -> 001 -> base/orig.mgz)
    set ConcatLtas = ""
    foreach nthlta ($LongLtas)
      set nthname=`basename $nthlta .lta`
      set nthdir=$subjdir/mri/orig
      set concatlta=${nthdir}/${nthname}-long.lta
      set ConcatLtas=($ConcatLtas $nthdir/${nthname}-long.lta)
      set cmd = (mri_concatenate_lta $nthlta $tpNtobase_regfile $concatlta)
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    end

    # use mri_robust_template just to create the average in base orig space:
    set cmd = (mri_robust_template)
    set cmd = ($cmd --mov ${CrossList})
    set cmd = ($cmd --average 1)
    set cmd = ($cmd --ixforms ${ConcatLtas})
    if ($#LongIscales > 0) then
      set cmd = ($cmd --iscalein ${LongIscales})
    endif
    set cmd = ($cmd --noit)
    set cmd = ($cmd --template ${rawvol})
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif

    # make sure orig is uchar:
    set cmd = (mri_convert -odt uchar ${rawvol} ${origvol})
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif

    goto motioncor_post_process

  endif #longitudinal

  # base processing (we do not need to do anything,
  #   as orig should be there, rawavg is not there, due to difficulties of
  #   averaging different image geometries across time)
  if ($DoCreateBaseSubj) then
    set origvol = $subjdir/mri/orig.mgz
    goto motioncor_post_process
  endif

  # default processing:
  set cmd = ();

  # Get list of input run directories #
  set RunList = ();
  ls $subjdir/mri/orig/[0-9][0-9][0-9].mgz >& /dev/null
  if(! $status) then
    set RunList = `ls $subjdir/mri/orig/[0-9][0-9][0-9].mgz`;
  else
    # No runs found
    ls $subjdir/mri//[0-9][0-9][0-9].mgz >& /dev/null
    if(! $status) then
      set RunList = `ls $subjdir/mri//[0-9][0-9][0-9].mgz`;
    else
      ls $subjdir/src/[0-9][0-9][0-9].mgz >& /dev/null
      if(! $status) then
         set RunList = $subjdir/src/[0-9][0-9][0-9].mgz
      endif
    endif
  endif
  if($#RunList == 0 && $RunIt) then
    echo "ERROR: no run data found in $subjdir/mri. Make sure to" \
      |& tee -a $LF
    echo "have a volume called 001.mgz in  $subjdir/mri/orig." |& tee -a $LF
    echo "If you have a second run of data call it 002.mgz, etc." \
      |& tee -a $LF
    echo "See also: http://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/Conversion" \
      |& tee -a $LF
    goto error_exit;
  else
    if ($RunIt) then
      echo "Found $#RunList runs" |& tee -a $LF
      foreach run ($RunList)
        echo $run |& tee -a $LF
      end
    endif
  endif

  # sanity-check: check if the input contains multiple frames, which would
  # be the case if a multi-echo frame mprage was accidently used as input.
  # without this check, andre is unhappy
  foreach RunVol ($RunList)
    echo "Checking for (invalid) multi-frame inputs..." |& tee -a $LF
    set nframes = `mri_info --nframes $RunVol |& tail -n 1`
    if ($nframes != 1) then
      echo "ERROR: input(s) cannot have multiple frames!" |& tee -a $LF
      echo "$RunVol has $nframes frames" |& tee -a $LF
      if ($nframes == 4) then
        echo "If this is a multi-frame MEMPRAGE image," |& tee -a $LF
        echo "use mri_concat --rms to combine echo frames." |& tee -a $LF
      endif
      goto error_exit;
    endif
  end

  set origvol = $subjdir/mri/orig.mgz
  set rawavg  = $subjdir/mri/rawavg.mgz

  # Only one run, copy to rawavg
  if($#RunList == 1) then
    echo "WARNING: only one run found. This is OK, but motion"|& tee -a $LF
    echo "correction cannot be performed on one run, so I'll"|& tee -a $LF
    echo "copy the run to rawavg and continue."|& tee -a $LF
    sleep 2s;
    set cmd = (cp $RunList $rawavg)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      sleep 1; # Sleep here to assure that they have diff time stamps
      $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

  # Actually perform the motion correction -- creates rawavg
  if($#RunList > 1) then
    # set names for ltas
    set RunLtas = ""
    set RunIscales = ""
    foreach nthid ($RunList)
      set nthname=`basename $nthid .mgz`
      set nthdir=`dirname $nthid`
      set nthlta=${nthdir}/${nthname}.lta
      set RunLtas=($RunLtas $nthlta)
      set RunIscales=($RunIscales ${nthdir}/${nthname}-iscale.txt)
    end

    if($DoRobustMotionCor) then
      set cmd = (mri_robust_template)
      set cmd = ($cmd --mov ${RunList})
      set cmd = ($cmd --average 1)
      set cmd = ($cmd --template ${rawavg})
      set cmd = ($cmd --satit)
      set cmd = ($cmd --inittp 1)
      set cmd = ($cmd --fixtp)
      set cmd = ($cmd --noit)
      set cmd = ($cmd --iscale)
      set cmd = ($cmd --iscaleout $RunIscales)
      set cmd = ($cmd --subsample 200)
      set cmd = ($cmd --lta $RunLtas)
    else
      # use FSL's flirt to do motion correction (averaging of runs)
      set cmd = (mri_motion_correct.fsl -o $rawavg -wild $RunList)
    endif
    echo "#-----------------------------------------------"
    $PWD |& tee -a $LF
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
      echo $cmd > $touchdir/motion_correct.touch
    endif
  endif

  # At this point, rawavg.mgz exists. Use it to create orig.mgz,
  # conform to COR FOV but keep mgz format.
  set cmd = (mri_convert $rawavg $origvol)
  if($UseCubic) set cmd = ($cmd -rt cubic)
  if($ConformKeepDC) set cmd = ($cmd --conform-dc)
  if($ConformMin) then
    set cmd = ($cmd --conform_min)
  else
    set cmd = ($cmd --conform)
    if($DoConformWidth256 || -e $subjdir/tmp/cw256) then
      # force conform width to 256
      set cmd = ($cmd --cw256)
      # see note just below on when -cw256 is necessary (ie, when FOV > 256)
    endif
  endif
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) then
    $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/conform.touch
  endif

  # this is the goto target for longitudinal processing (from above):
  motioncor_post_process:

  # check if FOV > 256 and error exit if so
  set FOV=`mri_info ${origvol} | grep fov: | awk '{print $2}'`
  set FOV_gt_256=`echo "${FOV} > 256" | bc`
  if ($FOV_gt_256) then
    echo "\n****************************************" |& tee -a $LF
    echo "ERROR! FOV=${FOV} > 256" |& tee -a $LF
    echo "Include the flag -cw256 with recon-all!" |& tee -a $LF
    echo "Inspect orig.mgz to ensure the head is fully visible." |& tee -a $LF
    echo "****************************************\n" |& tee -a $LF
    goto error_exit;
  endif

  # Add xfm to orig, even though it does not exist yet. This is a
  # compromise to keep from having to change the time stamp of
  # the orig volume after talairaching.
  set cmd = (mri_add_xform_to_header -c \
             $subjdir/mri/transforms/talairach.xfm \
             $origvol $origvol)
  echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
  if($RunIt) then
    $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif

endif # Motion Correction


#-----------          -----------#
##----------  -deface -----------#
#-----------          -----------#
if($DoDeface) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Deface `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set cmd = (mri_deface orig.mgz \
     $FREESURFER_HOME/average/$brain_template \
     $FREESURFER_HOME/average/$face_template \
     orig_defaced.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  touch $touchdir/deface.touch
endif


#-----------             -----------#
##----------  -talairach -----------#
#-----------             -----------#
if($DoTalairach) then
talairach:
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Talairach `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF
  set xfm = transforms/talairach.xfm
  set xfma = transforms/talairach.auto.xfm
  if ($longitudinal) then
    # longitudinal processing:
    if( -e $longbasedir/mri/$xfm) then
      set tal_xfm = $xfm
    else
      set tal_xfm = $xfma
    endif
    # copy from the base (as we are now in same space)
    # if edits were made to base, they will be also in long
    set cmd = (cp $longbasedir/mri/$tal_xfm $subjdir/mri/$xfma)
  else
    # default processing:
    # first run bias correction...
    if ($DoTalairachUseNu) then
      # note that this only works if nu exists
      # this is used as an alternative if tal is giving bad results
      set tal_input = nu.mgz
    else
      # default: run one pass of nu_correct, as its been found that scans
      # with strong bias fields can cause talairach_avi to fail.  note that
      # this orig_nu.mgz uses the full head, whereas nu.mgz is created using
      # the brainmask, and talairach.xfm used to find the white matter ball.
      set tal_input = orig_nu.mgz
      set cmd = (mri_nu_correct.mni --no-rescale --i orig.mgz --o $tal_input)
      # -3T flag support:
      if ($DoNuIntensityCor3T) then
        # 3T params from Zheng, Chee, Zagorodnov 2009 NeuroImage paper
        # "Improvement of brain segmentation accuracy by optimizing
        # non-uniformity correction using N3"
        # namely specifying iterations, proto-iters and distance: 
        set cmd = ($cmd --n 1 --proto-iters 1000 --distance 50)
      else
      # 1.5T default:
        set cmd = ($cmd --n 1 --proto-iters 1000 --distance 200)
      endif
      # per c.larsen, decrease convergence threshold (default is 0.001)
      set cmd = ($cmd --stop 1e-4)
      # per c.larsen, decrease shrink parameter: finer sampling (default is 4)
      set cmd = ($cmd --shrink 2)
      # allow expert-options override
      set xopts = `fsr-getxopts mri_nu_correct.mni $XOptsFile`;
      set cmd = ($cmd $xopts)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    # now run the talairach registration...
    if ($UseMincMritotal) then
      # use the MINC mritotal utility
      set xopts = `fsr-getxopts talairach $XOptsFile`;
      set cmd = (talairach --i $tal_input --xfm $xfma $xopts)
    else
      # Avi Snyder's registration tools
      set xopts = `fsr-getxopts talairach_avi $XOptsFile`;
      set cmd = (talairach_avi --i $tal_input --xfm $xfma)
      if($?CustomTalAtlas && "$CustomTalAtlas" != "") then
        # use user-specified atlas found in average dir
        set cmd = ($cmd --atlas "$CustomTalAtlas")
      else
        if($UseYa3tTalAtlas) then
          # special atlas composed of young adults scanned at 3T
          set cmd = ($cmd --atlas 3T18yoSchwartzReactN32_as_orig)
        endif
      endif
      set cmd = ($cmd $xopts)
    endif
  endif
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if ( ! $UseMincMritotal) then
    echo "talairach_avi log file is transforms/talairach_avi.log..." \
        |& tee -a $LF |& tee -a $CF
  endif
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;

  if( -e $xfm && ! $DoCleanTal) then
    echo "\nINFO: $xfm already exists!" \
        |& tee -a $LF |& tee -a $CF
    echo "The new $xfma will not be copied to $xfm" \
        |& tee -a $LF |& tee -a $CF
    echo "This is done to retain any edits made to $xfm" \
        |& tee -a $LF |& tee -a $CF
    echo "Add the -clean-tal flag to recon-all to overwrite $xfm\n" \
        |& tee -a $LF |& tee -a $CF
  endif

  if($DoCleanTal || ! -e $xfm) then
    if(-e $xfm) cp $xfm transforms/bak/talairach.xfm.$DateString
    set cmd = (cp $xfma $xfm)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) then
      sleep 2; # Sleep here to assure that they have diff time stamps
      $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

  echo $cmd > $touchdir/talairach.touch
endif

# perform the failure detection scheme
if($DoTalCheck) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Talairach Failure Detection `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  # first run Laurence's AFD tool:
  set xopts = `fsr-getxopts talairach_afd $XOptsFile`;
  set xfm = transforms/talairach.xfm
  set cmd = (talairach_afd -T 0.005 -xfm $xfm $xopts)
  set afdTestFailed = 0;
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) then
    $fs_time $cmd |& tee -a $LF
    if($status) then
      set handleTalErrors = 1;
      goto handle_tal_error;
    endif
  endif
  # now run Avi's QA check on the results found in talairach_avi.log
  # see document RLB700_preprocessing_statistics.pdf for details
  set avilog = ($subjdir/mri/transforms/talairach_avi.log)
  if ( ! $UseMincMritotal && -e $avilog) then
    set cmd = (awk -f $FREESURFER_HOME/bin/extract_talairach_avi_QA.awk)
    set cmd = ($cmd $avilog)
    set qalog = ($subjdir/mri/transforms/talairach_avi_QA.log)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    set cmd2 = (tal_QC_AZS $avilog)
    set qalog2 = ($subjdir/mri/transforms/talairach_avi_QA2.log)
    echo "\n $cmd2 \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) then
      rm -f $qalog $qalog2
      $fs_time $cmd >& $qalog
      if($status) then
        echo "ERROR: ${cmd} failed!  See logfile ${qalog}" |& tee -a $LF
        goto error_exit;
      endif
# tal_QC_AZS disabled:
# failing in weird ways. getting caught in infinite 'test' loops.
if (0) then
      $fs_time $cmd2 >& $qalog2
      set tal_QC_AZS_status = $status
      if($tal_QC_AZS_status) then
        echo "INFO: ${cmd2} failed!  See logfile ${qalog2}" |& tee -a $LF
        echo "      skipping tal_QC_AZS test" |& tee -a $LF
        #NJS: skip instead of exit because tal_QC_AZS doesnt work on centos5.4
        #goto error_exit;
      endif
endif
      # first set of QA data:
      set talAviQA=`grep "TalAviQA" ${qalog} | awk '{print $2}'`
      echo "TalAviQA: ${talAviQA}" |& tee -a $LF
      set mean=(0.9781) # buckner40 mean TalAviQA
      set std=(0.0044)  # buckner40 std TalAviQA
      set zscore=`echo "scale=0;(${talAviQA} - ${mean}) / ${std}" | bc`
      echo "z-score: ${zscore}" |& tee -a $LF
      set zscoreThreshold=(-9) # conservative value, but catches M.Harms subjs.
# tal_QC_AZS disabled:
if (0) then
      # second set:
      if ( ! $tal_QC_AZS_status ) then
        set talAviQA2=`grep "atlas_transform_error" ${qalog2} | awk '{print $6}'`
        echo "TalAviQA2: ${talAviQA2}" |& tee -a $LF
        set atlaserrhi=`echo "${talAviQA2} > 24" | bc`
        set atlaserrlo=`echo "${talAviQA2} < -60" | bc`
      else
        set talAviQA2=0
        set atlaserrhi=0
        set atlaserrlo=0
      endif
else
      set talAviQA2=0
      set atlaserrhi=0
      set atlaserrlo=0
endif
      # check scores:
      set handleTalErrors = 0;
      if (($zscore < $zscoreThreshold) || $atlaserrhi || $atlaserrlo) then
        echo "WARNING: Talairach QA check failed!" |& tee -a $LF
        echo "z-score of ${zscore} is <= threshold of ${zscoreThreshold}\n" \
             |& tee -a $LF
# tal_QC_AZS disabled:
if (0) then
        echo "or the atlas xform error of $talAviQA2 is < -60 | > 24" \
             |& tee -a $LF
endif
        set handleTalErrors = 1;
      endif

handle_tal_error:
      if ($handleTalErrors) then
        echo "\nManual Talairach alignment may be necessary, or" |& tee -a $LF
        echo "include the -notal-check flag to skip this test," |& tee -a $LF
        echo "making sure the -notal-check flag follows -all" |& tee -a $LF
        echo "or -autorecon1 in the command string." |& tee -a $LF
        echo "See:\n" |& tee -a $LF
        echo "http://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/Talairach" \
            |& tee -a $LF
        echo "" |& tee -a $LF
        # IF Talairach alignment was run
        # AND it was using the default (711-2C) atlas
        # AND a check failed,
        # THEN first retry avi method using newer 3T Schwartz atlas 
        # THEN (if that fails) try Talairach alignment using MINC mritotal tool
        # ELSE error exit
        if($DoTalairach && ! $UseMincMritotal && ! $longitudinal && \
           ! $UseYa3tTalAtlas ) then
          echo "INFO: Retrying Talairach align using 3T-based atlas...\n" \
            |& tee -a $LF
          set UseYa3tTalAtlas = 1; # try 3T-based atlas
          set UseMincMritotal = 0;
          set DoCleanTal = 1;
          goto talairach;
        else if($DoTalairach && ! $UseMincMritotal && ! $longitudinal) then
          echo "INFO: Trying MINC mritotal to perform Talairach align...\n" \
            |& tee -a $LF
          set UseMincMritotal = 1;
          set DoCleanTal = 1;
          goto talairach;
        else
          echo "\nERROR: Talairach failed!\n" |& tee -a $LF
          goto error_exit;
        endif
      endif
    endif
  endif
endif


#-----------                          -----------#
#----------- Intensity Normalization1 -----------#
##----------      -normalization      -----------#
#-----------                          -----------#
if($DoNormalization) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Intensity Normalization `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF
  set xopts = `fsr-getxopts mri_normalize $XOptsFile`;
  if ( $longitudinal && $UseLongbaseCtrlVol) then
    # longitudinal processing stream AND using ctrl_vol.mgz from base:
    if( ! -e $longbasedir/mri/ctrl_vol.mgz || \
        ! -e $longbasedir/mri/bias_vol.mgz ) then
      echo "Recompute intensity norm to create $longbaseid ctrl_vol.mgz" \
        |& tee -a $LF
      set cmd = (mri_normalize)
      if($#Norm3dIters)  set cmd = ($cmd -n $Norm3dIters)
      if($#Norm1_b)      set cmd = ($cmd -b $Norm1_b)
      if($#Norm1_n)      set cmd = ($cmd -n $Norm1_n)
      if($IsMPRAGE)      set cmd = ($cmd -mprage)
      if($IsWashuMPRAGE) set cmd = ($cmd -washu_mprage)
      set cmd = ($cmd \
        -mask $longbasedir/mri/brain.mgz \
        -W $longbasedir/mri/ctrl_vol.mgz $longbasedir/mri/bias_vol.mgz \
        $longbasedir/mri/nu.mgz \
        $longbasedir/mri/T1_tmp.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
      if( ! -e $longbasedir/mri/ctrl_vol.mgz ) then
        echo "ERROR: unable to generate cntl-point volume for longbase" \
          |& tee -a $LF
        goto error_exit;
      endif
      rm -f $longbasedir/mri/T1_tmp.mgz
    endif
    # use ctrl_vol.mgz from base for normalization:
    set cmd = (mri_normalize \
      -w $subjdir/mri/ctrl_vol.mgz $subjdir/mri/bias_vol.mgz \
      -l $longbasedir/mri/ctrl_vol.mgz $longbasedir/mri/bias_vol.mgz \
      $subjdir/mri/orig_nu.mgz \
      $subjdir/mri/T1.mgz)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  else
    if ( $longitudinal ) then
      # the longitudinal stream skips the talairach step, so orig_nu doesnt
      # get created, so create it now...
      set cmd = (mri_nu_correct.mni --no-rescale --i orig.mgz --o orig_nu.mgz)
      # -3T flag support:
      if ($DoNuIntensityCor3T) then
        # 3T params from Zheng, Chee, Zagorodnov 2009 NeuroImage paper
        # "Improvement of brain segmentation accuracy by optimizing
        # non-uniformity correction using N3"
        # namely specifying iterations, proto-iters and distance: 
        set cmd = ($cmd --n 1 --proto-iters 1000 --distance 50)
      else
      # 1.5T default:
        set cmd = ($cmd --n 1 --proto-iters 1000 --distance 200)
      endif
      # per c.larsen, decrease convergence threshold (default is 0.001)
      set cmd = ($cmd --stop 1e-4)
      # per c.larsen, decrease shrink parameter: finer sampling (default is 4)
      set cmd = ($cmd --shrink 2)
      # allow expert-options override
      set xopts = `fsr-getxopts mri_nu_correct.mni $XOptsFile`;
      set cmd = ($cmd $xopts)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd >& orig_nu.log
      if($status) goto error_exit;
    endif
    # for cross, base (and long if not useLongBaseCtrlVol) processing streams:
    set cmd = (mri_normalize -g $NormMaxGrad);
    if($UseControlPoints) set cmd = ($cmd -f $ControlPointsFile)
    if($#Norm3dIters)     set cmd = ($cmd -n $Norm3dIters)
    if($#Norm1_b)         set cmd = ($cmd -b $Norm1_b)
    if($#Norm1_n)         set cmd = ($cmd -n $Norm1_n)
    if($IsMPRAGE)         set cmd = ($cmd -mprage)
    if($IsWashuMPRAGE)    set cmd = ($cmd -washu_mprage)
    if($ConformMin)       set cmd = ($cmd -noconform)
    # in base create the ctrl_vol.mgz for init longs later:
    if($DoCreateBaseSubj) set cmd = ($cmd -W ctrl_vol.mgz bias_vol.mgz)
    set cmd = ($cmd $xopts orig_nu.mgz T1.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif
  echo $cmd > $touchdir/inorm1.touch
endif


#-----------                 -----------#
#----------- Skull Stripping -----------#
##----------   -skullstrip   -----------#
#-----------                 -----------#
if($DoSkullStrip) then
skullstrip:
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Skull Stripping `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF

  if ($longitudinal) then
    # longitudinal processing stream (copy from base):
    set BM  = brainmask.mgz
    set BMA = brainmask.auto.mgz
    set bmbase = brainmask_${longbaseid}.mgz
    set cmd = (cp -vf ${longbasedir}/mri/${BM} ./${bmbase})
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    # first apply mask and keep deletion edits (1)
    set cmd = (mri_mask -keep_mask_deletion_edits)
    set cmd = ($cmd T1.mgz ${bmbase} ${BMA})
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    # then transfer the 255 edits (still keep deletions)
    set cmd = (mri_mask -transfer 255)
    set cmd = ($cmd -keep_mask_deletion_edits)
    set cmd = ($cmd $BMA ${bmbase} $BMA)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    goto skipped_skullstrip;
  endif

  # base subject stream:
  if($DoCreateBaseSubj) then
    set BMA = brainmask.auto.mgz
    set BM  = brainmask.mgz  #used later
    # create lists with all cross brainmasks and all ltas:
    set bmInVols=""
    set ltaXforms=""
    foreach s ($BaseSubjsList)
      set bmInVols = ($bmInVols ${SUBJECTS_DIR}/${s}/mri/brainmask.mgz)
      set ltaname = ${s}_to_${subjid}.lta
      set ltaXforms = ($ltaXforms ${subjdir}/mri/transforms/${ltaname})
    end

    if ($#bmInVols == 1) then
      # only a single time point in base
      set cmd = (mri_convert \
        -at $ltaXforms[1] \
        -rt nearest \
        $bmInVols[1] brainmask_template.mgz )
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    else
      # map all brainmask with nearest neighbor and average 0=mean=logicalOR:
      set cmd = (mri_robust_template --mov ${bmInVols})
      set cmd = ($cmd --average 0)
      set cmd = ($cmd --ixforms ${ltaXforms})
      set cmd = ($cmd --noit)
      set cmd = ($cmd --finalnearest)
      set cmd = ($cmd --template brainmask_template.mgz)
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    endif # more than 1 tp

    # create brainmask.auto by applying brainmask_template to T1
    # first apply mask and keep deletion edits (1)
    set cmd = (mri_mask -keep_mask_deletion_edits)
    set cmd = ($cmd T1.mgz brainmask_template.mgz $BMA)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    # then copy over the 255 (edits) and still keep deletions (1)
    set cmd = (mri_mask -transfer 255)
    set cmd = ($cmd -keep_mask_deletion_edits)
    set cmd = ($cmd $BMA brainmask_template.mgz $BMA)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    goto skipped_skullstrip;
  endif

  # default stream...
  set xopts = `fsr-getxopts mri_watershed $XOptsFile`;
  set opts = ();
  if($WaterShed == 0) set opts = ($opts -n);
  if($WaterShed == 2) set opts = ($opts -wat);
  if($WaterShed == 3) set opts = ($opts -wat+temp);
  if($WaterShed == 4) set opts = ($opts -atlas);
  if($WSLess) set opts = ($opts -less);
  if($WSMore) set opts = ($opts -more);
  if($WSAtlas) set opts = ($opts -atlas);
  if($WSCopy) set opts = ($opts -copy);
  if($#WSSeedPoint != 0) set opts = ($opts -s $WSSeedPoint);
  if($#WSPctPreFlood != 0) then
    set opts = ($opts -h $WSPctPreFlood);
    set DoMultiStrip = 0
  else if( -e optimal_preflood_height) then
    set WSPctPreFlood = `cat optimal_preflood_height`
    set opts = ($opts -h $WSPctPreFlood);
    set DoMultiStrip = 0
    echo "Using optimal preflood height of $WSPctPreFlood" |& tee -a $LF
  endif

  set cmd = (mri_watershed)
  set BM  = brainmask.mgz

  if ($WSGcaAtlas || $DoMultiStrip) then
    if ( ! $WSUseTalXfm) then # dont bother if using talairach.xfm
      # if using the GCA atlas to help with the skull-strip, then run the
      # GCA registration (mri_em_register) to align to an atlas with a skull,
      # unless that file already exists
      if ( ! -e transforms/talairach_with_skull.lta || $DoCleanLta ) then
        set xopts2 = `fsr-getxopts mri_em_register $XOptsFile`;
        set cmd2 = (mri_em_register)
        if($UseCuda) set cmd2 = (mri_em_register_cuda)
        set cmd2 = ($cmd2 -skull)
        set cmd2 = ($cmd2 $xopts2 orig_nu.mgz ${GCADIR}/$GCASkull)
        set cmd2 = ($cmd2 transforms/talairach_with_skull.lta)
        echo "\n $cmd2 \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) $fs_time $cmd2 |& tee -a $LF
        if($status) goto error_exit;
        echo $cmd2 > $touchdir/skull.lta.touch
      endif
    endif

    if ($WSGcaAtlas) then
      # if just using -brain_atlas flag, then include necessary options
      if ($WSUseTalXfm) then
        set opts = (-brain_atlas ${GCADIR}/$GCASkull \
                    transforms/talairach.xfm $opts)
      else
        set opts = (-brain_atlas ${GCADIR}/$GCASkull \
                    transforms/talairach_with_skull.lta $opts)
      endif
    endif
  endif

  if($DoMultiStrip) then

    # when DoMultiStrip is enabled, multiple instances of mri_watershed are
    # run each using the following preflood height parameters
    if ( $?WATERSHED_PREFLOOD_HEIGHTS ) then
      # externally specified in the environment
      set PREFLOOD_HEIGHTS = ( $WATERSHED_PREFLOOD_HEIGHTS )
    else
      # defaults:
      set PREFLOOD_HEIGHTS = ( 5 10 20 30 )
    endif
    set SS_VOLUMES = ( orig orig_nu T1 )
    if ( $?GOTO_LL_CALC ) goto ll_calc

    # create command files, one job for each volume type and preflood height...
    set CMDFS = ()
    foreach vol ( $SS_VOLUMES )
      foreach pfh ( $PREFLOOD_HEIGHTS )
        set cmd = (mri_watershed)
        set BMA_OLD = brainmask.auto.mgz
        set BMA = brainmask_${vol}_PFH${pfh}.auto.mgz
        if(-e $BMA_OLD && -e $BM && ! $DoCleanBM) then
          set cmd = ($cmd -keep $BMA_OLD $BM $BMA)
        endif
        set cmd = ($cmd $opts -h ${pfh} $xopts ${vol}.mgz $BMA)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        set CMDF = mri_watershed_${vol}_PFH${pfh}.cmd
        echo "$cmd" > $CMDF
        set CMDFS = ( $CMDFS $CMDF )
      end
    end

    # and launch parallel jobs and wait for completion.
    # the reconbatchjobs script will append each job output to $LF
    if($RunIt) then
      reconbatchjobs $LF $CMDFS
      if($status) then
        # don't exit, since some may encounter 'preflood height' failures
        echo "WARNING: Some multi-skullstrip operations may have failed!" \
            |& tee -a $LF |& tee -a $CF
        echo "         Continuing multi-skullstrip with the others..." \
            |& tee -a $LF |& tee -a $CF
      endif
    endif

    # brainmask volumes actually need to be T1 volumes, because while
    # mri_watershed may run best in some cases using orig.mgz as input,
    # we really want the brainmask to be from T1.mgz (post normalization)
    set CMDFS = ()
    foreach pfh ( $PREFLOOD_HEIGHTS )
      set BMA_ORIG = brainmask_orig_PFH${pfh}.auto.mgz
      if ( -e $BMA_ORIG ) then
        set cmd = (mri_mask T1.mgz $BMA_ORIG $BMA_ORIG)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        set CMDF = mri_mask_PFH${pfh}.cmd
        echo "$cmd" > $CMDF
        set CMDFS = ( $CMDFS $CMDF )
      endif
    end

    # and launch parallel jobs and wait for completion.
    # the reconbatchjobs script will append each job output to $LF
    if($RunIt) then
      if($#CMDFS != 0) then
        reconbatchjobs $LF $CMDFS
        if($status) goto error_exit;
      endif
    endif
    echo $cmd > $touchdir/skull_strip.touch

    # calculate a measure of skull-strip performance (mri_log_likelihood):
    ll_calc:
    set max_ll = -9999999999;
    set best_pfh = 0;
    set best_vol = ();
    set xopts = `fsr-getxopts mri_log_likelihood $XOptsFile`;
    foreach vol ( $SS_VOLUMES )
      foreach pfh ( $PREFLOOD_HEIGHTS )
        set BMA = brainmask_${vol}_PFH${pfh}.auto.mgz
        if ( ! -e $BMA) continue;
        set LTA = transforms/talairach_with_skull.lta
        set cmd = (mri_log_likelihood -orig T1.mgz $BMA)
        set cmd = ($cmd $xopts ${GCADIR}/$GCA $LTA)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) then
          $cmd |& tee -a $LF |& tee -a ll_tmp
          # extract the last line of output, containing the result
          set ll = `tail -n 1 ll_tmp`
          rm -f ll_tmp
        endif
        if($status) goto error_exit;
        # and make the best result the brainmask.auto.mgz
        if($RunIt) then
          echo "$BMA log_likelihood= $ll" |& tee -a $LF
          if ("$ll" == "nan") continue
          if ($ll > $max_ll) then
            set max_ll = $ll;
            set best_pfh = $pfh;
            set best_vol = $vol;
            rm -f brainmask.auto.mgz
            cp $BMA brainmask.auto.mgz
            if($status) goto error_exit;
          endif
        endif
      end
    end
    if($RunIt) then
      if ($best_pfh == 0) then
        echo "ERROR: failure in calculating best preflood height param." \
          |& tee -a $LF
        goto error_exit;
      endif
      echo ""
      echo "Optimal input vol: $best_vol, pre-flood height= $best_pfh, results in log_likelihood= $max_ll" \
        |& tee -a $LF
      #rm -f *_PFH*.auto.*
      #rm -f *_PFH*.*
      # save this result, so that it is used next time, negating the need
      # to run mulitstrip (parallel jobs) again
      echo "$best_vol" > optimal_skullstrip_invol
      echo "$best_pfh" > optimal_preflood_height
    endif
    echo $cmd > $touchdir/log_likelihood.touch
    # make sure this is set properly:
    set BMA = brainmask.auto.mgz

  else

    # single-job skull-strip (default)

    set BMA = brainmask.auto.mgz
    if(-e $BMA && -e $BM && ! $DoCleanBM) set cmd = ($cmd -keep $BMA $BM $BM)
    set INVOL = T1
    if( -e optimal_skullstrip_invol) set INVOL = `cat optimal_skullstrip_invol`
    if("$INVOL" == "T1") set opts = ( -T1 $opts )
    set cmd = ($cmd $opts $xopts $INVOL.mgz $BMA)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    if("$INVOL" == "orig") then
      # while mri_watershed may run best in some cases using orig.mgz as input,
      # we really want the brainmask to be from T1.mgz (post normalization)
      set cmd = (mri_mask T1.mgz $BMA $BMA)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/skull_strip.touch

  endif

  # Gcut:
  # Nanyang Technological University's skull-stripper, which is intended to
  # work best running after watershed.  it further removes dura.  see:
  # 'Skull Stripping Using Graph Cuts', Neuroimage, 2009
  # brainmask.gcuts.mgz is a debug file showing voxels that were cut.
  if($DoGcut) then
    set BMA = brainmask.auto.mgz
    set BGC = brainmask.gcuts.mgz
    set cmd = (rm -f $BGC)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    set xopts = `fsr-getxopts mri_gcut $XOptsFile`;
    set cmd = (mri_gcut $xopts -110 -mult $BMA T1.mgz $BMA $BGC)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    echo "" |& tee -a $LF
    echo "INFO: Care must be taken to thoroughly inspect your data" \
        |& tee -a $LF
    echo "      when using mri_gcut. In particular, inspect the edges of" \
        |& tee -a $LF
    echo "      gm and cerebellum for over-aggressive cutting." |& tee -a $LF
    echo "      Add -segmentation brainmask.gcuts.mgz to the tkmedit" |& tee -a $LF
    echo "      command string to view the voxels which gcut has removed." |& tee -a $LF
    echo "" |& tee -a $LF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    # binarize the gcuts file, setting vals to label 999 which appears as red
    # when loaded as a segmentation
    if ( -e $BGC) then
      set cmd = (mri_binarize --i $BGC --o $BGC --binval 999 --min 1)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

  skipped_skullstrip:

  if( -e $BM && ! $DoCleanBM) then
    echo "\nINFO: brainmask.mgz already exists!" \
        |& tee -a $LF |& tee -a $CF
    echo "The new brainmask.auto.mgz will not be copied to brainmask.mgz." \
        |& tee -a $LF |& tee -a $CF
    echo "This is done to retain any edits made to brainmask.mgz." \
        |& tee -a $LF |& tee -a $CF
    echo "Add the -clean-bm flag to recon-all to overwrite brainmask.mgz.\n" \
        |& tee -a $LF |& tee -a $CF
  endif

  if(! -e $BM || $DoCleanBM) then
    set cmd = (cp $BMA $BM)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) then
      sleep 1; # Sleep here to assure that they have diff time stamps
      $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

endif


#-----------                         -----------#
#----------- Nu Intensity Correction -----------#
##----------     -nuintensitycor     -----------#
#-----------                         -----------#
if($DoNuIntensityCor) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Nu Intensity Correction `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_nu_correct.mni $XOptsFile`;
  set cmd = (mri_nu_correct.mni --i orig.mgz --o nu.mgz)
  # to fix a problem with mri_nu_correct.mni messing with the histogramming
  # in some odd subjects (due to voxels outside the brain, which has the
  # effect of altering white matter intensity interpretation downstream),
  # the inclusion of talairach.xfm with mri_nu_correct.mni causes
  # mri_make_uchar to run, which uses the Tal xform to find a ball of voxels
  # that are mostly brain. The top of the intensity histogram in this ball
  # will then be white matter, which allows us to center it at the desired
  # value, approximately (110).
  if ($DoNuMakeUchar) then
    if ( ! -e transforms/talairach.xfm) then
      echo "WARNING: transforms/talairach.xfm does not exist!" \
        |& tee -a $LF
      echo "It will not be used by mri_nu_correct.mni." \
        |& tee -a $LF
    else
      set cmd = ($cmd --uchar transforms/talairach.xfm)
    endif
  endif
  # --cm for hi-res support:
  if ($ConformMin) set cmd = ($cmd --cm)
  # -3T flag support:
  if ($DoNuIntensityCor3T) then
    # 3T params from Zheng, Chee, Zagorodnov 2009 NeuroImage paper
    # "Improvement of brain segmentation accuracy by optimizing
    # non-uniformity correction using N3"
    # namely specifying iterations, proto-iters and distance: 
    set cmd = ($cmd --n 1 --proto-iters 1000 --distance 50)
  else
  # 1.5T default:
    set cmd = ($cmd --n 1 --proto-iters 1000 --distance 200)
  endif
  # per c.larsen, decrease convergence threshold (default is 0.001)
  set cmd = ($cmd --stop 1e-4)
  # per c.larsen, decrease shrink parameter: finer sampling (default is 4)
  set cmd = ($cmd --shrink 2)
  # add the mask, as per c.larsen, bias-field correction is known to work
  # much better when the brain area is properly masked, in this case by
  # brainmask.mgz.
  if ($UseMaskNuCorrect) then
    set cmd = ($cmd --mask brainmask.mgz)
    if ($#DilateMaskNuCorrect) then
      set cmd = ($cmd --mask-dilate $DilateMaskNuCorrect)
    endif
  endif
  # add user-specified option (from an 'experts file')
  set cmd = ($cmd $xopts)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  # Add xfm to nu
  # Why is this done here instead of after talairach.xfm is created?
  # To assure that it gets propagated?
  set cmd = (mri_add_xform_to_header -c \
             $subjdir/mri/transforms/talairach.xfm \
             nu.mgz nu.mgz)
  echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
  if($RunIt) then
    $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif
  if($?CREATE_NU_DIFF_FILES) then
    # for debug, create difference volumes between orig and nu files
    set cmd1 = (mri_diff orig.mgz orig_nu.mgz --diff diff-orig-orig_nu.mgz)
    set cmd2 = (mri_diff orig.mgz nu.mgz --diff diff-orig-nu.mgz)
    set cmd3 = (mri_diff orig_nu.mgz nu.mgz --diff diff-orig_nu-nu.mgz)
    echo "\n $cmd1 \n" |& tee -a $LF |& tee -a $CF
    echo "\n $cmd2 \n" |& tee -a $LF |& tee -a $CF
    echo "\n $cmd3 \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd1 |& tee -a $LF
      $fs_time $cmd2 |& tee -a $LF
      $fs_time $cmd3 |& tee -a $LF
    endif
  endif
  # done:
  touch $touchdir/nu.touch
endif




#-----------             -------------#
##---------- AUTORECON 2 -------------#
#-----------             -------------#

#--------------                   ---------------#
#-------------- GCA Registration  ---------------#
##-------------      -gcareg      ---------------#
#--------------                   ---------------#
if($DoGCAReg) then
  echo "#-------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# EM Registration `date`" |& tee -a $SF |& tee -a $LF  |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF
  set xopts = `fsr-getxopts mri_em_register $XOptsFile`;
  if($longitudinal) then
    # longitudinal processing:
     set cmd = (cp -vf $longbasedir/mri/transforms/talairach.lta \
                 transforms/talairach.lta )

  else
    set cmd = (mri_em_register)
    if($UseCuda) set cmd = (mri_em_register_cuda)
    if($DoCreateBaseSubj) then
      # base subj processing (norm_template instead of nu, and no mask needed):
      set cmd = ($cmd -mask brainmask.mgz $xopts \
                  norm_template.mgz ${GCADIR}/$GCA \
                  transforms/talairach.lta)
    else
      # default processing:
      set lta = transforms/talairach.lta
      if($#GCAOutputName) set lta = transforms/talairach.$GCAOutputName.lta
      set cmd = ($cmd -uns 3 -mask brainmask.mgz $xopts \
                  nu.mgz ${GCADIR}/$GCA $lta)
    endif
  endif
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/em_register.touch
endif


#------------                         --------------#
#------------ Canonical Normalization --------------#
##-----------         -canorm         --------------#
#------------                         --------------#
if($DoCANormalize) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# CA Normalize `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF

  set lta = transforms/talairach.lta
  set norm = norm.mgz
  set ctrl_pts = ctrl_pts.mgz
  if($#GCAOutputName) then
    set lta = transforms/talairach.$GCAOutputName.lta
    set norm = norm.$GCAOutputName.mgz
    set ctrl_pts = ctrl_pts.$GCAOutputName.mgz
  endif

  if ($longitudinal) then
    # longitudinal processing:
    # cp aseg from base to current TP:
    set cmd = (cp -vf ${longbasedir}/mri/aseg.mgz aseg_${longbaseid}.mgz)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if ($RunIt) $fs_time $cmd |& tee -a $LF
    if ($status) goto error_exit;
  endif

  set xopts = `fsr-getxopts mri_ca_normalize $XOptsFile`;
  set cmd = (mri_ca_normalize)
  if($UseCPsWithCaNorm)  set cmd = ($cmd -f $ControlPointsFile)
  if ($longitudinal) then
    # longitudinal processing:
    # use the aseg_base (just created) as initialization of the current TP:
    set cmd = ($cmd -long aseg_${longbaseid}.mgz)
  else
    # default stream
    set cmd = ($cmd -c $ctrl_pts)
  endif
  set cmd = ($cmd -mask brainmask.mgz $xopts)
  if($DoCreateBaseSubj) then
    # base subject stream
    # (use norm vol created during -base-init, no mask needed)
    set cmd = ($cmd norm_template.mgz)
  else
    # default stream
    set cmd = ($cmd nu.mgz)
  endif

  set cmd = ($cmd ${GCADIR}/$GCA $lta $norm)

  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/ca_normalize.touch

endif # DoCANormalize


#------------                        --------------#
#------------ Canonical Registration --------------#
##-----------        -careg          --------------#
#------------                        --------------#
if($DoCAReg) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# CA Reg `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF

  set xopts = `fsr-getxopts mri_ca_register $XOptsFile`;
  set cmd = (mri_ca_register)
  if($UseCuda) set cmd = (mri_ca_register_cuda)
  if($#GCARegIterations) set cmd = ($cmd -n $GCARegIterations)
  if($#GCARegTol) set cmd = ($cmd -tol $GCARegTol)
  set m3z = transforms/talairach.m3z
  set norm = norm.mgz
  if($#GCAOutputName) then
    set lta = transforms/talairach.$GCAOutputName.lta
    set m3z = transforms/talairach.$GCAOutputName.m3z
    set norm = norm.$GCAOutputName.mgz
  endif
  if($UnCompress) set cmd = ($cmd -uncompress)
  if($BigVentricles) set cmd = ($cmd -bigventricles)
  if( ! $BigVentricles) set cmd = ($cmd -nobigventricles)
  if($DoSecondPassRenorm) set cmd = ($cmd -secondpassrenorm)
  if( ! $longitudinal) set cmd = ($cmd -T $lta)
  if($UseTWMControlPoints) set cmd = ($cmd -twm $TWMControlPointsFile)
  if ( $longitudinal ) then
    # here is tpN's longitudinal command
    # init with warp (m3z) from base
    # no need to concatenate, as we are in same space now
    set cmd = ($cmd -levels 2 -A 1 \
                -l $longbasedir/mri/transforms/talairach.m3z \
                identity.nofile)
  endif

  set cmd = ($cmd $UseCAAlignAfter)
  set cmd = ($cmd -mask brainmask.mgz)
  set cmd = ($cmd $xopts $norm ${GCADIR}/$GCA $m3z)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  set st = $status
  if($st) then
    echo "ERROR: mri_ca_register with non-zero status $st" |& tee -a $LF
    echo "but continuing despite the error" |& tee -a $LF
    #goto error_exit;
  endif

  echo $cmd > $touchdir/ca_register.touch
endif


#------------                                   --------------#
#------------ Inverse of Canonical Registration --------------#
##-----------              -careginv            --------------#
#------------                                   --------------#
if($DoCARegInv) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# CA Reg Inv `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF
  # set xopts = `fsr-getxopts mri_ca_register $XOptsFile`; # careful here
  set cmd = (mri_ca_register)
  #NJS: cuda version doesnt work will -invert-and-save:
  #if($UseCuda) set cmd = (mri_ca_register_cuda)
  set cmd = ($cmd -invert-and-save transforms/talairach.m3z)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) then
    echo "ERROR: mri_ca_register with non-zero status $status" |& tee -a $LF
    goto error_exit;
  endif
  echo $cmd > $touchdir/ca_register_inv.touch
endif


#------------                                    --------------#
#------------ Removes neck and part of the face  --------------#
##-----------              -rmneck               --------------#
#------------                                    --------------#
if($DoRemoveNeck) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# Remove Neck `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_remove_neck $XOptsFile`;
  set xform = (transforms/talairach.m3z)
  if ( ! -e $xform) then
    echo "INFO: $xform not found, using talairach.lta instead" \
      |& tee -a $LF |& tee -a $CF
    set xform = (transforms/talairach.lta)
  endif
  set cmd = (mri_remove_neck -radius $RmNeckRadius $xopts \
             nu.mgz $xform \
             ${GCADIR}/$GCA nu_noneck.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/mri_remove_neck.touch
endif


#------------                                       --------------#
#------------ Recompute lta with skull but no neck  --------------#
##-----------              -skull-lta               --------------#
#------------                                       --------------#
if($DoSkullLTA) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# SkullLTA `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_em_register $XOptsFile`;
  set cmd = (mri_em_register)
  if ($UseCuda) set cmd = (mri_em_register_cuda)
  set cmd = ($cmd -skull -t transforms/talairach.lta \
     $xopts nu_noneck.mgz ${GCADIR}/$GCASkull \
     transforms/talairach_with_skull_2.lta)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/skull_2.lta.touch
endif


#--------------                      --------------#
#-------------- SubCort Segmentation --------------#
##-------------        -calabel      --------------#
#--------------                      --------------#
if($DoCALabel) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# SubCort Seg `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set DoASegMerge = 1; # Force

  if($DoCleanASeg) then
    set cmd = (rm -f aseg.presurf.mgz aseg.manedit.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
  endif

  # ----------- Prior to changing aseg.auto.mgz ------------#
  if( -e aseg.presurf.mgz && -e aseg.auto.mgz ) then
    # aseg.presurf.mgz and aseg.auto.mgz DO exist (at least 2nd pass)
    if( ! -e aseg.manedit.mgz) then
      # aseg.manedit.mgz does NOT exist
      # Check for diffs between aseg.auto and aseg.presurf
      # Note: if there are no diffs, then aseg.manedit.mgz is not created
      set cmd = (mri_seg_diff --seg1 aseg.auto.mgz \
        --seg2 aseg.presurf.mgz --diff aseg.manedit.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if( ! $RunIt) then
        echo "INFO: mri_seg_diff was not actually executed," |& tee -a $LF
        echo "so subsequent commands (shown with -dontrun)" |& tee -a $LF
        echo "may not have accurate arguments!" |& tee -a $LF
      endif
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
    else
      # aseg.manedit.mgz DOES exist
      # This has to be handled in two stages in case manedit itself has
      # been edited.
      # 1. Check for diffs between aseg.auto and aseg.presurf (new & old edits)
      set cmd = (mri_seg_diff --seg1 aseg.auto.mgz \
        --seg2 aseg.presurf.mgz --diff aseg.manedit.tmp.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if( ! $RunIt) then
        echo "INFO: mri_seg_diff was not actually executed," |& tee -a $LF
        echo "so subsequent commands (shown with -dontrun)" |& tee -a $LF
        echo "may not have accurate arguments!" |& tee -a $LF
      endif
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
      # 2. Merge new and old edits with manedit. If manedit has not
      # been edited, then there will be no change.
      if(-e aseg.manedit.tmp.mgz) then
        set cmd = (mri_seg_diff --seg aseg.manedit.mgz \
          --diff-in aseg.manedit.tmp.mgz --merged aseg.manedit.mgz)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) $cmd |& tee -a $LF
        if($status) goto error_exit;
        rm aseg.manedit.tmp.mgz
      endif
    endif
  endif

  # ------------ longitudinal (pre)processing ----------------#
  # fuse segmentations of subjects composing the 'longbase' subject
  if ($longitudinal && $UseAsegFusion) then
    cd $subjdir/mri > /dev/null
    $PWD |& tee -a $LF
    set BaseSubjsList = (`cat ${longbasedir}/${BaseSubjsListFname}`)
    # first create lta's of basesubjs to longsubj
    foreach s (${BaseSubjsList})
      # copy the transform (tpi cross to base) to local transform dir
      # where mri_fuse_segmentations is looking for it:
      set cmd = (cp -vf \
            ${longbasedir}/mri/transforms/${s}_to_${longbaseid}.lta \
            ${subjdir}/mri/transforms/${s}_to_${subjid}.lta)
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    end
    # now create the fused aseg
    set cmd = (mri_fuse_segmentations)
    set cmd = ($cmd -a aseg.presurf.mgz -c aseg.auto_noCCseg.mgz -n norm.mgz)
    set cmd = ($cmd ${subjid} ${BaseSubjsList} aseg.fused.mgz)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

  #------------------- mri_ca_label ------------------------#
  # Run mri_ca_label to create aseg.auto_noCCseg.mgz
  set xopts = `fsr-getxopts mri_ca_label $XOptsFile`;
  set cmd = (mri_ca_label -relabel_unlikely 9 .3 -prior 0.5)
  set cmd = ($cmd $UseCAAlign)
  if($NoWMSA) set cmd = ($cmd -nowmsa)
  set asegbasename=(aseg.auto_noCCseg)
  if($longitudinal && $UseAsegFusion) then
      # longitudinal processing: use 'fused' aseg just created
      set cmd=($cmd -r $subjdir/mri/aseg.fused.mgz)
      set cmd=($cmd -ri $longbasedir/mri/${asegbasename}.label_intensities.txt)
  endif
  set cmd = ($cmd $xopts norm.mgz)
  set cmd = ($cmd transforms/talairach.m3z)
  set cmd = ($cmd ${GCADIR}/$GCA)
  set cmd = ($cmd ${asegbasename}.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;

  #--- Corpus Callosum Segmentation ---#
  # Run mri_cc to create aseg.auto.mgz
  set xopts = `fsr-getxopts mri_cc $XOptsFile`;
  set cmd = (mri_cc -aseg aseg.auto_noCCseg.mgz -o aseg.auto.mgz \
    -lta ${subjdir}/mri/transforms/cc_up.lta $xopts $subjid);
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;

  echo $cmd > $touchdir/ca_label.touch
endif

# --------- Incorporate Manual ASeg Changes ----------------------
# Allow it to be done outside of CALabel. Note that DoASegMerge
# will be 1 if CALabel is run. This just allows the user to
# merge with Man Edits even if CALabel was not run, which will
# only have an effect if the user has actually changed aseg.manedit
if($DoASegMerge) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# Merge ASeg `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  if(-e aseg.manedit.mgz ) then
    set cmd = (mri_seg_diff --seg aseg.auto.mgz \
      --diff-in aseg.manedit.mgz --merged aseg.presurf.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if( ! $RunIt) then
      echo "INFO: mri_seg_diff was not actually executed," |& tee -a $LF
      echo "so subsequent commands (shown with -dontrun)" |& tee -a $LF
      echo "may not have accurate arguments!" |& tee -a $LF
    endif
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
  else
    set cmd = (cp aseg.auto.mgz aseg.presurf.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif

  echo $cmd > $touchdir/asegmerge.touch
endif


#-----------                          -----------------#
#----------- Intensity Normalization2 -----------------#
##----------     -normalization2      -----------------#
#-----------                          -----------------#
if($DoNormalization2) then
  echo "#--------------------------------------------" \
    |& tee -a $LF  |& tee -a $CF
  echo "#@# Intensity Normalization2 `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_normalize $XOptsFile`;
  set cmd = (mri_normalize);
  if($UseControlPoints)   set cmd = ($cmd -f $ControlPointsFile)
  if($#Norm3dIters)       set cmd = ($cmd -n $Norm3dIters)
  if($#Norm2_b)           set cmd = ($cmd -b $Norm2_b)
  if($#Norm2_n)           set cmd = ($cmd -n $Norm2_n)
  if($IsMPRAGE)           set cmd = ($cmd -mprage)
  if($IsWashuMPRAGE)      set cmd = ($cmd -washu_mprage)
  if($ConformMin)         set cmd = ($cmd -noconform)
  if($UseAseg && ! $NoAsegInorm2) set cmd = ($cmd -aseg aseg.presurf.mgz)
  if($NoNormMGZ) then
    # norm.mgz doesnt exist with -noaseg or -nosubcortseg, so use brainmask.mgz
    set cmd = ($cmd $xopts brainmask.mgz brain.mgz)
  else
    set cmd = ($cmd -mask brainmask.mgz $xopts norm.mgz brain.mgz)
  endif
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/inorm2.touch
endif


#--------------                        ---------------#
#-------------- Create BrainFinalSurfs ---------------#
##-------------         -maskbfs       ---------------#
#--------------                        ---------------#
if($DoMaskBFS) then
  echo "#--------------------------------------------" \
    |& tee -a $LF  |& tee -a $CF
  echo "#@# Mask BFS `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_mask $XOptsFile`;
  # Set threshold to WM_MIN_VAL=5
  set cmd = (mri_mask -T 5 $xopts brain.mgz brainmask.mgz brain.finalsurfs.mgz)
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  # if they exist, transfer finalsurfs edits (voxels=255 and voxels=1)
  if( -e brain.finalsurfs.manedit.mgz ) then
    set cmd = (mri_mask -transfer 255)
    set cmd = ($cmd -keep_mask_deletion_edits)
    set cmd = ($cmd brain.finalsurfs.mgz brain.finalsurfs.manedit.mgz \
        brain.finalsurfs.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  else
    if ( $longitudinal && -e ${SUBJECTS_DIR}/${tpNid}/mri/brain.finalsurfs.manedit.mgz ) then
      # transfer edits from cross
      set cmd = (mri_mask -transfer 255)
      set cmd = ($cmd -keep_mask_deletion_edits)
      set cmd = ($cmd -xform $tpNtobase_regfile)
      set cmd = ($cmd brain.finalsurfs.mgz)
      set cmd = ($cmd ${SUBJECTS_DIR}/${tpNid}/mri/brain.finalsurfs.manedit.mgz)
      set cmd = ($cmd brain.finalsurfs.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif
endif


#----------------                 -------------------#
#---------------- WM Segmentation -------------------#
##---------------  -segmentation  -------------------#
#----------------                 -------------------#
if($DoSegmentation) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# WM Segmentation `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null

  set AllowLongWMtransfers = "1"
  if(! $DoCleanWM && -e wm.mgz) then
    # test if edits were made
    # count 255 edits:
    set cmd = (mri_binarize --i wm.mgz --min 255 --max 255 \
        --o wm255.mgz --count wm255.txt)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    # count 1 edits:
    set cmd = (mri_binarize --i wm.mgz --min 1 --max 1 \
        --o wm1.mgz --count wm1.txt)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    # remove unnecessary mgz's
    set cmd = (rm wm1.mgz wm255.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    # get number of edits:
    set wm255=""
    if ( -e wm255.txt )  then
      set wm255 = `cat wm255.txt | awk ' { print $1 } '`
    endif
    set wm1=""
    if ( -e wm1.txt ) then
      set wm1 = `cat wm1.txt | awk ' { print $1 } '`
    endif

    # if edits exist:
    if ( "$wm1" != "0" || "$wm255" != "0" ) then
      echo "Found wm edits: $wm1 deletes, $wm255 fills" |& tee -a $LF
      set cmd = (cp wm.mgz wm.seg.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
      # wm.mgz was available (probably edited):
      # don't allow transfers in long below
      set AllowLongWMtransfers = "0"
    endif
  endif
  # ----------- Segment -------------------------
  set xopts = `fsr-getxopts mri_segment $XOptsFile`;
  set cmd = (mri_segment);
  if ($NoThicken) set cmd = ($cmd -thicken 0)
  # note: check for wm.mgz happens so that -dontrun output is correct
  if(! $DoCleanWM && -e wm.mgz && -e wm.seg.mgz) set cmd = ($cmd -keep)
  if($IsMPRAGE)         set cmd = ($cmd -mprage)
  if($IsWashuMPRAGE)    set cmd = ($cmd -washu_mprage)
  set cmd = ($cmd $WMSeg_wlo $WMSeg_ghi $xopts brain.mgz wm.seg.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  # ----------- Edit with ASeg -------------------------
  if($UseAseg) then
    set xopts = `fsr-getxopts mri_edit_wm_with_aseg $XOptsFile`;
    set cmd = (mri_edit_wm_with_aseg)
    if(! $DoCleanWM) set cmd = ($cmd -keep-in)
    set cmd = ($cmd $xopts wm.seg.mgz brain.mgz \
        aseg.presurf.mgz wm.asegedit.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif
  # ----------- PreTess -------------------------
  set xopts = `fsr-getxopts mri_pretess $XOptsFile`;
  set wmlabelstring = "wm"
  if($UseAseg) then
    set WM_vol = wm.asegedit.mgz
  else
    set WM_vol = wm.seg.mgz
  endif
  if($NoNormMGZ) then
    set norm_vol = brain.mgz
  else
    set norm_vol = norm.mgz
  endif
  set cmd = (mri_pretess )
  if(! $DoCleanWM && -e wm.mgz) set cmd = ($cmd -keep)
  set cmd = ($cmd $xopts $WM_vol $wmlabelstring $norm_vol wm.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;

  if($longitudinal && $AllowLongWMtransfers) then
    if ($UseLongbaseWMedits) then
      # transfer wm edits (voxels=255) from longbase wm.mgz to long tpN wm.mgz
      # and -keep_mask_deletion_edits transfers voxel-deletion (voxels=1) edits
      set cmd = (mri_mask -transfer 255)
      set cmd = ($cmd -keep_mask_deletion_edits)
      set cmd = ($cmd wm.mgz $longbasedir/mri/wm.mgz wm.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    else #default in -long:
      # transfer wm matter edits (voxels=255) from cross wm.mgz to long tpN wm.mgz
      # and -keep_mask_deletion_edits transfers voxel-deletion (voxels=1) edits
      set cmd = (mri_mask -transfer 255)
      set cmd = ($cmd -keep_mask_deletion_edits)
      set cmd = ($cmd -xform $tpNtobase_regfile)
      set cmd = ($cmd wm.mgz ${SUBJECTS_DIR}/${tpNid}/mri/wm.mgz wm.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

  echo $cmd > $touchdir/wmsegment.touch
endif


#----------------        -------------------#
##---------------  -fill -------------------#
#----------------        -------------------#
if($DoFill) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Fill `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_fill $XOptsFile`;
  set seedopts = ();
  if($#PonsSeedCRS) set seedopts = ($seedopts -Pv  $PonsSeedCRS);
  if($#CCSeedCRS)   set seedopts = ($seedopts -Cv  $CCSeedCRS);
  if($#LHSeedCRS)   set seedopts = ($seedopts -lhv $LHSeedCRS);
  if($#RHSeedCRS)   set seedopts = ($seedopts -rhv $RHSeedCRS);
  set cmd = (mri_fill -a ../scripts/ponscc.cut.log $seedopts)
  if(-e transforms/talairach.lta) then
    set cmd = ($cmd  -xform transforms/talairach.lta)
  endif
  if($UseAseg) set cmd = ($cmd -segmentation aseg.auto_noCCseg.mgz);
  if(! $UseOldTopoFix && ! $NoNormMGZ) set cmd = ($cmd -topofix norm.mgz);
  set cmd = ($cmd $xopts wm.mgz filled.mgz)
  $PWD |& tee -a $LF
  echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;

  echo $cmd > $touchdir/fill.touch
endif


#########################################################
#                  Per-Hemisphere                       #
#########################################################

#
# Notes on -parallel ($DoParallel) implementation:
# - clear the var CMDFS that stores command-files to run in parallel
# - start for loop on each hemi
# - print start-up log message, and build the 'cmd' var as usual
# - if DoParallel:
#     write 'cmd' to a file and put that filename in CMDFS
#     don't run the command just yet
# - else if not DoParallel (the traditional usage)
#     run the command
#     check error status
# - end for loop
# - if DoParallel:
#     run 'reconbatchjobs', which does the following grunt work:
#       - calls 'exec' on each command in the command file
#       - directs stdout/stderr to a temporary log file
#       - waits for each command to complete
#       - appends each temp log into recon-all.log
#       - check command return status and error-exit if error
#     check error status of reconbatchjobs
#


#----------------              -------------------#
##---------------  -tessellate -------------------#
#----------------              -------------------#
if($DoTessellate && ( ! $longitudinal )) then
  # no need to run hemis in parallel, as this already runs in seconds
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Tessellate $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF

    if($hemi == "lh") then
      set hemivalue = 255;
    else
      set hemivalue = 127;
    endif

    # necessary second pretess, per f.segonne
    set xopts = `fsr-getxopts mri_pretess $XOptsFile`;
    if($NoNormMGZ) then
      set norm_vol = brain.mgz
    else
      set norm_vol = norm.mgz
    endif
    set cmd = (mri_pretess $xopts ../mri/filled.mgz $hemivalue \
                ../mri/$norm_vol ../mri/filled-pretess$hemivalue.mgz)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    set xopts = `fsr-getxopts mri_tessellate $XOptsFile`;
    set cmd = (mri_tessellate $xopts ../mri/filled-pretess$hemivalue.mgz \
                $hemivalue ../surf/$hemi.orig.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    set cmd = (rm -f ../mri/filled-pretess$hemivalue.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF

    # remove possible extra components, per f.segonne
    set xopts = `fsr-getxopts mris_extract_main_component $XOptsFile`;
    set cmd = (mris_extract_main_component $xopts ../surf/$hemi.orig.nofix \
               ../surf/$hemi.orig.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    echo $cmd > $touchdir/$hemi.tessellate.touch
  end # Loop over hemilist
endif


#----------------           -------------------#
##---------------  -smooth1 -------------------#
#----------------           -------------------#
if($DoSmooth1 && ( ! $longitudinal )) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Smooth1 $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set xopts = `fsr-getxopts mris_smooth $XOptsFile`;
    # -nw prevents it from writing curv and area
    set cmd = (mris_smooth -nw)
    if ($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts \
        ../surf/$hemi.orig.nofix ../surf/$hemi.smoothwm.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_smooth_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.smoothwm1.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------------            -------------------#
##---------------  -inflate1 -------------------#
#----------------            -------------------#
if($DoInflate1 && ( ! $longitudinal )) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Inflation1 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set xopts = `fsr-getxopts mris_inflate $XOptsFile`;
    set cmd = (mris_inflate)
    if($UseCuda) set cmd = (mris_inflate_cuda)
    set cmd = ($cmd  -no-save-sulc $xopts \
      ../surf/$hemi.smoothwm.nofix ../surf/$hemi.inflated.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_inflate_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.inflate1.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------------           -------------------#
##---------------  -qsphere -------------------#
#----------------           -------------------#
if($DoQSphere && ( ! $longitudinal )) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# QSphere $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set xopts = `fsr-getxopts mris_sphere $XOptsFile`;
    set cmd = (mris_sphere -q)
    if($UseCuda) set cmd = (mris_sphere_cuda -q)
    if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts)
    set cmd = ($cmd ../surf/$hemi.inflated.nofix ../surf/$hemi.qsphere.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_sphere_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.qsphere.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------------              -------------------#
#---------------- Fix Topology -------------------#
##---------------     -fix     -------------------#
#----------------              -------------------#
if($DoFix && ( ! $longitudinal )) then
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Fix Topology $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    # Must copy unfixed to fixed
    set cmd = (cp ../surf/$hemi.orig.nofix ../surf/$hemi.orig)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    set cmd = (cp ../surf/$hemi.inflated.nofix ../surf/$hemi.inflated)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
  end # hemi first loop

  set NewTopoFixHemiList = (); # to handle Old/NewTopoFix use cases

  # Now can run fixer
  if($UseOldTopoFix) then
    set CMDFS = () # see earlier notes on -parallel implementation
    foreach hemi ($hemilist)
      set xopts = `fsr-getxopts mris_fix_topology $XOptsFile`;
      set cmd = (mris_fix_topology)
      set cmd = ($cmd -mgz -sphere qsphere.nofix)
      if($FixWithGA) set cmd = ($cmd -ga)
      if($FixDiagOnly) set cmd = ($cmd -diagonly)
      if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
      set cmd = ($cmd $xopts $subjid $hemi)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($DoParallel) then
        set CMDF = mris_fix_topology_${hemi}.cmd
        echo "$cmd" > $CMDF
        set CMDFS = ( $CMDFS $CMDF )
      else
        if($RunIt) $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    end # hemi loop
    if($RunIt && $DoParallel) then # if -parallel flag is used
      reconbatchjobs $LF $CMDFS |& tee -a $LF
      if($status) goto error_exit;
    endif

    foreach hemi ($hemilist)
      # check if total defect index != 0, meaning, euler # != 2 (surface bad)
      set cmd = (mris_euler_number ../surf/$hemi.orig)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) then
        $cmd >& mris_euler_number.${hemi}.log
        if($status) goto error_exit;
        set defect_idx=`grep "total defect index" mris_euler_number.${hemi}.log | awk '{print $5}'`
        if("$defect_idx" != "0") then
          echo "mris_fix_topology failed on ${hemi}! (euler number != 2)" |& tee -a $LF
          echo "Trying mris_topo_fixer on ${hemi}..." |& tee -a $LF
          set UseNewTopoFix = 1
          set NewTopoFixHemiList = ($NewTopoFixHemiList $hemi)
          set UseOldTopoFix = 0
          # cannot use the failed ?h.orig surface, must revert to ?.orig.nofix
          set cmd = (cp ../surf/$hemi.orig.nofix ../surf/$hemi.orig)
          echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
          if($RunIt) $cmd |& tee -a $LF
          if($status) goto error_exit;
        endif
        cat mris_euler_number.${hemi}.log |& tee -a $LF
        rm -f mris_euler_number.${hemi}.log
      endif
    end # hemi loop
  endif # UseOldTopoFix

  # the 'new' topology fixer is run if either the 'old' one failed,
  # or if usage is flagged on the recon-all command-string (-use-new_fixer)
  if($UseNewTopoFix) then
    if($#NewTopoFixHemiList == 0) then
      set NewTopoFixHemiList = ($hemilist) # use command-line default
      # else use the bad hemi(s) found in prior euler-number check
    endif
    set CMDFS = () # see earlier notes on -parallel implementation
    foreach hemi ($NewTopoFixHemiList)
      set cmd = (cp ../surf/$hemi.qsphere.nofix ../surf/$hemi.qsphere)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
      set cmd = (cp ../surf/$hemi.smoothwm.nofix ../surf/$hemi.smoothwm)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
      set xopts = `fsr-getxopts mris_topo_fixer $XOptsFile`;
      set cmd = (mris_topo_fixer -mgz -warnings)
      if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
      set cmd = ($cmd $xopts $subjid $hemi)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($DoParallel) then
        set CMDF = mris_topo_fixer_${hemi}.cmd
        echo "$cmd" > $CMDF
        set CMDFS = ( $CMDFS $CMDF )
      else
        if($RunIt) $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    end # hemi loop
    if($RunIt && $DoParallel) then # if -parallel flag is used
      reconbatchjobs $LF $CMDFS |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif # UseNewTopoFix

  # run surface intersection checker/fixer
  foreach hemi ($hemilist)
    set xopts = `fsr-getxopts mris_remove_intersection $XOptsFile`;
    set cmd = (mris_remove_intersection)
    set cmd = ($cmd $xopts ../surf/$hemi.orig ../surf/$hemi.orig)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    # Remove hemi.inflated, real one created after mris_make_surfaces
    set cmd = (rm ../surf/$hemi.inflated)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd
    if($UseNewTopoFix && -e ../surf/$hemi.orig_corrected ) then
      # Copy *h.orig_corrected to *h.orig.  orig_corrected is created
      # by mris_topo_fixer, which runs only when mris_fix_topology fails,
      # which could happen for one hemi and not the other, so check
      # if it exists prior to the copy in addition to checking the
      # UseNewTopoFix flag.
      set cmd = (cp ../surf/$hemi.orig_corrected ../surf/$hemi.orig )
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.topofix.touch
  end # Loop over hemilist
endif

# Smooth2 and Inflate2 stages run after make white surfs


#----------------                     -------------------#
#---------------- Make White Surfaces -------------------#
##---------------       -white        -------------------#
#----------------                     -------------------#
if($DoWhiteSurfs) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Make White Surf $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF

    if( $longitudinal ) then
      set cmd = (cp -vf $longbasedir/surf/${hemi}.white \
                        $subjdir/surf/${hemi}.orig)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;

      set cmd = (cp -vf $longbasedir/surf/${hemi}.white \
                        $subjdir/surf/${hemi}.orig_white)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;

      # also copy pial just in case (needed if $DoPialSurf == 0 below)
      set cmd = (cp -vf $longbasedir/surf/${hemi}.pial \
                        $subjdir/surf/${hemi}.orig_pial)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif

    # Note mris_make_surfaces uses filled.mgz implicitly
    set xopts = `fsr-getxopts mris_make_surfaces $XOptsFile`;
    if($longitudinal) then
      # longitudinal processing:
      set cmd = (mris_make_surfaces \
          -orig_white orig_white \
          -orig orig_white \
          -long \
          -max 3.5)
    else
      # default stream:
      set cmd = (mris_make_surfaces)
    endif
    if ($UseAseg) then
      set cmd = ($cmd -aseg ../mri/aseg.presurf)
    else
      set cmd = ($cmd -noaseg)
    endif
    set cmd = ($cmd -noaparc)
    if($DoPialSurfs) then
      # if creating pial downstream, then only do white surface now
      set cmd = ($cmd -whiteonly)
    else
      # else old-style single-run -finalsurfs is emulated
      if($longitudinal) set cmd = ($cmd -orig_pial orig_pial)
    endif
    set cmd = ($cmd -mgz -T1 brain.finalsurfs)
    set cmd = ($cmd $WMSeg_wlo $WMSeg_ghi $xopts $subjid $hemi)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_make_surfaces_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.white_surface.touch
    if( ! $DoPialSurfs) echo $cmd > $touchdir/$hemi.final_surfaces.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then # if -parallel flag is used
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------------           -------------------#
##---------------  -smooth2 -------------------#
#----------------           -------------------#
if($DoSmooth2) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Smooth2 $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set xopts = `fsr-getxopts mris_smooth $XOptsFile`;
    # Use -nw to keep from writing out curv and area
    # Default number of iterations is 10, but use 3 here
    set cmd = (mris_smooth -n 3 -nw)
    if ($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts)
    set cmd = ($cmd ../surf/$hemi.white ../surf/$hemi.smoothwm)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_smooth_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.smoothwm2.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------------            -------------------#
##---------------  -inflate2 -------------------#
#----------------            -------------------#
if($DoInflate2) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Inflation2 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set xopts = `fsr-getxopts mris_inflate $XOptsFile`;
    set cmd = (mris_inflate)
    if($UseCuda) set cmd = (mris_inflate_cuda)
    set cmd = ($cmd $xopts ../surf/$hemi.smoothwm \
               ../surf/$hemi.inflated)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_inflate_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.inflate2.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------                     -----------#
#---------- Curvature .H and .K -----------#
##---------       -curvHK       -----------#
#----------                     -----------#
if($DoCurvHK) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Curv .H and .K $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/surf > /dev/null
    $PWD |& tee -a $LF
    # create curvature files ?h.white.H and ?h.white.K
    set xopts = `fsr-getxopts mris_curatvure $XOptsFile`;
    set cmd = (mris_curvature -w $xopts $hemi.white)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_curvature_white_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.white.H.K.touch

    # create curvature files ?h.inflated.H and ?h.inflated.K
    set xopts = `fsr-getxopts mris_curatvure $XOptsFile`;
    set cmd = (mris_curvature -thresh .999 -n -a 5 -w -distances 10 10)
    set cmd = ($cmd $xopts $hemi.inflated)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_curvature_inflated_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.inflate.H.K.touch
  end # Loop over hemilist

  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
  foreach hemi ($hemilist)
    if( ! -e ${hemi}.white.H) goto error_exit;
    if( ! -e ${hemi}.inflated.H) goto error_exit;
  end
endif


#----------                            -----------#
#---------- Curvature Anatomical Stats -----------#
##---------        -curvstats          -----------#
#----------                            -----------#
if($DoCurvStats) then
  foreach hemi ($hemilist)
    echo "\n#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Curvature Stats $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/surf > /dev/null
    $PWD |& tee -a $LF
    set stats = ../stats/$hemi.curv.stats
    set xopts = `fsr-getxopts mris_curvature_stats $XOptsFile`;
    set cmd = (mris_curvature_stats -m --writeCurvatureFiles -G \
            -o $stats -F smoothwm \
            $xopts $subjid $hemi curv sulc);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    #if($status) goto error_exit;
    if(-e .xdebug_mris_curvature_stats) rm -f .xdebug_mris_curvature_stats
    echo $cmd > $touchdir/$hemi.curvstats.touch
  end # Loop over hemilist
endif


#-----------             -------------#
##---------- AUTORECON 3 -------------#
#-----------             -------------#


#----------------          ----------------#
##---------------  -sphere ----------------#
#----------------          ----------------#
if($DoSphere) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Sphere $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    if($longitudinal) then
      # longitudinal processing:
      set cmd = (cp $longbasedir/surf/$hemi.sphere $subjdir/surf/$hemi.sphere)
    else
      # default stream:
      set xopts = `fsr-getxopts mris_sphere $XOptsFile`;
      set cmd = (mris_sphere)
      if($UseCuda) set cmd = (mris_sphere_cuda)
      if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
      if($UseNoNeg) set cmd = ($cmd -remove_negative 1)
      set cmd = ($cmd $xopts)
      set cmd = ($cmd ../surf/$hemi.inflated ../surf/$hemi.sphere)
    endif
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_sphere_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.sphmorph.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------------                      -------------------#
#---------------- Surface Registration -------------------#
##---------------       -surfreg       -------------------#
#----------------                      -------------------#
if($DoSurfReg) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Surf Reg $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set AvgTif = ${AvgCurvTifPath}/$hemi.${AvgCurvTif}
    set xopts = `fsr-getxopts mris_register $XOptsFile`;
    set cmd = (mris_register -curv)
    if($UseNoNeg) set cmd = ($cmd -remove_negative 1)
    set cmd = ($cmd $xopts)
    if($longitudinal) then
      # longitudinal processing:
      set cmd = ($cmd  -nosulc -norot \
                    $longbasedir/surf/$hemi.sphere.reg \
                    $AvgTif \
                    ../surf/$hemi.sphere.reg)
    else
      # default stream:
      set cmd = ($cmd ../surf/$hemi.sphere $AvgTif ../surf/$hemi.sphere.reg)
    endif
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_register_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.sphreg.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#--------                             ---------#
#-------- Contra Surface Registration ---------#
##-------   -contrasurfreg            ---------#
##-------   -contrasurfreg-subj       ---------#
#--------                             ---------#

# Registers ipsi and contra
if($DoContraSurfReg) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    if($hemi == lh) then
      set nothemi = rh;
    else
      set nothemi = lh;
    endif
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Contra Surf Reg $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set AvgTif = ${AvgCurvTifPath}/$nothemi.${AvgCurvTif}
    set xopts = `fsr-getxopts mris_register $XOptsFile`;
    set cmd = (mris_register -curv -reverse ../surf/$hemi.sphere)
    if($UseNoNeg) set cmd = ($cmd -remove_negative 1)
    set cmd = ($cmd $xopts)
    set cmd = ($cmd $AvgTif ../surf/$hemi.$nothemi.sphere.reg)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_register_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.sphreg.contra.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif

# Register ipsi to contra directly (instead of thru sphere)
# Creates lh.rh.sphere (note that there is no .reg)
if($DoContraSurfRegWithinSubject) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    cd $subjdir/surf
    $PWD |& tee -a $LF
    if($hemi == lh) then
      set nothemi = rh;
    else
      set nothemi = lh;
    endif
    if(! -e $nothemi.inflated.H) then
      echo "ERROR: cannot find $nothemi.inflated.H, try running -inflate2" \
          |& tee -a $LF
      goto error_exit;
    endif
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Contra Surf Reg Within Subject $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    set cmd = (mris_register -dist 0.3 -reverse -1 \
       ./$hemi.sphere ./$nothemi.sphere ./$hemi.$nothemi.sphere)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_register_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.sphere.contra.touch
  end # hemi
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------                                         ----------------#
#---------- Surface Registration to Average Subject ----------------#
##---------           -surfreg-to-subject           ----------------#
#----------                                         ----------------#
if($#SurfRegToSubj) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Surf RegTo $SurfRegToSubj $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set AvgTif = $SUBJECTS_DIR/$SurfRegToSubj/$hemi.reg.template.tif
    set outreg =  ../surf/$hemi.sphere.$SurfRegToSubj.reg
    set cmd = (mris_register -curv)
    if($UseNoNeg) set cmd = ($cmd -remove_negative 1)
    set cmd = ($cmd ../surf/$hemi.sphere $AvgTif $outreg);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_register_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.sphreg.$SurfRegToSubj.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------------                  -------------------#
##---------------  -jacobian_white -------------------#
#----------------                  -------------------#
if($DoJacobianWhite) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Jacobian white $hemi `date`" \
        |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    # produce the jacobian, from the white surface to the sphere
    set cmd = (mris_jacobian \
                ../surf/$hemi.white \
                ../surf/$hemi.sphere.reg \
                ../surf/$hemi.jacobian_white)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_jacobian_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.jacobian_white.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#---                                                                  ---#
#--- Surface Registration, allow maximal distortion, produce Jacobian ---#
##--                        -jacobian_dist0                           ---#
#---                                                                  ---#
if($DoJacobianDist0) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Jacobian dist0 $hemi `date`" \
        |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set AvgTif = ${AvgCurvTifPath}/$hemi.${AvgCurvTif}
    set xopts = `fsr-getxopts mris_register $XOptsFile`;
    set cmd = (mris_register -curv -norot -jacobian \
        ../surf/$hemi.jacobian_dist0 -dist 0)
    set cmd = ($cmd $xopts)
    set cmd = ($cmd ../surf/$hemi.sphere.reg $AvgTif \
        ../surf/$hemi.sphere.dist0.jacobian.reg)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_register_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.jacobian_dist0.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#---------------                          ---------------#
#--------------- Average Curv for Display ---------------#
##--------------         -avgcurv         ---------------#
#---------------                          ---------------#
if($DoAvgCurv) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# AvgCurv $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set AvgTif = ${AvgCurvTifPath}/$hemi.${AvgCurvTif}
    set xopts = `fsr-getxopts mrisp_paint $XOptsFile`;
    # -a 5 means to smooth 5 iterations
    set cmd = (mrisp_paint -a 5 $xopts "$AvgTif#6" \
      ../surf/$hemi.sphere.reg ../surf/$hemi.avg_curv)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mrisp_paint_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.avgcurv.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------------                       -----------------#
#---------------- Cortical Parcellation -----------------#
##---------------       -cortparc       -----------------#
#----------------                       -----------------#
if($DoCortParc) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Cortical Parc $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set xopts = `fsr-getxopts mris_ca_label $XOptsFile`;
    set CPAtlas = ${GCSDIR}/$hemi.$GCS
    set annot = ../label/$hemi.aparc.annot
    set cmd = (mris_ca_label)
    if($UseAseg) set cmd = ($cmd -l ../label/$hemi.cortex.label)
    if($UseAseg) set cmd = ($cmd -aseg ../mri/aseg.presurf.mgz)
    if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts)
    if($longitudinal) then
      # longitudinal:
      set cmd = ($cmd -long -R $longbasedir/label/${hemi}.aparc.annot)
    endif
    set cmd = ($cmd $subjid $hemi ../surf/$hemi.sphere.reg $CPAtlas $annot)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_ca_label_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.aparc.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------------                    -------------------#
#---------------- Make Pial Surfaces -------------------#
##---------------       -pial        -------------------#
#----------------                    -------------------#
if($DoPialSurfs) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Make Pial Surf $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF

    if( $longitudinal && ! -e $subjdir/surf/${hemi}.orig_pial ) then
    # should rarely get here as this is copied above in Make White Surfaces
      set cmd = (cp -vf $longbasedir/surf/${hemi}.pial\
                        $subjdir/surf/${hemi}.orig_pial)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif

    # Note mris_make_surfaces uses filled.mgz implicitly
    set xopts = `fsr-getxopts mris_make_surfaces $XOptsFile`;
    if($longitudinal) then
      # longitudinal processing:
      set cmd = (mris_make_surfaces \
          -orig orig_white \
          -orig_white orig_white \
          -orig_pial orig_pial \
          -long -max 3.5)
    else
      # default stream:
      # NJS: -orig_pial white added 16Feb2015 per BF
      set cmd = (mris_make_surfaces \
          -orig_white white \
          -orig_pial white)
      if ($UseFixMtl) then
        # NJS: now external flag option, 3Jun2015
        set cmd = ($cmd -fix_mtl)
      endif
    endif
    if ($UseAseg) then
      set cmd = ($cmd -aseg ../mri/aseg.presurf)
    else
      set cmd = ($cmd -noaseg)
    endif
    if ($PialNoAparc) set cmd = ($cmd -noaparc)
    # -nowhite : do not refit white surface (nothing wrt white gets overwritten)
    set cmd = ($cmd -nowhite)
    set cmd = ($cmd -mgz -T1 brain.finalsurfs)
    set cmd = ($cmd $WMSeg_wlo $WMSeg_ghi $xopts $subjid $hemi);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_make_surfaces_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.pial_surface.touch
    echo $cmd > $touchdir/$hemi.final_surfaces.touch
  end # Loop hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------------                                     ----------------#
#---------------- Refine Pial Surfaces Using T2/FLAIR ----------------#
##---------------     -T2pial  and  -FLAIRpial        ----------------#
#----------------                                     ----------------#
# note: the registration portion requires existence of both surfaces
if($DoT2pial || $DoFLAIRpial) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Refine Pial Surfs w/ T2/FLAIR `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/scripts > /dev/null

  # should be one or the other.  'check_params' section checks for this.
  if($DoT2pial) set t2flair=(T2)
  if($DoFLAIRpial) set t2flair=(FLAIR)

  set mdir=$SUBJECTS_DIR/${subjid}/mri
  set sdir=$SUBJECTS_DIR/${subjid}/surf
  set tdir=$SUBJECTS_DIR/${subjid}/touch

  if (! -e $mdir/${t2flair}.mgz) then

    set t2flairraw = $mdir/orig/${t2flair}raw.mgz

    # Longitudinal processing
    if ($longitudinal) then

      # use T2/FLAIR raw from cross if missing in long
      if (! -e $t2flairraw) then
        set t2flairraw = ${SUBJECTS_DIR}/${tpNid}/mri/orig/${t2flair}raw.mgz
      endif
      if (! -e $t2flairraw) then
        echo "ERROR: mri/orig/${t2flair}raw.mgz missing in long and cross." \
          |& tee -a $LF
        goto error_exit;
      endif

      # concatenate lta if created in cross (T2cross->T1cross->longspace)
      # this avoids registering again if already done in cross
      if ( -e ${SUBJECTS_DIR}/${tpNid}/mri/transforms/${t2flair}raw.lta ) then
        set cmd = (mri_concatenate_lta )
        set cmd = ($cmd ${SUBJECTS_DIR}/${tpNid}/mri/transforms/${t2flair}raw.lta )
        set cmd = ($cmd $tpNtobase_regfile $mdir/transforms/${t2flair}raw.lta)
        echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
        if($RunIt) $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      else
        # if t2flairraw.lta does not exist in cross, register T2raw to longspace
        set xopts = `fsr-getxopts bbregister $XOptsFile`;
        set bbcmd = (bbregister \
            --s $subjid \
            --mov $t2flairraw \
            --lta $mdir/transforms/${t2flair}raw.lta \
            --init-$BBRInit \
            --T2 $xopts)
        echo "\n $bbcmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) $fs_time $bbcmd |& tee -a $LF
        if($status) goto error_exit;
      endif

    else #regular processing, register T2flairraw to T1 and create lta

      set LTAAuto = $mdir/transforms/${t2flair}raw.auto.lta 
      set LTAMan = $mdir/transforms/${t2flair}raw.lta 
      set DontCopy = 0
      if(-e $LTAAuto && -e $LTAMan) then
        set DontCopy = `diff $LTAAuto $LTAMan | grep -v \# | grep -v filename | wc -l`
      endif

      # first create a T2/FLAIR that is registered to the T1s
      set xopts = `fsr-getxopts bbregister $XOptsFile`;
      set bbcmd = (bbregister \
          --s $subjid \
          --mov $t2flairraw \
          --lta $LTAAuto \
          --init-$BBRInit \
          --T2 $xopts)
      echo "\n $bbcmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $bbcmd |& tee -a $LF
      if($status) goto error_exit;

      if($DontCopy == 0) then
        set cmd = (cp $LTAAuto $LTAMan)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif

    endif

    # both regular and long processing:

    # actually map the input (and make conform as the T1 target)
    set mapcmd = (mri_convert \
        -odt short \
        -at $mdir/transforms/${t2flair}raw.lta)
    if($UseCubic) set mapcmd = ($mapcmd -rt cubic -ns 1)
    set mapcmd = ($mapcmd -rl $mdir/orig.mgz )
    set mapcmd = ($mapcmd $t2flairraw )
    set mapcmd = ($mapcmd $mdir/${t2flair}.prenorm.mgz )
    echo "\n $mapcmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $mapcmd |& tee -a $LF
    if($status) goto error_exit;

    # then give the T2/FLAIR a little normalizing
    # note: pre-normalized file remains for debug, with .prenorm in name
    set normcmd = (mri_normalize \
        -sigma 0.5 -nonmax_suppress 0 -min_dist 1 \
        -aseg $mdir/aseg.presurf.mgz \
        -surface $sdir/rh.white identity.nofile \
        -surface $sdir/lh.white identity.nofile \
        $mdir/${t2flair}.prenorm.mgz \
        $mdir/${t2flair}.mgz)
    echo "\n $normcmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $normcmd |& tee -a $LF
    if($status) goto error_exit;
  endif

  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    $PWD |& tee -a $LF
    set xopts = `fsr-getxopts mris_make_surfaces $XOptsFile`;
    set nv1=(`mris_info $sdir/${hemi}.pial |& grep nvertices`)
    set nv2=(`mris_info $sdir/${hemi}.wo${t2flair}.pial |& grep nvertices`)
    set touch1=($tdir/${hemi}.pial_refine.touch)
    set touch2=($tdir/${hemi}.pial_surface.touch)
    if ( (! -e $sdir/${hemi}.wo${t2flair}.pial) || \
         ("$nv1" != "$nv2") || \
         (`UpdateNeeded $touch1 $touch2`) ) then
      set cmd = (cp -v $sdir/${hemi}.pial $sdir/${hemi}.wo${t2flair}.pial)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    set cmd = (mris_make_surfaces \
        -orig_white white \
        -orig_pial wo${t2flair}.pial)
    if ($UseAseg) then
      set cmd = ($cmd -aseg ../mri/aseg.presurf)
    else
      set cmd = ($cmd -noaseg)
    endif
    if ($PialNoAparc) set cmd = ($cmd -noaparc)
    # -nowhite : do not refit white surface (nothing wrt white gets overwritten)
    set cmd = ($cmd -nowhite)
    set cmd = ($cmd -mgz -T1 brain.finalsurfs)
    # if using a T2 or FLAIR to remove dura that might be confused with pial...
    if($DoT2pial) then
      set cmd = ($cmd -T2 ../mri/T2 -nsigma_above 2 -nsigma_below 5)
      if($#T2max) set cmd = ($cmd -T2_max $T2max);
    endif
    if ($DoFLAIRpial) set cmd = ($cmd -FLAIR ../mri/FLAIR \
        -nsigma_above 3 -nsigma_below 3)
    set cmd = ($cmd $WMSeg_wlo $WMSeg_ghi $xopts $subjid $hemi);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_make_surfaces_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.pial_refine.touch
  end # for each hemi
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif

  # redo ?h.volume files
  if(-e $subjdir/surf/rh.volume || -e $subjdir/surf/lh.volume) then
    foreach hemi ($hemilist)
      echo "#--------------------------------------------" |& tee -a $LF |& tee -a $CF
      echo "#@# Surf Volume $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
      cd $subjdir/surf > /dev/null
      $PWD |& tee -a $LF
      set cmd = (vertexvol --s $subjid --$hemi -$TH3Opt)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
      echo $cmd > $touchdir/$hemi.surfvolume.touch
    end # Loop over hemilist
  endif

endif # if correct pial w/ T2/FLAIR


# stats and GWcontrast must run here, after T2 pial refinement


#----------------              -------------------#
##---------------  -surfvolume -------------------#
#----------------              -------------------#
if($DoPialSurfs || $DoT2pial || $DoFLAIRpial || $DoSurfVolume) then
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Surf Volume $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/surf > /dev/null
    $PWD |& tee -a $LF
    set cmd = (vertexvol --s $subjid --$hemi -$TH3Opt)
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.surfvolume.touch
  end # Loop over hemilist
endif

#----------------                 ------------------#
#---------------- Cortical Ribbon ------------------#
##---------------   -cortribbon   ------------------#
#----------------                 ------------------#
if($DoCortRibbonVolMask) then
  echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
  echo "#@# Cortical ribbon mask `date`" \
      |& tee -a $SF|& tee -a $LF|& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mris_volmask $XOptsFile`;
  set cmd = (mris_volmask \
    --aseg_name aseg.presurf \
    --label_left_white   2 --label_left_ribbon   3 \
    --label_right_white 41 --label_right_ribbon 42 \
    --save_ribbon $subjid)
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/cortical_ribbon.touch
endif


#----------                          -----------#
#---------- Surface Anatomical Stats -----------#
##---------       -parcstats         -----------#
#----------                          -----------#
if($DoParcStats) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Parcellation Stats $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set annot = ../label/$hemi.aparc.annot
    set ctab  = ../label/aparc.annot.ctab
    set xopts = `fsr-getxopts mris_anatomical_stats $XOptsFile`;
    foreach surfname (white pial)
      if($surfname == white) set stats = ../stats/$hemi.aparc.stats
      if($surfname == pial)  set stats = ../stats/$hemi.aparc.pial.stats
      set cmd = (mris_anatomical_stats $TH3Opt -mgz)
      if($UseAseg) set cmd = ($cmd -cortex ../label/$hemi.cortex.label)
      set cmd = ($cmd -f $stats -b -a $annot -c $ctab $xopts \
        $subjid $hemi $surfname);
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($DoParallel) then
        set CMDF = mris_anatomical_stats_${hemi}_${surfname}.cmd
        echo "$cmd" > $CMDF
        set CMDFS = ( $CMDFS $CMDF )
      else
        if($RunIt) $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    end
    echo $cmd > $touchdir/$hemi.aparcstats.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------------                         -----------------#
#---------------- Cortical Parcellation 2 -----------------#
##---------------       -cortparc2        -----------------#
#----------------                         -----------------#
if($DoCortParc2) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#-----------------------------------------"\
      |& tee -a $LF |& tee -a $CF
    echo "#@# Cortical Parc 2 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set xopts = `fsr-getxopts mris_ca_label $XOptsFile`;
    set CPAtlas = ${GCSDIR}/${hemi}.${DESTRIEUX_GCS}
    set annot = ../label/$hemi.aparc.${DESTRIEUX_NAME}.annot
    set cmd = (mris_ca_label)
    if($UseAseg) set cmd = ($cmd -l ../label/$hemi.cortex.label)
    if($UseAseg) set cmd = ($cmd -aseg ../mri/aseg.presurf.mgz)
    if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts)
    if($longitudinal) then
      # longitudinal:
      set cmd = ($cmd -long -R \
                   $longbasedir/label/${hemi}.aparc.${DESTRIEUX_NAME}.annot)
    endif
    set cmd = ($cmd $subjid $hemi ../surf/$hemi.sphere.reg $CPAtlas $annot)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_ca_label_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.aparc2.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------                            ------------#
#---------- Surface Anatomical Stats 2 ------------#
##---------         -parcstats2         -----------#
#----------                            ------------#
if($DoParcStats2) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Parcellation Stats 2 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set annot = ../label/$hemi.aparc.${DESTRIEUX_NAME}.annot
    set stats = ../stats/$hemi.aparc.${DESTRIEUX_NAME}.stats
    set ctab  = ../label/aparc.annot.${DESTRIEUX_NAME}.ctab
    set xopts = `fsr-getxopts mris_anatomical_stats $XOptsFile`;
    set cmd = (mris_anatomical_stats  $TH3Opt -mgz)
    if($UseAseg) set cmd = ($cmd -cortex ../label/$hemi.cortex.label)
    set cmd = ($cmd -f $stats -b -a $annot -c $ctab $xopts $subjid $hemi white);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_anatomical_stats_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.aparcstats2.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------------                         -----------------#
#---------------- Cortical Parcellation 3 -----------------#
##---------------       -cortparc3        -----------------#
#----------------                         -----------------#
if($DoCortParc3) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#-----------------------------------------"\
      |& tee -a $LF |& tee -a $CF
    echo "#@# Cortical Parc 3 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set xopts = `fsr-getxopts mris_ca_label $XOptsFile`;
    set CPAtlas = ${GCSDIR}/${hemi}.${DKTATLAS40_GCS}
    set annot = ../label/$hemi.aparc.${DKTATLAS40_NAME}.annot
    set cmd = (mris_ca_label)
    if($UseAseg) set cmd = ($cmd -l ../label/$hemi.cortex.label)
    if($UseAseg) set cmd = ($cmd -aseg ../mri/aseg.presurf.mgz)
    if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts)
    if($longitudinal) then
      # longitudinal:
      set cmd = ($cmd -long -R \
                   $longbasedir/label/${hemi}.aparc.${DKTATLAS40_NAME}.annot)
    endif
    set cmd = ($cmd $subjid $hemi ../surf/$hemi.sphere.reg $CPAtlas $annot)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_ca_label_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.aparc2.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------                            -----------#
#---------- Surface Anatomical Stats 3 -----------#
##---------         -parcstats3        -----------#
#----------                            -----------#
if($DoParcStats3) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Parcellation Stats 3 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set annot = ../label/$hemi.aparc.${DKTATLAS40_NAME}.annot
    set stats = ../stats/$hemi.aparc.${DKTATLAS40_NAME}.stats
    set ctab  = ../label/aparc.annot.${DKTATLAS40_NAME}.ctab
    set xopts = `fsr-getxopts mris_anatomical_stats $XOptsFile`;
    set cmd = (mris_anatomical_stats  $TH3Opt -mgz)
    if($UseAseg) set cmd = ($cmd -cortex ../label/$hemi.cortex.label)
    set cmd = ($cmd -f $stats -b -a $annot -c $ctab $xopts $subjid $hemi white);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_anatomical_stats_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.aparcstats3.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#----------                ----------#
#---------- WM/GM Contrast ----------#
##---------  -pctsurfcon   ----------#
#----------                ----------#
# for longitutinal stream, skip in base (as rawavg does not exist)
if($DoPctSurfCon && ( ! $DoCreateBaseSubj )) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# WM/GM Contrast $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set xopts = `fsr-getxopts pctsurfcon $XOptsFile`;
    set cmd = (pctsurfcon --s $subjid)
    if($hemi == lh) set cmd = ($cmd --lh-only)
    if($hemi == rh) set cmd = ($cmd --rh-only)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = pctsurfcon_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.pctsurfcon.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#-----------------                         ------------------#
#----------------- Relabel Hypointensities ------------------#
##----------------      -hyporelabel       ------------------#
#-----------------                        ------------------ #
if($DoRelabelHypos) then
  echo "#-----------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Relabel Hypointensities `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF
  set cmd = (mri_relabel_hypointensities \
    aseg.presurf.mgz ../surf aseg.presurf.hypos.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/relabelhypos.touch
endif


#-----------------               -----------------#
##----------------  -aparc2aseg  -----------------#
#-----------------               -----------------#
if($DoAParc2ASeg) then
  echo "#-----------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# AParc-to-ASeg `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir > /dev/null
  $PWD |& tee -a $LF
  set xopts = `fsr-getxopts mri_aparc2aseg $XOptsFile`;
  # Desikan (or whatever was specified by -gcs)
  set cmd = (mri_aparc2aseg --s $subjid --volmask \
    --aseg aseg.presurf.hypos $xopts)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/aparc2aseg.touch
  # Now do Christophe's (if exist, which they may not, if -nocortparc2 used)
  if( -e ${subjdir}/label/lh.aparc.${DESTRIEUX_NAME}.annot && \
      -e ${subjdir}/label/rh.aparc.${DESTRIEUX_NAME}.annot ) then
    set xopts = `fsr-getxopts mri_aparc2aseg $XOptsFile`;
    set cmd = (mri_aparc2aseg --s $subjid --volmask \
        --aseg aseg.presurf.hypos --${DESTRIEUX_NAME} $xopts)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/aparc.${DESTRIEUX_NAME}2aseg.touch
  else
    echo "INFO: skipping ${DESTRIEUX_NAME} aparc2aseg" \
    |& tee -a $LF |& tee -a $CF
  endif
endif


#-----------------             ------------------ #
#-----------------  Final Aseg ------------------ #
##----------------  -apas2aseg ------------------ #
#-----------------             ------------------ #
if($DoAPas2ASeg) then
  echo "#-----------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# APas-to-ASeg `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF
  set cmd = (apas2aseg --i aparc+aseg.mgz --o aseg.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/apas2aseg.touch
endif


#--------------            --------------#
##-------------  -segstats --------------#
#--------------            --------------#
if($DoSegStats) then
  # Stats on the automatic segmentation
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# ASeg Stats `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir > /dev/null
  $PWD |& tee -a $LF
  set xopts = `fsr-getxopts mri_segstats $XOptsFile`;
  set cmd = (mri_segstats --seg mri/aseg.mgz --sum stats/aseg.stats)
  set cmd = ($cmd --pv mri/norm.mgz --empty)
  set cmd = ($cmd --brainmask mri/brainmask.mgz --brain-vol-from-seg)
  set cmd = ($cmd --excludeid 0 --excl-ctxgmwm)
  if ( -e mri/ribbon.mgz ) then
    set cmd = ($cmd --supratent)
  else
    echo "\nINFO: mri_segstats will not calculate Supratentorial" |& tee -a $LF
    echo "      due to missing ribbon.mgz file" |& tee -a $LF
  endif
  set cmd = ($cmd --subcortgray)
  set cmd = ($cmd --in mri/norm.mgz --in-intensity-name norm)
  set cmd = ($cmd --in-intensity-units MR)
  if ( -e mri/transforms/talairach.xfm ) then
    set cmd = ($cmd --etiv);
  else
    echo "\nINFO: mri_segstats will not calculate eTIV" |& tee -a $LF
    echo "      due to missing talairach.xfm file" |& tee -a $LF
  endif
  if ( ( -e surf/lh.white ) && ( -e surf/rh.white ) ) then
    set cmd = ($cmd --surf-wm-vol)
    if ( ( -e surf/lh.pial ) && ( -e surf/rh.pial ) ) then
      set cmd = ($cmd --surf-ctx-vol --totalgray)
    else
      echo "\nINFO: ?h.pial surfaces not available to mri_segstats.\n"\
       |& tee -a $SF |& tee -a $LF |& tee -a $CF
    endif
  else
    echo "\nINFO: ?h.white surfaces not available to mri_segstats.\n"\
     |& tee -a $SF |& tee -a $LF |& tee -a $CF
  endif
  if( ( -e surf/lh.orig.nofix ) && ( -e surf/rh.orig.nofix ) ) then
     set cmd = ($cmd --euler)
  endif
  set cmd = ($cmd --ctab $FREESURFER_HOME/ASegStatsLUT.txt)
  set cmd = ($cmd --subject $subjid $xopts);
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/segstats.touch
endif


#-----------------          ------------------#
##----------------  -wmparc ------------------#
#-----------------          ------------------#
if($DoWMParc) then
  echo "#-----------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# WMParc `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir > /dev/null
  $PWD |& tee -a $LF
  set xopts = `fsr-getxopts mri_aparc2aseg $XOptsFile`;
  set cmd = (mri_aparc2aseg --s $subjid --labelwm --hypo-as-wm --rip-unknown \
             --volmask --o mri/wmparc.mgz --ctxseg aparc+aseg.mgz $xopts )
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/wmaparc.touch
  # Do wm segstats while we're here
  set cmd = (mri_segstats)
  set cmd = ($cmd --seg mri/wmparc.mgz --sum stats/wmparc.stats \
    --pv mri/norm.mgz --excludeid 0 \
    --brainmask mri/brainmask.mgz --in mri/norm.mgz --in-intensity-name norm \
    --in-intensity-units MR --subject $subjid --surf-wm-vol \
    --ctab $FREESURFER_HOME/WMParcStatsLUT.txt )
  if ( -e mri/transforms/talairach.xfm ) then
    set cmd = ($cmd --etiv);
  else
    echo "INFO: mri_segstats will not calculate eTIV" |& tee -a $LF
    echo "      due to missing talairach.xfm file" |& tee -a $LF
  endif
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/wmaparc.stats.touch
endif


#--------------                    -----------------#
##-------------  -aparc+aseg-stats -----------------#
#--------------                    -----------------#
# This is not something you want to do in general. The volumes
# of cortical structures should be obtained from the aparc.stats,
# but getting the intensity means and stddevs can be useful.
if($DoAParcASegStats) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# AParcASeg Stats `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir > /dev/null
  set xopts = `fsr-getxopts mri_segstats $XOptsFile`;
  set cmd = (mri_segstats)
  set cmd = ($cmd --seg mri/aparc+aseg.mgz --sum stats/aparc+aseg.stats)
  set cmd = ($cmd --pv mri/norm.mgz )
  set cmd = ($cmd --excludeid 0 --ctab-default --empty)
  set cmd = ($cmd --brain-vol-from-seg --brainmask mri/brainmask.mgz)
  set cmd = ($cmd --in mri/norm.mgz --in-intensity-name norm)
  set cmd = ($cmd --in-intensity-units MR)
  set cmd = ($cmd --subject $subjid);
  if ( -e mri/transforms/talairach.xfm ) then
    set cmd = ($cmd --etiv);
  else
    echo "INFO: mri_segstats will not calculate eTIV" |& tee -a $LF
    echo "      due to missing talairach.xfm file" |& tee -a $LF
  endif
  set cmd = ($cmd $xopts);
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/aparc+aseg.stats.touch
endif


#--------                      --------#
#-------- Brodmann Area Labels --------#
##-------      -balabels       --------#
#--------                      --------#
# Create Brodmann area labels by mapping from fsaverage,
# then create the ?h.BA_exvivo.annot file from these labels,
# then generate a ?h.BA_exvivo.stats file from that annot.
if ($DoBaLabels) then
  cd $subjdir/label
  $PWD |& tee -a $LF

  # if fsaverage is not in subjects dir, put it there
  set HaveFsAverage=1;
  if ( ! -e $SUBJECTS_DIR/fsaverage) then
    echo "INFO: fsaverage subject does not exist in SUBJECTS_DIR" \
      |& tee -a $LF |& tee -a $CF
    set HaveFsAverage=0;
  else
    # check if the latest-greatest fsaverage is here (which would not be
    # the case if running on subjects processed by an older version)
    if ( ! -e $SUBJECTS_DIR/fsaverage/label/lh.entorhinal_exvivo.thresh.label) then
      echo "INFO: fsaverage subject does not have uptodate *rhinal labels!" \
        |& tee -a $LF |& tee -a $CF
      set HaveFsAverage=0;
      set cmd=(rm -Rf fsaverage)
      echo "\n cd $SUBJECTS_DIR; $cmd; cd - \n"|& tee -a $LF |& tee -a $CF
      cd $SUBJECTS_DIR
      if($RunIt && -e fsaverage) $fs_time $cmd |& tee -a $LF
      cd -
    endif
  endif
  if ( ! $HaveFsAverage ) then
    echo "INFO: Creating symlink to fsaverage subject..." \
      |& tee -a $LF |& tee -a $CF
    set cmd=(ln -s $FREESURFER_HOME/subjects/fsaverage)
    echo "\n cd $SUBJECTS_DIR; $cmd; cd - \n"|& tee -a $LF |& tee -a $CF
    cd $SUBJECTS_DIR
    if($RunIt && ! -e fsaverage) $fs_time $cmd |& tee -a $LF
    cd -
  endif

  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
        |& tee -a $LF |& tee -a $CF
    echo "#@# BA_exvivo Labels $hemi `date`" \
        |& tee -a $SF |& tee -a $LF |& tee -a $CF

    # generate label
    set CMDFS = () # see earlier notes on -parallel implementation
    foreach balabel (BA1_exvivo \
                     BA2_exvivo \
                     BA3a_exvivo \
                     BA3b_exvivo \
                     BA4a_exvivo \
                     BA4p_exvivo \
                     BA6_exvivo \
                     BA44_exvivo \
                     BA45_exvivo \
                     V1_exvivo \
                     V2_exvivo \
                     MT_exvivo \
                     entorhinal_exvivo \
                     perirhinal_exvivo)
      set cmd=(mri_label2label \
        --srcsubject fsaverage \
        --srclabel $SUBJECTS_DIR/fsaverage/label/${hemi}.${balabel}.label \
        --trgsubject $subjid \
        --trglabel ./${hemi}.${balabel}.label \
        --hemi ${hemi} \
        --regmethod surface)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($DoParallel) then
        set CMDF = mri_label2label_${balabel}_${hemi}.cmd
        echo "$cmd" > $CMDF
        set CMDFS = ( $CMDFS $CMDF )
      else
        if($RunIt) $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    end # balabel
    if($RunIt && $DoParallel) then
      reconbatchjobs $LF $CMDFS |& tee -a $LF
      if($status) goto error_exit;
    endif

    # generate .thresh labels
    set CMDFS = () # see earlier notes on -parallel implementation
    foreach balabel (BA1_exvivo \
                     BA2_exvivo \
                     BA3a_exvivo \
                     BA3b_exvivo \
                     BA4a_exvivo \
                     BA4p_exvivo \
                     BA6_exvivo \
                     BA44_exvivo \
                     BA45_exvivo \
                     V1_exvivo \
                     V2_exvivo \
                     MT_exvivo \
                     entorhinal_exvivo \
                     perirhinal_exvivo)
      set cmd=(mri_label2label \
        --srcsubject fsaverage \
        --srclabel $SUBJECTS_DIR/fsaverage/label/${hemi}.${balabel}.thresh.label \
        --trgsubject $subjid \
        --trglabel ./${hemi}.${balabel}.thresh.label \
        --hemi ${hemi} \
        --regmethod surface)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($DoParallel) then
        set CMDF = mri_label2label_${balabel}_${hemi}.cmd
        echo "$cmd" > $CMDF
        set CMDFS = ( $CMDFS $CMDF )
      else
        if($RunIt) $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    end # balabel
    if($RunIt && $DoParallel) then
      reconbatchjobs $LF $CMDFS |& tee -a $LF
      if($status) goto error_exit;
    endif

    # create .annot
    set cmd=(mris_label2annot \
        --s $subjid \
        --hemi $hemi \
        --ctab $FREESURFER_HOME/average/colortable_BA.txt \
        --l $hemi.BA1_exvivo.label \
        --l $hemi.BA2_exvivo.label \
        --l $hemi.BA3a_exvivo.label \
        --l $hemi.BA3b_exvivo.label \
        --l $hemi.BA4a_exvivo.label \
        --l $hemi.BA4p_exvivo.label \
        --l $hemi.BA6_exvivo.label \
        --l $hemi.BA44_exvivo.label \
        --l $hemi.BA45_exvivo.label \
        --l $hemi.V1_exvivo.label \
        --l $hemi.V2_exvivo.label \
        --l $hemi.MT_exvivo.label \
        --l $hemi.entorhinal_exvivo.label \
        --l $hemi.perirhinal_exvivo.label \
        --a BA_exvivo \
        --maxstatwinner \
        --noverbose )
    if($RunIt) if ( -e ./$hemi.BA_exvivo.annot) rm -fv ./$hemi.BA_exvivo.annot
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    # create .thresh.annot
    set cmd=(mris_label2annot \
        --s $subjid \
        --hemi $hemi \
        --ctab $FREESURFER_HOME/average/colortable_BA.txt \
        --l $hemi.BA1_exvivo.thresh.label \
        --l $hemi.BA2_exvivo.thresh.label \
        --l $hemi.BA3a_exvivo.thresh.label \
        --l $hemi.BA3b_exvivo.thresh.label \
        --l $hemi.BA4a_exvivo.thresh.label \
        --l $hemi.BA4p_exvivo.thresh.label \
        --l $hemi.BA6_exvivo.thresh.label \
        --l $hemi.BA44_exvivo.thresh.label \
        --l $hemi.BA45_exvivo.thresh.label \
        --l $hemi.V1_exvivo.thresh.label \
        --l $hemi.V2_exvivo.thresh.label \
        --l $hemi.MT_exvivo.thresh.label \
        --l $hemi.entorhinal_exvivo.thresh.label \
        --l $hemi.perirhinal_exvivo.thresh.label \
        --a BA_exvivo.thresh \
        --maxstatwinner \
        --noverbose )
    if($RunIt) if ( -e ./$hemi.BA_exvivo.thresh.annot) rm -fv ./$hemi.BA_exvivo.thresh.annot
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    # generate stats
    set annot = ./$hemi.BA_exvivo.annot
    set stats = ../stats/$hemi.BA_exvivo.stats
    set ctab  = ./BA_exvivo.ctab
    set xopts = `fsr-getxopts mris_anatomical_stats $XOptsFile`;
    set cmd = (mris_anatomical_stats  $TH3Opt -mgz -f $stats \
            -b -a $annot -c $ctab $xopts $subjid $hemi white);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    # generate .thresh stats
    set annot = ./$hemi.BA_exvivo.thresh.annot
    set stats = ../stats/$hemi.BA_exvivo.thresh.stats
    set ctab  = ./BA_exvivo.thresh.ctab
    set xopts = `fsr-getxopts mris_anatomical_stats $XOptsFile`;
    set cmd = (mris_anatomical_stats  $TH3Opt -mgz -f $stats \
            -b -a $annot -c $ctab $xopts $subjid $hemi white);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

  end # hemi
endif # DoBaLabels


#----------            ------------#
##---------  -label-V1 ------------#
#----------            ------------#
if($DoLabelV1) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Label V1 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    if ( ! -e $SUBJECTS_DIR/V1_average) then
      echo "ERROR: V1_average subject does not exist in SUBJECTS_DIR!"
      goto error_exit;
    endif
    cd $subjdir/label > /dev/null
    $PWD |& tee -a $LF
    set cmd=(predict_v1.sh)
    if( ! $RunIt) set cmd=($cmd -p)
    set cmd = ($cmd -h $hemi $subjid);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = predicit_v1_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.label_v1.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif


#--------                          --------#
#-------- Entorhinal Cortex Labels --------#
##-------  -label-exvivo-ec-avg    --------#
#--------                          --------#
# create entorhinal cortex labels by mapping from exvivo subjects,
# then generate ?h.EC_exvivo_average.stats files
if ($DoLabelExvivoEC) then
  cd $subjdir/label
  $PWD |& tee -a $LF
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
        |& tee -a $LF |& tee -a $CF
    echo "#@# Ex-vivo Entorhinal Cortex Label $hemi `date`" \
        |& tee -a $SF |& tee -a $LF |& tee -a $CF
    if ( ! -e $SUBJECTS_DIR/${hemi}.EC_average) then
      echo "INFO: ${hemi}.EC_average subject does not exist in SUBJECTS_DIR" \
        |& tee -a $LF |& tee -a $CF
      echo "INFO: Creating symlink to ${hemi}.EC_average subject..." \
        |& tee -a $LF |& tee -a $CF
      set cmd=(ln -s $FREESURFER_HOME/subjects/${hemi}.EC_average)
      echo "\n cd $SUBJECTS_DIR; $cmd; cd - \n"|& tee -a $LF |& tee -a $CF
      cd $SUBJECTS_DIR
      if($RunIt && ! -e ${hemi}.EC_average) $fs_time $cmd |& tee -a $LF
      cd -
    endif

    # generate label
    set cmd = (mris_spherical_average \
                 -erode 1 \
                 -orig white \
                 -t 0.4 \
                 -o ${subjid} \
                 label ${hemi}.entorhinal \
                 $hemi sphere.reg \
                 ${hemi}.EC_average \
                 ${hemi}.EC_exvivo_average.label)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    # generate stats
    set label = ./$hemi.EC_exvivo_average.label
    set stats = ../stats/$hemi.EC_exvivo_average.stats
    set xopts = `fsr-getxopts mris_anatomical_stats $XOptsFile`;
    set cmd = (mris_anatomical_stats  $TH3Opt -mgz -f $stats \
            -b -l $label $xopts $subjid $hemi white);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

  end # hemi
endif # DoLabelExvivoEC


#--------------                        -----------------#
#--------------  Hippocampal Subfields -----------------#
##-----------   -hippocampal-subfields-T1  -------------#
##-----------   -hippocampal-subfields-T1T2  -----------#
##-----------   -hippocampal-subfields-T2  -------------#
#--------------                        -----------------#
#--------------  Brainstem Substructures ---------------#
##-----------   -brainstem-structures  -----------------#
#--------------                        -----------------#

# For substructure segmentation of hippocampus or brainstem: check if Matlab runtime is there
if ($DoHippoSF_T1 || $DoHippoSF_T1T2 || $DoHippoSF_T2 || $DoBSsubst) then      

  if ( ! -e ${FREESURFER_HOME}/MCRv80/bin/glnxa64/libdctprocess.so \
    && ! -e ${FREESURFER_HOME}/MCRv80/bin/maci64/libdctprocess.jnilib  ) then
    echo "     "
    echo "ERROR: cannot find Matlab 2012b runtime in location:"
    echo "     "
    echo "${FREESURFER_HOME}/MCRv80"
    echo "     "
    echo "It is looking for either: "
    echo "  bin/glnxa64/libdctprocess.so    (Linux 64b) or"
    echo "  bin/maci64/libdctprocess.jnilib (Mac 64b)"
    echo " "
    echo "You will need to download the Matlab Compiler Runtime (MCR) for Matlab 2012b." 
    echo "To do so, please run the following commands (you might need root permissions):"
    echo " "
    echo "LINUX:"
    echo " "
    echo "cd ${FREESURFER_HOME}"
    echo "curl "\""http://surfer.nmr.mgh.harvard.edu/fswiki/MatlabRuntime?action=AttachFile&do=get&target=runtime2012bLinux.tar.gz"\"" -o "\""runtime2012b.tar.gz"\"""
    echo "tar xvf runtime2012b.tar.gz"
    echo " "
    echo "MAC:"
    echo " "
    echo "cd ${FREESURFER_HOME}"
    echo "curl "\""http://surfer.nmr.mgh.harvard.edu/fswiki/MatlabRuntime?action=AttachFile&do=get&target=runtime2012bMAC.tar.gz"\"" -o "\""runtime2012b.tar.gz"\"""
    echo "tar xvf runtime2012b.tar.gz"
    echo " "
    echo " "
    echo "For further details, please visit:"
    echo "     "
    echo "https://surfer.nmr.mgh.harvard.edu/fswiki/MatlabRuntime"
    echo " "
    goto error_exit;
  endif
endif

# brainstem structures: make sure required files from from default freesurfer processing are in there
if ($DoBSsubst) then 
  if (! -e ${subjdir}/mri/aseg.mgz || \
      ! -e ${subjdir}/mri/norm.mgz ) then
    echo "ERROR: cannot find norm.mgz or aseg.mgz for the subject."
    echo "ERROR: Maybe, run recon-all again or disable segmentation of brainstem substructures."
    goto error_exit;
  endif #checking of aseg.mgz and norm.mgz 
endif

# hippocampal subfields: make sure required files from default freesurfer processing are in there, and convert hemilist
if ($DoHippoSF_T1 || $DoHippoSF_T1T2 || $DoHippoSF_T2) then 
  if (! -e ${subjdir}/mri/wmparc.mgz || \
      ! -e ${subjdir}/mri/norm.mgz || \
      ! -e ${subjdir}/mri/transforms/talairach.xfm ) then
    echo "ERROR: cannot find wmparc.mgz or aseg.mgz or talairach.xfm for the subject."
    echo "ERROR: Maybe, run recon-all again or disable hippocampal subfields processing."
    goto error_exit;
  endif #checking of wmparc.mgz, norm.mgz and talairach.xfm

  # these tools assume 'left' and 'right' instead of our usual 'lh' and 'rh'
  if($#hemilist == 1) then
    if ("$hemilist" == "lh") set hippohemilist=(left)
    if ("$hemilist" == "rh") set hippohemilist=(right)
  else
    set hippohemilist=(left right)
  endif
endif


#--------------                        -----------------#
##-----------   -brainstem-structures  -----------------#
#--------------                        -----------------#
if($DoBSsubst) then
  set BSSLOG = ($subjdir/scripts/brainstem-structures.log)
  rm -f $BSSLOG
  echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF |& tee -a $BSSLOG
  echo "#@# Segmentation of brainstem substructures  `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF |& tee -a $BSSLOG

  # segmentation of brainstem structures
  set cmd = ( ${FREESURFER_HOME}/bin/segmentBS.sh \
    ${FREESURFER_HOME}/MCRv80 \
    $FREESURFER_HOME \
    $subjid  \
    $SUBJECTS_DIR )
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  echo "See log file: $BSSLOG"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $BSSLOG
  if($status) goto error_exit;

  echo $cmd > $touchdir/brainstem-structures.touch
endif

#--------------                        -----------------#
##-----------   -hippocampal-subfields-T1  -------------#
#--------------                        -----------------#
if($DoHippoSF_T1) then
  set HSFLOG = ($subjdir/scripts/hippocampal-subfields-T1.log)
  rm -f $HSFLOG

  # do hippocampal processing using just T1 data
  foreach hemi ($hippohemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF |& tee -a $HSFLOG
    echo "#@# Hippocampal Subfields processing (T1 only) $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF |& tee -a $HSFLOG
    
    set cmd = ( ${FREESURFER_HOME}/bin/segmentSF_T1.sh \
      ${FREESURFER_HOME}/MCRv80 \
      $FREESURFER_HOME \
      $subjid  \
      $SUBJECTS_DIR \
      $hemi )
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    echo "See log file: $HSFLOG"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $HSFLOG
    if($status) goto error_exit;
  end

  echo $cmd > $touchdir/hippo-subfields-T1.touch
endif

#--------------                        -----------------#
##------------- -hippocampal-subfields-T1T2  -----------#
#--------------                        -----------------#
if($DoHippoSF_T1T2) then 
  set HSFLOG = ($subjdir/scripts/hippocampal-subfields-T1T2.log)
  rm -f $HSFLOG

  # do hippocampal processing
  foreach hemi ($hippohemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF |& tee -a $HSFLOG
    echo "#@# Hippocampal Subfields processing (T1 + T2 volume) $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF |& tee -a $HSFLOG

    set cmd = ( ${FREESURFER_HOME}/bin/segmentSF_T1T2.sh \
      ${FREESURFER_HOME}/MCRv80 \
      $FREESURFER_HOME \
      $subjid  \
      $SUBJECTS_DIR \
      $T2volHippoSF \
      $hemi \
      $UserSuffix )
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    echo "See log file: $HSFLOG"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $HSFLOG
    if($status) goto error_exit;
  end

  echo $cmd > $touchdir/hippo-subfields-T1T2.touch
endif

#--------------                        -----------------#
##------------- -hippocampal-subfields-T2  -------------#
#--------------                        -----------------#
if($DoHippoSF_T2) then 

  set HSFLOG = ($subjdir/scripts/hippocampal-subfields-T2.log)
  rm -f $HSFLOG
  
  # do hippocampal processing
  foreach hemi ($hippohemilist)
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF |& tee -a $HSFLOG
    echo "#@# Hippocampal Subfields processing (T2 only) $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF |& tee -a $HSFLOG

    set cmd = ( ${FREESURFER_HOME}/bin/segmentSF_T2.sh \
      ${FREESURFER_HOME}/MCRv80 \
      $FREESURFER_HOME \
      $subjid  \
      $SUBJECTS_DIR \
      $T2volHippoSF \
      $hemi \
      $UserSuffix )
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    echo "See log file: $HSFLOG"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $HSFLOG
    if($status) goto error_exit;
  end
  
  echo $cmd > $touchdir/hippo-subfields-T2.touch
endif


#--------                          --------#
#-------- Local Gyrification Index --------#
##-------           -lgi           --------#
#--------                          --------#
if ($DoLocalGyriIndex) then
  cd $subjdir/surf
  $PWD |& tee -a $LF
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
        |& tee -a $LF |& tee -a $CF
    echo "#@# Local Gyrification Index $hemi `date`" \
        |& tee -a $SF |& tee -a $LF |& tee -a $CF
    set cmd=(mris_compute_lgi --i ${hemi}.pial)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = mris_compute_lgi_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  end # hemi
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif # DoLocalGyriIndex


#-----------------          ------------------#
##----------------  -qcache ------------------#
#-----------------          ------------------#
# Create the smoothed surfaces to fsaverage target needed by Qdec.
if ($DoQdecCache) then
  # check for the target subject 'fsaverage' (if using as default target)
  # and create symlink from distribution dir if not found in subjects dir
  if (("${target}" == "fsaverage") && ( ! -e $SUBJECTS_DIR/fsaverage)) then
    echo "INFO: fsaverage subject does not exist in SUBJECTS_DIR" \
      |& tee -a $LF |& tee -a $CF
    echo "INFO: Creating symlink to fsaverage subject..." \
      |& tee -a $LF |& tee -a $CF
    set cmd=(ln -s $FREESURFER_HOME/subjects/fsaverage)
    echo "\n cd $SUBJECTS_DIR; $cmd; cd - \n"|& tee -a $LF |& tee -a $CF
    cd $SUBJECTS_DIR
    if($RunIt && ! -e fsaverage) $fs_time $cmd |& tee -a $LF
    cd -
  endif

  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    foreach measure ($measurelist)
      echo "#--------------------------------------------" \
          |& tee -a $LF |& tee -a $CF
      echo "#@# Qdec Cache preproc $hemi $measure $target `date`" \
          |& tee -a $SF |& tee -a $LF |& tee -a $CF

      if ("${measuredir}" != "") then
        cd ${measuredir}
      else
        cd $subjdir/surf
      endif
      $PWD |& tee -a $LF

      set MeasFile=(${hemi}.${measure})
      # strip .mgz from filename (does nothing if not .mgz extension):
      set MeasFile=`basename ${MeasFile} .mgz`
      set MeasFile=(${MeasFile}.${target})
      set cmd=(mris_preproc \
          --s ${subjid} \
          --hemi ${hemi} \
          --meas ${measure} \
          --target ${target} \
          --out ${MeasFile}.mgh)
      if ("${measuredir}" != "") set cmd = ($cmd --surfdir ${measuredir})
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($DoParallel) then
        set CMDF = mris_preproc_${hemi}_${measure}_${target}.cmd
        echo "$cmd" > $CMDF
        set CMDFS = ( $CMDFS $CMDF )
      else
        if($RunIt) $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    end # measure
  end # hemi
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif

  # now surf2surf
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    foreach measure ($measurelist)
      set MeasFile=(${hemi}.${measure})
      # strip .mgz from filename (does nothing if not .mgz extension):
      set MeasFile=`basename ${MeasFile} .mgz`
      set MeasFile=(${MeasFile}.${target})
      foreach fwhm ($fwhmlist)
        echo "#--------------------------------------------" \
            |& tee -a $LF |& tee -a $CF
        echo "#@# Qdec Cache surf2surf $hemi $measure fwhm$fwhm $target `date`" \
            |& tee -a $SF |& tee -a $LF |& tee -a $CF
        set OutFile=(${hemi}.${measure})
        # strip .mgz from filename (does nothing if not .mgz extension):
        set OutFile=`basename ${OutFile} .mgz`
        set OutFile=(${OutFile}.fwhm${fwhm}.${target})
        set cmd=(mri_surf2surf --prune\
            --s ${target} \
            --hemi ${hemi} \
            --fwhm ${fwhm} \
            --sval ${MeasFile}.mgh \
            --tval ${OutFile}.mgh)
        if($SmoothCortexOnly)   set cmd = ($cmd --cortex)
        if(! $SmoothCortexOnly) set cmd = ($cmd --no-cortex)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($DoParallel) then
          set CMDF = mris_surf2surf_${hemi}_${measure}_${fwhm}_${target}.cmd
          echo "$cmd" > $CMDF
          set CMDFS = ( $CMDFS $CMDF )
        else
          if($RunIt) $fs_time $cmd |& tee -a $LF
          if($status) goto error_exit;
        endif
        echo $cmd > $touchdir/${hemi}.${measure}.${fwhm}.qcache.touch
      end # fwhm
    end # measure
  end # hemi
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif

  # file move
  foreach hemi ($hemilist)
    foreach measure ($measurelist)
      foreach fwhm ($fwhmlist)
        set OutFile=(${hemi}.${measure})
        # strip .mgz from filename (does nothing if not .mgz extension):
        set OutFile=`basename ${OutFile} .mgz`
        set OutFile=(${OutFile}.fwhm${fwhm}.${target})
        if($RunIt) then
          if ("${measuredir}" != "") then
            set cmd = (mv -v ${OutFile}.mgh $subjdir/surf)
            echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
            $cmd |& tee -a $LF
          endif
        endif
        echo $cmd > $touchdir/$hemi.$measure.$fwhm.qcache.touch
      end # fwhm
    end # measure
  end # hemi

  if($RunIt) rm -Rf tmp.mris_preproc.* # cleanup
endif # DoQdecCache


#----------                                     --------------#
#---------- Surface Vertices Number Match Check --------------#
##---------             -vno-check              --------------#
#----------                                     --------------#
if($DoVnoMatchCheck) then
  set CMDFS = () # see earlier notes on -parallel implementation
  foreach hemi ($hemilist)
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Vno Match Check $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF
    set cmd = (vno_match_check $subjid $hemi);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($DoParallel) then
      set CMDF = vno_match_check_${hemi}.cmd
      echo "$cmd" > $CMDF
      set CMDFS = ( $CMDFS $CMDF )
    else
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.vnomatchcheck.touch
  end # Loop over hemilist
  if($RunIt && $DoParallel) then
    reconbatchjobs $LF $CMDFS |& tee -a $LF
    if($status) goto error_exit;
  endif
endif



#--------------                    ----------------#
##-------------  END OF RECON-ALL  ----------------#
#--------------                    ----------------#

echo "" |& tee -a $LF
echo "#------------------------------------------" |& tee -a $LF
echo "" |& tee -a $LF

set EndTime = `date`;
set tSecEnd = `date '+%s'`;
@ tSecRun = $tSecEnd - $tSecStart;
set tRunHours = `echo $tSecRun/3600|bc -l`
set tRunHours = `printf %6.3f $tRunHours`
echo "Started at $StartTime " |& tee -a $LF
echo "Ended   at $EndTime" |& tee -a $LF
echo "#@#%# recon-all-run-time-hours $tRunHours" |& tee -a $LF

if($#NotifyFile != 0) then
  echo "INFO: touching notification file $NotifyFile" |& tee -a $LF
  touch $NotifyFile
endif

if($DoIsRunning && $#IsRunningFile) rm -f $IsRunningFile

# Create the Done File
echo "------------------------------" > $DoneFile
echo "SUBJECT $subjid" >> $DoneFile
echo "START_TIME $StartTime"     >> $DoneFile
echo "END_TIME $EndTime"     >> $DoneFile
echo "RUNTIME_HOURS $tRunHours" >> $DoneFile
echo "USER $user"      >> $DoneFile
echo "HOST `hostname`" >> $DoneFile
echo "PROCESSOR `uname -m`" >> $DoneFile
echo "OS `uname -s`"       >> $DoneFile
echo "UNAME `uname -a`"  >> $DoneFile
echo "VERSION $VERSION"    >> $DoneFile
echo "CMDPATH $0"          >> $DoneFile
echo "CMDARGS $argv0"      >> $DoneFile

echo "recon-all -s $subjid finished without error at `date`" \
    |& tee -a $LF |& tee -a $SF

if($#mailuser != 0) then
  echo "recon-all -s $subjid finished without error at `date`" | \
    mail -s "$subjid DONE `date`" $mailuser
endif

echo "done"

# add to usage tracking file, if configured and writable
# a sysadmin would need to have users set the environment var
# RECONALL_USAGE_FILE to a world-writable file. example:
# setenv RECONALL_USAGE_FILE /space/freesurfer/recon-all_run_log
if($?RECONALL_USAGE_FILE) then
  if(-e $RECONALL_USAGE_FILE) then
    if(-w $RECONALL_USAGE_FILE) then
      if ($RunIt) then
        echo "`date` `cat $FREESURFER_HOME/build-stamp.txt`" \
            >> $RECONALL_USAGE_FILE
        endif
      endif
  endif
endif

exit 0

#--------------                  ----------------#
##-------------  EXIT RECON-ALL  ----------------#
#--------------                  ----------------#

#-------------------------------------------------#
error_exit:
#-------------------------------------------------#
  uname -a | tee -a $LF | tee -a $SF
  echo "" |& tee -a $LF |& tee -a $SF
  echo "recon-all -s $subjid exited with ERRORS at `date`" \
    |& tee -a $LF |& tee -a $SF
  echo "" |& tee -a $LF |& tee -a $SF
  echo "For more details, see the log file $LF"
  echo "To report a problem, see http://surfer.nmr.mgh.harvard.edu/fswiki/BugReporting"|& tee -a $LF
  echo ""
  # Handle IsRunningFile
  if($DoIsRunning && $#IsRunningFile) rm -f $IsRunningFile
  # Mail the user
  if($#mailuser != 0) then
    echo "recon-all -s $subjid finished with errors at `date`" | \
      mail -s "$subjid ERROR `date`" $mailuser
  endif
  # Create an error file with date, cmd, etc of error
  if ( $?ErrorFile ) then
    echo "------------------------------" > $ErrorFile
    echo "SUBJECT $subjid" >> $ErrorFile
    echo "DATE `date`"     >> $ErrorFile
    echo "USER $user"      >> $ErrorFile
    echo "HOST `hostname`" >> $ErrorFile
    echo "PROCESSOR `uname -m`" >> $ErrorFile
    echo "OS `uname -s`"       >> $ErrorFile
    uname -a         >> $ErrorFile
    echo $VERSION    >> $ErrorFile
    echo $0          >> $ErrorFile
    echo "PWD `pwd`" >> $ErrorFile
    echo "CMD $cmd"  >> $ErrorFile
  endif
  if($?DoneFile) then
    echo "1" > $DoneFile
  endif
  # Finally exit
  exit 1;
endif

#-------------------------------------------------#
parse_args:
#-------------------------------------------------#
set cmdline = ($argv);
while( $#argv != 0 )

  set flag = $argv[1]; shift;

  switch($flag)

    case "-subject":
    case "-subjid":
    case "-sid":
    case "-s":
      if ( $#argv < 1) goto arg1err;
      set subjid = $argv[1]; shift;
      set subjid = `basename $subjid`; # removes trailing /
      breaksw

    case "-sb":
      # Hidden option: same as -s but no basename;
      # needed when passing a subdir of a subject
      # as a subject as with xhemi
      if( $#argv < 1) goto arg1err;
      set subjid = $argv[1]; shift;
      breaksw

    case "-sd":
      if ( $#argv < 1) goto arg1err;
      setenv  SUBJECTS_DIR $argv[1]; shift;
      breaksw

    case "-i"
      if( $#argv < 1) goto arg1err;
      set InputVol = "$argv[1]"; shift;
      if(! -e "$InputVol") then
        echo "ERROR: cannot find $InputVol"
        goto error_exit;
      endif
      if (-d "$InputVol") then
        echo "ERROR: You cannot give recon-all a folder as input. It must be an image file."
        echo "If you have multiple files, you need multiple -i flags."
        goto error_exit;
      endif
      if(! -r "$InputVol") then
        echo "ERROR: $InputVol exists but is not readable"
        goto error_exit;
      endif
      set InVolDir  = `dirname  "$InputVol"`;
      set InVolBase = `basename "$InputVol"`;
      pushd $InVolDir > /dev/null
      set InVolDir = `pwd`;
      popd > /dev/null
      set InputVol = "$InVolDir/$InVolBase";
      set InputList = ($InputList "$InputVol");
      set DoConvertInput = 1;
      breaksw

    case "-T2"
    case "-t2"
      if( $#argv < 1) goto arg1err;
      set InputT2Vol = "$argv[1]"; shift;
      if(! -e "$InputT2Vol") then
        echo "ERROR: cannot find $InputT2Vol"
        goto error_exit;
      endif
      if(! -r "$InputT2Vol") then
        echo "ERROR: $InputT2Vol exists but is not readable"
        goto error_exit;
      endif
      set T2InVolDir  = `dirname  "$InputT2Vol"`;
      set T2InVolBase = `basename "$InputT2Vol"`;
      pushd $T2InVolDir > /dev/null
      set T2InVolDir = `pwd`;
      popd > /dev/null
      set InputT2Vol = "$T2InVolDir/$T2InVolBase";
      set DoConvertT2Input = 1;
      breaksw

    case "-t2max"
    case "-T2max"
    case "-T2_max"
      if( $#argv < 1) goto arg1err;
      set T2max = "$argv[1]"; shift;
      breaksw

    case "-FLAIR"
    case "-flair"
      if( $#argv < 1) goto arg1err;
      set InputFlairVol = "$argv[1]"; shift;
      if(! -e "$InputFlairVol") then
        echo "ERROR: cannot find $InputFlairVol"
        goto error_exit;
      endif
      if(! -r "$InputFlairVol") then
        echo "ERROR: $InputFlairVol exists but is not readable"
        goto error_exit;
      endif
      set FlairInVolDir  = `dirname  "$InputFlairVol"`;
      set FlairInVolBase = `basename "$InputFlairVol"`;
      pushd $FlairInVolDir > /dev/null
      set FlairInVolDir = `pwd`;
      popd > /dev/null
      set InputFlairVol = "$FlairInVolDir/$FlairInVolBase";
      set DoConvertFlairInput = 1;
      breaksw

    # flags -long, -no-orig-pial and -uselongbasectrlvol are all associated
    # with longitudinal processing
    case "-long":
    case "-longitudinal":
      set longitudinal = 1;
      set NoRandomness = 1;
      if ( $#argv < 2) goto arg1err;
      # get the subject name to use for timepoint
      set tpNid = $argv[1]; shift;
      set tpNid = `basename $tpNid`; # remove trailing /
      # get the subject to use for the base subject
      set longbaseid = $argv[1]; shift;
      set longbaseid = `basename $longbaseid`; # remove trailing /
      # and create subjid to reflect its longitudinal relation to longbaseid
      set subjid = ${tpNid}.long.${longbaseid}
      breaksw

    case "-uselongbasectrlvol":
      set UseLongbaseCtrlVol = 1;
      breaksw

    case "-uselongbasewmedits":
      set UseLongbaseWMedits = 1;
      breaksw

    case "-noasegfusion":
      set UseAsegFusion = 0;
      breaksw

    case "-addtp":
      # 'fake'-add a new timepoint
      set DoAddTp = 1;
      breaksw

    case "-base-affine":
      set DoAffineBase = 1;
      # don't break here, but also switch on -base:
    case "-base":
      if ( $#argv < 1) goto arg1err;
      set subjid = $argv[1]; shift;
      set subjid = `basename $subjid`; # removes trailing /
      set DoCreateBaseSubj = 1;
      set NoRandomness = 1;
      breaksw

    case "-base-init":
      set DoCreateBaseInput = 1;
      breaksw
    case "-nobase-init":
      set DoCreateBaseInput = 0;
      breaksw

    case "-base-tp":
    case "-tp":
      if ( $#argv < 1) goto arg1err;
      set basetpid = $argv[1]; shift;
      set basetpid = `basename $basetpid`; # removes trailing /
      set BaseSubjsList = ($BaseSubjsList $basetpid);
      if($DoCreateBaseSubj) then
        if ("$basetpid" == "$subjid") then
          echo "ERROR: you need to specify a new ID for the base/template. "
          echo "It cannot be one of the time points."
          echo "Find more info at:"
          echo "http://surfer.nmr.mgh.harvard.edu/fswiki/LongitudinalProcessing"
          exit 1;
        endif
      endif
      breaksw

    case "-base-invol":
      if ( $#argv < 1) goto arg1err;
      set BaseSubjInvol = $argv[1]; shift;
      breaksw

    case "-motioncor":
    case "-mc":
      set DoMotionCor = 1;
      breaksw
    case "-nomotioncor":
    case "-nomc":
      set DoMotionCor = 0;
      breaksw

    case "-robust-motioncor":
    case "-motioncor-robust":
      set DoMotionCor = 1;
      set DoRobustMotionCor = 1;
      breaksw
    case "-norobust-motioncor":
    case "-nomotioncor-robust":
      set DoRobustMotionCor = 0;
      breaksw

    case "-flirt-motioncor":
    case "-motioncor-flirt":
      set DoMotionCor = 1;
      set DoRobustMotionCor = 0;
      breaksw

    case "-3T":
    case "-3t":
      set UseYa3tTalAtlas = 1;
      set DoNuIntensityCor3T = 1;
      breaksw

    case "-talairach":
      set DoTalairach = 1;
      breaksw
    case "-talairach-nu":
      set DoTalairach = 1;
      set DoTalairachUseNu = 1;
      breaksw
    case "-notalairach":
    case "-no-talairach":
      set DoTalairach = 0;
      set DoTalCheck = 0;
      breaksw
    case "-use-mritotal":
      set UseMincMritotal = 1;
      breaksw
    case "-schwartzya3t-atlas":
      set UseYa3tTalAtlas = 1;
      breaksw
    case "-custom-tal-atlas":
      if ( $#argv < 1) goto arg1err;
      set CustomTalAtlas = $argv[1]; shift;
      breaksw

    case "-tal-check":
    case "-talairach-check":
    case "-talcheck":
      set DoTalCheck = 1;
      breaksw;
    case "-notal-check":
    case "-notalairach-check":
    case "-no-tal-check":
    case "-no-talairach-check":
    case "-notalcheck":
    case "-no-talcheck":
      set DoTalCheck = 0;
      breaksw;

    case "-deface":
      set DoDeface = 1;
      breaksw
    case "-nodeface":
      set DoDeface = 0;
      breaksw

    # note: norm3diters and normmaxgrads is applied to both runs of
    # mri_normalize.  use -norm1-b, -norm1-n, -norm2-b, -norm2-n to
    # distinguish -b and -n of the two mri_normalize runs
    case "-norm3diters":
      if ( $#argv < 1) goto arg1err;
      set Norm3dIters = $argv[1]; shift;
      breaksw

    case "-normmaxgrad":
      if ( $#argv < 1) goto arg1err;
      set NormMaxGrad = $argv[1]; shift;
      breaksw
    case "-norm1-b":
      if ( $#argv < 1) goto arg1err;
      set Norm1_b = $argv[1]; shift;
      breaksw
    case "-norm1-n":
      if ( $#argv < 1) goto arg1err;
      set Norm1_n = $argv[1]; shift;
      breaksw
    case "-norm2-b":
      if ( $#argv < 1) goto arg1err;
      set Norm2_b = $argv[1]; shift;
      breaksw
    case "-norm2-n":
      if ( $#argv < 1) goto arg1err;
      set Norm2_n = $argv[1]; shift;
      breaksw

    case "-normalization":
      set DoNormalization = 1;
      breaksw
    case "-nonormalization":
      set DoNormalization = 0;
      breaksw
    case "-normalization2":
      set DoNormalization2 = 1;
      breaksw
    case "-nonormalization2":
      set DoNormalization2 = 0;
      breaksw
    case "-usecontrolpoints":
      set UseControlPoints = 1;
      breaksw

    case "-maskbfs":
      set DoMaskBFS = 1;
      breaksw
    case "-nomaskbfs":
      set DoMaskBFS = 0;
      breaksw

    case "-skullstrip":
      set DoSkullStrip = 1;
      breaksw
    case "-noskullstrip":
      set DoSkullStrip = 0;
      breaksw

    case "-multistrip":
      set DoMultiStrip = 1;
      set DoSkullStrip = 1;
      set DoCleanPFH   = 1;
      breaksw
    case "-nomultistrip":
      set DoMultiStrip = 0;
      breaksw

    case "-watershed":
      echo $argv[1];
      if ( $#argv < 1 ) goto arg1err;
      switch($argv[1])
        case "nowatershed":
          set WaterShed = 0; breaksw;
        case "normal":
          set WaterShed = 1; breaksw;
        case "watershedonly":
          set WaterShed = 2; breaksw;
        case "watershedtemplate":
          set WaterShed = 3; breaksw;
        case "atlas":
          set WaterShed = 4; breaksw;
        default:
          echo "ERROR: -watershed argument $argv[1] unrecognized."
          echo "Valid arguments are: atlas, nowatershed, normal, watershedonly,"
          echo "and watershedtemplate."
          goto error_exit;
        breaksw;
      endsw
      shift;
      breaksw
    case "-wsless":
      set WSLess = 1; breaksw
    case "-wsmore":
      set WSMore = 1; breaksw
    case "-wsatlas":
      set WSAtlas = 1; breaksw
    case "-no-wsatlas":
      set WSAtlas = 0; breaksw
    case "-wsthresh":
      if ( $#argv < 1) goto arg1err;
      set WSPctPreFlood = $argv[1]; shift;
      breaksw
    case "-wsseed":
      if ( $#argv < 3) goto arg3err;
      set WSSeedPoint = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-wsgcaatlas":
      set WSGcaAtlas = 1; breaksw
    case "-nowsgcaatlas":
    case "-no-wsgcaatlas":
      set WSGcaAtlas = 0; breaksw
    case "-wstalxfm":
      set WSUseTalXfm = 1; breaksw
    case "-no-wstalxfm":
      set WSUseTalXfm = 0; breaksw
    case "-wscopy":
      set WSCopy = 1; breaksw

    case "-gcut":
      set DoGcut = 1;
      breaksw

    case "-no-gcut":
    case "-nogcut":
      set DoGcut = 0;
      breaksw

    case "-nuintensitycor":
    case "-nu_correct":
      set DoNuIntensityCor = 1;
      breaksw
    case "-nonuintensitycor":
      set DoNuIntensityCor = 0;
      breaksw

    case "-nuintensitycor-mask":
      set DoNuIntensityCor = 1;
      set UseMaskNuCorrect = 1;
      breaksw
    case "-nuintensitycor-nomask":
      set DoNuIntensityCor = 1;
      set UseMaskNuCorrect = 0;
      breaksw
    case "-nuintensitycor-mask-dilate":
      set DoNuIntensityCor = 1;
      set UseMaskNuCorrect = 1;
      if ( $#argv < 1) goto arg1err;
      set DilateMaskNuCorrect = $argv[1]; shift;
      breaksw
    case "-nuintensitycor-mask-nodilate":
      set DoNuIntensityCor = 1;
      set UseMaskNuCorrect = 1;
      set DilateMaskNuCorrect = ();
      breaksw

    case "-nuintensitycor-3T":
    case "-nuintensitycor-3t":
      set DoNuIntensityCor = 1;
      set DoNuIntensityCor3T = 1;
      breaksw

    case "-numakeuchar":
      set DoNuMakeUchar = 1;
      breaksw
    case "-no-numakeuchar":
    case "-nonumakeuchar":
      set DoNuMakeUchar = 0;
      breaksw

    case "-gcareg":
      set DoGCAReg = 1;
      breaksw
    case "-nogcareg":
      set DoGCAReg = 0;
      breaksw

    case "-careginv":
      set DoCARegInv = 1;
      breaksw
    case "-nocareginv":
      set DoCARegInv = 0;
      breaksw

    case "-canorm":
      set DoCANormalize = 1;
      breaksw
    case "-nocanorm":
      set DoCANormalize = 0;
      breaksw
    case "-canorm-usecps":
      set DoCANormalize = 1;
      set UseCPsWithCaNorm = 1;
      breaksw

    case "-careg":
      set DoCAReg = 1;
      breaksw
    case "-nocareg":
      set DoCAReg = 0;
      breaksw

    case "-seg-wlo"
      if( $#argv < 1) goto arg1err;
      set WMSeg_wlo = (-wlo $argv[1]); shift;
      breaksw
    case "-seg-ghi"
      if( $#argv < 1) goto arg1err;
      set WMSeg_ghi = (-ghi $argv[1]); shift;
      breaksw

    case "-ca-align":
      set UseCAAlign = (-align);
      breaksw
    case "-no-ca-align":
      set UseCAAlign = ();
      breaksw

    case "-ca-align-after":
      set UseCAAlignAfter = (-align-after);
      breaksw
    case "-no-ca-align-after":
      set UseCAAlignAfter = ();
      breaksw

    case "-rmneck":
      set DoRemoveNeck = 1;
      breaksw
    case "-normneck":
      set DoRemoveNeck = 0;
      breaksw

    case "-skull-lta":
      set DoSkullLTA  = 1;
      breaksw
    case "-noskull-lta":
      set DoSkullLTA  = 0;
      breaksw

    case "-calabel":
      set DoCALabel = 1;
      breaksw
    case "-nocalabel":
      set DoCALabel = 0;
      breaksw

    case "-asegmerge":
      set DoASegMerge = 1;
      breaksw
    case "-no-asegmerge":
      # Note: this will be overriden if DoCALabel=1
      set DoASegMerge = 0;
      breaksw

    case "-subcortseg":
      set DoGCAReg         = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 0;
      breaksw

    case "-nosubcortseg":
      set DoGCAReg         = 0;
      set DoRemoveNeck     = 0;
      set DoSkullLTA       = 0;
      set DoCANormalize    = 0;
      set DoCAReg          = 0;
      set DoCALabel        = 0;
      set DoSegStats       = 0;
      set NoNormMGZ        = 1;
      breaksw

    case "-noaseg":
      set UseAseg          = 0;
      set DoGCAReg         = 0;
      set DoRemoveNeck     = 0;
      set DoSkullLTA       = 0;
      set DoCANormalize    = 0;
      set DoCAReg          = 0;
      set DoCALabel        = 0;
      set DoSegStats       = 0;
      set NoNormMGZ        = 1;
      set DoAParc2ASeg     = 0;
      set DoAPas2ASeg      = 0;
      set DoWMParc         = 0;
      set DoCortRibbonVolMask = 0;
      breaksw

    case "-noaseg-inorm2":
      set NoAsegInorm2     = 1;
      breaksw

    case "-gca":
      if ( $#argv < 1) goto arg1err;
      set GCA = $argv[1]; shift;
      breaksw

    case "-twm":
      if ( $#argv < 1) goto arg1err;
      set UseTWMControlPoints = 1;
      set TWMControlPointsFile = $argv[1]; shift;
      if(! -e "$TWMControlPointsFile") then
        echo "ERROR: cannot find $TWMControlPointsFile"
        goto error_exit;
      endif
      breaksw

    case "-gca-skull":
      if ( $#argv < 1) goto arg1err;
      set GCASkull = $argv[1]; shift;
      breaksw

    case "-gca-dir":
      if ( $#argv < 1) goto arg1err;
      set GCADIR = $argv[1]; shift;
      breaksw

    case "-gcs":
      if ( $#argv < 1) goto arg1err;
      set GCS = $argv[1]; shift;
      breaksw

    case "-gcs-dir":
      if ( $#argv < 1) goto arg1err;
      set GCSDIR = $argv[1]; shift;
      breaksw

    case "-segmentation":
      set DoSegmentation = 1;
      breaksw
    case "-nosegmentation":
      set DoSegmentation = 0;
      breaksw

    case "-fill":
      set DoFill = 1;
      breaksw
    case "-nofill":
      set DoFill = 0;
      breaksw
    case "-pons-crs":
      if ( $#argv < 3) goto arg3err;
      set PonsSeedCRS = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-cc-crs":
      if ( $#argv < 3) goto arg3err;
      set CCSeedCRS = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-lh-crs":
      if ( $#argv < 3) goto arg3err;
      set LHSeedCRS = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-rh-crs":
      if ( $#argv < 3) goto arg3err;
      set RHSeedCRS = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw

    case "-tessellate":
    case "-tess":
      set DoTessellate = 1;
      breaksw
    case "-notessellate":
    case "-notess":
      set DoTessellate = 0;
      breaksw

    case "-smooth1":
      set DoSmooth1 = 1;
      breaksw
    case "-nosmooth1":
      set DoSmooth1 = 0;
      breaksw

    case "-inflate1":
      set DoInflate1 = 1;
      breaksw
    case "-noinflate1":
      set DoInflate1 = 0;
      breaksw

    case "-svinitinflated":
      set SvInitInflated = 1;
      breaksw
    case "-nosvinitinflated":
      set SvInitInflated = 0;
      breaksw

    case "-qsphere":
      set DoQSphere = 1;
      breaksw
    case "-noqsphere":
      set DoQSphere = 0;
      breaksw

    case "-fix":
      set DoFix = 1;
      breaksw
    case "-nofix":
      set DoFix = 0;
      breaksw

    case "-fix-with-ga":
      set FixWithGA = 1;
      breaksw

    case "-fix-with-ga-errflag":
      set DoFix = 1;
      set FixWithGA = 1;
      set FixWithErrFlag = 1;
      breaksw

    case "-no-fix-with-ga":
      set FixWithGA = 0;
      breaksw

    case "-fix-diag-only":
      set DoFix = 1;
      set FixWithGA = 1;
      set FixDiagOnly = 1;
      breaksw

    case "-use-old-fixer":
      set UseOldTopoFix = 1;
      set UseNewTopoFix = 0;
      breaksw

    case "-use-new-fixer":
      set UseOldTopoFix = 0;
      set UseNewTopoFix = 1;
      breaksw

    case "-whitesurfs":
    case "-white":
      set DoWhiteSurfs = 1;
      breaksw
    case "-nowhitesurfs":
    case "-nowhite":
      set DoWhiteSurfs = 0;
      breaksw

    case "-smooth2":
      set DoSmooth2 = 1;
      breaksw
    case "-nosmooth2":
      set DoSmooth2 = 0;
      breaksw

    case "-inflate2":
      set DoInflate2 = 1;
      breaksw
    case "-noinflate2":
      set DoInflate2 = 0;
      breaksw

    case "-curvHK":
      set DoCurvHK = 1;
      breaksw
    case "-nocurvHK":
      set DoCurvHK = 0;
      breaksw

    case "-curvstats":
      set DoCurvStats = 1;
      breaksw
    case "-nocurvstats":
      set DoCurvStats = 0;
      breaksw

    case "-sphere":
      set DoSphere = 1;
      breaksw
    case "-nosphere":
      set DoSphere = 0;
      breaksw

    case "-surfreg":
      set DoSurfReg = 1;
      breaksw
    case "-nosurfreg":
      set DoSurfReg = 0;
      breaksw

    # Specify an average subject, which will have a tif
    # in its directory. Output will be hemi.sphere.avgsubj.reg
    case "-surfreg-to-subject":
      if( $#argv < 1) goto arg1err;
      set SurfRegToSubj = $argv[1]; shift;
      breaksw
    case "-no-surfreg-to-subject":
      set SurfRegToSubj = ();
      breaksw

    case "-jacobian_white":
      set DoJacobianWhite = 1;
      breaksw
    case "-nojacobian_white":
      set DoJacobianWhite = 0;
      breaksw

    case "-jacobian_dist0":
      set DoJacobianDist0 = 1;
      breaksw
    case "-nojacobian_dist0":
      set DoJacobianDist0 = 0;
      breaksw

    case "-contrasurfreg":
      set DoContraSurfReg = 1;
      breaksw
    case "-nocontrasurfreg":
      set DoContraSurfReg = 0;
      breaksw

    case "-contrasurfreg-subj":
      set DoContraSurfRegWithinSubject = 1;
      breaksw
    case "-nocontrasurfreg-subj":
      set DoContraSurfRegWithinSubject = 0;
      breaksw

    case "-avgcurv":
      set DoAvgCurv = 1;
      breaksw
    case "-noavgcurv":
      set DoAvgCurv = 0;
      breaksw

    case "-cortparc":
      set DoCortParc = 1;
      breaksw
    case "-nocortparc":
      set DoCortParc = 0;
      breaksw

    case "-pialsurfs":
    case "-pial":
      set DoPialSurfs = 1;
      breaksw
    case "-nopialsurfs":
    case "-nopial":
      set DoPialSurfs = 0;
      breaksw

    case "-pial-noaparc":
    case "-pial_noaparc":
      set DoPialSurfs = 1;
      set PialNoAparc = 1;
      breaksw

    # backward compatibility with single-run mris_make_surfaces:
    case "-finalsurfs":
      set DoWhiteSurfs = 1;
      set DoPialSurfs = 0;
      set DoSurfVolume = 1;
      breaksw

    case "-nofinalsurfs":
      set DoWhiteSurfs = 0;
      set DoPialSurfs = 0;
      breaksw

    case "-surfvolume":
      set DoSurfVolume = 1;
      breaksw;

    case "-cortribbon":
      set DoCortRibbonVolMask = 1;
      breaksw
    case "-nocortribbon":
      set DoCortRibbonVolMask = 0;
      breaksw

    case "-parcstats":
      set DoParcStats = 1;
      breaksw
    case "-noparcstats":
      set DoParcStats = 0;
      breaksw

    case "-cortparc2":
      set DoCortParc2 = 1;
      breaksw
    case "-nocortparc2":
      set DoCortParc2 = 0;
      breaksw

    case "-parcstats2":
      set DoParcStats2 = 1;
      breaksw
    case "-noparcstats2":
      set DoParcStats2 = 0;
      breaksw

    case "-cortparc3":
      set DoCortParc3 = 1;
      breaksw
    case "-nocortparc3":
      set DoCortParc3 = 0;
      breaksw

    case "-parcstats3":
      set DoParcStats3 = 1;
      breaksw
    case "-noparcstats3":
      set DoParcStats3 = 0;
      breaksw

    case "-pctsurfcon":
      set DoPctSurfCon = 1;
      breaksw
    case "-nopctsurfcon":
    case "-no-pctsurfcon":
      set DoPctSurfCon = 0;
      breaksw

    case "-hyporelabel":
      set DoRelabelHypos = 1;
      breaksw
    case "-nohyporelabel":
      set DoRelabelHypos = 0;
      breaksw

    case "-aparc2aseg":
      set DoAParc2ASeg = 1;
      breaksw
    case "-noaparc2aseg":
      set DoAParc2ASeg = 0;
      breaksw

    case "-apas2aseg":
      set DoAPas2ASeg = 1;
      breaksw
    case "-noapas2aseg":
      set DoAPas2ASeg = 0;
      breaksw

    case "-aparc+aseg-stats":
      set DoAParcASegStats = 1;
      breaksw
    case "-no-aparc+aseg-stats":
      set DoAParcASegStats = 0;
      breaksw

    case "-segstats":
      set DoSegStats = 1;
      breaksw
    case "-nosegstats":
      set DoSegStats = 0;
      breaksw

    case "-wmparc":
      set DoWMParc = 1;
      breaksw
    case "-nowmparc":
      set DoWMParc = 0;
      breaksw

    case "-balabels":
    case "-ba_labels":
    case "-ba-labels":
    case "-label_ba":
    case "-label_BA":
      set DoBaLabels = 1;
      breaksw;

    case "-nobalabels":
    case "-noba_labels":
    case "-noba-labels":
    case "-nolabel_ba":
    case "-nolabel_BA":
    case "-no_ba_labels":
    case "-no-ba-labels":
    case "-no_label_ba":
    case "-no_label_BA":
      set DoBaLabels = 0;
      breaksw;

    case "-label_v1":
    case "-label_V1":
    case "-label-v1":
    case "-label-V1":
      set DoLabelV1 = 1;
      breaksw;

    case "-label_exvivo_ec_avg":
    case "-label-exvivo-ec-avg":
    case "-label_exvivo_EC_avg":
    case "-label-exvivo-EC-avg":
      set DoLabelExvivoEC = 1;
      breaksw;

    case "-nolabel_exvivo_ec_avg":
    case "-nolabel-exvivo-ec-avg":
    case "-nolabel_exvivo_EC_avg":
    case "-nolabel-exvivo-EC-avg":
    case "-no_label_exvivo_ec_avg":
    case "-no-label-exvivo-ec-avg":
    case "-no_label_exvivo_EC_avg":
    case "-no-label-exvivo-EC-avg":
      set DoLabelExvivoEC = 0;
      breaksw;

#---------------------------------------------------#
# Note: end of flags for recon-all stages above, 
# below are 'autorecon' and other multi-stage flags
#---------------------------------------------------#

    case "-all":
    case "-autorecon-all":
      set DoCreateBaseInput = 1;
      set DoMotionCor      = 1;
      set DoTalairach      = 1;
      set DoTalCheck       = 1;
      set DoNormalization  = 1;
      set DoSkullStrip     = 1;
      set DoNuIntensityCor = 1;
      set DoGCAReg         = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoNormalization2 = 1;
      set DoMaskBFS        = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoWhiteSurfs     = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoCurvHK         = 1;
      set DoCurvStats      = 1;
      set DoSphere         = 1;
      set DoSurfReg        = 1;
      set DoContraSurfReg  = 0;
      set DoAvgCurv        = 1;
      set DoJacobianWhite  = 1;
      set DoCortParc       = 1;
      set DoPialSurfs      = 1;
      set DoCortRibbonVolMask = 1;
      set DoParcStats      = 1;
      set DoCortParc2      = 1;
      set DoParcStats2     = 1;
      set DoCortParc3      = 1;
      set DoParcStats3     = 1;
      set DoPctSurfCon     = 1;
      set DoRelabelHypos   = 1;
      set DoAParc2ASeg     = 1;
      set DoAPas2ASeg      = 1;
      set DoSegStats       = 1;
      set DoWMParc         = 1;
      set DoBaLabels       = 1;
      breaksw

    case "-autorecon1":
      set DoCreateBaseInput = 1;
      set DoMotionCor      = 1;
      set DoTalairach      = 1;
      set DoTalCheck       = 1;
      set DoNormalization  = 1;
      set DoSkullStrip     = 1;
      set DoNuIntensityCor = 1;
      breaksw

    case "-gcatrain-iter":
      if($#argv < 2) goto arg2err;
      set gcafile = $argv[1]; shift;
      if(! -e $gcafile) then
        echo "ERROR: cannot find $gcafile"
        exit 1;
      endif
      set gcafile = `getfullpath $gcafile`
      set GCA    = `basename $gcafile`
      set GCADIR = `dirname $gcafile`
      set GCAOutputName = $argv[1]; shift;
      set DoGCAReg         = 1;
      set DoRemoveNeck     = 0;
      set DoSkullLTA       = 0;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 0;
      set DoSegStats       = 0;
      breaksw

    case "-gcareg-iters":
      if($#argv < 1) goto arg1err;
      set GCARegIterations = $argv[1]; shift;
      breaksw
    case "-gcareg-tol":
      if($#argv < 1) goto arg1err;
      set GCARegTol = $argv[1]; shift;
      breaksw

    case "-autorecon2":
      set DoGCAReg         = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 0;
      set DoNormalization2 = 1;
      set DoMaskBFS        = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoWhiteSurfs     = 1;
      set DoCurvHK         = 1;
      set DoCurvStats      = 1;
      breaksw

    case "-autorecon2-volonly":
      set DoGCAReg         = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 0;
      set DoNormalization2 = 1;
      set DoMaskBFS        = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      breaksw

    case "-autorecon2-perhemi":
    case "-autorecon2-surfonly":
    case "-autorecon2-surfsonly":
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoWhiteSurfs     = 1;
      set DoSegStats       = 0;
      set DoCurvHK         = 1;
      set DoCurvStats      = 1;
      breaksw

    case "-autorecon2-inflate1":
      set DoGCAReg         = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 0;
      set DoNormalization2 = 1;
      set DoMaskBFS        = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      breaksw

    case "-autorecon2-cp":
    case "-autorecon2-noaseg":
    case "-autorecon2-wm":
      set DoNormalization2 = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoMaskBFS        = 1;
      set DoWhiteSurfs     = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoSegStats       = 0;
      set DoCurvHK         = 1;
      set DoCurvStats      = 1;
      breaksw

    case "-autorecon-pial":
      set DoMaskBFS        = 1;
      set DoWhiteSurfs     = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoSegStats       = 1;
      set DoCurvHK         = 1;
      set DoCurvStats      = 1;
      set DoSphere         = 1;
      set DoSurfReg        = 1;
      set DoContraSurfReg  = 0;
      set DoAvgCurv        = 1;
      set DoJacobianWhite  = 1;
      set DoCortParc       = 1;
      set DoPialSurfs      = 1;
      set DoPctSurfCon     = 1;
      set DoCortRibbonVolMask = 1;
      set DoParcStats      = 1;
      set DoCortParc2      = 1;
      set DoParcStats2     = 1;
      set DoCortParc3      = 1;
      set DoParcStats3     = 1;
      set DoRelabelHypos   = 1;
      set DoAParc2ASeg     = 1;
      set DoAPas2ASeg      = 1;
      set DoWMParc         = 1;
      set DoBaLabels       = 1;
      breaksw

    case "-autorecon3":
      set DoSphere         = 1;
      set DoSurfReg        = 1;
      set DoContraSurfReg  = 0;
      set DoAvgCurv        = 1;
      set DoJacobianWhite  = 1;
      set DoCortParc       = 1;
      set DoPialSurfs      = 1;
      set DoCortRibbonVolMask = 1;
      set DoParcStats      = 1;
      set DoCortParc2      = 1;
      set DoParcStats2     = 1;
      set DoCortParc3      = 1;
      set DoParcStats3     = 1;
      set DoPctSurfCon     = 1;
      set DoRelabelHypos   = 1;
      set DoAParc2ASeg     = 1;
      set DoAPas2ASeg      = 1;
      set DoSegStats       = 1;
      set DoWMParc         = 1;
      set DoBaLabels       = 1;
      breaksw

    # skips unnecessary steps (sphere reg) in autorecon3 when refining pial surface only
    case "-autorecon3-T2pial":
    case "-T2pial-only":
      set DoT2pial         = 1;
      set DoCortRibbonVolMask = 1;
      set DoParcStats      = 1;
      set DoCortParc2      = 1;
      set DoParcStats2     = 1;
      set DoCortParc3      = 1;
      set DoParcStats3     = 1;
      set DoPctSurfCon     = 1;
      set DoRelabelHypos   = 1;
      set DoAParc2ASeg     = 1;
      set DoAPas2ASeg      = 1;
      set DoSegStats       = 1;
      set DoWMParc         = 1;
      set DoBaLabels       = 1;
      breaksw

    case "-autorecon-hemi":
      if ( $#argv < 1) goto arg1err;
      set hemilist = $argv[1]; shift;
      if($hemilist != lh && $hemilist != rh) then
        echo "ERROR: hemi = $hemilist, must be either lh or rh"
        goto error_exit;
      endif
      set LF_DEFAULT_NAME = "recon-all-${hemilist}.log"
      set SF_DEFAULT_NAME = "recon-all-status-${hemilist}.log"
      set CF_DEFAULT_NAME = "recon-all-${hemilist}.cmd"
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoWhiteSurfs     = 1;
      set DoCurvHK         = 1;
      set DoCurvStats      = 1;
      set DoSphere         = 1;
      set DoSurfReg        = 1;
      set DoContraSurfReg  = 0;
      set DoAvgCurv        = 1;
      set DoJacobianWhite  = 1;
      set DoCortParc       = 1;
      set DoPialSurfs      = 1;
      set DoCortRibbonVolMask = 0;
      set DoParcStats      = 1;
      set DoCortParc2      = 1;
      set DoParcStats2     = 1;
      set DoCortParc3      = 1;
      set DoParcStats3     = 1;
      set DoPctSurfCon     = 1;
      set DoRelabelHypos   = 1;
      set DoAParc2ASeg     = 0;
      set DoAPas2ASeg      = 0;
      set DoWMParc         = 0;
      set DoSegStats       = 0;
      set DoBaLabels       = 1;
      breaksw

#-------------------------------------------------#
# below are utility flags and special modifiers
#-------------------------------------------------#

    case "-hemi":
      if ( $#argv < 1) goto arg1err;
      set hemilist = $argv[1]; shift;
      if($hemilist != lh && $hemilist != rh) then
        echo "ERROR: hemi = $hemilist, must be either lh or rh"
        goto error_exit;
      endif
      breaksw

    # This is a temporary flag to test how changing the way the vertex
    # area is computed in mrisurf.c affects a recon. It is set by default!
    case "-fixvertexarea"
      setenv FIX_VERTEX_AREA;
      breaksw
    case "-nofixvertexarea"
      unsetenv FIX_VERTEX_AREA;
      breaksw

    case "-norandomness":
      set NoRandomness = 1;
      breaksw

    case "-randomness":
      set NoRandomness = 0;
      breaksw

    # -th3 turns on new volume calc for mris_anat_stats
    case "-th3":
      set TH3Flag = 1
      breaksw
    case "-no-th3":
      set TH3Flag = 0
      breaksw

    case "-rng-seed":
      set NoRandomness = 1;
      set RngSeed = $argv[1]; shift;
      breaksw

    case "-expert":
      if( $#argv < 1) goto arg1err;
      set XOptsFile = $argv[1]; shift;
      fsr-checkxopts $XOptsFile
      if($status) goto error_exit;
      set XOptsFile = `getfullpath $XOptsFile`
      breaksw

    case "-xopts-use"
      set XOptsUse = 1; # Use pre-existing xopts
      breaksw
    case "-xopts-clean"
      set XOptsClean = 1; # Delete pre-existing xopts
      breaksw
    case "-xopts-overwrite"
      set XOptsOverwrite = 1; # Overwrite pre-existing xopts
      breaksw

    case "-clean":
      set DoCleanCSDF  = 1;
      set DoCleanCW256 = 1;
      set DoCleanTal   = 1;
      set DoCleanLta   = 1;
      set DoCleanCP    = 1;
      set DoCleanTWM   = 1;
      set DoCleanSeed  = 1;
      set DoCleanPFH   = 1;
      set DoCleanBM    = 1;
      set DoCleanASeg  = 1;
      set DoCleanWM    = 1;
      set DoCleanBFSE  = 1;
      set DoCleanXopts = 1;
      set DoCleanT2    = 1;
      set DoCleanFLAIR = 1;
      breaksw

    case "-clean-xopts":
      set DoCleanXopts = 1;
      breaksw

    case "-clean-cw256":
      set DoCleanCW256 = 1;
      breaksw

    case "-clean-cp":
      set DoCleanCP   = 1;
      breaksw

    case "-clean-twm":
      set DoCleanTWM  = 1;
      breaksw

    case "-clean-wm":
      set DoCleanWM   = 1;
      breaksw

    case "-clean-cpwm":
    case "-clean-wmcp":
      set DoCleanWM   = 1;
      set DoCleanCP   = 1;
      breaksw

    case "-clean-seed":
      set DoCleanSeed   = 1;
      breaksw

    case "-clean-tal":
      set DoCleanTal   = 1;
      breaksw

    case "-clean-lta":
      set DoCleanLta   = 1;
      breaksw

    case "-clean-pfh":
      set DoCleanPFH   = 1;
      breaksw

    case "-clean-bm":
      set DoCleanBM   = 1;
      breaksw

    case "-clean-aseg":
      set DoCleanASeg   = 1;
      breaksw

    case "-clean-bfse":
      set DoCleanBFSE   = 1;
      breaksw

    case "-clean-T2":
      set DoCleanT2 = 1;
      breaksw

    case "-clean-FLAIR":
      set DoCleanFLAIR = 1;
      breaksw

    case "-superclean":
    case "-super-clean":
      set DoSuperClean = 1;
      breaksw

    case "-waitfor":
      if ( $#argv < 1) goto arg1err;
      set WaitForFile = $argv[1]; shift;
      breaksw

    case "-notify":
      if ( $#argv < 1) goto arg1err;
      set NotifyFile = $argv[1]; shift;
      breaksw

    case "-mail":
      if ( $#argv < 1) goto arg1err;
      set mailuser = $argv[1]; shift;
      breaksw

    case "-status":
      if ( $#argv < 1) goto arg1err;
      set SF = $argv[1]; shift;
      breaksw

    case "-noappendlog":
      set AppendLog = 0;
      breaksw

    case "-noappendstatus":
      set AppendStatus = 0;
      breaksw

    case "-noappend":
      set AppendLog = 0;
      set AppendStatus = 0;
      breaksw

    case "-done":
      if ( $#argv < 1) goto arg1err;
      set DoneFile = $argv[1]; shift;
      rm -f $DoneFile
      breaksw

    case "-log":
      if ( $#argv < 1) goto arg1err;
      set LF = $argv[1]; shift;
      breaksw

    case "-nolog":
      set LF = /dev/null
      breaksw

    case "-csurfdir":
      if ( $#argv < 1) goto arg1err;
      setenv FREESURFER_HOME $argv[1]; shift;
      if(! -e $FREESURFER_HOME) then
        echo "ERROR: cannot find $FREESURFER_HOME"
        goto error_exit;
      endif
      pushd $FREESURFER_HOME > /dev/null
      setenv FREESURFER_HOME `pwd`;
      breaksw

    case "-patch":
      if ( $#argv < 1) goto arg1err;
      set PatchDir = $argv[1]; shift;
      if(! -e $PatchDir) then
        echo "ERROR: cannot find patch $PatchDir"
        exit 1;
      endif
      set path = ($PatchDir $path)
      breaksw

    case "-dontrun":
      set RunIt = 0;
      breaksw

    case "-onlyversions":
      set DoVersionsOnly = 1;
      breaksw

    case "-allowcoredump":
      limit coredumpsize unlimited
      breaksw

    case "-no-isrunning":
      set DoIsRunning = 0;
      breaksw

    case "-threads"
    case "-nthreads"
      if($#argv < 1) goto arg1err;
      setenv OMP_NUM_THREADS $argv[1]; shift;
      setenv FS_OMP_NUM_THREADS $OMP_NUM_THREADS
      breaksw

    case "-force":
      echo "ERROR: -force is no longer used. You can continue an analysis on an"
      echo " existing subject by omitting -force AND all -i flags."
      exit 1;
      set Force = 1;
      breaksw

    case "-verbose":
      set verbose = 1;
      breaksw

    case "-echo":
      set echo = 1;
      breaksw

    case "-debug":
      set verbose = 1;
      set echo = 1;
      breaksw

    case "-umask":
      if ( $#argv < 1) goto arg1err;
      umask $1; shift;
      breaksw

    case "-grp":
      if ( $#argv < 1) goto arg1err;
      set grp = $argv[1];
      set curgrp = `id -gn`;
      if($grp != $curgrp) then
        echo "ERROR: current group ($curgrp) does not equal specified group $grp"
        goto error_exit;
      endif
      breaksw

    case "-cm":
      set ConformMin = 1;
      echo "INFO: all volumes are conformed to the min voxel size"
      breaksw

    case "-conform-dc":
      set ConformKeepDC = 1;
      echo "INFO: keeping DC when conforming"
      breaksw

    case "-hires":
      set HiRes = 1;
      set ConformMin = 1;
      echo "INFO: hi-res volumes are conformed to the min voxel size"
      # per testing by Natalia Zaretskaya, Mar 2015, the flags which
      # normally disable the aseg steps are no longer necessary (which
      # means aseg.mgz can be created with hi-res data).
      breaksw

    case "-use-aseg":
      set UseAseg = 1;
      breaksw

    case "-no-use-aseg":
      set UseAseg = 0;
      breaksw

    case "-noneg":
      set UseNoNeg = 1;
      breaksw

    case "-nothicken":
      set NoThicken = 1;
      breaksw

    case "-uncompress":
      set UnCompress = 1;
      breaksw

    case "-bigventricles":
      set BigVentricles = 1;
      breaksw

    case "-nobigventricles":
      set BigVentricles = 0;
      breaksw

    case "-secondpassrenorm":
      set DoSecondPassRenorm = 1;
      breaksw

    case "-mprage":
      set IsMPRAGE = 1;
      breaksw;

    case "-washu_mprage":
      set IsWashuMPRAGE = 1;
      breaksw;

    case "-cw256":
      set DoConformWidth256 = 1;
      breaksw;

    case "-nowmsa":
      set NoWMSA = 1;
      breaksw;

    case "-avgcurvtifpath":
      if ( $#argv < 1) goto arg1err;
      set AvgCurvTifPath = $argv[1]; shift;
      breaksw

    case "-avgcurvtif":
      if ( $#argv < 1) goto arg1err;
      set AvgCurvTif = $argv[1]; shift;
      breaksw

    case "-qcache":
      set DoQdecCache = 1;
      breaksw;

    case "-smooth-cortex-only"
      set SmoothCortexOnly = 1;
      breaksw;

    case "-no-smooth-cortex-only"
      set SmoothCortexOnly = 0;
      breaksw;

    case "-measure":
      if ( $#argv < 1) goto arg1err;
      if ( $UserMeasureList ) then
        set measurelist = ($measurelist $argv[1]); shift;
      else
        set measurelist = $argv[1]; shift;
        set UserMeasureList = 1; # allow for multiple instances of -measure
      endif
      breaksw

    case "-measuredir":
      if ( $#argv < 1) goto arg1err;
      set measuredir = $argv[1]; shift;
      breaksw

    case "-fwhm":
      if ( $#argv < 1) goto arg1err;
      set fwhmlist = $argv[1]; shift;
      breaksw

    case "-target":
      if ( $#argv < 1) goto arg1err;
      set target = $argv[1]; shift;
      breaksw

    case "-vno_match_check":
    case "-vno_check":
    case "-vno-check":
      set DoVnoMatchCheck = 1;
      breaksw;

    case "-make"
      if ( $#argv < 1) goto arg1err;
      set DoMakefile = 1;
      set MakefileTarget = $argv[1]; shift;
      breaksw;

    case "-time":
      set DoTime = 1;
      breaksw;

    case "-notime":
      set DoTime = 0;
      breaksw;

    case "-lgi":
    case "-lGI":
    case "-localGI":
      set DoLocalGyriIndex = 1;
      breaksw;

    case "-use-concat-lta-tal":
      set UseConcatLtaTal = 1;
      breaksw;

    case "-show-edits":
    case "-show_edits":
    case "-showedits":
      set DoShowEdits = 1;
      breaksw;

    case "-use-cuda":
    case "-use_cuda":
    case "-use-gpu":
    case "-use_gpu":
      set UseCuda = 1;
      # then set LD_LIBRARY_PATH to distributed cuda libs
      source $FREESURFER_HOME/bin/cuda_setup
      breaksw;

    case "-get-cuda":
    case "-get-gpu":
    case "-show-cuda":
    case "-show-gpu":
      set GetCuda = 1; # info dump in check_params section below
      # then set LD_LIBRARY_PATH to distributed cuda libs
      source $FREESURFER_HOME/bin/cuda_setup
      breaksw;

    case "-parallel":
      set DoParallel = 1;
      # the user can override this thread count with -openmp
      setenv OMP_NUM_THREADS 4
      setenv FS_OMP_NUM_THREADS 4 # support for re-entrant recon-all
      # override: -itkthreads <num_threads>
      setenv ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS 4
      breaksw

    case "-openmp":
      # located after -parallel so as to allow threadcount override
      if ( $#argv < 1) goto arg1err;
      setenv OMP_NUM_THREADS $argv[1]; shift;
      setenv FS_OMP_NUM_THREADS $OMP_NUM_THREADS # re-entrant recon-all
      breaksw;

    case "-itkthreads":
      # located after -parallel so as to allow threadcount override
      if ( $#argv < 1) goto arg1err;
      setenv ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS $argv[1]; shift;
      breaksw;


    # hippocampal subfield processing (in vivo atlas, Dickerson data)
    case "-hippo-subfields":
      echo "ERROR: This form of hippocampal subfield segmentation"
      echo "is deprecated.  Use -hippocampal-subfields-<T1/T1T2/T2>"
      goto error_exit;
      breaksw;

    # hippocampal subfield processing (ex vivo atlas, only T1)
    case "-hippocampal-subfields-T1":
      set DoHippoSF_T1 = 1;
      breaksw;

    # hippocampal subfield processing (ex vivo atlas, multispectral)
    case "-hippocampal-subfields-T1T2":
      set DoHippoSF_T1T2 = 1;
      if( $#argv < 2) goto arg2err;
      set T2volHippoSF = "$argv[1]"; shift;
      set UserSuffix = "$argv[1]"; shift;
      breaksw;
    case "-hippocampal-subfields-T2":
      set DoHippoSF_T2 = 1;
      if( $#argv < 2) goto arg2err;
      set T2volHippoSF = "$argv[1]"; shift;
      set UserSuffix = "$argv[1]"; shift;
      breaksw;

    # processing of brainstem substructures
    case "-brainstem-structures":
      set DoBSsubst = 1;
      breaksw;

   
    case "-cubic":
      set UseCubic = 1;
      breaksw
    case "-nocubic":
    case "-no-cubic":
    case "-no_cubic":
      set UseCubic = 0;
      breaksw

    case "-fix_mtl":
    case "-fix-mtl":
      set UseFixMtl = 1;
      breaksw
    case "-nofix_mtl":
    case "-nofix-mtl":
    case "-no_fix_mtl":
    case "-no-fix-mtl":
      set UseFixMtl = 0;
      breaksw

    case "-T2pial":
    case "-t2pial":
      set DoT2pial = 1;
      breaksw
    case "-noT2pial":
    case "-no-T2pial":
    case "-no_T2pial":
    case "-no-t2pial":
    case "-no_t2pial":
      set DoT2pial = 0;
      breaksw

    case "-FLAIRpial":
    case "-flairpial":
      set DoFLAIRpial = 1;
      breaksw
    case "-noFLAIRpial":
    case "-no-FLAIRpial":
    case "-no_FLAIRpial":
    case "-no-flairpial":
    case "-no_flairpial":
      set DoFLAIRpial = 0;
      breaksw

    case "-bbr-init-coreg"
      set BBRInit = coreg;
      breaksw
    case "-bbr-init-fsl"
      set BBRInit = fsl;
      breaksw
    case "-bbr-init-spm"
      set BBRInit = spm;
      breaksw
    case "-bbr-init-rr"
      set BBRInit = rr;
      breaksw
    case "-bbr-init-header"
      set BBRInit = header;
      breaksw
    case "-bbr-init-best"
      set BBRInit = best;
      breaksw

    default:
      echo ERROR: Flag $flag unrecognized.
      echo $cmdline
      goto error_exit;
      breaksw
  endsw
end

#-------------------------------------------------#
goto parse_args_return;
#-------------------------------------------------#

#-------------------------------------------------#
arg1err:
#-------------------------------------------------#
  echo "ERROR: flag $flag requires one argument"
  exit 1

#-------------------------------------------------#
arg2err:
#-------------------------------------------------#
  echo "ERROR: flag $flag requires two argument"
  exit 1

#-------------------------------------------------#
arg3err:
#-------------------------------------------------#
  echo "ERROR: flag $flag requires three arguments"
  exit 1

#-------------------------------------------------#
check_params:
#-------------------------------------------------#
  if($DoT2pial && $DoFLAIRpial) then
    echo "Cannot specify both T2 and FLAIR for pial correction."
    goto error_exit;
  endif

  if($DoHippoSF_T1T2 || $DoHippoSF_T2) then
    if(! -e "$T2volHippoSF") then
      echo "ERROR: cannot find $T2volHippoSF"
      goto error_exit;
    endif
    if (-d "$T2volHippoSF") then
      echo "ERROR: You cannot give the hippocampal subfield segmentation a folder as an input. It must be an image file."
      goto error_exit;
    endif
    if(! -r "$T2volHippoSF") then
      echo "ERROR: $T2volHippoSF exists but is not readable"
      goto error_exit;
    endif
    set InVolDir  = `dirname  "$T2volHippoSF"`;
    set InVolBase = `basename "$T2volHippoSF"`;
    pushd $InVolDir > /dev/null
    set InVolDir = `pwd`;
    popd > /dev/null
    set T2volHippoSF = "$InVolDir/$InVolBase";
  endif

  if($UseCuda || $GetCuda) then
    # test a binary
    echo "Testing for CUDA device:"
    $FREESURFER_HOME/bin/mri_em_register_cuda --version \
        | grep -v "\-\-all\-info"
    if ($status) goto error_exit;
    echo ""

    # print version of installed driver
    if ( -e /proc/driver/nvidia/version) then
      echo "NVIDIA driver version info:"
      cat /proc/driver/nvidia/version | grep NVIDIA
      echo ""
    endif

    if ($GetCuda) then
      $FREESURFER_HOME/bin/cudadetect
      if ($status) goto error_exit;
      exit 0;
    endif
  endif

  if(! $DoVersionsOnly) then
    if($#subjid != 1) then
      echo "ERROR: must specify a subject id"
      exit 1;
    endif

    if(! $?SUBJECTS_DIR ) then
      echo "ERROR: environment variable SUBJECTS_DIR not set"
      echo "  this can be done by setting it in the shell before"
      echo "  executing recon-all or by using the -sd flag"
      exit 1;
    endif

    if(! -e $SUBJECTS_DIR ) then
      echo "ERROR: SUBJECTS_DIR $SUBJECTS_DIR does not exist."
      exit 1;
    endif

    # Get the full path #
    pushd $SUBJECTS_DIR > /dev/null
    setenv SUBJECTS_DIR `$PWD`;
    popd > /dev/null

    set subjdir = $SUBJECTS_DIR/$subjid

    if($TH3Flag)   set TH3Opt = "-th3"
    if(! $TH3Flag) set TH3Opt = "-no-th3"

    #------------ Longitudinal ---------------#
    if($longitudinal) then

      # assert that $tpNid does not contain .long.
      set haslong = `echo $tpNid | grep "\.long\."`
      if ( "$haslong" != "" ) then
        echo ""
        echo "ERROR: Detected \'.long.\' in a subject id!
        echo ""
        echo "       If you are trying to run or re-run a longitudinal time point"
        echo "       please specify the following parameters:"
        echo ""
        echo "       \' -long <tpNid> <templateid> \'"
        echo ""
        echo "       where <tpNid> is the time point id (SAME as cross sectional"
        echo "       ID) and <templateid> is the ID created in the -base run."
        echo "       The directory <tpNid>.long.<templateid> will be created"
        echo "       automatically or used for output, if it already exists."
        echo ""
        echo "       If you are running a \'-base\' please specify a different name."
        echo "       Usage of \'.long.\' is reserved for the automatically created"
        echo "       longitudinal output."
        echo ""
        exit 1;
      endif

      #make sure cross sectional tpNid exists:
      if ( ! -e ${SUBJECTS_DIR}/${tpNid} ) then
        echo ""
        echo "ERROR: Cross sectional tpNid: ${SUBJECTS_DIR}/${tpNid}"
        echo "       does not exist!"
        echo ""
        exit 1;
      endif

      # check if base/template specified
      if($#longbaseid != 1) then
        echo ""
        echo "ERROR: Specify the <templateid> for this subject template "
        echo "       (created during the -base run):"
        echo ""
        echo "       \' -long  <tpNid> <templateid> \'"
        echo ""
        exit 1;
      endif

      # Error if longbaseid contains .long.
      set haslong = `echo $longbaseid | grep "\.long\."`
      if ( "$haslong" != "" ) then
        echo ""
        echo "ERROR: The <templateid> may not contain .long. (reserved for"
        echo "       automatic output of a longitudinal time point)."
        echo "       Specify the <templateid> for this subject template "
        echo "       (created during the -base run):"
        echo ""
        echo "       \' -long  <tpNid> <templateid> \'"
        echo ""
        exit 1;
      endif

      set longbasedir = $SUBJECTS_DIR/$longbaseid
      if(! -e $longbasedir) then
        echo "ERROR: cannot find base/template dir: $longbasedir"
        echo ""
        exit 1;
      endif
      if ( ! -e ${longbasedir}/${BaseSubjsListFname}) then
        echo "ERROR: file ${longbasedir}/${BaseSubjsListFname} does not exist!"
        echo ""
        exit 1;
      else
        set found_tpNid = 0
        set found_longbaseid = 0
        foreach f (`cat ${longbasedir}/${BaseSubjsListFname}`)
          if (${f} == ${tpNid}) set found_tpNid = 1
          if (${f} == ${longbaseid}) set found_longbaseid = 1
        end
        if ( ! $found_tpNid && ! $DoAddTp  ) then
          echo "ERROR: $tpNid is not in ${longbasedir}/${BaseSubjsListFname}"
          echo ""
          exit 1
        endif
        # check that baseid is not the same as any of the timepoint subj IDs
        if ( $found_longbaseid ) then
          echo "ERROR: Template/base ID cannot be the same as a time point ID"
          echo "       (in ${longbasedir}/${BaseSubjsListFname})"
          echo ""
          echo "       Find more info at:"
          echo "       http://surfer.nmr.mgh.harvard.edu/fswiki/LongitudinalProcessing"
          echo ""
          exit 1
        endif
      endif

    else # ================= if cross run or base ==========================

      # make sure $subjid does not contain .long.
      set haslong  = `echo $subjid | grep "\.long\."`
      set hasxhemi = `echo $subjid | grep xhemi`
      if ( "$haslong" != "" && "$hasxhemi" == "" ) then
        echo ""
        echo "ERROR: Are you trying to run or re-run a longitudinal time point?"
        echo "       If so, please specify the following parameters:"
        echo ""
        echo "       \' -long <tpNid> <templateid> \'"
        echo ""
        echo "       where <tpNid> is the time point id (SAME as cross sectional"
        echo "       ID) and <templateid> is the ID created in the -base run."
        echo "       The directory <tpNid>.long.<templateid> will be created"
        echo "       automatically or used for output, if it already exists."
        echo ""
        exit 1;
      endif

    endif

    # error if base subject is run as a regular subject:
    if ( ! $DoCreateBaseSubj  )  then
      if ( -e $subjdir/$BaseSubjsListFname ) then
        echo ""
        echo "ERROR: It appears that this subject ID is an existing"
        echo "       base/template from longitudinal processing (-base):"
        echo "       $subjid"
        echo "       If you are trying to re-run a -base template you"
        echo "       need to pass the -base and all -tp flags: "
        echo ""
        echo "       \' -base <templateid> -tp <tpNid> ... -all \'"
        echo ""
        echo "       (Instead of -all you can pass other flags, such"
        echo "       as -autorecon2 -autorecon3 to run only parts.)"
        exit 1;
      endif
    endif

    # error if existing regular (cross run) is run as base
    if ( $DoCreateBaseSubj && -e $subjdir) then
      if ( ! -e $subjdir/$BaseSubjsListFname ) then
        echo ""
        echo "ERROR: It appears that the -base templateID that you passed:"
        echo "       -base $subjid"
        echo "       is an existing regular (cross sectional) run!"
        echo "       Please make sure you pass a new name (not one of"
        echo "       the time points) for the template with -base."
        echo "       For example, if you are trying to create a -base:"
        echo ""
        echo "       \' -base BertTemplate -tp Bert1 -tp Bert2 ... \'"
        echo ""
        exit 1;
      endif
    endif


    #---------------------------------------------------------#
    if($#InputList == 0) then
      if(! $DoCreateBaseSubj) then
        if($longitudinal) mkdir -p ${subjdir}
        if(! -e $subjdir) then
          echo "ERROR: cannot find $subjdir"
          exit 1;
        endif
        if(! -w $subjdir) then
          echo "ERROR: you do not have write permission to $subjdir"
          exit 1;
        endif
      endif
    else # An input was passed
      if( -e $subjdir) then
        echo "ERROR: You are trying to re-run an existing subject with (possibly)"
        echo " new input data (-i). If this is truly new input data, you should delete"
        echo " the subject folder and re-run, or specify a different subject name."
        echo " If you are just continuing an analysis of an existing subject, then "
        echo " omit all -i flags."
        exit 1;
      endif
      mkdir -p $subjdir
    endif
  else
    set subjdir = /tmp
  endif

  if(! $?FREESURFER_HOME ) then
    echo "ERROR: environment variable FREESURFER_HOME not set."
    exit 1;
  endif

  if(! -e $FREESURFER_HOME ) then
    echo "ERROR: FREESURFER_HOME $FREESURFER_HOME does not exist."
    exit 1;
  endif

  if(! -e ${GCADIR}/$GCA ) then
    echo "ERROR: cannot find ${GCADIR}/$GCA" |& tee -a $LF
    exit 1;
  endif

  if(! -e ${GCADIR}/$GCASkull && ($DoSkullLTA || $DoSkullStrip)) then
    echo "ERROR: cannot find ${GCADIR}/$GCASkull" \
      |& tee -a $LF
    exit 1;
  endif

  foreach hemi ($hemilist)
    set avgtif = ${AvgCurvTifPath}/$hemi.${AvgCurvTif};
    if(! -e $avgtif) then
      echo "ERROR: cannot find $avgtif."
      exit 1;
    endif
    set GCSHemi = ${GCSDIR}/$hemi.$GCS
    if(! -e $GCSHemi) then
      echo "ERROR: cannot find $GCSHemi."
      exit 1;
    endif
    set CPAtlas = ${GCSDIR}/$hemi.$GCS
    if(! -e $CPAtlas) then
      echo "ERROR: cannot find $CPAtlas."
      exit 1;
    endif
  end

  if($XOptsUse == 1 && $XOptsClean == 1) then
    echo "ERROR: cannot specify both -xopts-clean and -xopts-use"
    exit(1);
  endif

  if($IsMPRAGE == 1 && $IsWashuMPRAGE == 1) then
    echo "ERROR: cannot specify both -mprage and -washu_mprage"
    exit(1);
  endif

  mkdir -p $subjdir/scripts
  set XOptsPreExist = $subjdir/scripts/expert-options
  if(-e $XOptsPreExist) then
    # There is a pre-existing xopts file
    if($#XOptsFile == 0) then
      # XOpts not passed on cmd line
      if($XOptsUse == 0 && $XOptsClean == 0) then
        echo "ERROR: there is a pre-existing expert options file."
        echo "You must explicitly specify whether to:"
        echo "  1. Use the pre-existing file (-xopts-use)"
        echo "  2. Delete the pre-existing file (-xopts-clean)"
        exit(1);
      endif
      if($XOptsClean == 1) then
        rm -f $XOptsPreExist
        set XOptsFile = ();
      endif
      if($XOptsUse == 1) then
        set XOptsFile = $XOptsPreExist;
      endif
    else
      # XOpts was passed on cmd line, but pre-existing xopts file
      if(! $XOptsOverwrite) then
        echo "ERROR: there is a pre-existing expert options file and"
        echo "you have specified an expert options file on the command-line."
        echo "If you want to use the file specified on the command-line,"
        echo "you must run with -xopts-overwrite, or you may edit the "
        echo "existing file $XOptsFile (and not use the -expert option)."
        exit(1);
      endif
      # If it gets here, then overwrite
      rm -f $XOptsPreExist
      cp $XOptsFile $XOptsPreExist
      if($status) goto error_exit;
    endif
  else
    # No pre-existing file
    if($#XOptsFile != 0) then
      # Expert options file specified on cmd line, make copy
      cp $XOptsFile $XOptsPreExist
      if($status) goto error_exit;
    endif
  endif

  if($#NotifyFile != 0) then
    rm -f $NotifyFile;
    set tmpdir = `dirname $NotifyFile`;
    mkdir -p $tmpdir;
    pushd $tmpdir > /dev/null;
    set tmpdir = `$PWD`;
    set NotifyFile = $tmpdir/`basename $NotifyFile`;
    popd > /dev/null;
  endif

  if($#WaitForFile != 0) then
    set tmpdir = `dirname $WaitForFile`;
    mkdir -p $tmpdir;
    pushd $tmpdir > /dev/null;
    set tmpdir = `$PWD`;
    set WaitForFile = $tmpdir/`basename $WaitForFile`;
    popd > /dev/null;
  endif

  if(! $DoCleanTal && ! $DoCleanCP && ! $DoCleanBM && ! $DoConvertInput && \
     ! $DoCleanASeg && ! $DoCleanWM && ! $DoCleanSeed && ! $DoCleanCW256 && \
     ! $DoCortParc && ! $DoCortParc2 && ! $DoGCAReg && ! $DoCARegInv && \
     ! $DoMotionCor && ! $DoTalairach && ! $DoTalCheck && ! $DoCleanXopts && \
     ! $DoNormalization  && ! $#SurfRegToSubj &&\
     ! $DoNormalization2  && ! $DoParcStats && ! $DoParcStats2 && \
     ! $DoVersionsOnly && ! $DoDeface &&  ! $DoCleanPFH && \
     ! $DoSkullStrip && ! $DoSegmentation && ! $DoNuIntensityCor &&\
     ! $DoFill && ! $DoTessellate && ! $DoAParc2ASeg && ! $DoWMParc && \
     ! $DoSmooth1  && ! $DoInflate1 && ! $DoQSphere && ! $DoRemoveNeck &&\
     ! $DoFix  && ! $DoSmooth2 && ! $DoInflate2  && ! $DoSphere &&\
     ! $DoSkullLTA && ! $DoQdecCache  && ! $DoVnoMatchCheck &&\
     ! $DoSurfReg  && ! $DoContraSurfReg  && ! $DoAvgCurv && ! $DoSegStats &&\
     ! $DoMorphRGB && ! $DoWhiteSurfs && ! $DoContraSurfRegWithinSubject &&\
     ! $DoCortRibbonVolMask && ! $DoJacobianWhite && ! $DoJacobianDist0 && \
     ! $DoCANormalize && ! $DoCAReg && ! $DoCALabel && \
     ! $DoMaskBFS && ! $DoAParcASegStats && ! $DoLocalGyriIndex && \
     ! $DoMakefile && ! $DoParallel && ! $DoRelabelHypos && ! $DoCurvHK && \
     ! $DoSurfVolume && ! $DoASegMerge && ! $DoCurvStats && ! $DoLabelV1 && \
     ! $DoCreateBaseSubj && ! $DoBaLabels && ! $DoShowEdits && \
     ! $DoLabelExvivoEC && ! $DoPialSurfs && \
     ! $DoHippoSF_T1 && ! $DoHippoSF_T1T2 && ! $DoHippoSF_T2 &&  ! $DoBSsubst && \
     ! $DoPctSurfCon && ! $DoT2pial && ! $DoFLAIRpial && \
     ! $DoConvertT2Input && ! $DoConvertFlairInput && ! $DoSuperClean &&\
     ! $DoCortParc3 && ! $DoParcStats3 && ! $DoAPas2ASeg ) then
     echo "ERROR: nothing to do. You must specify an operation to perform by adding"
     echo "flags. Eg, -all, -autorecon1, -autorecon2, -autorecon3, etc."
     exit 1;
  endif

  if($WSMore && $WSLess) then
    echo "ERROR: cannot specify both -wsmore and -wsless"
    exit 1;
  endif

  if( ($WSMore || $WSLess) && $WSPctPreFlood ) then
    echo "ERROR: cannot specify -wsmore or -wsless and -wsthresh"
    exit 1;
  endif

  if($#SurfRegToSubj) then
    if(! -e $SUBJECTS_DIR/$SurfRegToSubj) then
      echo "ERROR: cannot find $SurfRegToSubj"
      exit 1;
    endif
    set AvgTif = $SUBJECTS_DIR/$SurfRegToSubj/$hemi.reg.template.tif
    if(! -e $AvgTif) then
      echo "ERROR: cannot find $AvgTif"
      exit 1;
    endif
  endif

  if($DoParallel == 1 && $#hemilist == 1) then
    echo "ERROR: cannot use -parallel with a single hemi"
    exit(1);
  endif

#-------------------------------------------------#
goto check_params_return;
#-------------------------------------------------#


#-------------------------------------------------#
usage_exit:
#-------------------------------------------------#
  echo ""
  echo "USAGE: $ProgName"
  echo ""
  echo " Required Arguments:";
  echo "   -subjid <subjid>"
  echo "   -<process directive>"
  echo ""
  echo " Fully-Automated Directive:"
  echo "  -all           : performs all stages of cortical reconstruction"
  echo "  -autorecon-all : same as -all"
  echo ""
  echo " Manual-Intervention Workflow Directives:"
  echo "  -autorecon1    : process stages 1-5 (see below)"
  echo "  -autorecon2    : process stages 6-23"
  echo "                   after autorecon2, check white surfaces:"
  echo "                     a. if wm edit was required, then run -autorecon2-wm"
  echo "                     b. if control points added, then run -autorecon2-cp"
  echo "                     c. proceed to run -autorecon3"
  echo "  -autorecon2-cp : process stages 12-23 (uses -f w/ mri_normalize, -keep w/ mri_seg)"
  echo "  -autorecon2-wm : process stages 15-23"
  echo "  -autorecon2-inflate1 : 6-18"
  echo "  -autorecon2-perhemi : tess, sm1, inf1, q, fix, sm2, inf2, finalsurf, ribbon"
  echo "  -autorecon3    : process stages 24-34"
  echo "                     if edits made to correct pial, then run -autorecon-pial"
  echo "  -hemi ?h       : just do lh or rh (default is to do both)"
  echo ""
  echo "  Autorecon Processing Stages (see -autorecon# flags above):"
  echo "    1.  Motion Correction and Conform"
  echo "    2.  NU (Non-Uniform intensity normalization)"
  echo "    3.  Talairach transform computation"
  echo "    4.  Intensity Normalization 1"
  echo "    5.  Skull Strip"
  echo ""
  echo "    6.  EM Register (linear volumetric registration)"
  echo "    7.  CA Intensity Normalization"
  echo "    8.  CA Non-linear Volumetric Registration "
  echo "    9.  Remove neck"
  echo "    10. EM Register, with skull"
  echo "    11. CA Label (Aseg: Volumetric Labeling) and Statistics"
  echo ""
  echo "    12. Intensity Normalization 2 (start here for control points)"
  echo "    13. White matter segmentation"
  echo "    14. Edit WM With ASeg"
  echo "    15. Fill (start here for wm edits)"
  echo "    16. Tessellation (begins per-hemisphere operations)"
  echo "    17. Smooth1"
  echo "    18. Inflate1"
  echo "    19. QSphere"
  echo "    20. Automatic Topology Fixer"
  echo "    21. White Surfs (start here for brain edits for pial surf)"
  echo "    22. Smooth2"
  echo "    23. Inflate2"
  echo ""
  echo "    24. Spherical Mapping"
  echo "    25. Spherical Registration "
  echo "    26. Spherical Registration, Contralater hemisphere"
  echo "    27. Map average curvature to subject"
  echo "    28. Cortical Parcellation (Labeling)"
  echo "    29. Cortical Parcellation Statistics"
  echo "    30. Pial Surfs"
  echo "    31. WM/GM Contrast"
  echo "    32. Cortical Ribbon Mask"
  echo "    33. Cortical Parcellation mapped to ASeg"
  echo "    34  Brodmann and exvio EC labels"
  echo ""
  echo " Step-wise Directives"
  echo "  See -help"
  echo ""
  echo " Expert Preferences"
  echo "  -pons-crs C R S : col, row, slice of seed point for pons, used in fill"
  echo "  -cc-crs C R S : col, row, slice of seed point for corpus callosum, used in fill"
  echo "  -lh-crs C R S : col, row, slice of seed point for left hemisphere, used in fill"
  echo "  -rh-crs C R S : col, row, slice of seed point for right hemisphere, used in fill"
  echo "  -nofill        : do not use the automatic subcort seg to fill"
  echo "  -watershed cmd : control skull stripping/watershed program"
  echo "  -wsless : decrease watershed threshold (leaves less skull, but can strip more brain)"
  echo "  -wsmore : increase watershed threshold (leaves more skull, but can strip less brain)"
  echo "  -wsatlas : use atlas when skull stripping"
  echo "  -no-wsatlas : do not use atlas when skull stripping"
  echo "  -no-wsgcaatlas : do not use GCA atlas when skull stripping"
  echo "  -wsthresh pct : explicity set watershed threshold"
  echo "  -wsseed C R S : identify an index (C, R, S) point in the skull"
  echo "  -norm3diters niters : number of 3d iterations for mri_normalize"
  echo "  -normmaxgrad maxgrad : max grad (-g) for mri_normalize. Default is 1."
  echo "  -norm1-b N : in the _first_ usage of mri_normalize, use control "
  echo "               point with intensity N below target (default=10.0) "
  echo "  -norm2-b N : in the _second_ usage of mri_normalize, use control "
  echo "               point with intensity N below target (default=10.0) "
  echo "  -norm1-n N : in the _first_ usage of mri_normalize, do N number "
  echo "               of iterations"
  echo "  -norm2-n N : in the _second_ usage of mri_normalize, do N number "
  echo "               of iterations"
  echo "  -cm           : conform volumes to the min voxel size "
  echo "  -no-fix-with-ga : do not use genetic algorithm when fixing topology"
  echo "  -fix-diag-only  : topology fixer runs until ?h.defect_labels files"
  echo "                    are created, then stops"
  echo "  -seg-wlo wlo : set wlo value for mri_segment and mris_make_surfaces"
  echo "  -seg-ghi ghi : set ghi value for mri_segment and mris_make_surfaces"
  echo "  -nothicken   : pass '-thicken 0' to mri_segment"
  echo "  -no-ca-align-after : turn off -align-after with mri_ca_register"
  echo "  -no-ca-align : turn off -align with mri_ca_label"
  echo "  -deface      : deface subject, written to orig_defaced.mgz"
  echo ""
  echo "  -expert file     : read-in expert options file"
  echo "  -xopts-use       : use pre-existing expert options file"
  echo "  -xopts-clean     : delete pre-existing expert options file"
  echo "  -xopts-overwrite : overwrite pre-existing expert options file"
  echo ""
  echo "  -mprage : assume scan parameters are MGH MP-RAGE protocol"
  echo "  -washu_mprage : assume scan parameters are Wash.U. MP-RAGE protocol."
  echo "                  both mprage flags affect mri_normalize and mri_segment,"
  echo "                  and assumes a darker gm."
  echo "  -schwartzya3t-atlas : for tal reg, use special young adult 3T atlas"
  echo ""
  echo "  -use-gpu : use GPU versions of mri_em_register, mri_ca_register,"
  echo "             mris_inflate and mris_sphere"
  echo ""
  echo " Notification Files (Optional)"
  echo "  -waitfor file : wait for file to appear before beginning"
  echo "  -notify  file : create this file after finishing"
  echo ""
  echo " Status and Log files (Optional)"
  echo "  -log     file : default is scripts/recon-all.log"
  echo "  -status  file : default is scripts/recon-all-status.log"
  echo "  -noappend     : start new log and status files instead of appending"
  echo "  -no-isrunning : do not check whether this subject is currently being processed"
  echo ""
  echo " Other Arguments (Optional)"
  echo "  -sd subjectsdir : specify subjects dir (default env SUBJECTS_DIR)"
  echo "  -mail username  : mail user when done"
  echo "  -umask umask    : set unix file permission mask (default 002)"
  echo "  -grp groupid    : check that current group is alpha groupid "
  echo "  -onlyversions   : print version of each binary and exit"
  echo "  -debug          : print out lots of info"
  echo "  -allowcoredump  : set coredump limit to unlimited"
  echo "  -dontrun        : do everything but execute each command"
  echo "  -version        : print version of this script and exit"
  echo "  -help           : voluminous bits of wisdom"
  echo ""

  if(! $PrintHelp) exit 1;

  echo $VERSION
  echo ""

  cat $0 | awk 'BEGIN{prt=0}{if(prt) print $0;if($1 == "BEGINHELP") prt=1}'

exit 1;

#---- Everything below here is printed out as part of help -----#
BEGINHELP

Performs all, or any part of, the FreeSurfer cortical reconstruction
process. This help only gives some simple information. For more
detailed documentation, see https://surfer.nmr.mgh.harvard.edu

Basic usages:

1. Subject dir does not exist:

  recon-all -subject subjectname -i invol1 <-i invol2> -all

Creates analysis directory $SUBJECTS_DIR/subjectname, converts one or
more input volumes to MGZ format in subjectname/mri/orig, and runs
all processing steps. If subjectname exists, then an error is returned
when -i is used; but this can be overridden with -force (in which
case any pre-existing source volumes are deleted).

2. Manual conversion into mgz:

  mkdir -p $SUBJECTS_DIR/subjectname/mri/orig
  mri_convert invol1 $SUBJECTS_DIR/subjectname/mri/orig/001.mgz
  mri_convert invol2 $SUBJECTS_DIR/subjectname/mri/orig/002.mgz
  recon-all -subject subjectname -all

If no input volumes are given, then it is assumed that the subject
directory has already been created and that the raw data already
exists in MGZ format in subjid/mri/orig as XXX.mgz, where XXX is a
3-digit, zero-padded number.


SUBJECT IDENTIFICATION STRING

-s subjectname
-sid subjectname
-subjid subjectname
-subject subjectname

'subjectname' is the FreeSurfer subject identification string which doubles
as the name of the reconstruction root directory for this subject. This
reconstruction should be referenced by this string for all FreeSurfer
commands and in the register.dat matrix (for functional interfacing).


SPECIFYING DIRECTIVES

Directives instruct recon-all which part(s) of the reconstruction
stream to run. While it is possible to do everything in one shot (using
the -all flag), there can be some benefits to customizing the
stream. These benefits include stopping to perform manual editing as
well as parallelization. Directives are either clustered or step-wise.
Clustered directives are sets of steps that can be performed by
specifying a single flag. A step-wise directive refers to a single
step.  Directives accumulate. A step can be removed from a cluster by
adding -no<step> after the cluster flag. For example, specifying
-all followed by -notalairach will perform all the reconstruction
steps except talairaching. However, note that if -notalairach *preceeded*
-all, talairaching would still be performed.


CLUSTERED DIRECTIVES

-all
-autorecon-all

Perform all reconstruction steps.

-autorecon1

Motion correction through skull strip.

-autorecon2

Subcortical segmentation through make white surfaces.

-autorecon2-cp

Normalization2 through make final surfaces.

-autorecon2-wm

Fill through make white surfaces. Used after editing wm volume after running
-autorecon2.

-autorecon-pial

Makes final surfaces (white and pial). Used after editing brain.finalsurfs
volume after running -autorecon2. The brain.finalsurfs.mgz volume may be
edited to fix problems with the pial surface.

-autorecon3

Spherical morph, automatic cortical parcellation, pial surf and ribbon mask.


STEP-WISE DIRECTIVES

Step-wise directives allow the user to implement a single step in the
reconstruction process. See also STEP DESCRIPTION SUMMARIES below.
They also allow users to include/exclude a step from a clustered
DIRECTIVE. To include a step, use -step (eg, -skullstrip). To exclude
a step, use -nostep (eg -noskullstrip).

Run times are approximate for an Intel Xeon E5-2643 64bit 3.4GHz processor:

  -<no>motioncor          2 min
  -<no>talairach        < 1 min
  -<no>normalization      2 min
  -<no>skullstrip        15 min
  -<no>nuintensitycor     1 min
  -<no>gcareg            15 min
  -<no>canorm             1 min
  -<no>careg              1 hour
  -<no>careginv           1 min
  -<no>rmneck             1 min
  -<no>skull-lta         12 min
  -<no>calabel           34 min
  -<no>normalization2     3 min
  -<no>maskbfs          < 1 min
  -<no>segmentation       1 min
  -<no>fill               1 min
  -<no>tessellate       < 1 min     per hemisphere
  -<no>smooth1          < 1 min     per hemisphere
  -<no>inflate1           1 min     per hemisphere
  -<no>qsphere            3 min     per hemisphere
  -<no>fix               15 min     per hemisphere
  -<no>white              3 min     per hemisphere
  -<no>smooth2          < 1 min     per hemisphere
  -<no>inflate2         < 1 min     per hemisphere
  -<no>curvHK           < 1 min     per hemisphere
  -<no>curvstats        < 1 min     per hemisphere
  -<no>sphere            40 min     per hemisphere
  -<no>surfreg           50 min     per hemisphere
  -<no>jacobian_white   < 1 min     per hemisphere
  -<no>avgcurv          < 1 min     per hemisphere
  -<no>cortparc           1 min     per hemisphere
  -<no>pial               4 min     per hemisphere
  -<no>surfvolune       < 1 min     per hemisphere
  -<no>cortribbon        15 min
  -<no>parcstats        < 1 min     per hemisphere
  -<no>cortparc2          1 min     per hemisphere
  -<no>parcstats2       < 1 min     per hemisphere
  -<no>cortparc3          1 min     per hemisphere
  -<no>parcstats3       < 1 min     per hemisphere
  -<no>pctsurfcon       < 1 min     per hemisphere
  -<no>hyporelabel      < 1 min     per hemisphere
  -<no>aparc2aseg         1 min
  -<no>apas2aseg          1 min
  -<no>segstats           3 min
  -<no>wmparc             7 min
  -<no>balabels           5 min     per hemisphere

  -all                    7 hours   both hemipheres

If -parallel is specified, runtime is reduced to 3 hours.

EXPERT PREFERENCES

-pons-crs C R S

Specify a seed point for the pons during the fill operation. This is
used to cut the brain stem from brain. By default, this point will be
determined automatically. It should only be specified if there is a
cut failure. To determine what this point should be, find the center
of the pons in the T1 volume (in tkmedit) and record the column, row,
and slice. Creates a file called scripts/seed-ponscrs.man.dat
with the CRS.

-cc-crs C R S

Specify a seed point for the corpus callosum during the fill
operation. This is used to help separate the hemispheres.  By default,
this point will be determined automatically. It should only be
specified if there is a cut failure.  To determine what this point
should be, find the center of the CC in the T1 volume (in tkmedit) and
record the column, row, and slice. Creates a file called
scripts/seed-cccrs.man.dat with the CRS.

-lh-crs C R S

Specify a seed point for the left hemisphere during the fill
operation. This is used to help identify the left hemisphere.  By
default, this point will be determined automatically. It should only
be specified if there is a cut failure.  To determine what this point
should be, find a point in the white matter mass of the left
hemisphere in the T1 volume (in tkmedit) and record the column, row,
and slice. Creates a file called scripts/seed-cccrs.man.dat with the
CRS. Remember that tkmedit displays the volume in radiological
convention (ie, left is right).

-rh-crs C R S

Same as -lh-crs but for the right hemisphere. Creates a file called
scripts/seed-rhcrs.man.dat with the CRS.

-watershed cmd

This controls how the skull stripping will be performed. Legal values are
normal (the default), atlas, nowatershed, watershedonly, and watershedtemplate.

-wsmore/-wsless

Increase/decrease the preflooding height (threshold) when skull
stripping. -wsmore will expand the skull surface; -wsless will shrink
the skull surface.  See also -wsthresh.

-wsthresh pctheight

Explicitly set the preflooding height when skull stripping.

-wsseed R C S

Supply a point in the volume that the user believes to be in the white
matter.  By default, this point will be determined automatically. It
should only be specified if there is a strip failure. To determine
what this point should be, find a point in the white matter using
tkmedit and record the Volume Index values (NOT the XYZ coordinates).

-no-wsgcaatlas

Disable usage of the GCA atlas when running mri_watershed skull-stripping.
The default is to use the GCA atlas to locate anatomy aiding skull-strip.

-gca gcafile

Specify the name of the gaussian classifier array (GCA) file
to be used with GCA registration and automatic subcortical
segmentation. It must be found in the FREESURFER_HOME/average directory (or
use -gca-dir to specify an alternate path).
The Default is RB_all_YYYY-MM-DD.gca located in
FREESURFER_HOME/average. This has no effect unless the GCA registration
or subcortical segmentation stages are to be performed.

-gca-skull gcafile

Specify the name of the gaussian classifier array (GCA) file to be used with
registration with skull.  It must be found in the FREESURFER_HOME/average
directory (or use -gca-dir to specify an alternate path).
The default is RB_all_withskull_YYYY-MM-DD.gca located in
FREESURFER_HOME/average.

-gcs gcsfile

Specify the name of the gaussian classifier surface atlas (GCS) file
to be used for the cortical parcellation stage. It must be found in the
FREESURFER_HOME/average directory (or use -gcs-dir to specify an alternate
path). The default is named
curvature.buckner40.filled.desikan_killiany.2007-06-20.gcs and is located in
FREESURFER_HOME/average.

-twm twmfile

Where (twmfile) is a control.dat format file (a point set in freeview)
with points manually selected to be in the white matter inferior to
hippocampus in the temporal lobe. This option is passed to mri_ca_register.

-nuiterations

Number of iterations in the non-uniform intensity correction.
Default is 1.

-norm3diters niters

Use niters 3d normalization iterations (passes as -n to _both_ runs of
mri_normalize).

-normmaxgrad maxgrad

Passes "-g maxgrad" to _both_ runs of mri_normalize. Max grad default is 1.

-norm1-b N

In the _first_ usage of mri_normalize (during creation of T1.mgz), use
control point with intensity N below target (default=10.0)

-norm1-n N

In the _first_ usage of mri_normalize, do N number of iterations

-norm2-b N

In the _second_ usage of mri_normalize (during creation of brain.mgz), use
control point with intensity N below target (default=10.0)

-norm2-n N

In the _second_ usage of mri_normalize, do N number of iterations

-noaseg

Skips subcortical segmentation steps (same as -nosubcortseg), and does
not use aseg.presurf.mgz for inorm2, wm segmentation, or filling. 
Use this flag for brains that do not support usage of Freesurfers subcortical
segmentation, such as baby brains, or non-human primates.

-noaseg-inorm2

Does not use aseg.presurf.mgz for the second mri_normalize step.

-bigventricles

If a subject has enlarged ventricles due to atrophy, include the -bigventricles
flag with the -autorecon2 stage in order to prevent surfaces extending into
the ventricle regions. The flag directly affects the binary mri_ca_register,
and mris_make_surfaces indirectly via aseg.presurf.mgz.

-norandomness

The random number generator used by certain binaries is seeded with the
same number, thus producing identical results from run to run.

-cw256

Include this flag after -autorecon1 if images have a FOV > 256.  The
flag causes mri_convert to conform the image to dimensions of 256^3.

-notal-check

Skip the automatic failure detection of Talairach alignment.

-qcache

Produce the pre-cached files required by the Qdec utility, allowing rapid
analysis of group data.  These files are created by running mris_preproc,
which creates smoothed surface data files sampled to the 'fsaverage'
common-space surface. By default, the surface data for thickness, curv, sulc,
area and jacobian_white are smoothed at 0, 5, 10, 15, 20, and 25 mm FWHM.
If just one set of surface data needs to be processed, then the option
-measure <surfmeas> can follow -qcache, where <surfmeas> is one of: thickness,
curv, sulc, area, jacobian_white or any surface measure. Multiple instances
of -measure <meas> is supported.  The -measuredir option allows
specifying a directory other than the default of surf. Another option is
-fwhm <num> where <num> is a value in mm.  Also, -target <name> allows
specifying a common-space target other than fsaverage (the default).
qcache is also a target for make, eg. recon-all -make qcache
See also: http://surfer.nmr.mgh.harvard.edu/fswiki/Qdec

-smooth-cortex-only

Only applies with -qcache. Only smooth data if it is part of the ?h.cortex.label.
This prevents values in the medial wall (which are meaningless) from being
smoothed into cortical areas. This is the default and you will have to turn
it off with -no-smooth-cortex-only.

-no-smooth-cortex-only

Allow medial wall values to smooth into cortex.

-make target

Runs recon-all through 'make', the standard utility used to create a file
only if its dependencies are out-of-date.  This -make option makes use of the
file recon-all.makefile, where the dependency chain is specified.
A 'target' argument must be specified.  The valid targets are:

  all
  autorecon1
  autorecon2
  autorecon2-volonly
  autorecon2-perhemi
  autorecon3
  qcache

These targets correspond to their flag equivalents in recon-all.  The
difference in behaviour is that files are created only if the file does not
exist or if an input file used to create it has a newer date than the file
in need of creation.  It is also possible to supply the full pathname to a
particular file as a target.

The flag -dontrun can also be specified to show the commands that will run
without excuting them.

-lgi
-lGI
-localGI

Computes local measurements of pial-surface gyrification at thousands of
points over the cortical surface. See reference [13] for details.

-label_v1

Create a label of V1, based on Hinds et al., NeuroImage 39 (2008) 1585-1599.

-balabels
-ba-labels
-ba_labels

Creates Brodmann area labels of BA1, BA2, BA3a, BA3b, BA4a, BA4p, BA6, BA44,
BA45, V1, V2, and V5/MT (and perirhinal) by mapping labels from the 
'fsaverage' subject, which must exist within the SUBJECTS_DIR.  
Based on:
"Cortical Folding Patterns and Predicting Cytoarchitecture", Fischl et al.,
Cerebral Cortex 2007.

-use-gpu

Use the GPU versions of the binaries mri_em_register, mri_ca_register,
mris_inflate, and mris_sphere.


EXPERT OPTIONS FILE

While the expert preferences flags supported by recon-all cover most of
the instances where special flags need to be passed to a FreeSurfer binary,
to allow passing an arbitrary flag to a binary, recon-all supports the
reading of a user-created file containing special options to include in
the command string (in addition to, not in place of).  The file should
contain as the first item the name of the command, and the items following
it on rest of the line will be passed as the extra options.  For example,
if a file called expert.opts is created containing these lines:

  mri_em_register -p .5
  mris_topo_fixer -asc

then the option "-p .5" will be passed to mri_em_register, and "-asc"
will be passed to mris_topo_fixer.  The name of the expert options file
is passed to recon-all with the -expert flag, eg.

  recon-all -expert expert.opts

When an expert options is passed, it will be copied to scripts/expert-options.
Future calls to recon-all, the user MUST explicitly specify how to treat this file.
Options are (1) use the file (-xopts-use), or (2) delete it (-xopts-clean). If
this file exsts and the user specifies another expert options file, then
the user must also specify -xopts-overwrite.

The following FreeSurfer binaries will accept an expert option:

  talairach_avi
  mri_normalize
  mri_watershed
  mri_em_register
  mri_ca_normalize
  mri_ca_register
  mri_remove_neck
  mri_ca_label
  mri_segstats
  mri_mask
  mri_segment
  mri_edit_wm_with_aseg
  mri_pretess
  mri_fill
  mri_tessellate
  mris_smooth
  mris_inflate
  mris_sphere
  mris_fix_topology
  mris_topo_fixer
  mris_remove_intersection
  mris_make_surfaces
  mris_surf2vol
  mris_register
  mris_jacobian
  mrisp_paint
  mris_ca_label
  mris_anatomical_stats
  mri_aparc2aseg


NOTIFICATION FILES

Notification files allow the user to cascade invocations to recon-all,
with one invocation waiting until another one terminates. This is done
by specifying a file that must exist before an invocation can precede
(-waitfor) and/or specifying a file that is created when an invocation
terminates (-notify). This type of interprocess communication can
allow users to parallelize the stream. If this is to be done, note
that each hemisphere can be run separately by specifying the -hemi
flag.


LOG AND STATUS FILES

By default, log and status files are created in subjid/scripts. The
log file contains all the output from all the programs that have been
run during the invocation to recon-all. The status file has a list of
all the programs that have been run and the time at which each
started. The log file is intended to be a record of what was done
whereas the status file allows the user to easily see where in the
stream a currently running process is. The log file should be sent
with all bug reports. By default, these files are called recon-all.log
and recon-all-status.log, but this can be changed with the -log and
-status options. By default, the log and status are appended to. New
log and status files can be forced with the -noappend flag.


OTHER ARGUMENTS

-sd subjectsdir

This allows the user to specify the root of the FreeSufer subjects
directory. If unspecified, the environment variable SUBJECTS_DIR
is used.

-mail username

Send email to username when the process terminates.


STEP DESCRIPTION SUMMARIES

Motion Correction (-<no>motioncor)

When there are multiple source volumes, this step will correct for
small motions between them and then average them together. The input
are the volumes found in file(s) mri/orig/XXX.mgz. The output will be
the volume mri/orig.mgz. If no runs are found, then it looks for
a volume in mri/orig (or mri/orig.mgz). If that volume is there, then
it is used in subsequent processes as if it was the motion corrected
volume. If no volume is found, then the process exits with errors.
The motion correction step uses a robust registration [14] procedure
to produce highly accurate registrations of the brain, ignoring outlier
regions, such as differen cropping planes, jaw, neck, eye movement etc.

Talairach (-<no>talairach)

This computes the affine transform from the orig volume to the MNI305
atlas using Avi Snyders 4dfp suite of image registration tools,
through a FreeSurfer script called talairach_avi. Several of the downstream
programs use talairach coordinates as seed points. You can/should check
how good the talairach registration is using
"tkregister2 --s subjid --fstal-avi". You must have an "fsaverage" subject in
your SUBJECTS_DIR. tkregister2 allows you to compare the orig volume
against the talairach volume resampled into the orig space. If you modify
the registration, it will change the talairach.xfm file. Your edits will
be *not* be overwritten unless you run recon-all specifying -clean-tal.
Run "tkregister2 --help" for more information.
Creates the files mri/transform/talairach.auto.xfm and talairach.xfm.
The flag -tal-check will check the registration against known-good transforms.
Adding the flag -use-mritotal after -talairach will use the MINC program
mritotal (see Collins, et al., 1994) to perform the transform.

Normalization (-<no>normalization)

Performs intensity normalization of the orig volume and places the
result in mri/T1.mgz. Attempts to correct for fluctuations in
intensity that would otherwise make intensity-based segmentation much
more difficult. Intensities for all voxels are scaled so that the mean
intensity of the white matter is 110. If there are problems with the
normalization, users can add control points. See also Normalization2.

Skull Strip (-<no>skullstrip)

Removes the skull from mri/T1.mgz and stores the result in
mri/brainmask.auto.mgz and mri/brainmask.mgz.
Runs the mri_watershed program. If the strip fails, users can specify
seed points (-wsseed) or change the threshold (-wsthresh, -wsmore, -wsless).
The -autorecon1 stage ends here.

NU Intensity Correction (-<no>nuintensitycor)

Non-parametric Non-uniform intensity Normalization (N3), corrects for
intensity non-uniformity in MR data,  making relatively few assumptions
about the data.  This runs the MINC tool 'nu_correct'.  By default, one
iteration of nu_correct is run.  The flag -nuiterations specification
of some other number of iterations.

Automatic Subcortical Segmentation (-<no>subcortseg)

This is done in six stages. (1) GCA linear registration
(-gcareg). This is an initial registration to a template. (2)
Canonical Normalization (-canorm), (3) Canonical Registration
(-careg). (4) Neck removal (-rmneck), (5) Registration, w/skull
(-skull-lta), and (6) Subcortical labeling (-calabel).
The stages are listed next.

EM (GCA) Registration (-<no>gcareg)

Computes transform to align the mri/nu.mgz volume to the default GCA atlas
found in FREESURFER_HOME/average (see -gca flag for more info).
Creates the file mri/transforms/talairach.lta.
The -autorecon2 stage starts here.

CA Normalize (-<no>canorm)

Further normalization, based on GCA model.
Creates mri/norm.mgz.
Note: -canorm-usecps will enable usage of control points during normalization.

CA Register (-<no>careg)

Computes a nonlinear transform to align with GCA atlas.
Creates the file mri/transform/talairach.m3z.

CA Register Inverse (-<no>careginv)

Computes the inverse of the nonlinear transform to align with GCA
atlas.  Creates the files mri/transform/talairach.m3z.{x,y,z}.mgz.

Remove neck (-<no>rmneck)

The neck region is removed from the NU-corrected volume mri/nu.mgz.
Makes use of transform computed from prior CA Register stage.
Creates the file mri/nu_noneck.mgz.

EM Registration, with Skull (-<no>skull-lta)

Computes transform to align volume mri/nu_noneck.mgz with GCA volume
possessing the skull.
Creates the file mri/transforms/talairach_with_skull_2.lta.

CA Label (-<no>calabel)

Labels subcortical structures, based in GCA model.
Creates the files mri/aseg.auto.mgz and mri/aseg.presurf.mgz.

ASeg Stats (-<no>segstats)

Computes statistics on the segmented subcortical structures found
in mri/aseg.mgz. Writes output to file stats/aseg.stats.

Normalization2 (-<no>normalization)

Performs a second (major) intensity correction using only the brain
volume as the input (so that it has to be done after the skull strip).
Intensity normalization works better when the skull has been removed.
Creates a new brain.mgz volume. The -autorecon2-cp stage begins here.
If -noaseg flag is used, then aseg.presurf.mgz is not used by mri_normalize.

WM Segmentation (-<no>segmentation)

Attempts to separate white matter from everything else. The input is
mri/brain.mgz, and the output is mri/wm.mgz.  Uses intensity,
neighborhood, and smoothness constraints.  This is the volume that is
edited when manually fixing defects. Calls mri_segment,
mri_edit_wm_with_aseg, and mri_pretess. To keep previous edits, run
with -keep. If -noaseg is used, them mri_edit_wm_aseg is skipped.

Cut/Fill (-<no>fill)

This creates the subcortical mass from which the orig surface is
created. The mid brain is cut from the cerebrum, and the hemispheres
are cut from each other. The left hemisphere is binarized to 255.
The right hemisphere is binarized to 127.  The input is mri/wm.mgz
and the output is mri/filled.mgz. Calls mri_fill. If the cut fails,
then seed points can be supplied (see -cc-crs, -pons-crs, -lh-crs,
-rh-crs). The actual points used for the cutting planes in the
corpus callosum and pons can be found in scripts/ponscc.cut.log.
The stage -autorecon2-wm begins here.  This is the last stage of
volumetric processing. If -noaseg is used, then aseg.presurf.mgz is 
not used by mri_fill.

Tessellation (-<no>tessellate)

This is the step where the orig surface (ie, surf/?h.orig.nofix) is
created. The surface is created by covering the filled hemisphere with
triangles. Runs mri_tessellate. The places where the points of the
triangles meet are called vertices. Creates the file surf/?h.orig.nofix
Note: the topology fixer will create the surface ?h.orig.

Orig Surface Smoothing (-<no>smooth1, -<no>smooth2)

After tesselation, the orig surface is very jagged because each
triangle is on the edge of a voxel face and so are at right angles to
each other. The vertex positions are adjusted slightly here to reduce
the angle. This is only necessary for the inflation processes.
Creates surf/?h.smoothwm(.nofix). Calls mris_smooth. Smooth1 is the step
just after tessellation, and smooth2 is the step just after topology
fixing.

Inflation (-<no>inflate1, -<no>inflate2)

Inflation of the surf/?h.smoothwm(.nofix) surface to create
surf/?h.inflated. The inflation attempts to minimize metric distortion
so that distances and areas are perserved (ie, the surface is not
stretched). In this sense, it is like inflating a paper bag and not a
balloon.  Inflate1 is the step just after tessellation, and inflate2
is the step just after topology fixing. Calls mris_inflate. Creates
?h.inflated, ?h.sulc, ?h.curv, and ?h.area.

QSphere (-<no>qsphere)

This is the initial step of automatic topology fixing. It is a
quasi-homeomorphic spherical transformation of the inflated surface designed
to localize topological defects for the subsequent automatic topology fixer.
Calls mris_sphere. Creates surf/?h.qsphere.nofix.

Automatic Topology Fixer (-<no>fix)

Finds topological defects (ie, holes in a filled hemisphere) using
surf/?h.qsphere.nofix, and changes the orig surface (surf/?h.orig.nofix)
to remove the defects. Changes the number of vertices.  All the defects
will be removed, but the user should check the orig surface in the volume
to make sure that it looks appropriate. Calls mris_topo_fixer.
Creates surf/?h.orig (by iteratively fixing surf/?h.orig.nofix).

White Surface (-<no>white)

Creates the ?h.white surfacees as well as the curvature file (?h.curv).
The white surface is created by "nudging" the orig surface so that it
closely follows the white-gray intensity gradient as found in the T1 volume.
Calls mris_make_surfaces.  See also "Pial Surface" and "Final Surfaces".

Spherical Inflation (-<no>sphere)

Inflates the orig surface into a sphere while minimizing metric
distortion.  This step is necessary in order to register the surface
to the spherical atlas. (also known as the spherical morph). Calls
mris_sphere. Creates surf/?h.sphere.  The -autorecon3 stage begins here.

Ipsilateral Surface Registation (Spherical Morph) (-<no>surfreg)

Registers the orig surface to the spherical atlas through
surf/?h.sphere. The surfaces are first coarsely registered by aligning
the large scale folding patterns found in ?h.sulc and then fine tuned
using the small-scale patterns as in ?h.curv.
Calls mris_register. Creates surf/?h.sphere.reg.

Jacobian (-<no>jacobian_white)

Computes how much the white surface was distorted in order to register
to the spherical atlas during the -surfreg step. Creates ?h.jacobian_white
(a curv formatted file). This step follows the surface registration step.

Surface Registation, maximal distortion, with Jacobian (-<no>jacobian_dist0)

Run spherical registration with no metric distortion penalty. This will
cause surface geometry to align regardless of the amount of distortion
induced (ie, distance contraints are turned off). The distortion will then
be quantified by the Jacobian of the transform. Creates ?h.jacobian_dist0 (a
curv formatted file) and ?h.sphere.dist0.jacobian.reg (a surface file). This
step is not run automatically because it can add about an hour per hemi.
Note: the file ?h.jacobian_white (see prior help text) is the Jacobian of
the white surface to spherical atlas alignment from -surfreg.

Contralateral Surface Registation (Spherical Morph) (-<no>contrasurfreg)

Same as ipsilateral but registers to the contralateral atlas.
Creates lh.rh.sphere.reg and rh.lh.sphere.reg.

Average Curvature (-<no>avgcurv)

Resamples the average curvature from the atlas to that of the subject.
Allows the user to display activity on the surface of an individual
with the folding pattern (ie, anatomy) of a group. Calls mrisp_paint.
Creates surf/?h.avg_curv.

Cortical Parcellation (-<no>cortparc, -<no>cortparc2, -<no>cortparc3 )

Assigns a neuroanatomical label to each location on the cortical surface.
Incorporates both geometric information derived from the cortical model
(sulcus and curvature), and neuroanatomical convention.
Calls mris_ca_label.  -cortparc creates label/?h.aparc.annot,
-cortparc2 creates /label/?h.aparc.a2009s.annot, and
-cortparc3 creates /label/?h.aparc.DKTatlas40.annot.

Pial Surface (-<no>pial)

Creates the ?h.pial surfaces as well as the thickness file (?h.thickness).
The pial surface is created by expanding the white surface so that it closely
follows the gray-CSF intensity gradient as found in the T1 volume.  The
cortical parcellation is also used to refine the surface in certain areas.
Calls mris_make_surfaces.  See also "Final Surfaces".

Final Surfaces (-<no>finalsurfs)

!!! DEPRECATED !!! This flag is intended to emulate the old-style single-run
mris_make_surfaces, where the white and pial surfaces are created at the same
time without aid from the cortical parcellation data.

WM/GM Contrast (-<no>pctsurfcon)

Computes the vertex-by-vertex percent contrast between white and gray matter.
The computation is:

         100*(W-G)
   pct = ---------
         0.5*(W+G)

The white matter is sampled 1mm below the white surface. The gray matter is
sampled 30% the thickness into the cortex. The volume that is sampled is
rawavg.mgz.  The output is stored in the surf dir of the given subject as
?h.w-g.pct.mgh.  Non-cortical regions (medial wall) are zeroed.
A stats file named ?h.w-g.pct.stats is also computed.

Surface Volume (-surfvolume)

Creates the ?h.volume file by first creating the ?h.mid.area file by
adding ?h.area(.white) to ?h.area.pial, then dividing by two.  Then
?h.volume is created by multiplying ?.mid.area with ?h.thickness.
This step is also run at the end of the -pial step.

Cortical Ribbon Mask (-<no>cortribbon)

Creates binary volume masks of the cortical ribbon, ie, each voxel is
either a 1 or 0 depending upon whether it falls in the ribbon or not.
Saved as ?h.ribbon.mgz.  Uses mgz regardless of whether the -mgz
option is used.

Parcellation Statistics (-<no>parcstats, -<no>parcstats2, -<no>parcstats3)

Runs mris_anatomical_stats to create a summary table of cortical
parcellation statistics for each structure, including 1. structure
name 2. number of vertices 3. total wm surface area (mm^2) 4. total gray
matter volume (mm^3) 5. average cortical thickness (mm) 6. standard
error of cortical thickness (mm) 7. integrated rectified mean wm
curvature 8. integrated rectified Gaussian wm curvature 9. folding index
10. intrinsic curvature index.
For -parcstats, the file is saved in stats/?h.aparc.stats.
For -parcstats2, the file is saved in stats/?h.aparc.${DESTRIEUX_NAME}.stats.
For -parcstats3, the file is saved in stats/?h.aparc.${DKTATLAS40_NAME}.stats.

Curvature Statistics  (-<no>curvstats)

Runs mris_curvature_stats to create a summary file (stats/?h.curv.stats)
of cortical curvature statistics.

LONGITUDINAL PROCESSING

The longitudinal processing scheme aims to incorporate the subject-wise
correlation of longitudinal data into the processing stream in order to
increase sensitivity and repeatability, see [14-16]. Care is taken to
avoid introduction of asymmetry-induced bias.

Here is a summary of the longitudinal workflow, where tpN refers to the
name of one timepoint of subject data, and longbase refers to the name
given to the base subject of a collection of timepoints:

1) cross-sectionally process tpN subjects (the default workflow):
  recon-all -s tp1 -i path_to_tp1_dicom -all
  recon-all -s tp2 -i path_to_tp2_dicom -all

2) create and process the unbiased base (subject template):
  recon-all -base longbase -tp tp1 -tp tp2 -all

3) longitudinally process tpN subjects:
  recon-all -long tp1 longbase -all
  recon-all -long tp2 longbase -all

4) do comparisons on results from 3), e.g. calculate differences
between tp2.long.longbase - tp1.long.longbase

Note that the longitudinal processing stream always produces output subject
data containing  .long.  in the name (to help distinguish from the default
stream).

Notice that the -all flag is included in the -base and -long calls above.
A work directive flag is required.

Other flags:

-uselongbasectrlvol

With -long: Switch on use of control-points from the base in the long
runs for intensity normalization (T1.mgz).

-uselongbasewmedits

With -long: Optionally transfer WM edits from base/template.
Default: map WM edits from corresponding cross run.

-no-orig-pial

If the orig pial surface data is not available, then specify this flag so that
mris_make_surfaces does not attempt to use it.

-noasegfusion

Do not create 'fused' aseg from the longbase timepoints, which would normally
be used to initialize the ca_labeling.  Instead, initialize using the longbase
aseg.mgz.

-addtp

If a new timepoint needs to be added to a longitudinal run where a base subject
has already been created (from prior timepoints), then the -addtp command
can be added to the -long command in order to 'fix-up' the longitudinal
stream to accept the new timepoint. Note that the base subject is *not*
recomputed using the new timepoint. This potentially introduces a bias, and it
is recommended to NOT add a time point this way! Instead recreate the base
from all time points and run all longitudinals again.
See the LongitudinalProcessing wiki page.

Example:

  recon-all -long <tpNsubjid> <longbasesubjid> -addtp -all

In this example, 'tnNsubjid' is the subject name (assumed processed in the
cross-sectional stream) to add as a new timepoint and upon which to run
the longitudinal stream (creating <tpNsubjid>.long.<longbasesubjid>).


USING IMAGES FROM A 3T SCANNER 

The -3T flag enables two specific options in recon-all for images acquired with
a 3T scanner:  3T-specific NU intensity correction parameters are used in the 
Non-Uniform normalization stage, and the Schwartz 3T atlas is used for 
Talairach alignment.


T2 OR FLAIR TO IMPROVE PIAL SURFACES

Pial surfaces can be improved using the different contrast in T2 or FLAIR
images. The original pial surfaces without T2/FLAIR data are saved as  
?h.woT2.pial or ?h.woFLAIR.pial, and new ?h.pial surfaces are created.  One 
example where this is useful is when there is dura in the brainmask.mgz that 
isn't removed by skull stripping. The flags for these commands are:

  -T2 <input T2 volume>  or -FLAIR <input FLAIR volume> 
    (Specify the  path to the T2 or FLAIR image to use)
  -T2pial or -FLAIRpial 
    (Create new pial surfaces using T2 or FLAIR images)

An example of running a subject through Freesurfer with a T2 image is:
  
  recon-all -s subjectname -i /path/to/input -T2 /path/to/T2_input -T2pial -all

T2 or FLAIR images can also be used with Freesurfer subjects that have already
been processed without them. Note that autorecon3 should also be re-ran to 
compute statistics based on the new surfaces. For example:
  
  recon-all -s subjectname -T2 /path/to/T2_volume -T2pial -autorecon3


MANUAL CHECKING AND EDITING OF SURFACES

To manually edit segmenation, run the following command (make sure
that your SUBJECTS_DIR environment variable is properly set).

  tkmedit subjid wm.mgz -aux T1.mgz

The surfaces can be loaded through the menu item
File->LoadMainSurface. To enable editing, set Tools->EditVoxels.  It
may also be convenient to bring up the reconstruction toolbar with
View->ToolBars->Reconstruction. Alt-C toggles between the main (wm)
and auxiliary (T1) volumes. Middle clicking will set a voxel value to
255; left clicking will set a voxel value to 0. Only edit the wm
volume. When finished, File->SaveMainVolume.

To view the inflated surface simultaneosly with the volume, run the
following command from a different shell:

  tksurfer subjid lh inflated

To goto a point on the surface inside the volume, click on the point
and hit SavePoint (icon looks like a floppy disk), then, in tkmedit,
hit GotoSavedPoint (icon looks like an open file).

Be sure to see the tutorials found at:
https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial


TOUCH FILES

This script creates a directory called "touch". Each time a stage is
run a "touch file" is created (eg, skull_strip.touch). This will be
used in the future to automatically determine which stages need to be
run or re-run. The modification time of the touch file is important.
The content is irrelevent, though it often contains a command-line.


FLATTENING

Flattening is not actually done in this script. This part just documents
how one would go about performing the flattening. First, load the subject
surface into tksurfer:

  tksurfer subjid lh inflated

Load the curvature through the File->Curvature->Load menu (load
lh.curv). This should show a green/red curvature pattern. Red = sulci.

Right click before making a cut; this will clear previous points. This
is needed because it will string together all the previous places you
have clicked to make the cut. To make a line cut, left click on a line
of points. Make the points fairly close together; if they are too far
appart, the cut fails. After making your line of points, execute the
cut by clicking on the Cut icon (scissors with an open triangle for a
line cut or scissors with a closed triangle for a closed cut). To make
a plane cut, left click on three points to define the plane, then left
click on the side to keep. Then hit the CutPlane icon.

Fill the patch. Left click in the part of the surface that you want to
form your patch. Then hit the Fill Uncut Area button (icon = filled
triangle). This will fill the patch with white. The non-patch area
will be unaccessible through the interface.  Save the patch through
File->Patch->SaveAs. For whole cortex, save it to something like
lh.cort.patch.3d. For occipital patches, save it to lh.occip.patch.3d.

Cd into the subject surf directory and run

  mris_flatten -w N -distances Size Radius lh.patch.3d lh.patch.flat

where N instructs mris_flatten to write out an intermediate surface
every N interations. This is only useful for making movies; otherwise
set N=0.  Size is maximum number of neighbors; Radius radius (mm) in
which to search for neighbors. In general, the more neighbors that are
taken into account, the less the metric distortion but the more
computationally intensive. Typical values are Size=12 for large
patches, and Size=20 for small patches. Radius is typically 7.
Note: flattening may take 12-24 hours to complete. The patch can be
viewed at any time by loading the subjects inflated surface, then
loading the patch through File->Patch->LoadPatch...


GETTING HELP

See https://surfer.nmr.mgh.harvard.edu
Send email to freesurfer@nmr.mgh.harvard.edu


REFERENCES

See https://www.zotero.org/freesurfer

[1] Collins, DL, Neelin, P., Peters, TM, and Evans, AC. (1994)
Automatic 3D Inter-Subject Registration of MR Volumetric Data in
Standardized Talairach Space, Journal of Computer Assisted Tomography,
18(2) p192-205, 1994 PMID: 8126267; UI: 94172121

[2] Cortical Surface-Based Analysis I: Segmentation and Surface
Reconstruction Dale, A.M., Fischl, Bruce, Sereno, M.I.,
(1999). Cortical Surface-Based Analysis I: Segmentation and Surface
Reconstruction.  NeuroImage 9(2):179-194

[3] Fischl, B.R., Sereno, M.I.,Dale, A. M.  (1999) Cortical
Surface-Based Analysis II: Inflation, Flattening, and Surface-Based
Coordinate System. NeuroImage, 9, 195-207.

[4] Fischl, Bruce, Sereno, M.I., Tootell, R.B.H., and Dale, A.M.,
(1999). High-resolution inter-subject averaging and a coordinate
system for the cortical surface. Human Brain Mapping, 8(4): 272-284

[5] Fischl, Bruce, and Dale, A.M., (2000).  Measuring the Thickness of
the Human Cerebral Cortex from Magnetic Resonance Images.  Proceedings
of the National Academy of Sciences, 97:11044-11049.

[6] Fischl, Bruce, Liu, Arthur, and Dale, A.M., (2001). Automated
Manifold Surgery: Constructing Geometrically Accurate and
Topologically Correct Models of the Human Cerebral Cortex. IEEE
Transactions on Medical Imaging, 20(1):70-80

[7] Non-Uniform Intensity Correction.
http://www.nitrc.org/projects/nu_correct/

[8] Fischl B, Salat DH, Busa E, Albert M, Dieterich M, Haselgrove C,
van der Kouwe A, Killiany R, Kennedy D, Klaveness S, Montillo A,
Makris N, Rosen B, Dale AM. Whole brain segmentation: automated
labeling of neuroanatomical structures in the human
brain. Neuron. 2002 Jan 31;33(3):341-55.

[9] Bruce Fischl, Andre van der Kouwe, Christophe Destrieux, Eric
Halgren, Florent Segonne, David H. Salat, Evelina Busa, Larry
J. Seidman, Jill Goldstein, David Kennedy, Verne Caviness, Nikos
Makris, Bruce Rosen, and Anders M. Dale.  Automatically Parcellating
the Human Cerebral Cortex. Cerebral Cortex January 2004; 14:11-22.

[10] Fischl B, Salat DH, van der Kouwe AJW, Makris N, SÃ©gonne F, Dale
AM. Sequence-Independent  Segmentation of Magnetic Resonance Images.
NeuroImage 23 Suppl 1, S69-84.

[11] Segonne F, Dale, AM, Busa E, Glessner M, Salvolini U, Hahn HK,
Fischl B, A Hybrid Approach to the Skull-Stripping Problem in MRI.
NeuroImage, 22,  pp. 1160-1075, 2004

[12] Han et al.,  Reliability of MRI-derived measurements of human
cerebral cortical thickness: The effects of field strength, scanner
upgrade and manufacturer, (2006) NeuroImage, 32(1):180-194.

[13] Schaer et al., A Surface-based Approach to Quantify Local Cortical
Gyrification (2007) IEEE Transactions on Medical Imaging.

[14] Martin Reuter, H Diana Rosas, Bruce Fischl.
Highly Accurate Inverse Consistent Registration: A Robust Approach.
NeuroImage 53(4), 1181-1196, 2010. http://dx.doi.org/10.1016/j.neuroimage.2010.07.020

[15] Martin Reuter, Bruce Fischl.
Avoiding Asymmetry-Induced Bias in Longitudinal Image Processing.
NeuroImage 51(1), 19-21, 2011. http://dx.doi.org/10.1016/j.neuroimage.2011.02.076

[16] Martin Reuter, Nicholas J Schmansky, H Diana Rosas, Bruce Fischl.
Within-Subject Template Estimation for Unbiased Longitudinal Image Analysis.
NeuroImage 61(4), 1402-1418, 2012. http://dx.doi.org/10.1016/j.neuroimage.2012.02.084
