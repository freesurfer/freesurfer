#! /bin/tcsh -f

#
# recon-all
#
# script to run all of the reconstruction routines
#
# Original Author: Doug Greve
# CVS Revision Info:
#    $Author: nicks $
#    $Date: 2010/12/30 19:11:13 $
#    $Revision: 1.313.2.32 $
#
# Copyright (C) 2002-2010,
# The General Hospital Corporation (Boston, MA).
# All rights reserved.
#
# Distribution, usage and copying of this software is covered under the
# terms found in the License Agreement file named 'COPYING' found in the
# FreeSurfer source code root directory, and duplicated here:
# https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferOpenSourceLicense
#
# General inquiries: freesurfer@nmr.mgh.harvard.edu
#

#
umask 002;

set VERSION = '$Id: recon-all,v 1.313.2.32 2010/12/30 19:11:13 nicks Exp $';
set ProgName = `basename $0`;

set inputargs = ($argv);
set subjid = ();
set hemilist = (lh rh);
set mailuser = ();
set WaitForFile = ();
set nWaitsMax  = 1000;
set WaitSleep =  1m;
set NotifyFile = ();
set PrintHelp = 0;
set LF = ();
set LF_DEFAULT_NAME = recon-all.log;
set SF = ();
set SF_DEFAULT_NAME = recon-all-status.log;
set CF = ();
set CF_DEFAULT_NAME = recon-all.cmd;
set AppendLog    = 1;
set AppendStatus = 1;
set DoTime = 0;
set fs_time = "";
set ErrorFile = /dev/null
set cmd = ();

set Force = 0;
set DoCleanCSDF  = 0;
set DoCleanCW256 = 0;
set DoCleanTal   = 0;
set DoCleanLta   = 0;
set DoCleanCP    = 0;
set DoCleanSeed  = 0;
set DoCleanPFH   = 0;
set DoCleanBM    = 0;
set DoCleanBFSE  = 0;
set DoCleanASeg  = 0;
set DoCleanWM    = 0;
set DoCleanXopts = 0;

set DoShowEdits  = 0;

set InputList = ();

# Expert preferences
set XOptsFile = ();
set XOptsClean = 0; # Delete a pre-existing xopts file
set XOptsUse   = 1; # Use a pre-existing xopts file (default '1': always use)
set XOptsOverwrite = 0; # Overwrite a pre-existing xopts file
set ControlPointsFile = ();
set PonsSeedCRS = (); # SeedCRS center of pons for mri_fill #
set CCSeedCRS = ();   # SeedCRS center of corpus callosum for mri_fill #
set RHSeedCRS = ();   # SeedCRS point in the right hemi wm for mri_fill #
set LHSeedCRS = ();   # SeedCRS point in the left  hemi wm for mri_fill #
set WaterShed = 1;      # 0=no WS, 1= WS normal, 2 = WS only, 3 = WS+1st
set WSLess    = 0;      # Shrinks skull surface
set WSMore    = 0;      # Expands skull surface
set WSPctPreFlood = (); # Pre-flooding height
set WSSeedPoint = ();   # C R S
set WSAtlas     = 0;    # 0=don't use atlas, 1=use atlas (for skull strip)
set WSGcaAtlas  = 1;    # 1=use GCA atlas and registration to do skull strip
set WSUseTalXfm = 0;    # 1=use talairach.xfm instead of talairach_with_skull
                        # to do atlas alignment during mri_watershed
set DoGcut = 1;         # 1=run mri_gcut after mri_watershed
set NuIterations = 2;   # Number of iterations for nu intensity correction
set ConformMin = 0;     # 1=conformed to min dimension
set HiRes = 0;          # 1=hires option (conformed to min dimension)
set Norm3dIters = ();   # passed as -n to mri_normalize
set NormMaxGrad = 1;    # passed as -g to mri_normalize (input: -normmaxgrad)
set WMSeg_wlo = ();  # from -seg-ghi and -seg-wlo, passed to mri_segment
set WMSeg_ghi = ();  #                             and mris_make_surfaces
set FixWithGA = 1;   # for topology fixer
set FixDiagOnly = 0; # for topology fixer
set RmNeckRadius = 25;  # used by mri_remove_neck
set UseCAAlign = (-align); # flag added to mri_ca_label
set UseCAAlignAfter = (-align-after); # flag added to mri_ca_register
set UseAseg  = 1 # when set to 0 (using -noaseg), then aseg.mgz is not used,
                 # nor is ?h.cortex.label (which originates through the aseg)
set NoAsegInorm2 = 0 # when set to 1 (using -noaseg-inorm2), then aseg.mgz
                     # is not used during the 2nd mri_normalize step
set UseNoNeg = 0 # if 1, add '-remove_negative 1' to mris_sphere,mris_register
set NoThicken = 0 # if 1, add '-thicken 0' to mri_segment
set UnCompress = 0    # if 1, add '-uncompress' to mri_ca_reg
set BigVentricles = 0 # if 1, add '-bigventricles' to mri_ca_label and reg.
                      # else, add '-nobigventricles'
set DoSecondPassRenorm = 0 # if 1, add -secondpassrenorm to mri_ca_register
set UseOldTopoFix = 1 # if 1, use mris_fix_topology instead of mris_topo_fixer
set UseNewTopoFix = 0 # if 1, use mris_topo_fixer instead of mris_fix_topology
set NoRandomness = 1 # if 1, seed critical binaries with identical seeds, to
                     # ensure consistency in surface creation. otherwise, the
                     # default is to seed with current time and date,
                     # resulting in slightly different surfaces each run.
                     # affects: mris_smooth, mris_sphere, mris_topology_fixer,
                     # mris_topo_fixer, mris_ca_label
set RngSeed = 1234   # seed for random number generator, used only when
                     # -norandomness flag is used, and can be overriden by
                     # the flag -rng-seed <seed>
set DoMultiStrip = 0 # if 1, then multiple instances of mri_watershed and
                     # mri_em_register are run in order to determine the best
                     # skull-strip
set IsMPRAGE = 0     # if 1, then -mprage added to mri_normalize/segment
set IsWashuMPRAGE = 0 # if 1, then -washu_mprage added to mri_normalize/segment
set DoConformWidth256 = 0 # if 1, then conform to 256^3 during
                          # the mri_convert -conform step
set NoNormMGZ = 0; # set to 1 when -nosubcortseg or -noaseg flag is used,
                   # which causes norm.mgz not to used during inorm2 step
set NoWMSA = 0;      # if 1, then -nowmsa flag is added to mri_ca_label
set DoQdecCache = 0; # if 1, then create smoothed fsaverage surface files
set measurelist = ( thickness area area.pial volume curv sulc white.K white.H jacobian_white  )
                     # ^ these are the files smoothed by DoQdecCache (-qcache)
set UserMeasureList = 0; # if 1, then 'measurelist' gets additional -measure args
set measuredir = (); # for specifying an alternate path to measure files
set fwhmlist = ( 0 5 10 15 20 25 ) # see DoQdecCache
set target = fsaverage # see DoQdecCache
set SmoothCortexOnly = 1; # For -qcache. smooths only within ?h.cortex.label

set UseMincMritotal = 0; # if 1, then use the BIC-MNI mritotal tal reg tools
set UseYa3tTalAtlas = 0; # if 1, use 3T18yoSchwartz young-adult 3T atlas for tal_avi
set DoMakefile = 0; # if 1, run make -f recon-all.makefile $(MakefileTarget)
set MakefileTarget = () # argument to recon-all -make
set DoAsegStatsDiff = 0; # if 1, then run asegstatsdiff
set DoAparcStatsDiff = 0; # if 1, then run aparcstatsdiff
set diffsubj = (); # the subject used by asegstatsdiff and aparcstatsdiff
set DoLabelV1 = 0; # if 1, create V1 label from O.Hinds V1 prediction atlas
set DoRobustMotionCor = 1; # if 1, then use mri_robust_template for motion cor
set mc_robust_template_avg_arg = 1; # when using mri_robust_template for motion
                     # correction, construct template from: 0 Mean, 1 Median
set UseCuda = 0; # if 1 (-use-cuda), then use GPU versions of tools:
                 # mri_em_register_cuda, mri_ca_register_cuda,
                 # mris_inflate_cuda, mris_sphere_cuda
set PialNoAparc = 0; # if 1 (-pial-noaparc), then add -noaparc flag to 
                     # mris_make_surfaces to bypass usage of parcellation
set DoNuMakeUchar = 1; # if 1, then run mri_nu_correct.mni using talairach.xfm
                       # to run mri_make_uchar to correct histogram problem

# Longitudinal processing:
set longitudinal = 0;    # if 1, will run the longitudinal scheme
set longbaseid = ();
set tpNid = ();
set longbasetotpN_regfile = ();   # reg file to align longbase to current subj
set UseConcatLtaTal = 0; # if 1, use mri_concatenate_lta during tal creation
set UseLongbaseCtrlVol = 0;   # if 1, use ctrl volume of longbase in norm step
set UseLongbaseWMedits = 0;   # if 1, use transfer wm edits from base (default from cross)
set UseAsegFusion = 1; # if 0, dont create 'fused' asegs from timepoints
set DoCreateBaseSubj = 0; # if 1, create the 'base' subject used in longitud
set BaseSubjInvol = (orig.mgz); # -base-invol allows using some other file
set BaseSubjsList = (); # subject set grabbed from -base-tp args
set BaseSubjsListFname = (base-tps); # file containing BaseSubjsList
set robust_template_avg_arg = 1; # construct template from: 0 Mean, 1 Median
set DoNuIntensityCor3T = 0; # if 1, use Zheng, Chee, Zagorodnov params for 3T
set DoAddTp = 0; # if 1, then 'fake'-add this timepoint to long subj set

# For defacing, as found in:
# $FREESURFER_HOME/average/
set brain_template = talairach_mixed_with_skull.gca
set face_template  = face.gca

# For subcortical segmentation
set GCA      = RB_all_2008-03-26.gca
set GCASkull = RB_all_withskull_2008-03-26.gca
set GCADIR   = "${FREESURFER_HOME}/average"

# For cortical registration, as found in $AvgCurvTifPath/$hemi.$AvgCurvTif
set AvgCurvTifPath = "${FREESURFER_HOME}/average"
set AvgCurvTif = average.curvature.filled.buckner40.tif

# Desikan-Killiany cortical parcellation atlas (-cortparc), as found in:
# $FREESURFER_HOME/average/$hemi.$GCS
# The 2009-03-04 atlas contains the insula label.
# The 2010-03-25 atlas has a different color for temporalpole (the old
# color was gray, which looked like the default tksurfer surface color).
set OLD_OLD_GCS = curvature.buckner40.filled.desikan_killiany.2007-06-20.gcs
set OLD_GCS = curvature.buckner40.filled.desikan_killiany.2009-03-04.gcs
set GCS = curvature.buckner40.filled.desikan_killiany.2010-03-25.gcs
set GCSDIR = "${FREESURFER_HOME}/average"

# Christophe Destrieux cortical parcellation atlas (-cortparc2):
set OLD_OLD_DESTRIEUX_GCS = atlas2002_simple.gcs
set OLD_OLD_DESTRIEUX_NAME = a2002s
set OLD_DESTRIEUX_GCS = atlas2005_simple.gcs
set OLD_DESTRIEUX_NAME = a2005s
set DESTRIEUX_GCS = destrieux.simple.2009-07-29.gcs
set DESTRIEUX_NAME = a2009s

# Set this to 0 to do everything but run the command.
# This is good for debugging.
set RunIt = 1;

# print versions and exit
set DoVersionsOnly = 0;

#----- Volume -----------#
set DoConvertInput   = 0;
set DoCreateBaseInput = 0;
set DoMotionCor      = 0;
set DoDeface         = 0;
set DoNuIntensityCor = 0;
set DoTalairach      = 0;
set DoTalCheck       = 0;
set DoNormalization  = 0;
set DoNormalization2 = 0;
set DoMaskBFS        = 0;
set UseControlPoints = 0;
set DoSkullStrip     = 0;
set DoSegmentation   = 0;
set DoGCAReg         = 0;
set DoCARegInv       = 0;
set DoCANormalize    = 0;
set DoCAReg          = 0;
set DoRemoveNeck     = 0;
set DoSkullLTA       = 0;
set DoCALabel        = 0;
set DoASegMerge      = 0;
set DoFill           = 0;
#----- Surface -----------#
set DoTessellate     = 0;
set SvInitOrigSurf   = 0;
set DoSmooth1        = 0;
set DoInflate1       = 0;
set DoQSphere        = 0;
set DoFix            = 0;
set DoSmooth2        = 0;
set DoInflate2       = 0;
set DoSphere         = 0;
set DoSurfReg        = 0;
set SurfRegToSubj    = ();
set DoJacobianWhite  = 0;
set DoJacobianDist0  = 0;
set DoContraSurfReg  = 0;
set DoContraSurfRegWithinSubject = 0;
set DoAvgCurv        = 0;
set DoMorphRGB       = 0;
set DoWhiteSurfs     = 0;
set DoCortParc       = 0;
set DoPialSurfs      = 0;
set DoSurfVolume     = 0;
set DoCortParc2      = 0;
set DoParcStats      = 0;
set DoParcStats2     = 0;
set DoCurvStats      = 0;
set DoVnoMatchCheck  = 0;
set DoLocalGyriIndex = 0;
set DoBaLabels       = 0;
set DoLabelExvivoEC  = 0;
# ----------- Surface and Volume ------------------#
set DoSurfSegEdit    = 0; # if 1, run mri_edit_segmentation_with_surfaces to
                          # fixup aseg.mgz with info from surfaces
                          # (this is the -surfsegedit flag)
set DoCortRibbonVolMask = 0;
set DoSegStats       = 0;
set DoAParc2ASeg = 0;
set DoWMParc = 0;
set DoAParcASegStats = 0;


set DoIsRunning  = 1;
set IsRunningFile  = ();

setenv LANG C # Required by MNI tool

# -------------------------------------------------- #
set PWD = pwd;
# better yet, make sure the real pwd is used:
if ( -e /bin/pwd ) set PWD = /bin/pwd
if($#argv == 0) goto usage_exit;
set n = `echo $argv | egrep -e -help | wc -l`
if($n != 0) then
  set PrintHelp = 1;
  goto usage_exit;
endif
set n = `echo $argv | egrep -e -version | wc -l`
if($n != 0) then
  echo $VERSION
  exit 0;
endif

goto parse_args;
parse_args_return:
goto check_params;
check_params_return:

# This allows the user to require that the build stamp be
# consistent from one recon-all invocation to the next.
# Good for frozen versions.
if($?REQUIRE_FS_MATCH == 0) setenv REQUIRE_FS_MATCH 0
#echo "REQUIRE_FS_MATCH $REQUIRE_FS_MATCH"
set bstampfile0 = $FREESURFER_HOME/build-stamp.txt
mkdir -p $SUBJECTS_DIR/$subjid/scripts
set bstampfile  = $SUBJECTS_DIR/$subjid/scripts/build-stamp.txt
if(-e $bstampfile0) then
  if(! -e $bstampfile) cp $bstampfile0 $bstampfile
  set bstamp0 = `cat $bstampfile0`
  set bstamp  = `cat $bstampfile`
  if("$bstamp0" != "$bstamp") then
    if($REQUIRE_FS_MATCH) then
      echo "ERROR: FreeSurfer build stamps do not match"
      echo "Subject Stamp: $bstamp"
      echo "Current Stamp: $bstamp0"
      exit 1;
    else
      echo "INFO: FreeSurfer build stamps do not match"
    endif
  endif
  echo "Subject Stamp: $bstamp"
  echo "Current Stamp: $bstamp0"
endif


if ($DoMakefile) then
  setenv RECONALL_MAKE_SUBJECT $subjid
  set make_flags=( $MakefileTarget )
  if ( ! $RunIt) set make_flags=( -n $make_flags )
  echo "Subject '$subjid': make $make_flags"
  make -f $FREESURFER_HOME/bin/recon-all.makefile ${make_flags}
  exit ($status)
endif

if ($DoTime) then
  fs_time ls >& /dev/null
  if ( ! $status) set fs_time=(fs_time)
endif

echo "INFO: SUBJECTS_DIR is $SUBJECTS_DIR"

# Get "True" FS HOME
pushd $FREESURFER_HOME > /dev/null
set freesurfer_home_true = `pwd`;
popd > /dev/null
echo "Actual FREESURFER_HOME $freesurfer_home_true"

set DateString = "`date '+%y%m%d%H%M'`"

cd $subjdir # This variable is set in check_params
mkdir -p mri scripts surf tmp label touch stats touch src trash bem
mkdir -p mri/transforms mri/transforms/bak mri/orig
set touchdir = $subjdir/touch

# Create cmd and env files from scratch
if(! $DoVersionsOnly) then
  set CF = ($subjdir/scripts/$CF_DEFAULT_NAME)
  rm -f $CF
  # Create a separate file for the env
  set ENVF = $subjdir/scripts/recon-all.env
  if(-e $ENVF) mv $ENVF $ENVF.bak
  date                                     >> $ENVF
  echo "FREESURFER_HOME $FREESURFER_HOME"  >> $ENVF
  echo "Actual FREESURFER_HOME $freesurfer_home_true"  >> $ENVF
  pwd                                      >> $ENVF
  echo "setenv SUBJECTS_DIR $SUBJECTS_DIR" >> $ENVF
  echo $inputargs                          >> $ENVF
  uname -a                                 >> $ENVF
  echo ""                                  >> $ENVF
  limit                                    >> $ENVF
  echo ""                                  >> $ENVF
  printenv                                 >> $ENVF
endif

if($DoVersionsOnly) then
  if (-e /dev/stdout) then
    set LF = /dev/stdout
    set SF = /dev/stdout
  else
    set LF = /dev/null
    set SF = /dev/null
  endif
endif

# ------------ Create the log file --------------- #
if($#LF == 0) then
  set LF = ($subjdir/scripts/$LF_DEFAULT_NAME)
  if(-e $LF) then
    ls -l $LF
    if(! $AppendLog) then
      mv $LF $LF.old
    else
      echo "\n\n"  >> $LF
      echo "New invocation of recon-all "  >> $LF
      echo "\n\n"  >> $LF
    endif
  endif
else
  if(-e $LF) then
    echo "\n\n"  >> $LF
    echo "New invocation of recon-all "  >> $LF
    echo "\n\n"  >> $LF
  endif
endif

date >> $LF
$PWD >> $LF
echo $0 >> $LF
echo $inputargs >> $LF
# if running using -make, then dont bother with repeated info dumps
if ($?RECONALL_MAKE_SUBJECT) goto skip_all_info
echo "subjid $subjid" >> $LF
echo "setenv SUBJECTS_DIR $SUBJECTS_DIR" >> $LF
echo "FREESURFER_HOME $FREESURFER_HOME" >> $LF
echo "Actual FREESURFER_HOME $freesurfer_home_true" >> $LF
if (-e $FREESURFER_HOME/build-stamp.txt) then
  echo "build-stamp.txt: `cat $FREESURFER_HOME/build-stamp.txt`" >> $LF
endif
uname -a | tee -a $LF
limit >> $LF
if (-e /usr/bin/free) then
  echo "" >> $LF
  /usr/bin/free >> $LF
  echo "" >> $LF
endif
if ("`uname -s`" == "Darwin") then
  echo "" >> $LF
  /usr/bin/top -l 1 | grep PhysMem >> $LF
  echo "" >> $LF
endif

## gather all versions here
echo "########################################" >> $LF
echo "program versions used" >> $LF
echo $VERSION                >> $LF
mri_motion_correct.fsl -version >> $LF
flirt.fsl -version >> $LF
if($status) goto error_exit;
talairach_avi --version >> $LF
tkregister2_cmdl --all-info >> $LF
nu_correct -version >> $LF
mri_make_uchar -all-info >> $LF
mri_normalize -all-info >> $LF
mri_watershed -all-info >> $LF
mri_gcut -all-info >> $LF
mri_segment -all-info >> $LF
mri_label2label -all-info >> $LF
mri_em_register -all-info >> $LF
mri_ca_normalize -all-info >> $LF
mri_ca_register -all-info >> $LF
mri_ca_label -all-info >> $LF
mri_pretess -all-info >> $LF
mri_fill -all-info >> $LF
mri_tessellate -all-info >> $LF
mri_concatenate_lta -all-info >> $LF
mri_normalize_tp2 -all-info >> $LF
mris_smooth -all-info >> $LF
mris_inflate -all-info >> $LF
mris_curvature -all-info >> $LF
mris_sphere -all-info >> $LF
mris_fix_topology -all-info >> $LF
mris_topo_fixer -all-info >> $LF
mris_ca_label -all-info >> $LF
mris_euler_number -all-info >> $LF
mris_make_surfaces -all-info >> $LF
mris_register -all-info >> $LF
mris_volmask --all-info >> $LF
mris_anatomical_stats -all-info >> $LF
mrisp_paint -all-info >> $LF
mris_curvature_stats -all-info >> $LF
if(-e .xdebug_mris_curvature_stats) rm -f .xdebug_mris_curvature_stats
mris_calc -all-info >> $LF
if(-e .xdebug_mris_calc) rm -f .xdebug_mris_calc
mri_robust_register -all-info >> $LF
mri_robust_template -all-info >> $LF
mri_and -all-info >> $LF
mri_or -all-info >> $LF
mri_fuse_segmentations -all-info >> $LF
mri_segstats -all-info >> $LF

echo "#######################################" >> $LF
echo "GCADIR $GCADIR" >> $LF
echo "GCA $GCA" >> $LF
echo "GCASkull $GCASkull" >> $LF
echo "AvgCurvTif $AvgCurvTif" >> $LF
echo "GCSDIR $GCSDIR" >> $LF
echo "GCS $GCS" >> $LF
echo "#######################################" >> $LF
skip_all_info:

if($DoVersionsOnly) exit 0;

# Delete the error file. This is created when error_exit is run.
set ErrorFile = $subjdir/scripts/recon-all.error
rm -f $ErrorFile
# Delete the done file. This is created when recon-all exits normally
set DoneFile = $subjdir/scripts/recon-all.done
rm -f $DoneFile

# ------------ Create the IsRunning File --------- #
if($DoIsRunning) then
  set IsRunningLH   = $subjdir/scripts/IsRunning.lh
  set IsRunningRH   = $subjdir/scripts/IsRunning.rh
  set IsRunningLHRH = $subjdir/scripts/IsRunning.lh+rh
  set bailfile = ();
  if($#hemilist == 1) then
    set hemi = $hemilist;
    set IsRunningFile = $subjdir/scripts/IsRunning.$hemi
    if(-e $IsRunningLHRH) set bailfile = $IsRunningLHRH
  else
    set IsRunningFile = $subjdir/scripts/IsRunning.lh+rh
    if(-e $IsRunningLH)   set bailfile = $IsRunningLH
    if(-e $IsRunningRH)   set bailfile = $IsRunningRH
  endif
  if(-e $IsRunningFile) set bailfile = $IsRunningFile
  if($#bailfile) then
    echo ""
    echo "ERROR: it appears that recon-all is already running"
    echo "for $subjid based on the presence of $bailfile. It could"
    echo "also be that recon-all was running at one point but"
    echo "died in an unexpected way. If it is the case that there"
    echo "is a process running, you can kill it and start over or"
    echo "just let it run. If the process has died, you should type:"
    echo ""
    echo "rm $bailfile"
    echo ""
    echo "and re-run. Or you can add -no-isrunning to the recon-all"
    echo "command-line. The contents of this file are:"
    echo "----------------------------------------------------------"
    cat  $bailfile
    echo "----------------------------------------------------------"
    exit 1;
  endif
  echo "------------------------------" > $IsRunningFile
  echo "SUBJECT $subjid" >> $IsRunningFile
  echo "HEMI    $hemilist"  >> $IsRunningFile
  echo "DATE `date`"     >> $IsRunningFile
  echo "USER $user"      >> $IsRunningFile
  echo "HOST `hostname`" >> $IsRunningFile
  echo "PROCESSID $$ "   >> $IsRunningFile
  echo "PROCESSOR `uname -m`" >> $IsRunningFile
  echo "OS `uname -s`"       >> $IsRunningFile
  uname -a         >> $IsRunningFile
  echo $VERSION    >> $IsRunningFile
endif

# ------- Check FREESURFER HOME consistency ---------------------#
set CSDF = $subjdir/scripts/csurfdir
if($DoCleanCSDF) rm -vf $CSDF
if(-e $CSDF) then
  set tmp = `cat $CSDF`;
  if($tmp != $FREESURFER_HOME) then
   echo "INFO: current FREESURFER_HOME does not match that of previous processing." \
     | tee -a $LF
   echo "    Current: $FREESURFER_HOME" | tee -a $LF
   echo "    Previous: $tmp" | tee -a $LF
   sleep 1;
  endif
else
  echo $FREESURFER_HOME > $CSDF
endif

# --------------- Create the status file ---------------- #
if($#SF == 0) then
  set SF = ($subjdir/scripts/$SF_DEFAULT_NAME)
  if(-e $SF) then
    if(! $AppendStatus) then
       mv $SF $SF.old
    else
      echo "\n\n"  >> $SF
      echo "New invocation of recon-all "  >> $SF
      echo "\n\n"  >> $SF
    endif
  endif
else
  if(-e $SF) then
    echo "\n\n"  >> $SF
    echo "New invocation of recon-all "  >> $SF
    echo "\n\n"  >> $SF
  endif
endif
echo "status file for recon-all" >> $SF
date >> $SF

# Put a copy of myself (this script) in the scripts dir
cp $0 $subjdir/scripts/recon-all.local-copy

# Wait for a file to appear #
if($#WaitForFile != 0) then
  echo "Waiting for $WaitForFile" |& tee -a $SF |& tee -a $LF
  echo "  WaitSleep $WaitSleep" |& tee -a $SF |& tee -a $LF
  echo "  nWaitsMax $nWaitsMax" |& tee -a $SF |& tee -a $LF
  @ nWaits = 1;
  while(! -e $WaitForFile && $nWaits < $nWaitsMax)
    sleep $WaitSleep;
    @ nWaits = $nWaits + 1;
  end
  if(! -e $WaitForFile ) then
    echo "ERROR: timed out waiting for $WaitForFile"
    goto error_exit;
  endif
  echo "Finished Waiting `date`" |& tee -a $SF |& tee -a $LF
endif

if( ! $RunIt) then
  echo "INFO: -dontrun flag is in effect, so subsequent commands" |& tee -a $LF
  echo "may not have accurate arguments!" |& tee -a $LF
endif


#------------ Clean -----------------------------#
if($DoCleanSeed) then
  set cmd = ("mv -f $subjdir/scripts/seed-*.crs.man.dat $subjdir/trash");
  echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanCW256) then
  set cmd = (mv -f $subjdir/tmp/cw256 $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanTal) then
  set cmd = (mv -f $subjdir/mri/transforms/talairach.xfm $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanLta) then
  set cmd = ("mv -f $subjdir/mri/transforms/*.lta $subjdir/trash")
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanPFH) then
  set cmd = (mv -f $subjdir/mri/optimal_preflood_height $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
  set cmd = (mv -f $subjdir/mri/optimal_skullstrip_invol $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanBM) then
  set cmd = (mv -f $subjdir/mri/brainmask.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanASeg) then
  set cmd = (mv -f $subjdir/mri/aseg.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
  set cmd = (mv -f $subjdir/mri/aseg.manedit.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanWM) then
  set cmd = (mv -f $subjdir/mri/wm.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
  set cmd = (mv -f $subjdir/mri/wm.seg.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanCP) then
  set cmd = (mv -f $subjdir/tmp/control.dat $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanBFSE) then
  set cmd = (mv -f $subjdir/mri/brain.finalsurfs.manedit.mgz $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif
if($DoCleanXopts) then
  set cmd = (mv -f $subjdir/scripts/expert-options $subjdir/trash)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $cmd  |& tee -a $LF
endif

#------------ Handle Seed Points for Fill/Cut, and Watershed ---------------#
set seedfile = $subjdir/scripts/seed-pons.crs.man.dat
if($#PonsSeedCRS) then
  echo "# Manually specified seed CRS for Pons" > $seedfile
  echo $PonsSeedCRS >>  $seedfile
endif
if(-e $seedfile) set PonsSeedCRS = `cat $seedfile | grep -v \#`
set seedfile = $subjdir/scripts/seed-cc.crs.man.dat
if($#CCSeedCRS) then
  echo "# Manually specified seed CRS for CC" > $seedfile
  echo $CCSeedCRS >>  $seedfile
endif
if(-e $seedfile) set CCSeedCRS = `cat $seedfile | grep -v \#`
set seedfile = $subjdir/scripts/seed-lh.crs.man.dat
if($#LHSeedCRS) then
  echo "# Manually specified seed CRS for LH" > $seedfile
  echo $LHSeedCRS >>  $seedfile
endif
if(-e $seedfile) set LHSeedCRS = `cat $seedfile | grep -v \#`
set seedfile = $subjdir/scripts/seed-rh.crs.man.dat
if($#RHSeedCRS) then
  echo "# Manually specified seed CRS for RH" > $seedfile
  echo $RHSeedCRS >>  $seedfile
endif
if(-e $seedfile) set RHSeedCRS = `cat $seedfile | grep -v \#`

set seedfile = $subjdir/scripts/seed-ws.crs.man.dat
if($#WSSeedPoint) then
  echo "# Manually specified seed CRS for watershed" > $seedfile
  echo $WSSeedPoint >>  $seedfile
endif
if(-e $seedfile) set WSSeedPoint = `cat $seedfile | grep -v \#`

#------------ Control Points for Intensity Normalization ------------------#
set ControlPointsFile = $subjdir/tmp/control.dat
if(-e $ControlPointsFile) then
  set UseControlPoints = 1;
endif

#---- Conform Width to 256 --------#
if( $DoConformWidth256) then
  echo "-cw256 option is now persistent (remove with -clean-cw256)" \
    |& tee -a $LF
  touch $subjdir/tmp/cw256
endif

#---------------- Show Edits ------------------#
# discover which edits a user has made, list them, and if volume edits were
# made, create a file which shows them (using mri_compile_edits)
if($DoShowEdits) then
  @ edit_count = 0;
  echo "-----------------------------------------------" |& tee -a $LF
  echo "Subject $subjid has the following edits..." |& tee -a $LF

  # control points
  if(-e $ControlPointsFile) then
    @ edit_count = $edit_count + 1;
    set num_cps = (`grep numpoints $ControlPointsFile | awk '{print $2}'`)
    echo "$num_cps control points declared in file $ControlPointsFile" |& tee -a $LF
  endif

  # seeds
  set seedfile = $subjdir/scripts/seed-pons.crs.man.dat
  if(-e $seedfile) then
    @ edit_count = $edit_count + 1;
    echo "Manually specified seed CRS for Pons in file $seedfile" |& tee -a $LF
  endif
  set seedfile = $subjdir/scripts/seed-cc.crs.man.dat
  if($#CCSeedCRS) then
    @ edit_count = $edit_count + 1;
    echo "Manually specified seed CRS for CC in file $seedfile" |& tee -a $LF
  endif
  set seedfile = $subjdir/scripts/seed-lh.crs.man.dat
  if($#LHSeedCRS) then
    @ edit_count = $edit_count + 1;
    echo "Manually specified seed CRS for LH in file $seedfile" |& tee -a $LF
  endif
  set seedfile = $subjdir/scripts/seed-rh.crs.man.dat
  if($#RHSeedCRS) then
    @ edit_count = $edit_count + 1;
    echo "Manually specified seed CRS for RH in file $seedfile" |& tee -a $LF
  endif

  set seedfile = $subjdir/scripts/seed-ws.crs.man.dat
  if($#WSSeedPoint) then
    @ edit_count = $edit_count + 1;
    echo "Manually specified seed CRS for watershed in file $seedfile" \
        |& tee -a $LF
  endif

  # expert opts
  if($#XOptsFile != 0) then
    if (-e $XOptsFile)) then
      @ edit_count = $edit_count + 1;
      echo "Expert options declared in file $XOptsFile" |& tee -a $LF
    endif
  endif

  # talairach.xfm
  set xfm = $subjdir/mri/transforms/talairach.xfm
  set xfma = $subjdir/mri/transforms/talairach.auto.xfm
  if(-e $xfm && -e $xfma) then
    diff $xfm $xfma >& /dev/null
    if($status) then
      @ edit_count = $edit_count + 1;
      echo "The talairach.xfm file appears to have been edited" |& tee -a $LF
   endif
  endif

  # cw256
  if(-e $subjdir/tmp/cw256) then
    @ edit_count = $edit_count + 1;
    echo "Conform-width (reduce FOV) to 256 is enabled" |& tee -a $LF
  endif

  # volume edits, as determined by mri_compile_edits:
  # brainmask.mgz, aseg.mgz, brain.finalsurfs.mgz, wm.mgz, brain.mgz
  set compile_edits=($subjdir/tmp/compile_edits)
  set cmd = (mri_compile_edits ${subjid} $subjdir/mri/edits.mgz)
  if($RunIt) then
    if ( -e $compile_edits) rm -f $compile_edits
    $cmd |& tee -a $LF |& tee -a $compile_edits
    set vol_edits=(`grep mri_compile_edits_found $compile_edits | awk '{print $1}'`)
    if($#vol_edits != 0) then
      @ edit_count = $edit_count + $vol_edits;
    endif
  endif

  # summarize
  echo "$edit_count edits were found for subject $subjid" |& tee -a $LF

endif


#----------- Longitudinal ------------------#
if($longitudinal) then
  # if adding a new timepoint was requested by -addtp flag
  if($DoAddTp) then
    echo "Adding $tpNid as timepoint to base $longbaseid" |& tee -a $LF
    set cmd=(mri_add_new_tp $longbaseid $tpNid)
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif

  # init regfile variable with map cross_tp to base:
  # used later in many places
  set tpNtobase_regfile = ${longbasedir}/mri/transforms/${tpNid}_to_${longbaseid}.lta

  # map control.dat file from the cross-sectional data for this subj
  if ( -e ${SUBJECTS_DIR}/${tpNid}/tmp/control.dat && ! $UseLongbaseCtrlVol ) then
	  # only if it does not already exist:
	  if ( ! -e ${subjdir}/tmp/control.dat ) then
      set cmd = (mkdir -p ${subjdir}/tmp)
      echo "\n $cmd"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      set cmd = (mri_map_cpdat -in ${SUBJECTS_DIR}/${tpNid}/tmp/control.dat)
      set cmd = ($cmd -out ${subjdir}/tmp/control.dat)
		  set cmd = ($cmd -lta $tpNtobase_regfile)
      echo " $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
	  endif
  endif
endif

#----------- Convert Input ------------------#
if($#InputList != 0) then
  @ nth = 1;
  foreach InputVol ($InputList)

    # sanity-check: make sure each input has the same dimensions
    if ($nth == 1) then
      # assume first input has 'correct' dimensions
      set firstInput = ($InputVol)
      set rows = `mri_info --nrows $InputVol |& tail -n 1`
      set cols = `mri_info --ncols $InputVol |& tail -n 1`
      set slices = `mri_info --nslices $InputVol |& tail -n 1`
    else
      # check subsequent against the first input
      set nrows = `mri_info --nrows $InputVol |& tail -n 1`
      set ncols = `mri_info --ncols $InputVol |& tail -n 1`
      set nslices = `mri_info --nslices $InputVol |& tail -n 1`
      if (($nrows != $rows) || \
          ($ncols != $cols) || \
          ($nslices != $slices)) then
        echo "ERROR: inputs have mismatched dimensions!" |& tee -a $LF
        echo "$firstInput is" |& tee -a $LF
        echo "$rows x $cols x $slices while" |& tee -a $LF
        echo "$InputVol is" |& tee -a $LF
        echo "$nrows x $ncols x $nslices" |& tee -a $LF
        goto error_exit;
      endif
    endif

    set nthid = `printf %03d.mgz $nth`
    set cmd = (mri_convert $InputVol $subjdir/mri/orig/$nthid)
    $PWD |& tee -a $LF
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    @ nth = $nth + 1;
  end
endif

#------------- Longitudinal 'base' subject input file creation ------------#
if ($DoCreateBaseInput && $DoCreateBaseSubj) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Longitudinal Base Subject Creation `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  if ($#BaseSubjsList == 0) then
    echo "ERROR: must specify subjects for base subject using -base-tp" \
      |& tee -a $LF
    goto error_exit;
  endif
  cd $subjdir > /dev/null
  $PWD |& tee -a $LF
  if($RunIt) rm -f ${BaseSubjsListFname};
  set subjInVols=();
  set normInVols=();
  set ltaXforms=();
  foreach s ($BaseSubjsList)
    if($RunIt) echo "${s}" >> ${BaseSubjsListFname};
    set normInVols = ($normInVols ${SUBJECTS_DIR}/${s}/mri/norm.mgz)
    set subjInVols = ($subjInVols ${SUBJECTS_DIR}/${s}/mri/${BaseSubjInvol})
    set ltaname = ${s}_to_${subjid}.lta
    set ltaXforms = ($ltaXforms ${subjdir}/mri/transforms/${ltaname})
  end
  # create the 'mean/median' norm volume:
  set cmd = (mri_robust_template --mov ${normInVols})
  set cmd = ($cmd --lta ${ltaXforms})
  set cmd = ($cmd --average ${robust_template_avg_arg})
  set cmd = ($cmd --template ${subjdir}/mri/norm_template.mgz)
  set cmd = ($cmd --sat 4.685 )
  echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
  if($RunIt) then
    $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif
  # create the 'mean/median' input volume:
  set cmd = (mri_robust_template --mov ${subjInVols})
  set cmd = ($cmd --average ${robust_template_avg_arg})
  set cmd = ($cmd --ixforms ${ltaXforms})
  set cmd = ($cmd --noit)
  set cmd = ($cmd --template ${subjdir}/mri/orig/001.mgz)
  echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
  if($RunIt) then
    $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif
  # now create the inverse transforms
  cd $subjdir/mri/transforms > /dev/null
  $PWD |& tee -a $LF
  foreach s ($BaseSubjsList)
    set cmd = (mri_concatenate_lta -invert1)
    set cmd = ($cmd ${s}_to_${subjid}.lta)
    set cmd = ($cmd identity.nofile)
    set cmd = ($cmd ${subjid}_to_${s}.lta)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  end
  touch $touchdir/base.touch
endif

#----------- Motion Correct and Average ------------------#
if($DoMotionCor) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# MotionCor `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF

  if ($longitudinal) then
    # longitudinal processing to create orig.mgz:

    # in order to create orig.mgz in LONG we need at least 001.mgz in CROSS:
    if ( ! -e ${SUBJECTS_DIR}/${tpNid}/mri/orig/001.mgz ) then
      echo "ERROR: no CROSS run data found in ${SUBJECTS_DIR}/${tpNid}/mri/orig/. Make sure to" \
        |& tee -a $LF
      echo "have a volume called 001.mgz there." |& tee -a $LF
      echo "If you have a second run of data call it 002.mgz, etc." \
        |& tee -a $LF
      echo "See also: http://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/Conversion" \
        |& tee -a $LF
      goto error_exit;
    endif

    # use orig/00?.mgz from cross:
    set CrossList = `ls ${SUBJECTS_DIR}/${tpNid}/mri/orig/[0-9][0-9][0-9].mgz`;
    set origvol = $subjdir/mri/orig.mgz

    if($#CrossList == 1) then
      # if only single input, directly resample to base space
      set cmd = (mri_convert -at $tpNtobase_regfile -odt uchar)
      set cmd = ($cmd ${SUBJECTS_DIR}/${tpNid}/mri/orig/001.mgz)
      set cmd = ($cmd ${origvol})
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
      goto motioncor_post_process
    endif

    # if ltas and iscales exist in cross, copy them over
    set CrossLtas = `ls ${SUBJECTS_DIR}/${tpNid}/mri/orig/[0-9][0-9][0-9].lta`;
    set CrossIscales = `ls ${SUBJECTS_DIR}/${tpNid}/mri/orig/[0-9][0-9][0-9]-iscale.txt`;
    if ( $#CrossLtas > 0 ) then
      # check if one lta for each mgz:
      # here we could better check if really each 00?.mgz has its own 00?.lta in future
      if ( $#CrossList != $#CrossLtas ) then
        echo "ERROR: Orig 00?.mgz runs and number of 00?.lta files must agree in" \
         |& tee -a $LF
        echo "${SUBJECTS_DIR}/${tpNid}/mri/orig/" \
         |& tee -a $LF
        goto error_exit;
      endif
      #copy ltas:
      cd $subjdir/mri/
      set cmd = (cp -vf ${CrossLtas})
      set cmd = ($cmd orig/)
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
      #copy iscales if available:
      if ($#CrossIscales > 0) then
        # here we could better check if really each 00?.mgz has its own iscale file in future
        if ( $#CrossList != $#CrossIscales ) then
          echo "ERROR: Orig 00?.mgz runs and number of 00?-iscale.txt files must agree in" \
            |& tee -a $LF
          echo "${SUBJECTS_DIR}/${tpNid}/mri/orig/" \
            |& tee -a $LF
          goto error_exit;
        endif
        cd $subjdir/mri/
        set cmd = (cp -vf ${CrossIscales})
        set cmd = ($cmd orig/)
        echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
        if($RunIt) $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    else
      # else the ltas don't exist (mabye because 5.0 or fsl was used, they are created by 5.1+)
      # if more than one input, re-receate the ltas:
      if($#CrossList > 1) then
        # set output names for ltas and iscales in long dir
        set LongLtas = ""
        set LongIscales = ""
        foreach nthid ($CrossList)
          set nthname=`basename $nthid .mgz`
          set nthdir=$subjdir/mri/orig
          set nthlta=${nthdir}/${nthname}.lta
          set LongLtas=($LongLtas $nthlta)
          set LongIscales=($LongIscales $nthdir/${nthname}-iscale.txt)
        end
        # perform motion correction again to obtain the ltas (but in long dir, don't touch cross):
        set rawavg  = $subjdir/mri/rawavg.mgz
        # the output rawavg in long will be ignored and not used for anything
        # except maybe debugging, we only need the ltas and iscales!
        set cmd = (mri_robust_template)
        set cmd = ($cmd --mov ${CrossList})
        set cmd = ($cmd --average 1)
        set cmd = ($cmd --template ${rawavg})
        set cmd = ($cmd --satit)
        set cmd = ($cmd --inittp 1)
        set cmd = ($cmd --fixtp)
        set cmd = ($cmd --noit)
        set cmd = ($cmd --iscale)
        set cmd = ($cmd --iscaleout $LongIscales)
        set cmd = ($cmd --subsample 200)
        set cmd = ($cmd --lta $LongLtas)
        echo "#-----------------------------------------------"
        $PWD |& tee -a $LF
        echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
        if($RunIt) then
          $fs_time $cmd |& tee -a $LF
          if($status) goto error_exit;
        endif
      else
        # we should never get here, this case hase been dealt with above
        echo Only single run - should not get here
        goto error_exit;
      endif
    endif

    # now we have the ltas in long (current tp : subjdir)
    set LongLtas = `ls $subjdir/mri/orig/[0-9][0-9][0-9].lta`;
    set LongIscales = `ls $subjdir/mri/orig/[0-9][0-9][0-9]-iscale.txt`;

    # concat ltas (e.g. 002 -> 001 -> base/orig.mgz)
    set ConcatLtas = ""
    foreach nthlta ($LongLtas)
      set nthname=`basename $nthlta .lta`
      set nthdir=$subjdir/mri/orig
      set concatlta=${nthdir}/${nthname}-long.lta
      set ConcatLtas=($ConcatLtas $nthdir/${nthname}-long.lta)
      set cmd = (mri_concatenate_lta $nthlta $tpNtobase_regfile $concatlta)
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    end

    # use mri_robust_template just to create the average in base orig space:
    set cmd = (mri_robust_template)
    set cmd = ($cmd --mov ${CrossList})
    set cmd = ($cmd --average 1)
    set cmd = ($cmd --ixforms ${ConcatLtas})
    if ($#LongIscales > 0) then
      set cmd = ($cmd --iscalein ${LongIscales})
    endif
    set cmd = ($cmd --noit)
    set cmd = ($cmd --template ${origvol})
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif

    goto motioncor_post_process

  endif #longitudinal

  # default processing:
  set cmd = ();

  # Get list of input run directories #
  set RunList = ();
  ls $subjdir/mri/orig/[0-9][0-9][0-9].mgz >& /dev/null
  if(! $status) then
    set RunList = `ls $subjdir/mri/orig/[0-9][0-9][0-9].mgz`;
  else
    # No runs found
    ls $subjdir/mri//[0-9][0-9][0-9].mgz >& /dev/null
    if(! $status) then
      set RunList = `ls $subjdir/mri//[0-9][0-9][0-9].mgz`;
    else
      ls $subjdir/src/[0-9][0-9][0-9].mgz >& /dev/null
      if(! $status) then
         set RunList = $subjdir/src/[0-9][0-9][0-9].mgz
      endif
    endif
  endif
  if($#RunList == 0 && $RunIt) then
    echo "ERROR: no run data found in $subjdir/mri. Make sure to" \
      |& tee -a $LF
    echo "have a volume called 001.mgz in  $subjdir/mri/orig." |& tee -a $LF
    echo "If you have a second run of data call it 002.mgz, etc." \
      |& tee -a $LF
    echo "See also: http://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/Conversion" \
      |& tee -a $LF
    goto error_exit;
  else
    if ($RunIt) then
      echo "Found $#RunList runs" |& tee -a $LF
      foreach run ($RunList)
        echo $run |& tee -a $LF
      end
    endif
  endif

  # sanity-check: check if the input contains multiple frames, which would
  # be the case if a multi-echo frame mprage was accidently used as input.
  # without this check, andre is unhappy
  foreach RunVol ($RunList)
    echo "Checking for (invalid) multi-frame inputs..." |& tee -a $LF
    set nframes = `mri_info --nframes $RunVol |& tail -n 1`
    if ($nframes != 1) then
      echo "ERROR: input(s) cannot have multiple frames!" |& tee -a $LF
      echo "$RunVol has $nframes frames" |& tee -a $LF
      goto error_exit;
    endif
  end

  set origvol = $subjdir/mri/orig.mgz
  set rawavg  = $subjdir/mri/rawavg.mgz

  # Only one run, copy to rawavg
  if($#RunList == 1) then
    echo "WARNING: only one run found. This is OK, but motion"|& tee -a $LF
    echo "correction cannot be performed on one run, so I'll"|& tee -a $LF
    echo "copy the run to rawavg and continue."|& tee -a $LF
    sleep 2s;
    set cmd = (cp $RunList $rawavg)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      sleep 1; # Sleep here to assure that they have diff time stamps
      $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

  # Actually perform the motion correction -- creates rawavg
  if($#RunList > 1) then
    # set names for ltas
    set RunLtas = ""
    set RunIscales = ""
    foreach nthid ($RunList)
      set nthname=`basename $nthid .mgz`
      set nthdir=`dirname $nthid`
      set nthlta=${nthdir}/${nthname}.lta
      set RunLtas=($RunLtas $nthlta)
      set RunIscales=($RunIscales ${nthdir}/${nthname}-iscale.txt)
    end

    if($DoRobustMotionCor) then
      set cmd = (mri_robust_template)
      set cmd = ($cmd --mov ${RunList})
      set cmd = ($cmd --average 1)
      set cmd = ($cmd --template ${rawavg})
      set cmd = ($cmd --satit)
      set cmd = ($cmd --inittp 1)
      set cmd = ($cmd --fixtp)
      set cmd = ($cmd --noit)
      set cmd = ($cmd --iscale)
      set cmd = ($cmd --iscaleout $RunIscales)
      set cmd = ($cmd --subsample 200)
      set cmd = ($cmd --lta $RunLtas)
    else
      # use FSL's flirt to do motion correction (averaging of runs)
      set cmd = (mri_motion_correct.fsl -o $rawavg -wild $RunList)
    endif
    echo "#-----------------------------------------------"
    $PWD |& tee -a $LF
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
      echo $cmd > $touchdir/motion_correct.touch
    endif
  endif

  # At this point, rawavg.mgz exists. Use it to create orig.mgz,
  # conform to COR FOV but keep mgz format.
  set cmd = (mri_convert $rawavg $origvol)
  if($ConformMin) then
    set cmd = ($cmd --conform_min)
  else
    set cmd = ($cmd --conform)
    if($DoConformWidth256 || -e $subjdir/tmp/cw256) then
      # force conform width to 256
      set cmd = ($cmd --cw256)
      # see note just below on when -cw256 is necessary (ie, when FOV > 256)
    endif
  endif
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) then
    $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/conform.touch
  endif

  # this is the goto target for longitudinal processing (from above):
  motioncor_post_process:

  # check if FOV > 256 and error exit if so
  set FOV=`mri_info ${origvol} | grep fov: | awk '{print $2}'`
  set FOV_gt_256=`echo "${FOV} > 256" | bc`
  if ($FOV_gt_256) then
    echo "\n****************************************" |& tee -a $LF
    echo "ERROR! FOV=${FOV} > 256" |& tee -a $LF
    echo "Include the flag -cw256 with recon-all!" |& tee -a $LF
    echo "****************************************\n" |& tee -a $LF
    goto error_exit;
  endif

  # Add xfm to orig, eventhough it does not exist yet. This is a
  # compromise to keep from having to change the time stamp of
  # the orig volume after talairaching.
  set cmd = (mri_add_xform_to_header -c \
             $subjdir/mri/transforms/talairach.xfm \
             $origvol $origvol)
  echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
  if($RunIt) then
    $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif


endif # Motion Correction


#----------- Talairach ------------------#
if($DoTalairach) then
talairach:
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Talairach `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xfm = transforms/talairach.xfm
  set xfma = transforms/talairach.auto.xfm
  if ($longitudinal) then
    # longitudinal processing:
    if( -e $longbasedir/mri/$xfm) then
      set tal_xfm = $xfm
    else
      set tal_xfm = $xfma
    endif
    # copy from the base (as we are now in same space)
    # if edits were made to base, they will be also in long
    set cmd = (cp $longbasedir/mri/$tal_xfm $subjdir/mri/$xfma)
  else
    # default processing:
    if ($UseMincMritotal) then
      # use the MINC mritotal utility
      set xopts = `fsr-getxopts talairach $XOptsFile`;
      set cmd = (talairach --i orig.mgz --xfm $xfma $xopts)
    else
      # Avi Snyder's registration tools
      set xopts = `fsr-getxopts talairach_avi $XOptsFile`;
      set cmd = (talairach_avi --i orig.mgz --xfm $xfma)
      if($UseYa3tTalAtlas) then
        # special atlas composed of young adults scanned at 3T
        set cmd = ($cmd --atlas 3T18yoSchwartzReactN32_as_orig)
      endif
      set cmd = ($cmd $xopts)
    endif
  endif
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;

  if( -e $xfm && ! $DoCleanTal) then
    echo "\nINFO: $xfm already exists!" \
        |& tee -a $LF |& tee -a $CF
    echo "The new $xfma will not be copied to $xfm" \
        |& tee -a $LF |& tee -a $CF
    echo "This is done to retain any edits made to $xfm" \
        |& tee -a $LF |& tee -a $CF
    echo "Add the -clean-tal flag to recon-all to overwrite $xfm\n" \
        |& tee -a $LF |& tee -a $CF
  endif

  if($DoCleanTal || ! -e $xfm) then
    if(-e $xfm) cp $xfm transforms/bak/talairach.xfm.$DateString
    set cmd = (cp $xfma $xfm)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) then
      sleep 1; # Sleep here to assure that they have diff time stamps
      $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

  echo $cmd > $touchdir/talairach.touch
endif

# perform the failure detection scheme
if($DoTalCheck) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Talairach Failure Detection `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  # first run Laurence's AFD tool:
  set xopts = `fsr-getxopts talairach_afd $XOptsFile`;
  set xfm = transforms/talairach.xfm
  set cmd = (talairach_afd -T 0.005 -xfm $xfm $xopts)
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) then
    $fs_time $cmd |& tee -a $LF
    if($status) then
      # IF Talairach alignment was run
      # AND it was using the avi synder method
      # AND this check failed,
      # THEN try Talairach alignment using MINC mritotal tool
      # ELSE error exit
      if($DoTalairach && ! $UseMincMritotal && ! $longitudinal) then
        echo "INFO: Attempting MINC mritotal to perform Talairach align" \
          |& tee -a $LF
        set UseMincMritotal = 1;
        goto talairach;
      else
        goto error_exit;
      endif
    endif
  endif
  # now run Avi's QA check on the results found in talairach_avi.log
  set avilog = ($subjdir/mri/transforms/talairach_avi.log)
  if ( ! $UseMincMritotal && -e $avilog) then
    set cmd = (awk -f $FREESURFER_HOME/bin/extract_talairach_avi_QA.awk)
    set cmd = ($cmd $avilog)
    set qalog = ($subjdir/mri/transforms/talairach_avi_QA.log)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd >& $qalog
      if($status) then
        echo "ERROR: ${cmd} failed!  See logfile ${qalog}" |& tee -a $LF
        goto error_exit;
      endif
      set talAviQA=`grep "TalAviQA" ${qalog} | awk '{print $2}'`
      echo "TalAviQA: ${talAviQA}" |& tee -a $LF
      set mean=(0.9781) # buckner40 mean TalAviQA
      set std=(0.0044)  # buckner40 std TalAviQA
      set zscore=`echo "scale=0;(${talAviQA} - ${mean}) / ${std}" | bc`
      echo "z-score: ${zscore}" |& tee -a $LF
      set zscoreThreshold=(-9) # conservative value, but catches M.Harms subjs.
      if ($zscore < $zscoreThreshold) then
        echo "ERROR: Talairach QA check failed!" |& tee -a $LF
        echo "       z-score = ${zscore} <= ${zscoreThreshold} = threshold" \
             |& tee -a $LF
        echo "Manual Talairach alignment may be necessary, or" |& tee -a $LF
        echo "include the -notal-check flag to skip this test," |& tee -a $LF
        echo "making sure the -notal-check flag follows -all" |& tee -a $LF
        echo "or -autorecon1 in the command string." |& tee -a $LF
        echo "See http://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/Talairach" |& tee -a $LF
        # IF Talairach alignment was run
        # AND it was using the avi synder method
        # AND this check failed,
        # THEN try Talairach alignment using MINC mritotal tool
        # ELSE error exit
        if($DoTalairach && ! $UseMincMritotal && ! $longitudinal) then
          echo "INFO: Attempting MINC mritotal to perform Talairach align" \
            |& tee -a $LF
          set UseMincMritotal = 1;
          goto talairach;
        else
          goto error_exit;
        endif
      endif
    endif
  endif
endif


#----------- Nu Intensity Correction ------------------#
if($DoNuIntensityCor) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Nu Intensity Correction `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_nu_correct.mni $XOptsFile`;
  set cmd = (mri_nu_correct.mni  --i orig.mgz --o nu.mgz )
  # to fix a problem with mri_nu_correct.mni messing with the histogramming
  # in some odd subjects (due to voxels outside the brain, which has the
  # effect of altering white matter intensity interpretation downstream),
  # the inclusion of talairach.xfm with mri_nu_correct.mni causes 
  # mri_make_uchar to run, which uses the Tal xform to find a ball of voxels
  # that are mostly brain. The top of the intensity histogram in this ball
  # will then be white matter, which allows us to center it at the desired
  # value, approximately (110).
  if ($DoNuMakeUchar) set cmd = ($cmd --uchar transforms/talairach.xfm)
  # --cm for hi-res support:
  if ($ConformMin) set cmd = ($cmd --cm)
  if ($DoNuIntensityCor3T) then
    # params from Zheng, Chee, Zagorodnov 2009 NeuroImage paper
    # "Improvement of brain segmentation accuracy by optimizing
    # non-uniformity correction using N3"
    set NuIterations = 1;
    set cmd = ($cmd --proto-iters 1000 --distance 50)
  endif
  set cmd = ($cmd --n $NuIterations $xopts)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  touch $touchdir/nu.touch
endif


#----------- Defacing ------------------#
if($DoDeface) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Deface `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set cmd = (mri_deface orig.mgz \
     $FREESURFER_HOME/average/$brain_template \
     $FREESURFER_HOME/average/$face_template \
     orig_defaced.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  touch $touchdir/deface.touch
endif


#----------- Intensity Normalization1 ------------------#
if($DoNormalization) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Intensity Normalization `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF
  set xopts = `fsr-getxopts mri_normalize $XOptsFile`;
  if ( $longitudinal && $UseLongbaseCtrlVol) then
    # longitudinal processing stream AND using ctrl_vol.mgz from base:
    if( ! -e $longbasedir/mri/ctrl_vol.mgz || ! -e $longbasedir/mri/bias_vol.mgz ) then
      echo "Recompute intensity norm to create $longbaseid ctrl_vol.mgz" \
        |& tee -a $LF
      set cmd = (mri_normalize)
      if($IsMPRAGE)      set cmd = ($cmd -mprage)
      if($IsWashuMPRAGE) set cmd = ($cmd -washu_mprage)
      set cmd = ($cmd \
        -mask $longbasedir/mri/brain.mgz \
        -W $longbasedir/mri/ctrl_vol.mgz $longbasedir/mri/bias_vol.mgz \
        $longbasedir/mri/nu.mgz \
        $longbasedir/mri/T1_tmp.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
      if( ! -e $longbasedir/mri/ctrl_vol.mgz ) then
        echo "ERROR: unable to generate cntl-point volume for longbase" \
          |& tee -a $LF
        goto error_exit;
      endif
      rm -f $longbasedir/mri/T1_tmp.mgz
    endif
		# use ctrl_vol.mgz from base for normalization:
    set cmd = (mri_normalize \
		  -w $subjdir/mri/ctrl_vol.mgz $subjdir/mri/bias_vol.mgz \
			-l $longbasedir/mri/ctrl_vol.mgz $longbasedir/mri/bias_vol.mgz \
      $subjdir/mri/nu.mgz \
      $subjdir/mri/T1.mgz)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  else
    # for cross, base (and long if not useLongBaseCtrlVol) processing streams:
    set cmd = (mri_normalize -g $NormMaxGrad);
    if($UseControlPoints) set cmd = ($cmd -f $ControlPointsFile)
    if($#Norm3dIters)     set cmd = ($cmd -n $Norm3dIters)
    if($IsMPRAGE)         set cmd = ($cmd -mprage)
    if($IsWashuMPRAGE)    set cmd = ($cmd -washu_mprage)
    if($ConformMin)       set cmd = ($cmd -noconform)
    # in base create the ctrl_vol.mgz for init longs later:
    if($DoCreateBaseSubj) set cmd = ($cmd -W ctrl_vol.mgz bias_vol.mgz)
    set cmd = ($cmd $xopts nu.mgz T1.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif
  echo $cmd > $touchdir/inorm1.touch
endif

#----------- Skull Stripping ------------------#
if($DoSkullStrip) then
skullstrip:
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Skull Stripping `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF

  if ($longitudinal) then
    # longitudinal processing stream (copy from base):
    set BM  = brainmask.mgz
    set BMA = brainmask.auto.mgz
    set bmbase = brainmask_${longbaseid}.mgz
    set cmd = (cp -vf ${longbasedir}/mri/${BM} ./${bmbase})
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    # first apply mask and keep deletion edits (1)
    set cmd = (mri_mask -keep_mask_deletion_edits)
    set cmd = ($cmd T1.mgz ${bmbase} ${BMA})
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    # then transfer the 255 edits (still keep deletions)
    set cmd = (mri_mask -transfer 255)
    set cmd = ($cmd -keep_mask_deletion_edits)
    set cmd = ($cmd $BMA ${bmbase} $BMA)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    goto skipped_skullstrip;
  endif

  # base subject stream:
  if($DoCreateBaseSubj) then
    set BMA = brainmask.auto.mgz
    set BM  = brainmask.mgz  #used later
    # create lists with all cross brainmasks and all ltas:
    set bmInVols=""
    set ltaXforms=""
    foreach s ($BaseSubjsList)
      set bmInVols = ($bmInVols ${SUBJECTS_DIR}/${s}/mri/brainmask.mgz)
      set ltaname = ${s}_to_${subjid}.lta
      set ltaXforms = ($ltaXforms ${subjdir}/mri/transforms/${ltaname})
    end
    # map all brainmask with nearest neighbor and average 0=mean=logicalOR:
    set cmd = (mri_robust_template --mov ${bmInVols})
    set cmd = ($cmd --average 0)
    set cmd = ($cmd --ixforms ${ltaXforms})
    set cmd = ($cmd --noit)
    set cmd = ($cmd --finalnearest)
    set cmd = ($cmd --template brainmask_template.mgz)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    # create brainmask.auto by applying brainmask_template to T1
		# first apply mask and keep deletion edits (1)
    set cmd = (mri_mask -keep_mask_deletion_edits)
    set cmd = ($cmd T1.mgz brainmask_template.mgz $BMA)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    # then copy over the 255 (edits) and still keep deletions (1)
    set cmd = (mri_mask -transfer 255)
    set cmd = ($cmd -keep_mask_deletion_edits)
    set cmd = ($cmd $BMA brainmask_template.mgz $BMA)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    goto skipped_skullstrip;
  endif

  # default stream...
  set xopts = `fsr-getxopts mri_watershed $XOptsFile`;
  set opts = ();
  if($WaterShed == 0) set opts = ($opts -n);
  if($WaterShed == 2) set opts = ($opts -wat);
  if($WaterShed == 3) set opts = ($opts -wat+temp);
  if($WaterShed == 4) set opts = ($opts -atlas);
  if($WSLess) set opts = ($opts -less);
  if($WSMore) set opts = ($opts -more);
  if($WSAtlas) set opts = ($opts -atlas);
  if($#WSSeedPoint != 0) set opts = ($opts -s $WSSeedPoint);
  if($#WSPctPreFlood != 0) then
    set opts = ($opts -h $WSPctPreFlood);
    set DoMultiStrip = 0
  else if( -e optimal_preflood_height) then
    set WSPctPreFlood = `cat optimal_preflood_height`
    set opts = ($opts -h $WSPctPreFlood);
    set DoMultiStrip = 0
    echo "Using optimal preflood height of $WSPctPreFlood" |& tee -a $LF
  endif

  set cmd = (mri_watershed)
  set BM  = brainmask.mgz

  if ($WSGcaAtlas || $DoMultiStrip) then
    if ( ! $WSUseTalXfm) then # dont bother if using talairach.xfm
      # if using the GCA atlas to help with the skull-strip, then run the
      # GCA registration (mri_em_register) to align to an atlas with a skull,
      # unless that file already exists
      if ( ! -e transforms/talairach_with_skull.lta || $DoCleanLta ) then
        set xopts2 = `fsr-getxopts mri_em_register $XOptsFile`;
        set cmd2 = (mri_em_register)
        if($UseCuda) set cmd2 = (mri_em_register_cuda)
        set cmd2 = ($cmd2 -skull)
        set cmd2 = ($cmd2 $xopts2 nu.mgz ${GCADIR}/$GCASkull)
        set cmd2 = ($cmd2 transforms/talairach_with_skull.lta)
        echo "\n $cmd2 \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) $fs_time $cmd2 |& tee -a $LF
        if($status) goto error_exit;
        echo $cmd2 > $touchdir/em_register.touch
      endif
    endif

    if ($WSGcaAtlas) then
      # if just using -brain_atlas flag, then include necessary options
      if ($WSUseTalXfm) then
        set opts = (-brain_atlas ${GCADIR}/$GCASkull \
                    transforms/talairach.xfm $opts)
      else
        set opts = (-brain_atlas ${GCADIR}/$GCASkull \
                    transforms/talairach_with_skull.lta $opts)
      endif
    endif
  endif

  if($DoMultiStrip) then

    # when DoMultiStrip is enabled, multiple instances of mri_watershed are
    # run each using the following preflood height parameters
    if ( $?WATERSHED_PREFLOOD_HEIGHTS ) then
      # externally specified in the environment
      set PREFLOOD_HEIGHTS = ( $WATERSHED_PREFLOOD_HEIGHTS )
    else
      # defaults:
      set PREFLOOD_HEIGHTS = ( 5 10 20 30 )
    endif
    set SS_VOLUMES = ( orig nu T1 )
    if ( $?GOTO_LL_CALC ) goto ll_calc

    # create command files, one job for each volume type and preflood height...
    set CMDFS = ()
    foreach vol ( $SS_VOLUMES )
      foreach pfh ( $PREFLOOD_HEIGHTS )
        set cmd = (mri_watershed)
        set BMA_OLD = brainmask.auto.mgz
        set BMA = brainmask_${vol}_PFH${pfh}.auto.mgz
        if(-e $BMA_OLD && -e $BM && ! $DoCleanBM) then
          set cmd = ($cmd -keep $BMA_OLD $BM $BMA)
        endif
        set cmd = ($cmd $opts -h ${pfh} $xopts ${vol}.mgz $BMA)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        set CMDF = mri_watershed_${vol}_PFH${pfh}.cmd
        echo "$cmd" > $CMDF
        set CMDFS = ( $CMDFS $CMDF )
      end
    end

    # and launch parallel jobs and wait for completion.
    # the batchjobs script will append each job output to $LF
    if($RunIt) then
      batchjobs $LF $CMDFS
      if($status) goto error_exit;
    endif

    # brainmask volumes actually need to be T1 volumes, because while
    # mri_watershed may run best in some cases using orig.mgz as input,
    # we really want the brainmask to be from T1.mgz (post normalization)
    set CMDFS = ()
    foreach pfh ( $PREFLOOD_HEIGHTS )
      set BMA_ORIG = brainmask_orig_PFH${pfh}.auto.mgz
      if ( -e $BMA_ORIG ) then
        set cmd = (mri_mask T1.mgz $BMA_ORIG $BMA_ORIG)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        set CMDF = mri_mask_PFH${pfh}.cmd
        echo "$cmd" > $CMDF
        set CMDFS = ( $CMDFS $CMDF )
      endif
    end

    # and launch parallel jobs and wait for completion.
    # the batchjobs script will append each job output to $LF
    if($RunIt) then
      if($#CMDFS != 0) then
        batchjobs $LF $CMDFS
        if($status) goto error_exit;
      endif
    endif
    echo $cmd > $touchdir/skull_strip.touch

    # calculate a measure of skull-strip performance (mri_log_likelihood):
    ll_calc:
    set max_ll = -9999999999;
    set best_pfh = 0;
    set best_vol = ();
    set xopts = `fsr-getxopts mri_log_likelihood $XOptsFile`;
    foreach vol ( $SS_VOLUMES )
      foreach pfh ( $PREFLOOD_HEIGHTS )
        set BMA = brainmask_${vol}_PFH${pfh}.auto.mgz
        set LTA = transforms/talairach_with_skull.lta
        set cmd = (mri_log_likelihood -orig T1.mgz $BMA)
        set cmd = ($cmd $xopts ${GCADIR}/$GCA $LTA)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) then
          $cmd |& tee -a $LF |& tee -a ll_tmp
          # extract the last line of output, containing the result
          set ll = `tail -n 1 ll_tmp`
          rm -f ll_tmp
        endif
        if($status) goto error_exit;
        # and make the best result the brainmask.auto.mgz
        if($RunIt) then
          echo "$BMA log_likelihood= $ll" |& tee -a $LF
          if ("$ll" == "nan") continue
          if ($ll > $max_ll) then
            set max_ll = $ll;
            set best_pfh = $pfh;
            set best_vol = $vol;
            rm -f brainmask.auto.mgz
            cp $BMA brainmask.auto.mgz
            if($status) goto error_exit;
          endif
        endif
      end
    end
    if($RunIt) then
      if ($best_pfh == 0) then
        echo "ERROR: failure in calculating best preflood height param." \
          |& tee -a $LF
        goto error_exit;
      endif
      echo ""
      echo "Optimal input vol: $best_vol, pre-flood height= $best_pfh, results in log_likelihood= $max_ll" \
        |& tee -a $LF
      #rm -f *_PFH*.auto.*
      #rm -f *_PFH*.*
      # save this result, so that it is used next time, negating the need
      # to run mulitstrip (parallel jobs) again
      echo "$best_vol" > optimal_skullstrip_invol
      echo "$best_pfh" > optimal_preflood_height
    endif
    echo $cmd > $touchdir/log_likelihood.touch
    # make sure this is set properly:
    set BMA = brainmask.auto.mgz

  else

    # single-job skull-strip (default)

    set BMA = brainmask.auto.mgz
    if(-e $BMA && -e $BM && ! $DoCleanBM) set cmd = ($cmd -keep $BMA $BM $BM)
    set INVOL = T1
    if( -e optimal_skullstrip_invol) set INVOL = `cat optimal_skullstrip_invol`
    if("$INVOL" == "T1") set opts = ( -T1 $opts )
    set cmd = ($cmd $opts $xopts $INVOL.mgz $BMA)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    if("$INVOL" == "orig") then
      # while mri_watershed may run best in some cases using orig.mgz as input,
      # we really want the brainmask to be from T1.mgz (post normalization)
      set cmd = (mri_mask T1.mgz $BMA $BMA)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/skull_strip.touch

  endif

  # Gcut:
  # Nanyang Technological University's skull-stripper, which is intended to
  # work best running after watershed.  it further removes dura.  see:
  # 'Skull Stripping Using Graph Cuts', Neuroimage, 2009
  # brainmask.gcuts.mgz is a debug file showing voxels that were cut.
  if($DoGcut) then
    set BMA = brainmask.auto.mgz
    set BGC = brainmask.gcuts.mgz
    set xopts = `fsr-getxopts mri_gcut $XOptsFile`;
    set cmd = (mri_gcut $xopts -110 -mult $BMA T1.mgz $BMA $BGC)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    # binarize the gcuts file, setting vals to label 999 which appears as red
    # when loaded as a segmentation
    set cmd = (mri_binarize --i $BGC --o $BGC --binval 999 --min 1)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif

  skipped_skullstrip:

  if( -e $BM && ! $DoCleanBM) then
    echo "\nINFO: brainmask.mgz already exists!" \
        |& tee -a $LF |& tee -a $CF
    echo "The new brainmask.auto.mgz will not be copied to brainmask.mgz." \
        |& tee -a $LF |& tee -a $CF
    echo "This is done to retain any edits made to brainmask.mgz." \
        |& tee -a $LF |& tee -a $CF
    echo "Add the -clean-bm flag to recon-all to overwrite brainmask.mgz.\n" \
        |& tee -a $LF |& tee -a $CF
  endif

  if(! -e $BM || $DoCleanBM) then
    set cmd = (cp $BMA $BM)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) then
      sleep 1; # Sleep here to assure that they have diff time stamps
      $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

endif

#-------------- GCA Registration  -------------------------#
if($DoGCAReg) then
  echo "#-------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# EM Registration `date`" |& tee -a $SF |& tee -a $LF  |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF
  set xopts = `fsr-getxopts mri_em_register $XOptsFile`;
  if($longitudinal) then
    # longitudinal processing:
     set cmd = (cp -vf $longbasedir/mri/transforms/talairach.lta \
                 transforms/talairach.lta )

  else
    set cmd = (mri_em_register)
    if($UseCuda) set cmd = (mri_em_register_cuda)
    if($DoCreateBaseSubj) then
      # base subj processing (norm_template instead of nu, and no mask needed):
      set cmd = ($cmd -mask brainmask.mgz $xopts \
                  norm_template.mgz ${GCADIR}/$GCA \
                  transforms/talairach.lta)
    else
      # default processing:
      set cmd = ($cmd -mask brainmask.mgz $xopts \
                  nu.mgz ${GCADIR}/$GCA \
                  transforms/talairach.lta)
    endif
  endif
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/em_register.touch
endif

#------------ Canonical Normalization --------------#
if($DoCANormalize) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# CA Normalize `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF

  if ($longitudinal) then
    # longitudinal processing:
    # cp aseg from base to current TP:
    set cmd = (cp -vf ${longbasedir}/mri/aseg.mgz aseg_${longbaseid}.mgz)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if ($RunIt) $fs_time $cmd |& tee -a $LF
    if ($status) goto error_exit;
  endif

  set xopts = `fsr-getxopts mri_ca_normalize $XOptsFile`;
  set cmd = (mri_ca_normalize)
  if($UseControlPoints)  set cmd = ($cmd -f $ControlPointsFile)
  if ($longitudinal) then
    # longitudinal processing:
    # use the aseg_base (just created) as initialization of the current TP:
    set cmd = ($cmd -long aseg_${longbaseid}.mgz)
  else
    # default stream
    set cmd = ($cmd -c ctrl_pts.mgz)
  endif
  set cmd = ($cmd -mask brainmask.mgz $xopts)
  if($DoCreateBaseSubj) then
    # base subject stream
    # (use norm vol created during -base-init, no mask needed)
    set cmd = ($cmd norm_template.mgz)
  else
    # default stream
    set cmd = ($cmd nu.mgz)
  endif
  set cmd = ($cmd ${GCADIR}/$GCA)
  set cmd = ($cmd transforms/talairach.lta norm.mgz)

  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/ca_normalize.touch

endif # DoCANormalize


#------------ Canonical Registration --------------#
if($DoCAReg) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# CA Reg `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF

  set xopts = `fsr-getxopts mri_ca_register $XOptsFile`;
  set cmd = (mri_ca_register)
  if($UseCuda) set cmd = (mri_ca_register_cuda)
  if($UnCompress) set cmd = ($cmd -uncompress)
  if($BigVentricles) set cmd = ($cmd -bigventricles)
  if( ! $BigVentricles) set cmd = ($cmd -nobigventricles)
  if($DoSecondPassRenorm) set cmd = ($cmd -secondpassrenorm)
  if( ! $longitudinal) set cmd = ($cmd -T transforms/talairach.lta)
  if ( $longitudinal ) then
    # here is tpN's longitudinal command
    # init with warp (m3z) from base
    # no need to concatenate, as we are in same space now
    set cmd = ($cmd -levels 2 -A 1 \
                -l $longbasedir/mri/transforms/talairach.m3z \
                identity.nofile)
  endif
  set cmd = ($cmd $UseCAAlignAfter)
  set cmd = ($cmd -mask brainmask.mgz)
  set cmd = ($cmd $xopts norm.mgz \
             ${GCADIR}/$GCA \
             transforms/talairach.m3z)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  set st = $status
  if($st) then
    echo "ERROR: mri_ca_register with non-zero status $st" |& tee -a $LF
    echo "but continuing despite the error" |& tee -a $LF
    #goto error_exit;
  endif

  echo $cmd > $touchdir/ca_register.touch
endif

#------------ Inverse of Canonical Registration --------------#
if($DoCARegInv) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# CA Reg Inv `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  $PWD |& tee -a $LF
  # set xopts = `fsr-getxopts mri_ca_register $XOptsFile`; # careful here
  set cmd = (mri_ca_register)
  #NJS: cuda version doesnt work will -invert-and-save:
  #if($UseCuda) set cmd = (mri_ca_register_cuda)
  set cmd = ($cmd -invert-and-save transforms/talairach.m3z)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) then
    echo "ERROR: mri_ca_register with non-zero status $status" |& tee -a $LF
    goto error_exit;
  endif
  echo $cmd > $touchdir/ca_register_inv.touch
endif

#------------ Removes neck and part of the face  --------------#
if($DoRemoveNeck) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# Remove Neck `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_remove_neck $XOptsFile`;
  set xform = (transforms/talairach.m3z)
  if ( ! -e $xform) then
    echo "INFO: $xform not found, using talairach.lta instead" \
      |& tee -a $LF |& tee -a $CF
    set xform = (transforms/talairach.lta)
  endif
  set cmd = (mri_remove_neck -radius $RmNeckRadius $xopts \
             nu.mgz $xform \
             ${GCADIR}/$GCA nu_noneck.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/mri_remove_neck.touch
endif

#------------ Recompute lta with skull but no neck  --------------#
if($DoSkullLTA) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# SkullLTA `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_em_register $XOptsFile`;
  set cmd = (mri_em_register)
  if ($UseCuda) set cmd = (mri_em_register_cuda)
  set cmd = ($cmd -skull -t transforms/talairach.lta \
     $xopts nu_noneck.mgz ${GCADIR}/$GCASkull \
     transforms/talairach_with_skull.lta)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/skull.lta.touch
endif

#-------------- SubCort Segmentation --------------#
if($DoCALabel) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# SubCort Seg `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set DoASegMerge = 1; # Force

  if($DoCleanASeg) then
    set cmd = (rm -f aseg.mgz aseg.manedit.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
  endif

  # ----------- Prior to changing aseg.auto.mgz -------------------#
  if( -e aseg.mgz &&  -e aseg.auto.mgz) then
    # aseg.mgz and aseg.auto.mgz DO exist (at least 2nd pass)
    if(! -e aseg.manedit.mgz) then
      # aseg.manedit.mgz does NOT exist
      # Check for diffs between aseg.auto and aseg
      # Note: if there are no diffs, then aseg.manedit.mgz is not created
      set cmd = (mri_seg_diff --seg1 aseg.auto.mgz \
        --seg2 aseg.mgz --diff aseg.manedit.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if( ! $RunIt) then
        echo "INFO: mri_seg_diff was not actually executed," |& tee -a $LF
        echo "so subsequent commands (shown with -dontrun)" |& tee -a $LF
        echo "may not have accurate arguments!" |& tee -a $LF
      endif
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
    else
      # aseg.manedit.mgz DOES exist
      # This has to be handled in two stages in case manedit itself has
      # been edited.
      # 1. Check for diffs bettween aseg.auto and aseg (new and old edits)
      set cmd = (mri_seg_diff --seg1 aseg.auto.mgz \
        --seg2 aseg.mgz --diff aseg.manedit.tmp.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if( ! $RunIt) then
        echo "INFO: mri_seg_diff was not actually executed," |& tee -a $LF
        echo "so subsequent commands (shown with -dontrun)" |& tee -a $LF
        echo "may not have accurate arguments!" |& tee -a $LF
      endif
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
      # 2. Merge new and old edits with manedit. If manedit has not
      # been edited, then there will be no change.
      if(-e aseg.manedit.tmp.mgz) then
        set cmd = (mri_seg_diff --seg aseg.manedit.mgz \
          --diff-in aseg.manedit.tmp.mgz --merged aseg.manedit.mgz)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) $cmd |& tee -a $LF
        if($status) goto error_exit;
        rm aseg.manedit.tmp.mgz
      endif
    endif
  endif

  # ------------ longitudinal (pre)processing ----------------#
  # fuse segmentations of subjects composing the 'longbase' subject
  if ($longitudinal && $UseAsegFusion) then
    cd $subjdir/mri > /dev/null
    $PWD |& tee -a $LF
    set BaseSubjsList = (`cat ${longbasedir}/${BaseSubjsListFname}`)
    # first create lta's of basesubjs to longsubj
    foreach s (${BaseSubjsList})
      # copy the transform (tpi cross to base) to local transform dir
      # where mri_fuse_segmentations is looking for it:
      set cmd = (cp -vf ${longbasedir}/mri/transforms/${s}_to_${longbaseid}.lta \
                        ${subjdir}/mri/transforms/${s}_to_${subjid}.lta)
      echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
      if($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
      endif
    end
    # now create the fused aseg
    set cmd = (mri_fuse_segmentations)
    set cmd = ($cmd -a aseg.mgz -c aseg.auto_noCCseg.mgz -n norm.mgz)
    set cmd = ($cmd ${subjid} ${BaseSubjsList} aseg.fused.mgz)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

  #------------------- mri_ca_label -------------------------------#
  # Run mri_ca_label to create aseg.auto_noCCseg.mgz
  set xopts = `fsr-getxopts mri_ca_label $XOptsFile`;
  set cmd = (mri_ca_label)
  set cmd = ($cmd $UseCAAlign)
  if($BigVentricles) set cmd = ($cmd -bigventricles)
  if( ! $BigVentricles) set cmd = ($cmd -nobigventricles)
  if($NoWMSA) set cmd = ($cmd -nowmsa)
  set asegbasename=(aseg.auto_noCCseg)
  if($longitudinal && $UseAsegFusion) then
      # longitudinal processing: use 'fused' aseg just created
      set cmd=($cmd -r $subjdir/mri/aseg.fused.mgz)
      set cmd=($cmd -ri $longbasedir/mri/${asegbasename}.label_intensities.txt)
  endif
  set cmd = ($cmd $xopts norm.mgz)
  set cmd = ($cmd transforms/talairach.m3z)
  set cmd = ($cmd ${GCADIR}/$GCA)
  set cmd = ($cmd ${asegbasename}.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;

  #--- Corpus Callosum Segmentation ---#
  # Run mri_cc to create aseg.auto.mgz
  set xopts = `fsr-getxopts mri_cc $XOptsFile`;
  set cmd = (mri_cc -aseg aseg.auto_noCCseg.mgz -o aseg.auto.mgz \
    -lta ${subjdir}/mri/transforms/cc_up.lta $subjid $xopts);
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;

  echo $cmd > $touchdir/ca_label.touch
endif

# --------- Incorporate Manual ASeg Changes ----------------------
# Allow it to be done outside of CALabel. Note that DoASegMerge
# will be 1 if CALabel is run. This just allows the user to
# merge with Man Edits even if CALabel was not run, which will
# only have an effect if the user has actually changed aseg.manedit
if($DoASegMerge) then
  echo "#--------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# Merge ASeg `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  if(-e aseg.manedit.mgz ) then
    set cmd = (mri_seg_diff --seg aseg.auto.mgz \
      --diff-in aseg.manedit.mgz --merged aseg.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if( ! $RunIt) then
      echo "INFO: mri_seg_diff was not actually executed," |& tee -a $LF
      echo "so subsequent commands (shown with -dontrun)" |& tee -a $LF
      echo "may not have accurate arguments!" |& tee -a $LF
    endif
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
  else
    set cmd = (cp aseg.auto.mgz aseg.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif

  echo $cmd > $touchdir/asegmerge.touch
endif

# ----------- Intensity Normalization2 ------------------------#
if($DoNormalization2) then
  echo "#--------------------------------------------" \
    |& tee -a $LF  |& tee -a $CF
  echo "#@# Intensity Normalization2 `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_normalize $XOptsFile`;
  set cmd = (mri_normalize);
  if($UseControlPoints)   set cmd = ($cmd -f $ControlPointsFile)
  if($IsMPRAGE)           set cmd = ($cmd -mprage)
  if($IsWashuMPRAGE)      set cmd = ($cmd -washu_mprage)
  if($ConformMin)         set cmd = ($cmd -noconform)
  if($UseAseg && ! $NoAsegInorm2) set cmd = ($cmd -aseg aseg.mgz)
  if($NoNormMGZ) then
    # norm.mgz doesnt exist with -noaseg or -nosubcortseg, so use brainmask.mgz
    set cmd = ($cmd $xopts brainmask.mgz brain.mgz)
  else
    set cmd = ($cmd -mask brainmask.mgz $xopts norm.mgz brain.mgz)
  endif
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/inorm2.touch
endif

# -------------- Mask BFS ----------------------#
if($DoMaskBFS) then
  echo "#--------------------------------------------" \
    |& tee -a $LF  |& tee -a $CF
  echo "#@# Mask BFS `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_mask $XOptsFile`;
  # Set threshold to WM_MIN_VAL=5
  set cmd = (mri_mask -T 5 $xopts brain.mgz brainmask.mgz brain.finalsurfs.mgz)
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  # if they exist, transfer finalsurfs edits (voxels=255 and voxels=1)
  if( -e brain.finalsurfs.manedit.mgz) then
    set cmd = (mri_mask -transfer 255)
    set cmd = ($cmd -keep_mask_deletion_edits)
    set cmd = ($cmd brain.finalsurfs.mgz brain.finalsurfs.manedit.mgz \
        brain.finalsurfs.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif
endif

#---------------- WM Segmentation --------------------------#
if($DoSegmentation) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# WM Segmentation `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null

  set AllowLongWMtransfers = "1"
  if(! $DoCleanWM && -e wm.mgz) then
    set cmd = (cp wm.mgz wm.seg.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    # wm.mgz was available (probably edited):
    # don't allow transfers in long below
    set AllowLongWMtransfers = "0"
  endif
  # ----------- Segment -------------------------
  set xopts = `fsr-getxopts mri_segment $XOptsFile`;
  set cmd = (mri_segment);
  if ($NoThicken) set cmd = ($cmd -thicken 0)
  # note: check for wm.mgz happens so that -dontrun output is correct
  if(! $DoCleanWM && -e wm.mgz && -e wm.seg.mgz) set cmd = ($cmd -keep)
  if($IsMPRAGE)         set cmd = ($cmd -mprage)
  if($IsWashuMPRAGE)    set cmd = ($cmd -washu_mprage)
  set cmd = ($cmd $WMSeg_wlo $WMSeg_ghi $xopts brain.mgz wm.seg.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  # ----------- Edit with ASeg -------------------------
  if($UseAseg) then
    set xopts = `fsr-getxopts mri_edit_wm_with_aseg $XOptsFile`;
    set cmd = (mri_edit_wm_with_aseg)
    if(! $DoCleanWM) set cmd = ($cmd -keep-in)
    set cmd = ($cmd $xopts wm.seg.mgz brain.mgz aseg.mgz wm.asegedit.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif
  # ----------- PreTess -------------------------
  set xopts = `fsr-getxopts mri_pretess $XOptsFile`;
  set wmlabelstring = "wm"
  if($UseAseg) then
    set WM_vol = wm.asegedit.mgz
  else
    set WM_vol = wm.seg.mgz
  endif
  if($NoNormMGZ) then
    set norm_vol = brain.mgz
  else
    set norm_vol = norm.mgz
  endif
  set cmd = (mri_pretess )
  if(! $DoCleanWM && -e wm.mgz) set cmd = ($cmd -keep)
  set cmd = ($cmd $xopts $WM_vol $wmlabelstring $norm_vol wm.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;

  if($longitudinal && $AllowLongWMtransfers) then
    if ($UseLongbaseWMedits) then
      # transfer wm edits (voxels=255) from longbase wm.mgz to long tpN wm.mgz
      # and -keep_mask_deletion_edits transfers voxel-deletion (voxels=1) edits
      set cmd = (mri_mask -transfer 255)
      set cmd = ($cmd -keep_mask_deletion_edits)
      set cmd = ($cmd wm.mgz $longbasedir/mri/wm.mgz wm.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    else #default in -long:
      # transfer wm matter edits (voxels=255) from cross wm.mgz to long tpN wm.mgz
      # and -keep_mask_deletion_edits transfers voxel-deletion (voxels=1) edits
      set cmd = (mri_mask -transfer 255)
      set cmd = ($cmd -keep_mask_deletion_edits)
      set cmd = ($cmd -xform $tpNtobase_regfile)
      set cmd = ($cmd wm.mgz ${SUBJECTS_DIR}/${tpNid}/mri/wm.mgz wm.mgz)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
  endif

  echo $cmd > $touchdir/wmsegment.touch
endif

#---------------- Fill --------------------------#
if($DoFill) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# Fill `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_fill $XOptsFile`;
  set seedopts = ();
  if($#PonsSeedCRS) set seedopts = ($seedopts -Pv  $PonsSeedCRS);
  if($#CCSeedCRS)   set seedopts = ($seedopts -Cv  $CCSeedCRS);
  if($#LHSeedCRS)   set seedopts = ($seedopts -lhv $LHSeedCRS);
  if($#RHSeedCRS)   set seedopts = ($seedopts -rhv $RHSeedCRS);
  set cmd = (mri_fill -a ../scripts/ponscc.cut.log $seedopts)
  if(-e transforms/talairach.lta) then
    set cmd = ($cmd  -xform transforms/talairach.lta)
  endif
  if($UseAseg) set cmd = ($cmd -segmentation aseg.auto_noCCseg.mgz);
  if(! $UseOldTopoFix && ! $NoNormMGZ) set cmd = ($cmd -topofix norm.mgz);
  set cmd = ($cmd $xopts wm.mgz filled.mgz)
  $PWD |& tee -a $LF
  echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;

  echo $cmd > $touchdir/fill.touch
endif

#########################################################
#                  Per-Hemisphere                       #
#########################################################

foreach hemi ($hemilist)

  #---------------- Tessellate --------------------------#
  if($DoTessellate && ( ! $longitudinal )) then
    if($hemi == "lh") then
      set hemivalue = 255;
    else
      set hemivalue = 127;
    endif
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Tessellate $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    $PWD |& tee -a $LF

    # necessary second pretess, per f.segonne
    set xopts = `fsr-getxopts mri_pretess $XOptsFile`;
    if($NoNormMGZ) then
      set norm_vol = brain.mgz
    else
      set norm_vol = norm.mgz
    endif
    set cmd = (mri_pretess $xopts ../mri/filled.mgz $hemivalue \
                ../mri/$norm_vol ../mri/filled-pretess$hemivalue.mgz)
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    set xopts = `fsr-getxopts mri_tessellate $XOptsFile`;
    set cmd = (mri_tessellate $xopts ../mri/filled-pretess$hemivalue.mgz \
                $hemivalue ../surf/$hemi.orig.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    set cmd = (rm -f ../mri/filled-pretess$hemivalue.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF

    # remove possible extra components, per f.segonne
    set xopts = `fsr-getxopts mris_extract_main_component $XOptsFile`;
    set cmd = (mris_extract_main_component $xopts ../surf/$hemi.orig.nofix \
               ../surf/$hemi.orig.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    echo $cmd > $touchdir/$hemi.tessellate.touch
  endif

  #---------------- Smooth1 --------------------------#
  if($DoSmooth1 && ( ! $longitudinal )) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Smooth1 $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_smooth $XOptsFile`;
    # -nw prevents it from writing curv and area
    set cmd = (mris_smooth -nw)
    if ($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts \
        ../surf/$hemi.orig.nofix ../surf/$hemi.smoothwm.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    $PWD |& tee -a $LF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.smoothwm1.touch
  endif

  #---------------- Inflate1 --------------------------#
  if($DoInflate1 && ( ! $longitudinal )) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Inflation1 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_inflate $XOptsFile`;
    set cmd = (mris_inflate)
    if($UseCuda) set cmd = (mris_inflate_cuda)
    set cmd = ($cmd  -no-save-sulc $xopts \
      ../surf/$hemi.smoothwm.nofix ../surf/$hemi.inflated.nofix)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    $PWD |& tee -a $LF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.inflate1.touch
  endif

  #---------------- QSphere --------------------------#
  if($DoQSphere && ( ! $longitudinal )) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# QSphere $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_sphere $XOptsFile`;
    set cmd = (mris_sphere -q)
    if($UseCuda) set cmd = (mris_sphere_cuda -q)
    if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts)
    set cmd = ($cmd ../surf/$hemi.inflated.nofix ../surf/$hemi.qsphere.nofix)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.qsphere.touch
  endif

  #---------------- Fix Topology --------------------------#
  if($DoFix && ( ! $longitudinal )) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Fix Topology $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    # Must copy unfixed to fixed
    set cmd = (cp ../surf/$hemi.orig.nofix ../surf/$hemi.orig)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    set cmd = (cp ../surf/$hemi.inflated.nofix ../surf/$hemi.inflated)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
    # Now can run fixer
    if($UseOldTopoFix) then
      set xopts = `fsr-getxopts mris_fix_topology $XOptsFile`;
      set cmd = (mris_fix_topology)
      set cmd = ($cmd -mgz -sphere qsphere.nofix)
      if($FixWithGA) set cmd = ($cmd -ga)
      if($FixDiagOnly) set cmd = ($cmd -diagonly)
      if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
      set cmd = ($cmd $xopts $subjid $hemi)
      $PWD |& tee -a $LF
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
      # check if total defect index != 0, meaning, euler # != 2 (surface bad)
      set cmd = (mris_euler_number ../surf/$hemi.orig)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) then
        $cmd >& mris_euler_number.log
        if($status) goto error_exit;
        set defect_idx=`grep "total defect index" mris_euler_number.log | awk '{print $5}'`
        if("$defect_idx" != "0") then
          echo "mris_fix_topology failed! (euler number != 2)" |& tee -a $LF
          echo "Trying mris_topo_fixer..." |& tee -a $LF
          set UseNewTopoFix = 1
          set UseOldTopoFix = 0
          # cannot use the failed ?h.orig surface, must revert to ?.orig.nofix
          set cmd = (cp ../surf/$hemi.orig.nofix ../surf/$hemi.orig)
          echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
          if($RunIt) $cmd |& tee -a $LF
          if($status) goto error_exit;
        endif
        cat mris_euler_number.log |& tee -a $LF
        rm -f mris_euler_number.log
      endif
    endif
    if($UseNewTopoFix) then
      set cmd = (cp ../surf/$hemi.qsphere.nofix ../surf/$hemi.qsphere)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
      set cmd = (cp ../surf/$hemi.smoothwm.nofix ../surf/$hemi.smoothwm)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd |& tee -a $LF
      if($status) goto error_exit;
      set xopts = `fsr-getxopts mris_topo_fixer $XOptsFile`;
      set cmd = (mris_topo_fixer -mgz -warnings)
      if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
      set cmd = ($cmd $xopts $subjid $hemi)
      $PWD |& tee -a $LF
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif
    # run surface intersection checker/fixer
    set xopts = `fsr-getxopts mris_remove_intersection $XOptsFile`;
    set cmd = (mris_remove_intersection)
    set cmd = ($cmd $xopts ../surf/$hemi.orig ../surf/$hemi.orig)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    # Remove hemi.inflated, real one created after mris_make_surfaces
    set cmd = (rm ../surf/$hemi.inflated)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd
    if($UseNewTopoFix) then
      # Copy *h.orig_corrected to *h.orig
      set cmd = (cp ../surf/$hemi.orig_corrected ../surf/$hemi.orig )
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $cmd
      if($status) goto error_exit;
    endif
    echo $cmd > $touchdir/$hemi.topofix.touch
  endif

  # Smooth2 and Inflate2 moved to after make white surfs

  #---------------- Make White Surfaces --------------------------#
  if($DoWhiteSurfs) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Make White Surf $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null

    if( $longitudinal ) then
      set cmd = (cp -vf $longbasedir/surf/${hemi}.white \
                        $subjdir/surf/${hemi}.orig)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;

      set cmd = (cp -vf $longbasedir/surf/${hemi}.white \
                        $subjdir/surf/${hemi}.orig_white)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif

    # Note mris_make_surfaces uses filled.mgz implicitly
    set xopts = `fsr-getxopts mris_make_surfaces $XOptsFile`;
    if($longitudinal) then
      # longitudinal processing:
      set cmd = (mris_make_surfaces \
          -orig_white orig_white \
          -orig orig_white \
          -long \
          -max 3.5)
    else
      # default stream:
      set cmd = (mris_make_surfaces)
    endif
    if ( ! $UseAseg) set cmd = ($cmd -noaseg)
    set cmd = ($cmd -noaparc)
    if($DoPialSurfs) then
      # if creating pial downstream, then only do white surface now
      set cmd = ($cmd -whiteonly)
    else
      # else old-style single-run -finalsurfs is emulated
      if($longitudinal) set cmd = ($cmd -orig_pial orig_pial)
    endif
    set cmd = ($cmd -mgz -T1 brain.finalsurfs)
    set cmd = ($cmd $WMSeg_wlo $WMSeg_ghi $xopts $subjid $hemi)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.white_surface.touch
    if( ! $DoPialSurfs) echo $cmd > $touchdir/$hemi.final_surfaces.touch
  endif

  #---------------- Smooth2 --------------------------#
  if($DoSmooth2) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Smooth2 $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_smooth $XOptsFile`;
    # Use -nw to keep from writing out curv and area
    # Default number of iterations is 10, but use 3 here
    set cmd = (mris_smooth -n 3 -nw)
    if ($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts)
    set cmd = ($cmd ../surf/$hemi.white ../surf/$hemi.smoothwm)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    $PWD |& tee -a $LF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.smoothwm2.touch
  endif

  #---------------- Inflate2 --------------------------#
  if($DoInflate2) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Inflation2 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_inflate $XOptsFile`;
    set cmd = (mris_inflate)
    if($UseCuda) set cmd = (mris_inflate_cuda)
    set cmd = ($cmd $xopts ../surf/$hemi.smoothwm \
               ../surf/$hemi.inflated)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    # create curvature files ?h.inflated.H and ?h.inflated.K
    set xopts = `fsr-getxopts mris_curatvure $XOptsFile`;
    set cmd = (mris_curvature -thresh .999 -n -a 5 -w -distances 10 10)
    set cmd = ($cmd $xopts ../surf/$hemi.inflated)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.inflate2.touch
  endif

  # ---------- Curvature Anatomical Stats ---------------------------
  if($DoCurvStats) then
    echo "\n#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Curvature Stats $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/surf > /dev/null
    set stats = ../stats/$hemi.curv.stats
    set xopts = `fsr-getxopts mris_curvature_stats $XOptsFile`;
    set cmd = (mris_curvature_stats -m --writeCurvatureFiles -G \
            -o $stats -F smoothwm \
            $xopts $subjid $hemi curv sulc);
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    #if($status) goto error_exit;
    if(-e .xdebug_mris_curvature_stats) rm -f .xdebug_mris_curvature_stats
    echo $cmd > $touchdir/$hemi.curvstats.touch
  endif


  #---------------Begin Morph --------------------------------#
  #---------------- Sphere --------------------------#
  if($DoSphere) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Sphere $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    if($longitudinal) then
      # longitudinal processing:
      set cmd = (cp $longbasedir/surf/$hemi.sphere $subjdir/surf/$hemi.sphere)
    else
      # default stream:
      set xopts = `fsr-getxopts mris_sphere $XOptsFile`;
      set cmd = (mris_sphere)
      if($UseCuda) set cmd = (mris_sphere_cuda)
      if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
      if($UseNoNeg) set cmd = ($cmd -remove_negative 1)
      set cmd = ($cmd $xopts)
      set cmd = ($cmd ../surf/$hemi.inflated ../surf/$hemi.sphere)
    endif
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.sphmorph.touch
  endif

  #---------------- Surface Registration --------------------------#
  if($DoSurfReg) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Surf Reg $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set AvgTif = ${AvgCurvTifPath}/$hemi.${AvgCurvTif}
    set xopts = `fsr-getxopts mris_register $XOptsFile`;
    set cmd = (mris_register -curv)
    if($UseNoNeg) set cmd = ($cmd -remove_negative 1)
    set cmd = ($cmd $xopts)
    if($longitudinal) then
      # longitudinal processing:
      set cmd = ($cmd  -nosulc -norot \
                    $longbasedir/surf/$hemi.sphere.reg \
                    $AvgTif \
                    ../surf/$hemi.sphere.reg)
    else
      # default stream:
      set cmd = ($cmd ../surf/$hemi.sphere $AvgTif ../surf/$hemi.sphere.reg)
    endif
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.sphreg.touch
  endif

  #---------- Surface Registration to Average Subject ----------------#
  if($#SurfRegToSubj) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Surf RegTo $SurfRegToSubj $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set AvgTif = $SUBJECTS_DIR/$SurfRegToSubj/$hemi.reg.template.tif
    set outreg =  ../surf/$hemi.sphere.$SurfRegToSubj.reg
    set cmd = (mris_register -curv)
    if($UseNoNeg) set cmd = ($cmd -remove_negative 1)
    set cmd = ($cmd ../surf/$hemi.sphere $AvgTif $outreg);
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.sphreg.$SurfRegToSubj.touch
  endif

  #---------------- Jacobian white --------------------------#
  if($DoJacobianWhite) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Jacobian white $hemi `date`" \
        |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    # produce the jacobian, from the white surface to the sphere
    set cmd = (mris_jacobian \
                ../surf/$hemi.white \
                ../surf/$hemi.sphere.reg \
                ../surf/$hemi.jacobian_white)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.jacobian_white.touch
  endif

  #--- Surface Registration, allow maximal distortion, produce Jacobian ---#
  if($DoJacobianDist0) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Jacobian dist0 $hemi `date`" \
        |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set AvgTif = ${AvgCurvTifPath}/$hemi.${AvgCurvTif}
    set xopts = `fsr-getxopts mris_register $XOptsFile`;
    set cmd = (mris_register -curv -norot -jacobian \
        ../surf/$hemi.jacobian_dist0 -dist 0)
    set cmd = ($cmd $xopts)
    set cmd = ($cmd ../surf/$hemi.sphere.reg $AvgTif \
        ../surf/$hemi.sphere.dist0.jacobian.reg)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.jacobian_dist0.touch
  endif

  #---------------- Average Curv for Display----------------------#
  if($DoAvgCurv) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# AvgCurv $hemi `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set AvgTif = ${AvgCurvTifPath}/$hemi.${AvgCurvTif}
    set xopts = `fsr-getxopts mrisp_paint $XOptsFile`;
    # -a 5 means to smooth 5 iterations
    set cmd = (mrisp_paint -a 5 $xopts "$AvgTif#6" \
      ../surf/$hemi.sphere.reg ../surf/$hemi.avg_curv)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.avgcurv.touch
  endif

  #---------------- Cortical Parcellation------------------------#
  if($DoCortParc) then
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Cortical Parc $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_ca_label $XOptsFile`;
    set CPAtlas = ${GCSDIR}/$hemi.$GCS
    set annot = ../label/$hemi.aparc.annot
    set cmd = (mris_ca_label)
    if($UseAseg) set cmd = ($cmd -l ../label/$hemi.cortex.label)
    if($UseAseg) set cmd = ($cmd -aseg ../mri/aseg.mgz)
    if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts)
    if($longitudinal) then
      # longitudinal:
      set cmd = ($cmd -long -R $longbasedir/label/${hemi}.aparc.annot)
    endif
    set cmd = ($cmd $subjid $hemi ../surf/$hemi.sphere.reg $CPAtlas $annot)
    $PWD |& tee -a $LF
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.aparc.touch
  endif

  #---------------- Make Pial Surfaces --------------------------#
  if($DoPialSurfs) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Make Pial Surf $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null

    if( $longitudinal ) then
      set cmd = (cp -vf $longbasedir/surf/${hemi}.pial\
                        $subjdir/surf/${hemi}.orig_pial)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    endif

    # Note mris_make_surfaces uses filled.mgz implicitly
    set xopts = `fsr-getxopts mris_make_surfaces $XOptsFile`;
    if($longitudinal) then
      # longitudinal processing:
      set cmd = (mris_make_surfaces \
          -orig orig_white \
          -orig_white orig_white \
          -orig_pial orig_pial \
          -long -max 3.5)
    else
      # default stream:
      set cmd = (mris_make_surfaces)
    endif
    if ( ! $UseAseg) set cmd = ($cmd -noaseg)
    if ($PialNoAparc) set cmd = ($cmd -noaparc)
    # -white NOWRITE: dont overwrite white, curv, area, and cortex.label files
    set cmd = ($cmd -white NOWRITE)
    set cmd = ($cmd -mgz -T1 brain.finalsurfs)
    set cmd = ($cmd $WMSeg_wlo $WMSeg_ghi $xopts $subjid $hemi);
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.pial_surface.touch
    echo $cmd > $touchdir/$hemi.final_surfaces.touch
  endif
  if($DoPialSurfs || $DoSurfVolume) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Surf Volume $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/surf > /dev/null
    $PWD |& tee -a $LF
    set cmd=(mris_calc -o ${hemi}.area.mid ${hemi}.area add ${hemi}.area.pial)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    set cmd=(mris_calc -o ${hemi}.area.mid ${hemi}.area.mid div 2)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    set cmd=(mris_calc -o ${hemi}.volume)
    set cmd=($cmd ${hemi}.area.mid mul ${hemi}.thickness)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    if(-e .xdebug_mris_calc) rm -f .xdebug_mris_calc
    echo $cmd > $touchdir/$hemi.surfvolume.touch
  endif

  # ---------- Surface Anatomical Stats ---------------------------
  if($DoParcStats) then
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Parcellation Stats $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set annot = ../label/$hemi.aparc.annot
    set stats = ../stats/$hemi.aparc.stats
    set ctab  = ../label/aparc.annot.ctab
    set xopts = `fsr-getxopts mris_anatomical_stats $XOptsFile`;
    set cmd = (mris_anatomical_stats -mgz)
    if($UseAseg) set cmd = ($cmd -cortex ../label/$hemi.cortex.label)
    set cmd = ($cmd -f $stats -b -a $annot -c $ctab $xopts $subjid $hemi white);
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.aparcstats.touch
  endif

  #---------------- Cortical Parcellation 2------------------------#
  if($DoCortParc2) then
    echo "#-----------------------------------------"\
      |& tee -a $LF |& tee -a $CF
    echo "#@# Cortical Parc 2 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set xopts = `fsr-getxopts mris_ca_label $XOptsFile`;
    set CPAtlas = ${GCSDIR}/${hemi}.${DESTRIEUX_GCS}
    set annot = ../label/$hemi.aparc.${DESTRIEUX_NAME}.annot
    set cmd = (mris_ca_label)
    if($UseAseg) set cmd = ($cmd -l ../label/$hemi.cortex.label)
    if($UseAseg) set cmd = ($cmd -aseg ../mri/aseg.mgz)
    if($NoRandomness) set cmd = ($cmd -seed $RngSeed)
    set cmd = ($cmd $xopts)
    if($longitudinal) then
      # longitudinal:
      set cmd = ($cmd -long -R \
                   $longbasedir/label/${hemi}.aparc.${DESTRIEUX_NAME}.annot)
    endif
    set cmd = ($cmd $subjid $hemi ../surf/$hemi.sphere.reg $CPAtlas $annot)
    $PWD |& tee -a $LF
    echo "\n $cmd \n" |& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.aparc2.touch
  endif

  # ---------- Surface Anatomical Stats 2 ---------------------------
  if($DoParcStats2) then
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Parcellation Stats 2 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set annot = ../label/$hemi.aparc.${DESTRIEUX_NAME}.annot
    set stats = ../stats/$hemi.aparc.${DESTRIEUX_NAME}.stats
    set ctab  = ../label/aparc.annot.${DESTRIEUX_NAME}.ctab
    set xopts = `fsr-getxopts mris_anatomical_stats $XOptsFile`;
    set cmd = (mris_anatomical_stats -mgz)
    if($UseAseg) set cmd = ($cmd -cortex ../label/$hemi.cortex.label)
    set cmd = ($cmd -f $stats -b -a $annot -c $ctab $xopts $subjid $hemi white);
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.aparcstats2.touch
  endif

  # ---------- Surface Vertices Number Match Check --------------
  if($DoVnoMatchCheck) then
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Vno Match Check $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set cmd = (vno_match_check $subjid $hemi);
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.vnomatchcheck.touch
  endif

  # ------ Compare aseg stats of two subjects ------
  if ($DoAparcStatsDiff) then
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# AParc Stats Diff `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $SUBJECTS_DIR > /dev/null
    $PWD |& tee -a $LF
    foreach parc (aparc)
      foreach meas (area volume thickness)
        set subj1=($diffsubj)
        if ( "x$subj1" == "x$subjid" ) then
          # aparcstats2table doesnt accept identical subject names, so fake it
          ln -s $subj1 ${diffsubj}_tmp
          set subj1=(${diffsubj}_tmp)
        endif
        set cmd=(aparcstatsdiff $subj1 $subjid $hemi $parc $meas)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) $fs_time $cmd |& tee -a $LF
        if (-e ${diffsubj}_tmp) rm ${diffsubj}_tmp
      end
    end
    echo $cmd > $touchdir/aparcstatsdiff.touch
  endif

  # ---------- Label V1 ----------------
  if($DoLabelV1) then
    echo "#-----------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Label V1 $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    if ( ! -e $SUBJECTS_DIR/V1_average) then
      echo "ERROR: V1_average subject does not exist in SUBJECTS_DIR!"
      goto error_exit;
    endif
    cd $subjdir/label > /dev/null
    $PWD |& tee -a $LF
    set cmd=(predict_v1.sh)
    if( ! $RunIt) set cmd=($cmd -p)
    set cmd = ($cmd -h $hemi $subjid);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.label_v1.touch
  endif

end # Loop over hemilist


#-------Edit Aseg with Surfaces -------------#
if($DoSurfSegEdit) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# SurfSegEdit `date`" \
    |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mri_edit_segmentation_with_surfaces $XOptsFile`;
  set cmd = (mri_edit_segmentation_with_surfaces $xopts)
  set cmd = ($cmd aseg.auto.mgz ../surf norm.mgz aseg.surfedit.mgz)
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  $PWD |& tee -a $LF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  # now merge any manual edits that user might have made
  if(-e aseg.manedit.mgz ) then
    set cmd = (mri_seg_diff --seg aseg.surfedit.mgz \
      --diff-in aseg.manedit.mgz --merged aseg.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if( ! $RunIt) then
      echo "INFO: mri_seg_diff was not actually executed," |& tee -a $LF
      echo "so subsequent commands (shown with -dontrun)" |& tee -a $LF
      echo "may not have accurate arguments!" |& tee -a $LF
    endif
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
  # if no manual edits, then copy to aseg.mgz
  else
    set cmd = (cp aseg.surfedit.mgz aseg.mgz)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $cmd |& tee -a $LF
    if($status) goto error_exit;
  endif
  echo $cmd > $touchdir/surfsegedit.touch
endif

#---------------- Cortical Ribbon -------------------------#
if($DoCortRibbonVolMask) then
  echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
  echo "#@# Cortical ribbon mask `date`" \
      |& tee -a $SF|& tee -a $LF|& tee -a $CF
  cd $subjdir/mri > /dev/null
  set xopts = `fsr-getxopts mris_volmask $XOptsFile`;
  set cmd = (mris_volmask \
    --label_left_white   2 --label_left_ribbon   3 \
    --label_right_white 41 --label_right_ribbon 42 \
    --save_ribbon $subjid)
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/cortical_ribbon.touch
endif

#-------------- ASeg Stats --------------#
if($DoSegStats) then
  # Stats on the automatic segmentation
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# ASeg Stats `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir > /dev/null
  set xopts = `fsr-getxopts mri_segstats $XOptsFile`;
  set cmd = (mri_segstats --seg mri/aseg.mgz --sum stats/aseg.stats)
  set cmd = ($cmd --pv mri/norm.mgz --empty)
  set cmd = ($cmd --excludeid 0 --excl-ctxgmwm)
  if ( -e mri/ribbon.mgz ) then
    set cmd = ($cmd --supratent)
  else
    echo "\nINFO: mri_segstats will not calculate Supratentorial" |& tee -a $LF
    echo "      due to missing ribbon.mgz file" |& tee -a $LF
  endif
  set cmd = ($cmd --subcortgray)
  set cmd = ($cmd --in mri/norm.mgz --in-intensity-name norm)
  set cmd = ($cmd --in-intensity-units MR)
  if ( -e mri/transforms/talairach.xfm ) then
    set cmd = ($cmd --etiv);
  else
    echo "\nINFO: mri_segstats will not calculate eTIV" |& tee -a $LF
    echo "      due to missing talairach.xfm file" |& tee -a $LF
  endif
  if ( ( -e surf/lh.white ) && ( -e surf/rh.white ) ) then
    set cmd = ($cmd --surf-wm-vol)
    if ( ( -e surf/lh.pial ) && ( -e surf/rh.pial ) ) then
      set cmd = ($cmd --surf-ctx-vol --totalgray)
    else
      echo "\nINFO: ?h.pial surfaces not available to mri_segstats.\n"\
       |& tee -a $SF |& tee -a $LF |& tee -a $CF
    endif
  else
    echo "\nINFO: ?h.white surfaces not available to mri_segstats.\n"\
     |& tee -a $SF |& tee -a $LF |& tee -a $CF
  endif
  set cmd = ($cmd --ctab $FREESURFER_HOME/ASegStatsLUT.txt)
  set cmd = ($cmd --subject $subjid $xopts);
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;

  echo $cmd > $touchdir/segstats.touch
endif

if ($DoAsegStatsDiff) then
  # Compare aseg stats of two subjects
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# ASeg Stats Diff `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $SUBJECTS_DIR > /dev/null
  set subj1=($diffsubj)
  if ( "x$subj1" == "x$subjid" ) then
    # asegstats2table doesnt accept identical subject names, so fake it
    ln -s $subj1 ${diffsubj}_tmp
    set subj1=(${diffsubj}_tmp)
  endif
  set cmd=(asegstatsdiff $subj1 $subjid)
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if (-e ${diffsubj}_tmp) rm ${diffsubj}_tmp
  echo $cmd > $touchdir/asegstatsdiff.touch
endif

# ----------------- AParc2ASeg ---------------------------------------- #
if($DoAParc2ASeg) then
  echo "#-----------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# AParc-to-ASeg `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir > /dev/null
  set xopts = `fsr-getxopts mri_aparc2aseg $XOptsFile`;
  # Desikan (or whatever was specified by -gcs)
  set cmd = (mri_aparc2aseg --s $subjid --volmask $xopts)
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/aparc2aseg.touch
  # Now do Christophe's (if exist, which they may not, if -nocortparc2 used)
  if( -e ${subjdir}/label/lh.aparc.${DESTRIEUX_NAME}.annot && \
      -e ${subjdir}/label/rh.aparc.${DESTRIEUX_NAME}.annot ) then
    set xopts = `fsr-getxopts mri_aparc2aseg $XOptsFile`;
    set cmd = (mri_aparc2aseg --s $subjid --volmask --${DESTRIEUX_NAME} $xopts)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/aparc.${DESTRIEUX_NAME}2aseg.touch
  else
    echo "INFO: skipping ${DESTRIEUX_NAME} aparc2aseg" \
    |& tee -a $LF |& tee -a $CF
  endif
endif

# ----------------- WMParc ---------------------------------------- #
if($DoWMParc) then
  echo "#-----------------------------------------"|& tee -a $LF |& tee -a $CF
  echo "#@# WMParc `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir > /dev/null
  set xopts = `fsr-getxopts mri_aparc2aseg $XOptsFile`;
  set cmd = (mri_aparc2aseg --s $subjid --labelwm --hypo-as-wm --rip-unknown \
             --volmask --o mri/wmparc.mgz --ctxseg aparc+aseg.mgz $xopts )
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/wmaparc.touch
  # Do segstats while we're here
  set cmd = (mri_segstats --seg mri/wmparc.mgz --sum stats/wmparc.stats \
    --pv mri/norm.mgz --excludeid 0 --brain-vol-from-seg  \
    --brainmask mri/brainmask.mgz --in mri/norm.mgz --in-intensity-name norm \
    --in-intensity-units MR --subject $subjid --surf-wm-vol \
    --ctab $FREESURFER_HOME/WMParcStatsLUT.txt )
  if ( -e mri/transforms/talairach.xfm ) then
    set cmd = ($cmd --etiv);
  else
    echo "INFO: mri_segstats will not calculate eTIV" |& tee -a $LF
    echo "      due to missing talairach.xfm file" |& tee -a $LF
  endif
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/wmaparc.stats.touch
endif

# -----------------------------------------------------------
# Do Contra Surface Registration here so don't have
# to wait for other results
foreach hemi ($hemilist)

  # Registers ipsi and contra
  if($DoContraSurfReg) then
    if($hemi == lh) then
      set nothemi = rh;
    else
      set nothemi = lh;
    endif
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Contra Surf Reg $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    cd $subjdir/scripts > /dev/null
    set AvgTif = ${AvgCurvTifPath}/$nothemi.${AvgCurvTif}
    set xopts = `fsr-getxopts mris_register $XOptsFile`;
    set cmd = (mris_register -curv -reverse ../surf/$hemi.sphere)
    if($UseNoNeg) set cmd = ($cmd -remove_negative 1)
    set cmd = ($cmd $xopts)
    set cmd = ($cmd $AvgTif ../surf/$hemi.$nothemi.sphere.reg)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.sphreg.contra.touch
  endif

  # Register ipsi to contra directly (instead of thru sphere)
  # Creates lh.rh.sphere (note that there is no .reg)
  if($DoContraSurfRegWithinSubject) then
    cd $subjdir/surf
    if($hemi == lh) then
      set nothemi = rh;
    else
      set nothemi = lh;
    endif
    if(! -e $nothemi.inflated.H) then
      echo "ERROR: cannot find $nothemi.inflated.H, try running -inflate2" \
          |& tee -a $LF
      goto error_exit;
    endif
    echo "#--------------------------------------------" \
      |& tee -a $LF |& tee -a $CF
    echo "#@# Contra Surf Reg Within Subject $hemi `date`" \
      |& tee -a $SF |& tee -a $LF |& tee -a $CF
    set cmd = (mris_register -dist 0.3 -reverse -1 \
       ./$hemi.sphere ./$nothemi.sphere ./$hemi.$nothemi.sphere)
    $PWD |& tee -a $LF
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;
    echo $cmd > $touchdir/$hemi.sphere.contra.touch
  endif

end # hemi


# ---------------------------------------------------------------
# Create the smoothed surfaces to fsaverage target needed by Qdec.
if ($DoQdecCache) then
  if ("${measuredir}" != "") then
    cd ${measuredir}
  else
    cd $subjdir/surf
  endif
  $PWD |& tee -a $LF
  foreach hemi ($hemilist)
    foreach measure ($measurelist)
      echo "#--------------------------------------------" \
          |& tee -a $LF |& tee -a $CF
      echo "#@# Qdec Cache $hemi $measure $target `date`" \
          |& tee -a $SF |& tee -a $LF |& tee -a $CF

      # check for the target subject 'fsaverage' (if using as default target)
      # and create symlink from distribution dir if not found in subjects dir
      if (("${target}" == "fsaverage") && ( ! -e $SUBJECTS_DIR/fsaverage)) then
        echo "INFO: fsaverage subject does not exist in SUBJECTS_DIR" \
          |& tee -a $LF |& tee -a $CF
        echo "INFO: Creating symlink to fsaverage subject..." \
          |& tee -a $LF |& tee -a $CF
        set cmd=(ln -s $FREESURFER_HOME/subjects/fsaverage \
          $SUBJECTS_DIR/fsaverage)
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) $fs_time $cmd |& tee -a $LF
      endif

      # now check that the measure file exists, print only warning if not
      if ( ! -e ${hemi}.${measure} ) then
        echo "INFO: File ${hemi}.${measure} does not exist!" \
            |& tee -a $LF |& tee -a $CF
        echo "Skipping creation of smoothed data for ${hemi}.${measure}" \
            |& tee -a $LF |& tee -a $CF
      else
        set MeasFile=(${hemi}.${measure})
        # strip .mgz from filename (does nothing if not .mgz extension):
        set MeasFile=`basename ${MeasFile} .mgz`
        set MeasFile=(${MeasFile}.${target})
        set cmd=(mris_preproc \
            --s ${subjid} \
            --hemi ${hemi} \
            --meas ${measure} \
            --target ${target} \
            --out ${MeasFile}.mgh)
        if ("${measuredir}" != "") set cmd = ($cmd --surfdir ${measuredir})
        echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
        if($RunIt) $fs_time $cmd |& tee -a $LF
        if($status) goto error_exit;
        if($RunIt) rm -Rf tmp.mris_preproc.*

        foreach fwhm ($fwhmlist)
          set OutFile=(${hemi}.${measure})
          # strip .mgz from filename (does nothing if not .mgz extension):
          set OutFile=`basename ${OutFile} .mgz`
          set OutFile=(${OutFile}.fwhm${fwhm}.${target})
          set cmd=(mri_surf2surf \
              --s ${target} \
              --hemi ${hemi} \
              --fwhm ${fwhm} \
              --sval ${MeasFile}.mgh \
              --tval ${OutFile}.mgh)
          if($SmoothCortexOnly)   set cmd = ($cmd --cortex)
          if(! $SmoothCortexOnly) set cmd = ($cmd --no-cortex)
          echo "#--------------------------------------------" \
              |& tee -a $LF |& tee -a $CF
          echo "#@# Qdec Cache $hemi $measure fwhm$fwhm $target `date`" \
              |& tee -a $SF |& tee -a $LF |& tee -a $CF
          echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
          if($RunIt) $fs_time $cmd |& tee -a $LF
          if($status) goto error_exit;
          if($RunIt) rm -Rf tmp.mris_preproc.*
          if($RunIt) then
            if ("${measuredir}" != "") then
              mv -v ${OutFile}.mgh $subjdir/surf
            endif
          endif
          echo $cmd > $touchdir/$hemi.$measure.$fwhm.qcache.touch
        end # fwhm
      endif # if ( ! -e ${hemi}.${measure} )
    end # measure
  end # hemi
endif # DoQdecCache


# ---------------------------------------------------------------
# Compute local gyrification index measurements
if ($DoLocalGyriIndex) then
  cd $subjdir/surf
  $PWD |& tee -a $LF
  foreach hemi ($hemilist)
      echo "#--------------------------------------------" \
          |& tee -a $LF |& tee -a $CF
      echo "#@# Local Gyrification Index $hemi `date`" \
          |& tee -a $SF |& tee -a $LF |& tee -a $CF
      set cmd=(mris_compute_lgi --i ${hemi}.pial)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
  end # hemi
endif # DoLocalGyriIndex


# --------------------------------------------------------------------
# Create Brodmann area labels by mapping from fsaverage,
# then create the ?h.BA.annot file from these labels,
# then generate a ?h.BA.stats file from that annot.
if ($DoBaLabels) then
  cd $subjdir/label
  $PWD |& tee -a $LF
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
        |& tee -a $LF |& tee -a $CF
    echo "#@# BA Labels $hemi `date`" \
        |& tee -a $SF |& tee -a $LF |& tee -a $CF
    if ( ! -e $SUBJECTS_DIR/fsaverage) then
      echo "INFO: fsaverage subject does not exist in SUBJECTS_DIR" \
        |& tee -a $LF |& tee -a $CF
      echo "INFO: Creating symlink to fsaverage subject..." \
        |& tee -a $LF |& tee -a $CF
      set cmd=(ln -s $FREESURFER_HOME/subjects/fsaverage \
        $SUBJECTS_DIR/fsaverage)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
    endif

    # generate labels
    foreach balabel (BA1 BA2 BA3a BA3b BA4a BA4p BA6 BA44 BA45 V1 V2 MT)
      set cmd=(mri_label2label \
        --srcsubject fsaverage \
        --srclabel $SUBJECTS_DIR/fsaverage/label/${hemi}.${balabel}.label \
        --trgsubject $subjid \
        --trglabel ./${hemi}.${balabel}.label \
        --hemi ${hemi} \
        --regmethod surface)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
      if($status) goto error_exit;
    end # balabel

    # create .annot
    set cmd=(mris_label2annot \
        --s $subjid \
        --hemi $hemi \
        --ctab $FREESURFER_HOME/average/colortable_BA.txt \
        --l $hemi.BA1.label \
        --l $hemi.BA2.label \
        --l $hemi.BA3a.label \
        --l $hemi.BA3b.label \
        --l $hemi.BA4a.label \
        --l $hemi.BA4p.label \
        --l $hemi.BA6.label \
        --l $hemi.BA44.label \
        --l $hemi.BA45.label \
        --l $hemi.V1.label \
        --l $hemi.V2.label \
        --l $hemi.MT.label \
        --a BA \
        --maxstatwinner \
        --noverbose )
    if($RunIt) if ( -e ./$hemi.BA.annot) rm -fv ./$hemi.BA.annot
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    # generate stats
    set annot = ./$hemi.BA.annot
    set stats = ../stats/$hemi.BA.stats
    set ctab  = ./BA.ctab
    set xopts = `fsr-getxopts mris_anatomical_stats $XOptsFile`;
    set cmd = (mris_anatomical_stats -mgz -f $stats \
            -b -a $annot -c $ctab $xopts $subjid $hemi white);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

  end # hemi
endif # DoBaLabels


# --------------------------------------------------------------------
# Create entorhinal cortex labels by mapping from exvivo subjects,
# then generate ?h.entorhinal_exvivo.stats files
if ($DoLabelExvivoEC) then
  cd $subjdir/label
  $PWD |& tee -a $LF
  foreach hemi ($hemilist)
    echo "#--------------------------------------------" \
        |& tee -a $LF |& tee -a $CF
    echo "#@# Ex-vivo Entorhinal Cortex Label $hemi `date`" \
        |& tee -a $SF |& tee -a $LF |& tee -a $CF
    if ( ! -e $SUBJECTS_DIR/${hemi}.EC_average) then
      echo "INFO: ${hemi}.EC_average subject does not exist in SUBJECTS_DIR" \
        |& tee -a $LF |& tee -a $CF
      echo "INFO: Creating symlink to ${hemi}.EC_average subject..." \
        |& tee -a $LF |& tee -a $CF
      set cmd=(ln -s $FREESURFER_HOME/subjects/${hemi}.EC_average \
        $SUBJECTS_DIR/${hemi}.EC_average)
      echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
      if($RunIt) $fs_time $cmd |& tee -a $LF
    endif

    # generate label
    set cmd = (mris_spherical_average \
                 -erode 1 \
                 -orig white \
                 -t 0.4 \
                 -o ${subjid} \
                 label ${hemi}.entorhinal \
                 $hemi sphere.reg \
                 ${hemi}.EC_average \
                 ${hemi}.entorhinal_exvivo.label)
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

    # generate stats
    set label = ./$hemi.entorhinal_exvivo.label
    set stats = ../stats/$hemi.entorhinal_exvivo.stats
    set xopts = `fsr-getxopts mris_anatomical_stats $XOptsFile`;
    set cmd = (mris_anatomical_stats -mgz -f $stats \
            -b -l $label $xopts $subjid $hemi white);
    echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
    if($RunIt) $fs_time $cmd |& tee -a $LF
    if($status) goto error_exit;

  end # hemi
endif # DoLabelExvivoEC


#-------------- AParc+ASeg Stats -----------------#
# This is not something you want to do in general. The volumes
# of cortical structures should be obtained from the aparc.stats,
# but getting the intensity means and stddevs can be useful.
if($DoAParcASegStats) then
  echo "#--------------------------------------------" \
    |& tee -a $LF |& tee -a $CF
  echo "#@# AParcASeg Stats `date`" |& tee -a $SF |& tee -a $LF |& tee -a $CF
  cd $subjdir > /dev/null
  set xopts = `fsr-getxopts mri_segstats $XOptsFile`;
  set cmd = (mri_segstats --seg mri/aparc+aseg.mgz --sum stats/aparc+aseg.stats)
  set cmd = ($cmd --pv mri/norm.mgz )
  set cmd = ($cmd --excludeid 0 --ctab-default --empty)
  set cmd = ($cmd --brain-vol-from-seg --brainmask mri/brainmask.mgz)
  set cmd = ($cmd --in mri/norm.mgz --in-intensity-name norm)
  set cmd = ($cmd --in-intensity-units MR)
  set cmd = ($cmd --subject $subjid);
  if ( -e mri/transforms/talairach.xfm ) then
    set cmd = ($cmd --etiv);
  else
    echo "INFO: mri_segstats will not calculate eTIV" |& tee -a $LF
    echo "      due to missing talairach.xfm file" |& tee -a $LF
  endif
  set cmd = ($cmd $xopts);
  $PWD |& tee -a $LF
  echo "\n $cmd \n"|& tee -a $LF |& tee -a $CF
  if($RunIt) $fs_time $cmd |& tee -a $LF
  if($status) goto error_exit;
  echo $cmd > $touchdir/aparc+aseg.stats.touch
endif


echo "" |& tee -a $LF
echo "#------------------------------------------" |& tee -a $LF
echo "" |& tee -a $LF

if($#NotifyFile != 0) then
  echo "INFO: touching notification file $NotifyFile" |& tee -a $LF
  touch $NotifyFile
endif

if($DoIsRunning && $#IsRunningFile) rm -f $IsRunningFile

# Create the Done File
echo "------------------------------" > $DoneFile
echo "SUBJECT $subjid" >> $DoneFile
echo "DATE `date`"     >> $DoneFile
echo "USER $user"      >> $DoneFile
echo "HOST `hostname`" >> $DoneFile
echo "PROCESSOR `uname -m`" >> $DoneFile
echo "OS `uname -s`"       >> $DoneFile
uname -a         >> $DoneFile
echo $VERSION    >> $DoneFile
echo $0          >> $DoneFile

echo "recon-all -s $subjid finished without error at `date`" \
    |& tee -a $LF |& tee -a $SF


if($#mailuser != 0) then
  echo "recon-all -s $subjid finished without error at `date`" | \
    mail -s "$subjid DONE `date`" $mailuser
endif

echo "done"

# add to usage tracking file, if configured and writable
# a sysadmin would need to have users set the environment var
# RECONALL_USAGE_FILE to a world-writable file. example:
# setenv RECONALL_USAGE_FILE /space/freesurfer/recon-all_run_log
if($?RECONALL_USAGE_FILE) then
  if(-e $RECONALL_USAGE_FILE) then
    if(-w $RECONALL_USAGE_FILE) then
      if ($RunIt) then
        echo "`date` `cat $FREESURFER_HOME/build-stamp.txt`" \
            >> $RECONALL_USAGE_FILE
        endif
      endif
  endif
endif

exit 0
#############------------------------------------#######################
##################>>>>>>>>>>>>>.<<<<<<<<<<<<<<<<<#######################
#############------------------------------------#######################

############--------------##################
error_exit:
  uname -a | tee -a $LF | tee -a $SF
  echo "" |& tee -a $LF |& tee -a $SF
  echo "recon-all -s $subjid exited with ERRORS at `date`" \
    |& tee -a $LF |& tee -a $SF
  echo "" |& tee -a $LF |& tee -a $SF
  echo "For more details, see the log file $LF" 
  echo "To report a problem, see http://surfer.nmr.mgh.harvard.edu/fswiki/BugReporting"|& tee -a $LF
  echo "" 
  # Handle IsRunningFile
  if($DoIsRunning && $#IsRunningFile) rm -f $IsRunningFile
  # Mail the user
  if($#mailuser != 0) then
    echo "recon-all -s $subjid finished with errors at `date`" | \
      mail -s "$subjid ERROR `date`" $mailuser
  endif
  # Create an error file with date, cmd, etc of error
  if ( $?ErrorFile ) then
    echo "------------------------------" > $ErrorFile
    echo "SUBJECT $subjid" >> $ErrorFile
    echo "DATE `date`"     >> $ErrorFile
    echo "USER $user"      >> $ErrorFile
    echo "HOST `hostname`" >> $ErrorFile
    echo "PROCESSOR `uname -m`" >> $ErrorFile
    echo "OS `uname -s`"       >> $ErrorFile
    uname -a         >> $ErrorFile
    echo $VERSION    >> $ErrorFile
    echo $0          >> $ErrorFile
    echo "PWD `pwd`" >> $ErrorFile
    echo "CMD $cmd"  >> $ErrorFile
  endif
  # Finally exit
  exit 1;
endif

############--------------##################
parse_args:
set cmdline = ($argv);
while( $#argv != 0 )

  set flag = $argv[1]; shift;

  switch($flag)

    # This is a temporary flag to test how changing the way the vertex
    # area is computed in mrisurf.c affects a recon. It is set by default!
    case "-fixvertexarea"
      setenv FIX_VERTEX_AREA;
      breaksw
    case "-nofixvertexarea"
      unsetenv FIX_VERTEX_AREA;
      breaksw

    case "-subject":
    case "-subjid":
    case "-sid":
    case "-s":
      if ( $#argv < 1) goto arg1err;
      set subjid = $argv[1]; shift;
      set subjid = `basename $subjid`; # removes trailing /
      breaksw

    case "-sb":
      # Hidden option: same as -s but no basename;
      # needed when passing a subdir of a subject
      # as a subject.
      if( $#argv < 1) goto arg1err;
      set subjid = $argv[1]; shift;
      breaksw

    case "-sd":
      if ( $#argv < 1) goto arg1err;
      setenv  SUBJECTS_DIR $argv[1]; shift;
      breaksw

    case "-i"
      if( $#argv < 1) goto arg1err;
      set InputVol = "$argv[1]"; shift;
      if(! -e "$InputVol") then
        echo "ERROR: cannot find $InputVol"
        goto error_exit;
      endif
      if(! -r "$InputVol") then
        echo "ERROR: $InputVol exists but is not readable"
        goto error_exit;
      endif
      set InVolDir  = `dirname  "$InputVol"`;
      set InVolBase = `basename "$InputVol"`;
      pushd $InVolDir > /dev/null
      set InVolDir = `pwd`;
      popd > /dev/null
      set InputVol = "$InVolDir/$InVolBase";
      set InputList = ($InputList "$InputVol");
      set DoConvertInput = 1;
      breaksw

    case "-base":
      if ( $#argv < 1) goto arg1err;
      set subjid = $argv[1]; shift;
      set subjid = `basename $subjid`; # removes trailing /
      set DoCreateBaseSubj = 1;
      set NoRandomness = 1;
      breaksw

    case "-base-init":
      set DoCreateBaseInput = 1;
      breaksw
    case "-nobase-init":
      set DoCreateBaseInput = 0;
      breaksw

    case "-base-tp":
    case "-tp":
      if ( $#argv < 1) goto arg1err;
      set basetpid = $argv[1]; shift;
      set basetpid = `basename $basetpid`; # removes trailing /
      set BaseSubjsList = ($BaseSubjsList $basetpid);
      if($DoCreateBaseSubj) then
        if ("$basetpid" == "$subjid") then
          echo "ERROR: you need to specify a new ID for the base/template. "
          echo "It cannot be one of the time points."
          echo "Find more info at:"
          echo "http://surfer.nmr.mgh.harvard.edu/fswiki/LongitudinalProcessing"
          exit 1;
        endif
      endif
      breaksw

    case "-base-invol":
      if ( $#argv < 1) goto arg1err;
      set BaseSubjInvol = $argv[1]; shift;
      breaksw

    case "-hemi":
      if ( $#argv < 1) goto arg1err;
      set hemilist = $argv[1]; shift;
      if($hemilist != lh && $hemilist != rh) then
        echo "ERROR: hemi = $hemilist, must be either lh or rh"
        goto error_exit;
      endif
      breaksw

    case "-mail":
      if ( $#argv < 1) goto arg1err;
      set mailuser = $argv[1]; shift;
      breaksw

    case "-motioncor":
    case "-mc":
      set DoMotionCor = 1;
      breaksw
    case "-nomotioncor":
    case "-nomc":
      set DoMotionCor = 0;
      breaksw

    case "-robust-motioncor":
    case "-motioncor-robust":
      set DoMotionCor = 1;
      set DoRobustMotionCor = 1;
      breaksw
    case "-norobust-motioncor":
    case "-nomotioncor-robust":
      set DoRobustMotionCor = 0;
      breaksw

    case "-flirt-motioncor":
    case "-motioncor-flirt":
      set DoMotionCor = 1;
      set DoRobustMotionCor = 0;
      breaksw

    case "-talairach":
      set DoTalairach = 1;
      breaksw
    case "-notalairach":
      set DoTalairach = 0;
      set DoTalCheck = 0;
      breaksw
    case "-use-mritotal":
      set UseMincMritotal = 1;
      breaksw
    case "-schwartzya3t-atlas":
      set UseYa3tTalAtlas = 1;
      breaksw

    case "-deface":
      set DoDeface = 1;
      breaksw
    case "-nodeface":
      set DoDeface = 0;
      breaksw

    case "-nuintensitycor":
    case "-nu_correct":
      set DoNuIntensityCor = 1;
      breaksw
    case "-nonuintensitycor":
      set DoNuIntensityCor = 0;
      breaksw

    case "-nuintensitycor-3T":
    case "-nuintensitycor-3t":
      set DoNuIntensityCor = 1;
      set DoNuIntensityCor3T = 1;
      breaksw

    case "-nuiterations":
      if ( $#argv < 1) goto arg1err;
      set NuIterations = $argv[1]; shift;
      breaksw

    case "-numakeuchar":
      set DoNuMakeUchar = 1;
      breaksw
    case "-no-numakeuchar":
    case "-nonumakeuchar":
      set DoNuMakeUchar = 0;
      breaksw

    case "-norm3diters":
      if ( $#argv < 1) goto arg1err;
      set Norm3dIters = $argv[1]; shift;
      breaksw

    case "-normmaxgrad":
      if ( $#argv < 1) goto arg1err;
      set NormMaxGrad = $argv[1]; shift;
      breaksw

    case "-normalization":
      set DoNormalization = 1;
      breaksw
    case "-nonormalization":
      set DoNormalization = 0;
      breaksw
    case "-normalization2":
      set DoNormalization2 = 1;
      breaksw
    case "-nonormalization2":
      set DoNormalization2 = 0;
      breaksw
    case "-usecontrolpoints":
      set UseControlPoints = 1;
      breaksw

    case "-maskbfs":
      set DoMaskBFS = 1;
      breaksw
    case "-nomaskbfs":
      set DoMaskBFS = 0;
      breaksw

    case "-skullstrip":
      set DoSkullStrip = 1;
      breaksw
    case "-noskullstrip":
      set DoSkullStrip = 0;
      breaksw

    case "-multistrip":
      set DoMultiStrip = 1;
      set DoSkullStrip = 1;
      breaksw
    case "-nomultistrip":
      set DoMultiStrip = 0;
      breaksw

    case "-segmentation":
      set DoSegmentation = 1;
      breaksw
    case "-nosegmentation":
      set DoSegmentation = 0;
      breaksw

    case "-gcareg":
      set DoGCAReg = 1;
      breaksw
    case "-nogcareg":
      set DoGCAReg = 0;
      breaksw

    case "-careginv":
      set DoCARegInv = 1;
      breaksw
    case "-nocareginv":
      set DoCARegInv = 0;
      breaksw

    case "-canorm":
      set DoCANormalize = 1;
      breaksw
    case "-nocanorm":
      set DoCANormalize = 0;
      breaksw

    case "-careg":
      set DoCAReg = 1;
      breaksw
    case "-nocareg":
      set DoCAReg = 0;
      breaksw

    case "-rmneck":
      set DoRemoveNeck = 1;
      breaksw
    case "-normneck":
      set DoRemoveNeck = 0;
      breaksw

    case "-skull-lta":
      set DoSkullLTA  = 1;
      breaksw
    case "-noskull-lta":
      set DoSkullLTA  = 0;
      breaksw

    case "-calabel":
      set DoCALabel = 1;
      breaksw
    case "-nocalabel":
      set DoCALabel = 0;
      breaksw

    case "-asegmerge":
      set DoASegMerge = 1;
      breaksw
    case "-no-asegmerge":
      # Note: this will be overriden if DoCALabel=1
      set DoASegMerge = 0;
      breaksw

    case "-subcortseg":
      set DoGCAReg         = 1;
      set DoCARegInv       = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 1;
      breaksw

    case "-nosubcortseg":
      set DoGCAReg         = 0;
      set DoCARegInv       = 0;
      set DoRemoveNeck     = 0;
      set DoSkullLTA       = 0;
      set DoCANormalize    = 0;
      set DoCAReg          = 0;
      set DoCALabel        = 0;
      set DoSegStats       = 0;
      set NoNormMGZ        = 1;
      breaksw

    case "-noaseg":
      set UseAseg          = 0;
      set DoGCAReg         = 0;
      set DoCARegInv       = 0;
      set DoRemoveNeck     = 0;
      set DoSkullLTA       = 0;
      set DoCANormalize    = 0;
      set DoCAReg          = 0;
      set DoCALabel        = 0;
      set DoSegStats       = 0;
      set NoNormMGZ        = 1;
      set DoAParc2ASeg     = 0;
      set DoWMParc         = 0;
      set DoCortRibbonVolMask = 0;
      breaksw

    case "-noaseg-inorm2":
      set NoAsegInorm2     = 1;
      breaksw

    case "-gca":
      if ( $#argv < 1) goto arg1err;
      set GCA = $argv[1]; shift;
      breaksw

    case "-gca-skull":
      if ( $#argv < 1) goto arg1err;
      set GCASkull = $argv[1]; shift;
      breaksw

    case "-gca-dir":
      if ( $#argv < 1) goto arg1err;
      set GCADIR = $argv[1]; shift;
      breaksw

    case "-gcs":
      if ( $#argv < 1) goto arg1err;
      set GCS = $argv[1]; shift;
      breaksw

    case "-gcs-dir":
      if ( $#argv < 1) goto arg1err;
      set GCSDIR = $argv[1]; shift;
      breaksw

    case "-fill":
      set DoFill = 1;
      breaksw
    case "-nofill":
      set DoFill = 0;
      breaksw
    case "-pons-crs":
      if ( $#argv < 3) goto arg3err;
      set PonsSeedCRS = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-cc-crs":
      if ( $#argv < 3) goto arg3err;
      set CCSeedCRS = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-lh-crs":
      if ( $#argv < 3) goto arg3err;
      set LHSeedCRS = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-rh-crs":
      if ( $#argv < 3) goto arg3err;
      set RHSeedCRS = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-watershed":
      echo $argv[1];
      if ( $#argv < 1 ) goto arg1err;
      switch($argv[1])
        case "nowatershed":
          set WaterShed = 0; breaksw;
        case "normal":
          set WaterShed = 1; breaksw;
        case "watershedonly":
          set WaterShed = 2; breaksw;
        case "watershedtemplate":
          set WaterShed = 3; breaksw;
        case "atlas":
          set WaterShed = 4; breaksw;
        default:
          echo "ERROR: -watershed argument $argv[1] unrecognized."
          echo "Valid arguments are: atlas, nowatershed, normal, watershedonly,"
          echo "and watershedtemplate."
          goto error_exit;
        breaksw;
      endsw
      shift;
      breaksw
    case "-wsless":
      set WSLess = 1; breaksw
    case "-wsmore":
      set WSMore = 1; breaksw
    case "-wsatlas":
      set WSAtlas = 1; breaksw
    case "-no-wsatlas":
      set WSAtlas = 0; breaksw
    case "-wsthresh":
      if ( $#argv < 1) goto arg1err;
      set WSPctPreFlood = $argv[1]; shift;
      breaksw
    case "-wsseed":
      if ( $#argv < 3) goto arg3err;
      set WSSeedPoint = ($argv[1] $argv[2] $argv[3]);
      shift;shift;shift;
      breaksw
    case "-wsgcaatlas":
      set WSGcaAtlas = 1; breaksw
    case "-nowsgcaatlas":
    case "-no-wsgcaatlas":
      set WSGcaAtlas = 0; breaksw
    case "-wstalxfm":
      set WSUseTalXfm = 1; breaksw
    case "-no-wstalxfm":
      set WSUseTalXfm = 0; breaksw

    case "-no-gcut":
    case "-nogcut":
      set DoGcut = 0;
      breaksw

    case "-seg-wlo"
      if( $#argv < 1) goto arg1err;
      set WMSeg_wlo = (-wlo $argv[1]); shift;
      breaksw
    case "-seg-ghi"
      if( $#argv < 1) goto arg1err;
      set WMSeg_ghi = (-ghi $argv[1]); shift;
      breaksw

    case "-ca-align":
      set UseCAAlign = (-align);
      breaksw
    case "-no-ca-align":
      set UseCAAlign = ();
      breaksw

    case "-ca-align-after":
      set UseCAAlignAfter = (-align-after);
      breaksw
    case "-no-ca-align-after":
      set UseCAAlignAfter = ();
      breaksw

    case "-tessellate":
    case "-tess":
      set DoTessellate = 1;
      breaksw
    case "-notessellate":
    case "-notess":
      set DoTessellate = 0;
      breaksw

    case "-smooth1":
      set DoSmooth1 = 1;
      breaksw
    case "-nosmooth1":
      set DoSmooth1 = 0;
      breaksw

    case "-inflate1":
      set DoInflate1 = 1;
      breaksw
    case "-noinflate1":
      set DoInflate1 = 0;
      breaksw

    case "-svinitinflated":
      set SvInitInflated = 1;
      breaksw
    case "-nosvinitinflated":
      set SvInitInflated = 0;
      breaksw

    case "-qsphere":
      set DoQSphere = 1;
      breaksw
    case "-noqsphere":
      set DoQSphere = 0;
      breaksw

    case "-fix":
      set DoFix = 1;
      breaksw
    case "-nofix":
      set DoFix = 0;
      breaksw

    case "-fix-with-ga":
      set FixWithGA = 1;
      breaksw

    case "-fix-with-ga-errflag":
      set DoFix = 1;
      set FixWithGA = 1;
      set FixWithErrFlag = 1;
      breaksw

    case "-no-fix-with-ga":
      set FixWithGA = 0;
      breaksw

    case "-fix-diag-only":
      set DoFix = 1;
      set FixWithGA = 1;
      set FixDiagOnly = 1;
      breaksw

    case "-use-old-fixer":
      set UseOldTopoFix = 1;
      set UseNewTopoFix = 0;
      breaksw

    case "-use-new-fixer":
      set UseOldTopoFix = 0;
      set UseNewTopoFix = 1;
      breaksw

    case "-norandomness":
      set NoRandomness = 1;
      breaksw

    case "-randomness":
      set NoRandomness = 0;
      breaksw

    case "-rng-seed":
      set NoRandomness = 1;
      set RngSeed = $argv[1]; shift;
      breaksw

    case "-smooth2":
      set DoSmooth2 = 1;
      breaksw
    case "-nosmooth2":
      set DoSmooth2 = 0;
      breaksw

    case "-inflate2":
      set DoInflate2 = 1;
      breaksw
    case "-noinflate2":
      set DoInflate2 = 0;
      breaksw

    case "-cortribbon":
      set DoCortRibbonVolMask = 1;
      breaksw
    case "-nocortribbon":
      set DoCortRibbonVolMask = 0;
      breaksw

    case "-sphere":
      set DoSphere = 1;
      breaksw
    case "-nosphere":
      set DoSphere = 0;
      breaksw

    case "-surfreg":
      set DoSurfReg = 1;
      breaksw
    case "-nosurfreg":
      set DoSurfReg = 0;
      breaksw

    # Specify an average subject, which will have a tif
    # in its directory. Output will be hemi.sphere.avgsubj.reg
    case "-surfreg-to-subject":
      if( $#argv < 1) goto arg1err;
      set SurfRegToSubj = $argv[1]; shift;
      breaksw
    case "-no-surfreg-to-subject":
      set SurfRegToSubj = ();
      breaksw

    case "-jacobian_white":
      set DoJacobianWhite = 1;
      breaksw
    case "-nojacobian_white":
      set DoJacobianWhite = 0;
      breaksw

    case "-jacobian_dist0":
      set DoJacobianDist0 = 1;
      breaksw
    case "-nojacobian_dist0":
      set DoJacobianDist0 = 0;
      breaksw

    case "-contrasurfreg":
      set DoContraSurfReg = 1;
      breaksw
    case "-nocontrasurfreg":
      set DoContraSurfReg = 0;
      breaksw

    case "-contrasurfreg-subj":
      set DoContraSurfRegWithinSubject = 1;
      breaksw
    case "-nocontrasurfreg-subj":
      set DoContraSurfRegWithinSubject = 0;
      breaksw

    case "-avgcurv":
      set DoAvgCurv = 1;
      breaksw
    case "-noavgcurv":
      set DoAvgCurv = 0;
      breaksw

    case "-whitesurfs":
    case "-white":
      set DoWhiteSurfs = 1;
      breaksw
    case "-nowhitesurfs":
    case "-nowhite":
      set DoWhiteSurfs = 0;
      breaksw

    case "-pialsurfs":
    case "-pial":
      set DoPialSurfs = 1;
      breaksw
    case "-nopialsurfs":
    case "-nopial":
      set DoPialSurfs = 0;
      breaksw

    case "-pial-noaparc":
    case "-pial_noaparc":
      set DoPialSurfs = 1;
      set PialNoAparc = 1;
      breaksw

    # backward compatibility with single-run mris_make_surfaces:
    case "-finalsurfs":
      set DoWhiteSurfs = 1;
      set DoPialSurfs = 0;
      set DoSurfVolume = 1;
      breaksw

    case "-nofinalsurfs":
      set DoWhiteSurfs = 0;
      set DoPialSurfs = 0;
      breaksw

    case "-cortparc":
      set DoCortParc = 1;
      breaksw
    case "-nocortparc":
      set DoCortParc = 0;
      breaksw

    case "-cortparc2":
      set DoCortParc2 = 1;
      breaksw
    case "-nocortparc2":
      set DoCortParc2 = 0;
      breaksw

    case "-parcstats":
      set DoParcStats = 1;
      breaksw
    case "-noparcstats":
      set DoParcStats = 0;
      breaksw

    case "-parcstats2":
      set DoParcStats2 = 1;
      breaksw
    case "-noparcstats2":
      set DoParcStats2 = 0;
      breaksw

    case "-surfsegedit":
      set DoSurfSegEdit = 1;
      breaksw
    case "-nosurfsegedit":
      set DoSurfSegEdit = 0;
      breaksw

    case "-segstats":
      set DoSegStats = 1;
      breaksw
    case "-nosegstats":
      set DoSegStats = 0;
      breaksw

    case "-curvstats":
      set DoCurvStats = 1;
      breaksw
    case "-nocurvstats":
      set DoCurvStats = 0;
      breaksw

    case "-aparc2aseg":
      set DoAParc2ASeg = 1;
      breaksw
    case "-noaparc2aseg":
      set DoAParc2ASeg = 0;
      breaksw

    case "-aparc+aseg-stats":
      set DoAParcASegStats = 1;
      breaksw
    case "-no-aparc+aseg-stats":
      set DoAParcASegStats = 0;
      breaksw

    case "-wmparc":
      set DoWMParc = 1;
      breaksw
    case "-nowmparc":
      set DoWMParc = 0;
      breaksw

    case "-expert":
      if( $#argv < 1) goto arg1err;
      set XOptsFile = $argv[1]; shift;
      fsr-checkxopts $XOptsFile
      if($status) goto error_exit;
      set XOptsFile = `getfullpath $XOptsFile`
      breaksw

    case "-xopts-use"
      set XOptsUse = 1; # Use pre-existing xopts
      breaksw
    case "-xopts-clean"
      set XOptsClean = 1; # Delete pre-existing xopts
      breaksw
    case "-xopts-overwrite"
      set XOptsOverwrite = 1; # Overwrite pre-existing xopts
      breaksw

    case "-clean":
      set DoCleanCSDF  = 1;
      set DoCleanCW256 = 1;
      set DoCleanTal   = 1;
      set DoCleanLta   = 1;
      set DoCleanCP    = 1;
      set DoCleanSeed  = 1;
      set DoCleanPFH   = 1;
      set DoCleanBM    = 1;
      set DoCleanASeg  = 1;
      set DoCleanWM    = 1;
      set DoCleanBFSE  = 1;
      set DoCleanXopts = 1;
      breaksw

    case "-clean-xopts":
      set DoCleanXopts = 1;
      breaksw

    case "-clean-cw256":
      set DoCleanCW256 = 1;
      breaksw

    case "-clean-cp":
      set DoCleanCP   = 1;
      breaksw

    case "-clean-wm":
      set DoCleanWM   = 1;
      breaksw

    case "-clean-cpwm":
    case "-clean-wmcp":
      set DoCleanWM   = 1;
      set DoCleanCP   = 1;
      breaksw

    case "-clean-seed":
      set DoCleanSeed   = 1;
      breaksw

    case "-clean-tal":
      set DoCleanTal   = 1;
      breaksw

    case "-clean-lta":
      set DoCleanLta   = 1;
      breaksw

    case "-clean-pfh":
      set DoCleanPFH   = 1;
      breaksw

    case "-clean-bm":
      set DoCleanBM   = 1;
      breaksw

    case "-clean-aseg":
      set DoCleanASeg   = 1;
      breaksw

    case "-clean-bfse":
      set DoCleanBFSE   = 1;
      breaksw

    case "-all":
    case "-autorecon-all":
      set DoCreateBaseInput = 1;
      set DoMotionCor      = 1;
      set DoTalairach      = 1;
      set DoTalCheck       = 1;
      set DoNuIntensityCor = 1;
      set DoNormalization  = 1;
      set DoSkullStrip     = 1;
      set DoGCAReg         = 1;
      set DoCARegInv       = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoNormalization2 = 1;
      set DoMaskBFS        = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoWhiteSurfs     = 1;
      set DoSphere         = 1;
      set DoSurfReg        = 1;
      set DoContraSurfReg  = 0;
      set DoAvgCurv        = 1;
      set DoJacobianWhite  = 1;
      set DoCortParc       = 1;
      set DoPialSurfs      = 1;
      set DoParcStats      = 1;
      set DoCortParc2      = 1;
      set DoParcStats2     = 1;
      set DoCortRibbonVolMask = 1;
      set DoSegStats       = 1;
      set DoAParc2ASeg     = 1;
      set DoWMParc         = 1;
      set DoCurvStats      = 1;
      set DoBaLabels       = 1;
      set DoLabelExvivoEC  = 1;
      breaksw

    case "-autorecon1":
      set DoCreateBaseInput = 1;
      set DoMotionCor      = 1;
      set DoTalairach      = 1;
      set DoTalCheck       = 1;
      set DoNuIntensityCor = 1;
      set DoNormalization  = 1;
      set DoSkullStrip     = 1;
      breaksw

    case "-autorecon2":
      set DoGCAReg         = 1;
      set DoCARegInv       = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 1;
      set DoNormalization2 = 1;
      set DoMaskBFS        = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoWhiteSurfs     = 1;
      breaksw

    case "-autorecon2-volonly":
      set DoGCAReg         = 1;
      set DoCARegInv       = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 1;
      set DoNormalization2 = 1;
      set DoMaskBFS        = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      breaksw

    case "-autorecon2-perhemi":
    case "-autorecon2-surfonly":
    case "-autorecon2-surfsonly":
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoWhiteSurfs     = 1;
      set DoSegStats       = 1;
      set DoCurvStats      = 1;
      breaksw

    case "-autorecon2-inflate1":
      set DoGCAReg         = 1;
      set DoCARegInv       = 1;
      set DoRemoveNeck     = 1;
      set DoSkullLTA       = 1;
      set DoCANormalize    = 1;
      set DoCAReg          = 1;
      set DoCALabel        = 1;
      set DoSegStats       = 1;
      set DoNormalization2 = 1;
      set DoMaskBFS        = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      breaksw

    case "-autorecon2-cp":
    case "-autorecon2-aseg":
      set DoNormalization2 = 1;
      set DoSegmentation   = 1;
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoMaskBFS        = 1;
      set DoWhiteSurfs     = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoSegStats       = 1;
      set DoCurvStats      = 1;
      breaksw

    case "-autorecon2-wm":
      set DoFill           = 1;
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoMaskBFS        = 1;
      set DoWhiteSurfs     = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoSegStats       = 1;
      set DoCurvStats      = 1;
      breaksw

    case "-autorecon2-pial":
    case "-autorecon3-pial":
    case "-autorecon-pial":
      set DoMaskBFS        = 1;
      set DoWhiteSurfs     = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoSegStats       = 1;
      set DoCurvStats      = 1;
      set DoSphere         = 1;
      set DoSurfReg        = 1;
      set DoContraSurfReg  = 0;
      set DoAvgCurv        = 1;
      set DoJacobianWhite  = 1;
      set DoCortParc       = 1;
      set DoPialSurfs      = 1;
      set DoParcStats      = 1;
      set DoCortParc2      = 1;
      set DoParcStats2     = 1;
      breaksw

    case "-autorecon3":
      set DoSphere         = 1;
      set DoSurfReg        = 1;
      set DoContraSurfReg  = 0;
      set DoAvgCurv        = 1;
      set DoJacobianWhite  = 1;
      set DoCortParc       = 1;
      set DoPialSurfs      = 1;
      set DoParcStats      = 1;
      set DoCortParc2      = 1;
      set DoParcStats2     = 1;
      set DoSegStats       = 1;
      set DoCortRibbonVolMask = 1;
      set DoAParc2ASeg     = 1;
      set DoWMParc         = 1;
      set DoBaLabels       = 1;
      set DoLabelExvivoEC  = 1;
      breaksw

    case "-autorecon-hemi":
      if ( $#argv < 1) goto arg1err;
      set hemilist = $argv[1]; shift;
      if($hemilist != lh && $hemilist != rh) then
        echo "ERROR: hemi = $hemilist, must be either lh or rh"
        goto error_exit;
      endif
      set LF_DEFAULT_NAME = "recon-all-${hemilist}.log"
      set SF_DEFAULT_NAME = "recon-all-status-${hemilist}.log"
      set CF_DEFAULT_NAME = "recon-all-${hemilist}.cmd"
      set DoTessellate     = 1;
      set DoSmooth1        = 1;
      set DoInflate1       = 1;
      set DoQSphere        = 1;
      set DoFix            = 1;
      set DoSmooth2        = 1;
      set DoInflate2       = 1;
      set DoWhiteSurfs     = 1;
      set DoSphere         = 1;
      set DoSurfReg        = 1;
      set DoContraSurfReg  = 0;
      set DoAvgCurv        = 1;
      set DoJacobianWhite  = 1;
      set DoCortParc       = 1;
      set DoPialSurfs      = 1;
      set DoParcStats      = 1;
      set DoCortParc2      = 1;
      set DoParcStats2     = 1;
      set DoCortRibbonVolMask = 0;
      set DoAParc2ASeg     = 0;
      set DoWMParc         = 0;
      set DoSegStats       = 1;
      set DoCurvStats      = 1;
      set DoBaLabels       = 1;
      set DoLabelExvivoEC  = 1;
      breaksw

    case "-waitfor":
      if ( $#argv < 1) goto arg1err;
      set WaitForFile = $argv[1]; shift;
      breaksw

    case "-notify":
      if ( $#argv < 1) goto arg1err;
      set NotifyFile = $argv[1]; shift;
      breaksw

    case "-status":
      if ( $#argv < 1) goto arg1err;
      set SF = $argv[1]; shift;
      breaksw

    case "-noappendlog":
      set AppendLog = 0;
      breaksw

    case "-noappendstatus":
      set AppendStatus = 0;
      breaksw

    case "-noappend":
      set AppendLog = 0;
      set AppendStatus = 0;
      breaksw

    case "-log":
      if ( $#argv < 1) goto arg1err;
      set LF = $argv[1]; shift;
      breaksw

    case "-nolog":
      set LF = /dev/null
      breaksw

    case "-csurfdir":
      if ( $#argv < 1) goto arg1err;
      setenv FREESURFER_HOME $argv[1]; shift;
      if(! -e $FREESURFER_HOME) then
        echo "ERROR: cannot find $FREESURFER_HOME"
        goto error_exit;
      endif
      pushd $FREESURFER_HOME > /dev/null
      setenv FREESURFER_HOME `pwd`;
      breaksw

    case "-dontrun":
      set RunIt = 0;
      breaksw

    case "-onlyversions":
      set DoVersionsOnly = 1;
      breaksw

    case "-allowcoredump":
      limit coredumpsize unlimited
      breaksw

    case "-no-isrunning":
      set DoIsRunning = 0;
      breaksw

    case "-force":
      set Force = 1;
      breaksw

    case "-verbose":
      set verbose = 1;
      breaksw

    case "-echo":
      set echo = 1;
      breaksw

    case "-debug":
      set verbose = 1;
      set echo = 1;
      breaksw

    case "-umask":
      if ( $#argv < 1) goto arg1err;
      umask $1; shift;
      breaksw

    case "-grp":
      if ( $#argv < 1) goto arg1err;
      set grp = $argv[1];
      set curgrp = `id -gn`;
      if($grp != $curgrp) then
        echo "ERROR: current group ($curgrp) does not equal specified group $grp"
        goto error_exit;
      endif
      breaksw

    case "-cm":
      set ConformMin = 1;
      echo "INFO: all volumes are conformed to the min voxel size"
      breaksw

    case "-hires":
      set HiRes = 1;
      set ConformMin = 1;
      echo "INFO: hi-res volumes are conformed to the min voxel size"
      # dont use atlas for skull strip:
      set WSAtlas = 0;
      set WSGcaAtlas = 0;
      # -noaseg flags:
      set UseAseg          = 0;
      set DoGCAReg         = 0;
      set DoCARegInv       = 0;
      set DoRemoveNeck     = 0;
      set DoSkullLTA       = 0;
      set DoCANormalize    = 0;
      set DoCAReg          = 0;
      set DoCALabel        = 0;
      set DoSegStats       = 0;
      set NoNormMGZ        = 1;
      set DoAParc2ASeg     = 0;
      set DoWMParc         = 0;
      set DoCortRibbonVolMask = 0;
      breaksw

    case "-noneg":
      set UseNoNeg = 1;
      breaksw

    case "-nothicken":
      set NoThicken = 1;
      breaksw

    case "-uncompress":
      set UnCompress = 1;
      breaksw

    case "-bigventricles":
      set BigVentricles = 1;
      breaksw

    case "-nobigventricles":
      set BigVentricles = 0;
      breaksw

    case "-secondpassrenorm":
      set DoSecondPassRenorm = 1;
      breaksw

    case "-diffsubj":
      if ( $#argv < 1) goto arg1err;
      set diffsubj = $argv[1]; shift;
      set diffsujb = `basename $diffsubj`; # remove trailing /
      breaksw

    # flags -long, -no-orig-pial and -uselongbasectrlvol are all associated
    # with longitudinal processing
    case "-long":
    case "-longitudinal":
      set longitudinal = 1;
      set NoRandomness = 1;
      if ( $#argv < 2) goto arg1err;
      # get the subject name to use for timepoint
      set tpNid = $argv[1]; shift;
      set tpNid = `basename $tpNid`; # remove trailing /
      # get the subject to use for the base subject
      set longbaseid = $argv[1]; shift;
      set longbaseid = `basename $longbaseid`; # remove trailing /
      # and create subjid to reflect its longitudinal relation to longbaseid
      set subjid = ${tpNid}.long.${longbaseid}
      breaksw

    case "-addtp":
      # 'fake'-add a new timepoint
      set DoAddTp = 1;
      breaksw

    case "-noasegfusion":
      set UseAsegFusion = 0;
      breaksw

    case "-uselongbasectrlvol":
      set UseLongbaseCtrlVol = 1;
      breaksw

    case "-uselongbasewmedits":
      set UseLongbaseWMedits = 1;
      breaksw

    case "-mprage":
      set IsMPRAGE = 1;
      breaksw;

    case "-washu_mprage":
      set IsWashuMPRAGE = 1;
      breaksw;

    case "-cw256":
      set DoConformWidth256 = 1;
      breaksw;

    case "-nowmsa":
      set NoWMSA = 1;
      breaksw;

    case "-tal-check":
    case "-talcheck":
      set DoTalCheck = 1;
      breaksw;

    case "-notal-check":
    case "-no-tal-check":
    case "-notalcheck":
    case "-no-talcheck":
      set DoTalCheck = 0;
      breaksw;

    case "-avgcurvtifpath":
      if ( $#argv < 1) goto arg1err;
      set AvgCurvTifPath = $argv[1]; shift;
      breaksw

    case "-avgcurvtif":
      if ( $#argv < 1) goto arg1err;
      set AvgCurvTif = $argv[1]; shift;
      breaksw

    case "-qcache":
      set DoQdecCache = 1;
      breaksw;

    case "-smooth-cortex-only"
      set SmoothCortexOnly = 1;
      breaksw;

    case "-no-smooth-cortex-only"
      set SmoothCortexOnly = 0;
      breaksw;

    case "-measure":
      if ( $#argv < 1) goto arg1err;
      if ( $UserMeasureList ) then
        set measurelist = ($measurelist $argv[1]); shift;
      else
        set measurelist = $argv[1]; shift;
        set UserMeasureList = 1; # allow for multiple instances of -measure
      endif
      breaksw

    case "-measuredir":
      if ( $#argv < 1) goto arg1err;
      set measuredir = $argv[1]; shift;
      breaksw

    case "-fwhm":
      if ( $#argv < 1) goto arg1err;
      set fwhmlist = $argv[1]; shift;
      breaksw

    case "-target":
      if ( $#argv < 1) goto arg1err;
      set target = $argv[1]; shift;
      breaksw

    case "-vno_match_check":
    case "-vno_check":
    case "-vno-check":
      set DoVnoMatchCheck = 1;
      breaksw;

    case "-make"
      if ( $#argv < 1) goto arg1err;
      set DoMakefile = 1;
      set MakefileTarget = $argv[1]; shift;
      breaksw;

    case "-asegstatsdiff":
      set DoAsegStatsDiff = 1;
      breaksw;

    case "-aparcstatsdiff":
      set DoAparcStatsDiff = 1;
      breaksw;

    case "-time":
      set DoTime = 1;
      breaksw;

    case "-notime":
      set DoTime = 0;
      breaksw;

    case "-lgi":
    case "-lGI":
    case "-localGI":
      set DoLocalGyriIndex = 1;
      breaksw;

    case "-balabels":
    case "-ba_labels":
    case "-ba-labels":
    case "-label_ba":
    case "-label_BA":
      set DoBaLabels = 1;
      breaksw;

    case "-nobalabels":
    case "-noba_labels":
    case "-noba-labels":
    case "-nolabel_ba":
    case "-nolabel_BA":
    case "-no_ba_labels":
    case "-no-ba-labels":
    case "-no_label_ba":
    case "-no_label_BA":
      set DoBaLabels = 0;
      breaksw;

    case "-surfvolume":
      set DoSurfVolume = 1;
      breaksw;

    case "-label_v1":
    case "-label_V1":
    case "-label-v1":
    case "-label-V1":
      set DoLabelV1 = 1;
      breaksw;

    case "-label_exvivo_ec":
    case "-label-exvivo-ec":
    case "-label_exvivo_EC":
    case "-label-exvivo-EC":
      set DoLabelExvivoEC = 1;
      breaksw;

    case "-nolabel_exvivo_ec":
    case "-nolabel-exvivo-ec":
    case "-nolabel_exvivo_EC":
    case "-nolabel-exvivo-EC":
    case "-no_label_exvivo_ec":
    case "-no-label-exvivo-ec":
    case "-no_label_exvivo_EC":
    case "-no-label-exvivo-EC":
      set DoLabelExvivoEC = 0;
      breaksw;

    case "-use-concat-lta-tal":
      set UseConcatLtaTal = 1;
      breaksw;

    case "-show-edits":
    case "-show_edits":
    case "-showedits":
      set DoShowEdits = 1;
      breaksw;

    case "-use-cuda":
    case "-use_cuda":
    case "-use-gpu":
    case "-use_gpu":
      set UseCuda = 1;
      breaksw;

    default:
      echo ERROR: Flag $flag unrecognized.
      echo $cmdline
      goto error_exit;
      breaksw
  endsw
end

goto parse_args_return;
############--------------##################
############--------------##################
arg1err:
  echo "ERROR: flag $flag requires one argument"
  exit 1
############--------------##################
############--------------##################
arg3err:
  echo "ERROR: flag $flag requires three arguments"
  exit 1
############--------------##################


############--------------##################
check_params:
  if(! $DoVersionsOnly) then
    if($#subjid != 1) then
      echo "ERROR: must specify a subject id"
      exit 1;
    endif

    if(! $?SUBJECTS_DIR ) then
      echo "ERROR: environment variable SUBJECTS_DIR not set"
      echo "  this can be done by setting it in the shell before"
      echo "  executing recon-all or by using the -sd flag"
      exit 1;
    endif

    if(! -e $SUBJECTS_DIR ) then
      echo "ERROR: SUBJECTS_DIR $SUBJECTS_DIR does not exist."
      exit 1;
    endif

    # Get the full path #
    pushd $SUBJECTS_DIR > /dev/null
    setenv SUBJECTS_DIR `$PWD`;
    popd > /dev/null

    set subjdir = $SUBJECTS_DIR/$subjid

    #------------ Longitudinal -----------------------------------#
    if($longitudinal) then
      if($#longbaseid != 1) then
        echo "ERROR: must specify a subject id for the long-base subject"
        exit 1;
      endif
      set longbasedir = $SUBJECTS_DIR/$longbaseid
      if(! -e $longbasedir) then
        echo "ERROR: cannot find $longbasedir"
        exit 1;
      endif
      if ( ! -e ${longbasedir}/${BaseSubjsListFname}) then
        echo "ERROR: file ${longbasedir}/${BaseSubjsListFname} does not exist!"
        exit 1;
      else
        grep -w $tpNid ${longbasedir}/${BaseSubjsListFname} >& /dev/null
        if ($status) then
          echo "ERROR: $tpNid is not in ${longbasedir}/${BaseSubjsListFname}"
          exit 1
        endif
        # check that baseid is not the same as any of the timepoint subj IDs
        grep -w $longbaseid ${longbasedir}/${BaseSubjsListFname} >& /dev/null
        if ( ! $status) then
          echo "ERROR: longitudinal base ID cannot be the same as a timepoint"
          echo "subject ID (in ${longbasedir}/${BaseSubjsListFname})"
          echo "Find more info at:"
          echo "http://surfer.nmr.mgh.harvard.edu/fswiki/LongitudinalProcessing"
          exit 1
        endif
      endif
    endif

    #----------------------------------------------------------------#
    if(($#InputList == 0) && (! $DoCreateBaseSubj)) then
      if($longitudinal) mkdir -p ${subjdir}
      if(! -e $subjdir) then
        echo "ERROR: cannot find $subjdir"
        exit 1;
      endif
      if(! -w $subjdir) then
        echo "ERROR: you do not have write permission to $subjdir"
        exit 1;
      endif
    else
      if( -e $subjdir) then
        if(! $Force) then
          echo "ERROR: $subjdir exists, delete or re-run with -force"
          exit 1;
        else
          echo "INFO: $subjdir exists with -i, but -force specified."
          echo "Deleting any previous source volumes"
          rm -f $subjdir/src/[0-9][0-9][0-9].mgz >& /dev/null
          rm -f $subjdir/mri/orig/[0-9][0-9][0-9].mgz >& /dev/null
        endif
      endif
      mkdir -p $subjdir
    endif
  else
    set subjdir = /tmp
  endif

  if(! $?FREESURFER_HOME ) then
    echo "ERROR: environment variable FREESURFER_HOME not set."
    exit 1;
  endif

  if(! -e $FREESURFER_HOME ) then
    echo "ERROR: FREESURFER_HOME $FREESURFER_HOME does not exist."
    exit 1;
  endif

  if(! -e ${GCADIR}/$GCA ) then
    echo "ERROR: cannot find ${GCADIR}/$GCA" |& tee -a $LF
    exit 1;
  endif

  if(! -e ${GCADIR}/$GCASkull ) then
    echo "ERROR: cannot find ${GCADIR}/$GCASkull" \
      |& tee -a $LF
    exit 1;
  endif

  foreach hemi ($hemilist)
    set avgtif = ${AvgCurvTifPath}/$hemi.${AvgCurvTif};
    if(! -e $avgtif) then
      echo "ERROR: cannot find $avgtif."
      exit 1;
    endif
    set GCSHemi = ${GCSDIR}/$hemi.$GCS
    if(! -e $GCSHemi) then
      echo "ERROR: cannot find $GCSHemi."
      exit 1;
    endif
    set CPAtlas = ${GCSDIR}/$hemi.$GCS
    if(! -e $CPAtlas) then
      echo "ERROR: cannot find $CPAtlas."
      exit 1;
    endif
  end

  if($XOptsUse == 1 && $XOptsClean == 1) then
    echo "ERROR: cannot specify both -xopts-clean and -xopts-use"
    exit(1);
  endif

  if($IsMPRAGE == 1 && $IsWashuMPRAGE == 1) then
    echo "ERROR: cannot specify both -mprage and -washu_mprage"
    exit(1);
  endif

  set XOptsPreExist = $subjdir/scripts/expert-options
  if(-e $XOptsPreExist) then
    # There is a pre-existing xopts file
    if($#XOptsFile == 0) then
      # XOpts not passed on cmd line
      if($XOptsUse == 0 && $XOptsClean == 0) then
        echo "ERROR: there is a pre-existing expert options file."
        echo "You must explicitly specify whether to:"
        echo "  1. Use the pre-existing file (-xopts-use)"
        echo "  2. Delete the pre-existing file (-xopts-clean)"
        exit(1);
      endif
      if($XOptsClean == 1) then
        rm -f $XOptsPreExist
        set XOptsFile = ();
      endif
      if($XOptsUse == 1) then
        set XOptsFile = $XOptsPreExist;
      endif
    else
      # XOpts was passed on cmd line, but pre-existing xopts file
      if(! $XOptsOverwrite) then
        echo "ERROR: there is a pre-existing expert options file and"
        echo "you have specified an expert options file on the command-line."
        echo "If you want to use the file specified on the command-line,"
        echo "you must run with -xopts-overwrite, or you may edit the "
        echo "existing file $XOptsFile (and not use the -expert option)."
        exit(1);
      endif
      # If it gets here, then overwrite
      rm -f $XOptsPreExist
      cp $XOptsFile $XOptsPreExist
      if($status) goto error_exit;
    endif
  else
    # No pre-existing file
    if($#XOptsFile != 0) then
      # Expert options file specified on cmd line, make copy
      cp $XOptsFile $XOptsPreExist
      if($status) goto error_exit;
    endif
  endif

  if($#NotifyFile != 0) then
    rm -f $NotifyFile;
    set tmpdir = `dirname $NotifyFile`;
    mkdir -p $tmpdir;
    pushd $tmpdir > /dev/null;
    set tmpdir = `$PWD`;
    set NotifyFile = $tmpdir/`basename $NotifyFile`;
    popd > /dev/null;
  endif

  if($#WaitForFile != 0) then
    set tmpdir = `dirname $WaitForFile`;
    mkdir -p $tmpdir;
    pushd $tmpdir > /dev/null;
    set tmpdir = `$PWD`;
    set WaitForFile = $tmpdir/`basename $WaitForFile`;
    popd > /dev/null;
  endif

  if(! $DoCleanTal && ! $DoCleanCP && ! $DoCleanBM && ! $DoConvertInput && \
     ! $DoCleanASeg && ! $DoCleanWM && ! $DoCleanSeed && ! $DoCleanCW256 && \
     ! $DoCortParc && ! $DoCortParc2 && ! $DoGCAReg && ! $DoCARegInv && \
     ! $DoMotionCor && ! $DoTalairach && ! $DoTalCheck && ! $DoCleanXopts && \
     ! $DoNormalization  && ! $#SurfRegToSubj &&\
     ! $DoNormalization2  && ! $DoParcStats && ! $DoParcStats2 && \
     ! $DoVersionsOnly && ! $DoDeface &&  ! $DoCleanPFH && \
     ! $DoSkullStrip && ! $DoSegmentation && ! $DoNuIntensityCor &&\
     ! $DoFill && ! $DoTessellate && ! $DoAParc2ASeg && ! $DoWMParc && \
     ! $DoSmooth1  && ! $DoInflate1 && ! $DoQSphere && ! $DoRemoveNeck &&\
     ! $DoFix  && ! $DoSmooth2 && ! $DoInflate2  && ! $DoSphere &&\
     ! $DoSkullLTA && ! $DoQdecCache  && ! $DoVnoMatchCheck &&\
     ! $DoSurfReg  && ! $DoContraSurfReg  && ! $DoAvgCurv && ! $DoSegStats &&\
     ! $DoMorphRGB && ! $DoWhiteSurfs && ! $DoContraSurfRegWithinSubject &&\
     ! $DoCortRibbonVolMask && ! $DoJacobianWhite && ! $DoJacobianDist0 && \
     ! $DoCANormalize && ! $DoCAReg && ! $DoCALabel && \
     ! $DoMaskBFS && ! $DoAParcASegStats && ! $DoLocalGyriIndex && \
     ! $DoMakefile && ! $DoAsegStatsDiff && ! $DoAparcStatsDiff && \
     ! $DoSurfVolume && ! $DoASegMerge && ! $DoCurvStats && ! $DoLabelV1 && \
     ! $DoCreateBaseSubj && ! $DoBaLabels && ! $DoShowEdits && \
     ! $DoLabelExvivoEC && ! $DoSurfSegEdit && ! $DoPialSurfs ) then
     echo "ERROR: nothing to do"
     exit 1;
  endif

  if($WSMore && $WSLess) then
    echo "ERROR: cannot specify both -wsmore and -wsless"
    exit 1;
  endif

  if( ($WSMore || $WSLess) && $WSPctPreFlood ) then
    echo "ERROR: cannot specify -wsmore or -wsless and -wsthresh"
    exit 1;
  endif

  if ($DoAsegStatsDiff) then
    if ( $#diffsubj != 1 ) then
      echo "ERROR: -asegstatsdiff requires -diffsubj <subjid>"
      exit 1;
    endif
  endif
  if ($DoAparcStatsDiff) then
    if ( $#diffsubj != 1 ) then
      echo "ERROR: -aparcstatsdiff requires -diffsubj <subjid>"
      exit 1;
    endif
  endif

  if($#SurfRegToSubj) then
    if(! -e $SUBJECTS_DIR/$SurfRegToSubj) then
      echo "ERROR: cannot find $SurfRegToSubj"
      exit 1;
    endif
    set AvgTif = $SUBJECTS_DIR/$SurfRegToSubj/$hemi.reg.template.tif
    if(! -e $AvgTif) then
      echo "ERROR: cannot find $AvgTif"
      exit 1;
    endif

  endif

goto check_params_return;
############--------------##################


############--------------##################
usage_exit:
  echo ""
  echo "USAGE: $ProgName"
  echo ""
  echo " Required Arguments:";
  echo "   -subjid <subjid>"
  echo "   -<process directive>"
  echo ""
  echo " Fully-Automated Directive:"
  echo "  -all           : performs all stages of cortical reconstruction"
  echo "  -autorecon-all : same as -all"
  echo ""
  echo " Manual-Intervention Workflow Directives:"
  echo "  -autorecon1    : process stages 1-5 (see below)"
  echo "  -autorecon2    : process stages 6-23"
  echo "                   after autorecon2, check white surfaces:"
  echo "                     a. if wm edit was required, then run -autorecon2-wm"
  echo "                     b. if control points added, then run -autorecon2-cp"
  echo "                     c. proceed to run -autorecon3"
  echo "  -autorecon2-cp : process stages 12-23 (uses -f w/ mri_normalize, -keep w/ mri_seg)"
  echo "  -autorecon2-wm : process stages 15-23"
  echo "  -autorecon2-inflate1 : 6-18"
  echo "  -autorecon2-perhemi : tess, sm1, inf1, q, fix, sm2, inf2, finalsurf, ribbon"
  echo "  -autorecon3    : process stages 24-31"
  echo "                     if edits made to correct pial, then run -autorecon2-pial"
  echo "  -hemi ?h       : just do lh or rh (default is to do both)"
  echo ""
  echo "  Autorecon Processing Stages (see -autorecon# flags above):"
  echo "    1.  Motion Correction and Conform"
  echo "    2.  NU (Non-Uniform intensity normalization)"
  echo "    3.  Talairach transform computation"
  echo "    4.  Intensity Normalization 1"
  echo "    5.  Skull Strip"
  echo ""
  echo "    6.  EM Register (linear volumetric registration)"
  echo "    7.  CA Intensity Normalization"
  echo "    8.  CA Non-linear Volumetric Registration "
  echo "    9.  Remove neck"
  echo "    10. EM Register, with skull"
  echo "    11. CA Label (Aseg: Volumetric Labeling) and Statistics"
  echo ""
  echo "    12. Intensity Normalization 2 (start here for control points)"
  echo "    13. White matter segmentation"
  echo "    14. Edit WM With ASeg"
  echo "    15. Fill (start here for wm edits)"
  echo "    16. Tessellation (begins per-hemisphere operations)"
  echo "    17. Smooth1"
  echo "    18. Inflate1"
  echo "    19. QSphere"
  echo "    20. Automatic Topology Fixer"
  echo "    21. White Surfs (start here for brain edits for pial surf)"
  echo "    22. Smooth2"
  echo "    23. Inflate2"
  echo ""
  echo "    24. Spherical Mapping"
  echo "    25. Spherical Registration "
  echo "    26. Spherical Registration, Contralater hemisphere"
  echo "    27. Map average curvature to subject"
  echo "    28. Cortical Parcellation (Labeling)"
  echo "    29. Cortical Parcellation Statistics"
  echo "    30. Pial Surfs"
  echo "    31. Cortical Ribbon Mask"
  echo "    32. Cortical Parcellation mapped to ASeg"
  echo "    33  Brodmann and exvio EC labels"
  echo ""
  echo " Step-wise Directives"
  echo "  See -help"
  echo ""
  echo " Expert Preferences"
  echo "  -pons-crs C R S : col, row, slice of seed point for pons, used in fill"
  echo "  -cc-crs C R S : col, row, slice of seed point for corpus callosum, used in fill"
  echo "  -lh-crs C R S : col, row, slice of seed point for left hemisphere, used in fill"
  echo "  -rh-crs C R S : col, row, slice of seed point for right hemisphere, used in fill"
  echo "  -nofill        : do not use the automatic subcort seg to fill"
  echo "  -watershed cmd : control skull stripping/watershed program"
  echo "  -wsless : decrease watershed threshold (shrinks skull surface)"
  echo "  -wsmore : increase watershed threshold (expands skull surface)"
  echo "  -wsatlas : use atlas when skull stripping"
  echo "  -no-wsatlas : do not use atlas when skull stripping"
  echo "  -no-wsgcaatlas : do not use GCA atlas when skull stripping"
  echo "  -wsthresh pct : explicity set watershed threshold"
  echo "  -wsseed C R S : identify an index (C, R, S) point in the skull"
  echo "  -nuiterations N : set number of iterations for nu intensity "
  echo "                    correction (default is $NuIterations)"
  echo "  -norm3diters niters : number of 3d iterations for mri_normalize"
  echo "  -normmaxgrad maxgrad : max grad (-g) for mri_normalize. Default is 1."
  echo "  -cm           : conform volumes to the min voxel size "
  echo "  -no-fix-with-ga : do not use genetic algorithm when fixing topology"
  echo "  -fix-diag-only  : topology fixer runs until ?h.defect_labels files"
  echo "                    are created, then stops"
  echo "  -seg-wlo wlo : set wlo value for mri_segment and mris_make_surfaces"
  echo "  -seg-ghi ghi : set ghi value for mri_segment and mris_make_surfaces"
  echo "  -nothicken   : pass '-thicken 0' to mri_segment"
  echo "  -no-ca-align-after : turn off -align-after with mri_ca_register"
  echo "  -no-ca-align : turn off -align with mri_ca_label"
  echo "  -deface      : deface subject, written to orig_defaced.mgz"
  echo ""
  echo "  -expert file     : read-in expert options file"
  echo "  -xopts-use       : use pre-existing expert options file"
  echo "  -xopts-clean     : delete pre-existing expert options file"
  echo "  -xopts-overwrite : overwrite pre-existing expert options file"
  echo ""
  echo "  -mprage : assume scan parameters are MGH MP-RAGE protocol"
  echo "  -washu_mprage : assume scan parameters are Wash.U. MP-RAGE protocol."
  echo "                  both mprage flags affect mri_normalize and mri_segment,"
  echo "                  and assumes a darker gm."
#  echo "  -schwartzya3t-atlas : for tal reg, use special young adult 3T atlas"
  echo ""
  echo "  -use-gpu : use GPU versions of mri_em_register, mri_ca_register,"
  echo "             mris_inflate and mris_sphere"
  echo ""
  echo " Notification Files (Optional)"
  echo "  -waitfor file : wait for file to appear before beginning"
  echo "  -notify  file : create this file after finishing"
  echo ""
  echo " Status and Log files (Optional)"
  echo "  -log     file : default is scripts/recon-all.log"
  echo "  -status  file : default is scripts/recon-all-status.log"
  echo "  -noappend     : start new log and status files instead of appending"
  echo "  -no-isrunning : do not check whether this subject is currently being processed"
  echo ""
  echo " Other Arguments (Optional)"
  echo "  -force          : with -i, allows pre-existing subjdir. Deletes source."
  echo "  -sd subjectsdir : specify subjects dir (default env SUBJECTS_DIR)"
  echo "  -mail username  : mail user when done"
  echo "  -umask umask    : set unix file permission mask (default 002)"
  echo "  -grp groupid    : check that current group is alpha groupid "
  echo "  -onlyversions   : print version of each binary and exit"
  echo "  -debug          : print out lots of info"
  echo "  -allowcoredump  : set coredump limit to unlimited"
  echo "  -dontrun        : do everything but execute each command"
  echo "  -version        : print version of this script and exit"
  echo "  -help           : voluminous bits of wisdom"
  echo ""

  if(! $PrintHelp) exit 1;

  echo $VERSION
  echo ""

  cat $0 | awk 'BEGIN{prt=0}{if(prt) print $0;if($1 == "BEGINHELP") prt=1}'

exit 1;

#---- Everything below here is printed out as part of help -----#
BEGINHELP

Performs all, or any part of, the FreeSurfer cortical reconstruction
process. This help only gives some simple information. For more
detailed documentation, see https://surfer.nmr.mgh.harvard.edu

Basic usages:

1. Subject dir does not exist:

  recon-all -subject subjectname -i invol1 <-i invol2> -all

Creates analysis directory $SUBJECTS_DIR/subjectname, converts one or
more input volumes to MGZ format in subjectname/mri/orig, and runs
all processing steps. If subjectname exists, then an error is returned
when -i is used; but this can be overridden with -force (in which
case any pre-existing source volumes are deleted).

2. Manual conversion into mgz:

  mkdir -p $SUBJECTS_DIR/subjectname/mri/orig
  mri_convert invol1 $SUBJECTS_DIR/subjectname/mri/orig/001.mgz
  mri_convert invol2 $SUBJECTS_DIR/subjectname/mri/orig/002.mgz
  recon-all -subject subjectname -all

If no input volumes are given, then it is assumed that the subject
directory has already been created and that the raw data already
exists in MGZ format in subjid/mri/orig as XXX.mgz, where XXX is a
3-digit, zero-padded number.


SUBJECT IDENTIFICATION STRING

-s subjectname
-sid subjectname
-subjid subjectname
-subject subjectname

'subjectname' is the FreeSurfer subject identification string which doubles
as the name of the reconstruction root directory for this subject. This
reconstruction should be referenced by this string for all FreeSurfer
commands and in the register.dat matrix (for functional interfacing).


SPECIFYING DIRECTIVES

Directives instruct recon-all which part(s) of the reconstruction
stream to run. While it is possible to do everything in one shot (using
the -all flag), there can be some benefits to customizing the
stream. These benefits include stopping to perform manual editing as
well as parallelization. Directives are either clustered or step-wise.
Clustered directives are sets of steps that can be performed by
specifying a single flag. A step-wise directive refers to a single
step.  Directives accumulate. A step can be removed from a cluster by
adding -no<step> after the cluster flag. For example, specifying
-all followed by -notalairach will perform all the reconstruction
steps except talairaching. However, note that if -notalairach *preceeded*
-all, talairaching would still be performed.


CLUSTERED DIRECTIVES

-all
-autorecon-all

Perform all reconstruction steps.

-autorecon1

Motion correction through skull strip.

-autorecon2

Subcortical segmentation through make white surfaces.

-autorecon2-cp

Normalization2 through make final surfaces.

-autorecon2-wm

Fill through make white surfaces. Used after editing wm volume after running
-autorecon2.

-autorecon2-pial
-autorecon3-pial
-autorecon-pial

Makes final surfaces (white and pial). Used after editing brain.finalsurfs
volume after running -autorecon2. The brain.finalsurfs.mgz volume may be
edited to fix problems with the pial surface.

-autorecon3

Spherical morph, automatic cortical parcellation, pial surf and ribbon mask.


STEP-WISE DIRECTIVES

Step-wise directives allow the user to implement a single step in the
reconstruction process. See also STEP DESCRIPTION SUMMARIES below.
They also allow users to include/exclude a step from a clustered
DIRECTIVE. To include a step, use -step (eg, -skullstrip). To exclude
a step, use -nostep (eg -noskullstrip).

Run times are approximate for an AMD Opteron 64bit 2.5GHz processor:

  -<no>motioncor        < 5 min
  -<no>nuintensitycor     3 min
  -<no>talairach          4 min
  -<no>normalization      3 min
  -<no>skullstrip         1 min
  -<no>gcareg             8 min
  -<no>canorm             1 min
  -<no>careg             10 hours
  -<no>rmneck             3 min
  -<no>skull-lta          9 min
  -<no>calabel           30 min
  -<no>normalization2     3 min
  -<no>segmentation       4 min
  -<no>fill               1 min
  -<no>tessellate       < 1 min     per hemisphere
  -<no>smooth1          < 1 min     per hemisphere
  -<no>inflate1           1 min     per hemisphere
  -<no>qsphere           16 min     per hemisphere
  -<no>fix              1-9 hours   per hemisphere
  -<no>euler            < 1 min     per hemisphere
  -<no>smooth2          < 1 min     per hemisphere
  -<no>inflate2           2 min     per hemisphere
  -<no>white              1 hour    per hemisphere
  -<no>sphere           1-2 hours   per hemisphere
  -<no>surfreg            1 hour    per hemisphere
  -<no>jacobian_white   < 1 min     per hemisphere
  -<no>contrasurfreg      1 hour    per hemisphere
  -<no>avgcurv          < 1 min     per hemisphere
  -<no>cortparc           1 min     per hemisphere
  -<no>parcstats        < 1 min     per hemisphere
  -<no>cortparc2          1 min     per hemisphere
  -<no>parcstats2       < 1 min     per hemisphere
  -<no>pial               1 hour    per hemisphere
  -<no>cortribbon        20 min
  -<no>aparc2aseg         1 min
  -<no>wmparc            20 min

  -all                20-40 hours   both hemipheres


EXPERT PREFERENCES

-pons-crs C R S

Specify a seed point for the pons during the fill operation. This is
used to cut the brain stem from brain. By default, this point will be
determined automatically. It should only be specified if there is a
cut failure. To determine what this point should be, find the center
of the pons in the T1 volume (in tkmedit) and record the column, row,
and slice. Creates a file called scripts/seed-ponscrs.man.dat
with the CRS.

-cc-crs C R S

Specify a seed point for the corpus callosum during the fill
operation. This is used to help separate the hemispheres.  By default,
this point will be determined automatically. It should only be
specified if there is a cut failure.  To determine what this point
should be, find the center of the CC in the T1 volume (in tkmedit) and
record the column, row, and slice. Creates a file called
scripts/seed-cccrs.man.dat with the CRS.

-lh-crs C R S

Specify a seed point for the left hemisphere during the fill
operation. This is used to help identify the left hemisphere.  By
default, this point will be determined automatically. It should only
be specified if there is a cut failure.  To determine what this point
should be, find a point in the white matter mass of the left
hemisphere in the T1 volume (in tkmedit) and record the column, row,
and slice. Creates a file called scripts/seed-cccrs.man.dat with the
CRS. Remember that tkmedit displays the volume in radiological
convention (ie, left is right).

-rh-crs C R S

Same as -lh-crs but for the right hemisphere. Creates a file called
scripts/seed-rhcrs.man.dat with the CRS.

-watershed cmd

This controls how the skull stripping will be performed. Legal values are
normal (the default), atlas, nowatershed, watershedonly, and watershedtemplate.

-wsmore/-wsless

Increase/decrease the preflooding height (threshold) when skull
stripping. -wsmore will expand the skull surface; -wsless will shrink
the skull surface.  See also -wsthresh.

-wsthresh pctheight

Explicitly set the preflooding height when skull stripping.

-wsseed R C S

Supply a point in the volume that the user believes to be in the white
matter.  By default, this point will be determined automatically. It
should only be specified if there is a strip failure. To determine
what this point should be, find a point in the white matter using
tkmedit and record the Volume Index values (NOT the XYZ coordinates).

-no-wsgcaatlas

Disable usage of the GCA atlas when running mri_watershed skull-stripping.
The default is to use the GCA atlas to locate anatomy aiding skull-strip.

-gca gcafile

Specify the name of the gaussian classifier array (GCA) file
to be used with GCA registration and automatic subcortical
segmentation. It must be found in the FREESURFER_HOME/average directory (or
use -gca-dir to specify an alternate path).
The Default is RB_all_YYYY-MM-DD.gca located in
FREESURFER_HOME/average. This has no effect unless the GCA registration
or subcortical segmentation stages are to be performed.

-gca-skull gcafile

Specify the name of the gaussian classifier array (GCA) file to be used with
registration with skull.  It must be found in the FREESURFER_HOME/average
directory (or use -gca-dir to specify an alternate path).
The default is RB_all_withskull_YYYY-MM-DD.gca located in
FREESURFER_HOME/average.

-gcs gcsfile

Specify the name of the gaussian classifier surface atlas (GCS) file
to be used for the cortical parcellation stage. It must be found in the
FREESURFER_HOME/average directory (or use -gcs-dir to specify an alternate
path). The default is named
curvature.buckner40.filled.desikan_killiany.2007-06-20.gcs and is located in
FREESURFER_HOME/average.

-nuiterations

Number of iterations in the non-uniform intensity correction.
Default is 2.

-norm3diters niters

Use niters 3d normalization iterations (passes as -n to mri_normalize).

-normmaxgrad maxgrad

Passes "-g maxgrad" to mri_normalize. Max grad default is 1.

-noaseg

Skips subcortical segmentation steps (same as -nosubcortseg), and does
not use aseg.mgz for inorm2, wm segmentation, or filling. Use this flag
for brains that do not support usage of Freesurfers subcortical
segmentation, such as baby brains, or non-human primates.

-noaseg-inorm2

Does not use aseg.mgz for the second mri_normalize step.

-bigventricles

If a subject has enlarged ventricles due to atrophy, include the -bigventricles
flag with the -autorecon2 stage in order to prevent surfaces extending into
the ventricle regions. The flag directly affects the binaries mri_ca_register
and mri_ca_label, and mris_make_surfaces indirectly via aseg.mgz.

-norandomness

The random number generator used by certain binaries is seeded with the
same number, thus producing identical results from run to run.

-cw256

Include this flag after -autorecon1 if images have a FOV > 256.  The
flag causes mri_convert to conform the image to dimensions of 256^3.

-notal-check

Skip the automatic failure detection of Talairach alignment.

-qcache

Produce the pre-cached files required by the Qdec utility, allowing rapid
analysis of group data.  These files are created by running mris_preproc,
which creates smoothed surface data files sampled to the 'fsaverage'
common-space surface. By default, the surface data for thickness, curv, sulc,
area and jacobian_white are smoothed at 0, 5, 10, 15, 20, and 25 mm FWHM.
If just one set of surface data needs to be processed, then the option
-measure <surfmeas> can follow -qcache, where <surfmeas> is one of: thickness,
curv, sulc, area, jacobian_white or any surface measure. Multiple instances
of -measure <meas> is supported.  The -measuredir option allows
specifying a directory other than the default of surf. Another option is
-fwhm <num> where <num> is a value in mm.  Also, -target <name> allows
specifying a common-space target other than fsaverage (the default).
qcache is also a target for make, eg. recon-all -make qcache
See also: http://surfer.nmr.mgh.harvard.edu/fswiki/Qdec

-smooth-cortex-only

Only applies with -qcache. Only smooth data if it is part of the ?h.cortex.label.
This prevents values in the medial wall (which are meaningless) from being 
smoothed into cortical areas. This is the default and you will have to turn 
it off with -no-smooth-cortex-only.

-no-smooth-cortex-only

Allow medial wall values to smooth into cortex.

-make target

Runs recon-all through 'make', the standard utility used to create a file
only if its dependencies are out-of-date.  This -make option makes use of the
file recon-all.makefile, where the dependency chain is specified.
A 'target' argument must be specified.  The valid targets are:

  all
  autorecon1
  autorecon2
  autorecon2-volonly
  autorecon2-perhemi
  autorecon3
  qcache

These targets correspond to their flag equivalents in recon-all.  The
difference in behaviour is that files are created only if the file does not
exist or if an input file used to create it has a newer date than the file
in need of creation.  It is also possible to supply the full pathname to a
particular file as a target.

The flag -dontrun can also be specified to show the commands that will run
without excuting them.

-lgi
-lGI
-localGI

Computes local measurements of pial-surface gyrification at thousands of
points over the cortical surface. See reference [13] for details.

-label_v1

Create a label of V1, based on Hinds et al., NeuroImage 39 (2008) 1585-1599.

-balabels
-ba-labels
-ba_labels

Creates Brodmann area labels of BA1, BA2, BA3a, BA3b, BA4a, BA4p, BA6, BA44,
BA45, V1, V2, and V5/MT by mapping labels from the 'fsaverage' subject.
The 'fsaverage' subject must exist within the SUBJECTS_DIR.  Based on:
"Cortical Folding Patterns and Predicting Cytoarchitecture", Fischl et al.,
Cerebral Cortex 2007.

-use-gpu

Use the GPU versions of the binaries mri_em_register, mri_ca_register,
mris_inflate, and mris_sphere.


EXPERT OPTIONS FILE

While the expert preferences flags supported by recon-all cover most of
the instances where special flags need to be passed to a FreeSurfer binary,
to allow passing an arbitrary flag to a binary, recon-all supports the
reading of a user-created file containing special options to include in
the command string (in addition to, not in place of).  The file should
contain as the first item the name of the command, and the items following
it on rest of the line will be passed as the extra options.  For example,
if a file called expert.opts is created containing these lines:

  mri_em_register -p .5
  mris_topo_fixer -asc

then the option "-p .5" will be passed to mri_em_register, and "-asc"
will be passed to mris_topo_fixer.  The name of the expert options file
is passed to recon-all with the -expert flag, eg.

  recon-all -expert expert.opts

When an expert options is passed, it will be copied to scripts/expert-options.
Future calls to recon-all, the user MUST explicitly specify how to treat this file.
Options are (1) use the file (-xopts-use), or (2) delete it (-xopts-clean). If
this file exsts and the user specifies another expert options file, then
the user must also specify -xopts-overwrite.

The following FreeSurfer binaries will accept an expert option:

  talairach_avi
  mri_normalize
  mri_watershed
  mri_em_register
  mri_ca_normalize
  mri_ca_register
  mri_remove_neck
  mri_ca_label
  mri_segstats
  mri_mask
  mri_segment
  mri_edit_wm_with_aseg
  mri_pretess
  mri_fill
  mri_tessellate
  mris_smooth
  mris_inflate
  mris_sphere
  mris_fix_topology
  mris_topo_fixer
  mris_remove_intersection
  mris_make_surfaces
  mris_surf2vol
  mris_register
  mris_jacobian
  mrisp_paint
  mris_ca_label
  mris_anatomical_stats
  mri_aparc2aseg


NOTIFICATION FILES

Notification files allow the user to cascade invocations to recon-all,
with one invocation waiting until another one terminates. This is done
by specifying a file that must exist before an invocation can precede
(-waitfor) and/or specifying a file that is created when an invocation
terminates (-notify). This type of interprocess communication can
allow users to parallelize the stream. If this is to be done, note
that each hemisphere can be run separately by specifying the -hemi
flag.


LOG AND STATUS FILES

By default, log and status files are created in subjid/scripts. The
log file contains all the output from all the programs that have been
run during the invocation to recon-all. The status file has a list of
all the programs that have been run and the time at which each
started. The log file is intended to be a record of what was done
whereas the status file allows the user to easily see where in the
stream a currently running process is. The log file should be sent
with all bug reports. By default, these files are called recon-all.log
and recon-all-status.log, but this can be changed with the -log and
-status options. By default, the log and status are appended to. New
log and status files can be forced with the -noappend flag.


OTHER ARGUMENTS

-sd subjectsdir

This allows the user to specify the root of the FreeSufer subjects
directory. If unspecified, the environment variable SUBJECTS_DIR
is used.

-mail username

Send email to username when the process terminates.


STEP DESCRIPTION SUMMARIES

Motion Correction (-<no>motioncor)

When there are multiple source volumes, this step will correct for
small motions between them and then average them together. The input
are the volumes found in file(s) mri/orig/XXX.mgz. The output will be
the volume mri/orig.mgz. If no runs are found, then it looks for
a volume in mri/orig (or mri/orig.mgz). If that volume is there, then
it is used in subsequent processes as if it was the motion corrected
volume. If no volume is found, then the process exits with errors.

NU Intensity Correction (-<no>nuintensitycor)

Non-parametric Non-uniform intensity Normalization (N3), corrects for
intensity non-uniformity in MR data,  making relatively few assumptions
about the data.  This runs the MINC tool 'nu_correct'.  By default, four
iterations of nu_correct are run.  The flag -nuiterations specification
of some other number of iterations.

Talairach (-<no>talairach)

This computes the affine transform from the orig volume to the MNI305
atlas using Avi Snyders 4dfp suite of image registration tools,
through a FreeSurfer script called talairach_avi. Several of the downstream
programs use talairach coordinates as seed points. You can/should check
how good the talairach registration is using
"tkregister2 --s subjid --fstal-avi". You must have an "fsaverage" subject in
your SUBJECTS_DIR. tkregister2 allows you to compare the orig volume
against the talairach volume resampled into the orig space. If you modify
the registration, it will change the talairach.xfm file. Your edits will
be *not* be overwritten unless you run recon-all specifying -clean-tal.
Run "tkregister2 --help" for more information.
Creates the files mri/transform/talairach.auto.xfm and talairach.xfm.
The flag -tal-check will check the registration against known-good transforms.
Adding the flag -use-mritotal after -talairach will use the MINC program
mritotal (see Collins, et al., 1994) to perform the transform.

Normalization (-<no>normalization)

Performs intensity normalization of the orig volume and places the
result in mri/T1.mgz. Attempts to correct for fluctuations in
intensity that would otherwise make intensity-based segmentation much
more difficult. Intensities for all voxels are scaled so that the mean
intensity of the white matter is 110. If there are problems with the
normalization, users can add control points. See also Normalization2.

Skull Strip (-<no>skullstrip)

Removes the skull from mri/T1.mgz and stores the result in
mri/brainmask.auto.mgz and mri/brainmask.mgz.
Runs the mri_watershed program. If the strip fails, users can specify
seed points (-wsseed) or change the threshold (-wsthresh, -wsmore, -wsless).
The -autorecon1 stage ends here.

Automatic Subcortical Segmentation (-<no>subcortseg)

This is done in six stages. (1) GCA linear registration
(-gcareg). This is an initial registration to a template. (2)
Canonical Normalization (-canorm), (3) Canonical Registration
(-careg). (4) Neck removal (-rmneck), (5) Registration, w/skull
(-skull-lta), and (6) Subcortical labeling (-calabel).
The stages are listed next.

EM (GCA) Registration (-<no>gcareg)

Computes transform to align the mri/nu.mgz volume to the default GCA atlas
found in FREESURFER_HOME/average (see -gca flag for more info).
Creates the file mri/transforms/talairach.lta.
The -autorecon2 stage starts here.

CA Normalize (-<no>canorm)

Further normalization, based on GCA model.
Creates mri/norm.mgz.

CA Register (-<no>careg)

Computes a nonlinear transform to align with GCA atlas.
Creates the file mri/transform/talairach.m3z.

CA Register Inverse (-<no>careginv)

Computes the inverse of the nonlinear transform to align with GCA
atlas.  Creates the files mri/transform/talairach.m3z.{x,y,z}.mgz.

Remove neck (-<no>rmneck)

The neck region is removed from the NU-corrected volume mri/nu.mgz.
Makes use of transform computed from prior CA Register stage.
Creates the file mri/nu_noneck.mgz.

EM Registration, with Skull (-<no>skull-lta)

Computes transform to align volume mri/nu_noneck.mgz with GCA volume
possessing the skull.
Creates the file mri/transforms/talairach_with_skull.lta.

CA Label (-<no>calabel)

Labels subcortical structures, based in GCA model.
Creates the files mri/aseg.auto.mgz and mri/aseg.mgz.

ASeg Stats (-<no>segstats)

Computes statistics on the segmented subcortical structures found
in mri/aseg.mgz. Writes output to file stats/aseg.stats.

Normalization2 (-<no>normalization)

Performs a second (major) intensity correction using only the brain
volume as the input (so that it has to be done after the skull strip).
Intensity normalization works better when the skull has been removed.
Creates a new brain.mgz volume. The -autorecon2-cp stage begins here.
If -noaseg flag is used, then aseg.mgz is not used by mri_normalize.

WM Segmentation (-<no>segmentation)

Attempts to separate white matter from everything else. The input is
mri/brain.mgz, and the output is mri/wm.mgz.  Uses intensity,
neighborhood, and smoothness constraints.  This is the volume that is
edited when manually fixing defects. Calls mri_segment,
mri_edit_wm_with_aseg, and mri_pretess. To keep previous edits, run
with -keep. If -noaseg is used, them mri_edit_wm_aseg is skipped.

Cut/Fill (-<no>fill)

This creates the subcortical mass from which the orig surface is
created. The mid brain is cut from the cerebrum, and the hemispheres
are cut from each other. The left hemisphere is binarized to 255.
The right hemisphere is binarized to 127.  The input is mri/wm.mgz
and the output is mri/filled.mgz. Calls mri_fill. If the cut fails,
then seed points can be supplied (see -cc-crs, -pons-crs, -lh-crs,
-rh-crs). The actual points used for the cutting planes in the
corpus callosum and pons can be found in scripts/ponscc.cut.log.
The stage -autorecon2-wm begins here.  This is the last stage of
volumetric processing. If -noaseg is used, then aseg.mgz is not used
by mri_fill.

Tessellation (-<no>tessellate)

This is the step where the orig surface (ie, surf/?h.orig.nofix) is
created. The surface is created by covering the filled hemisphere with
triangles. Runs mri_tessellate. The places where the points of the
triangles meet are called vertices. Creates the file surf/?h.orig.nofix
Note: the topology fixer will create the surface ?h.orig.

Orig Surface Smoothing (-<no>smooth1, -<no>smooth2)

After tesselation, the orig surface is very jagged because each
triangle is on the edge of a voxel face and so are at right angles to
each other. The vertex positions are adjusted slightly here to reduce
the angle. This is only necessary for the inflation processes.
Creates surf/?h.smoothwm(.nofix). Calls mris_smooth. Smooth1 is the step
just after tessellation, and smooth2 is the step just after topology
fixing.

Inflation (-<no>inflate1, -<no>inflate2)

Inflation of the surf/?h.smoothwm(.nofix) surface to create
surf/?h.inflated. The inflation attempts to minimize metric distortion
so that distances and areas are perserved (ie, the surface is not
stretched). In this sense, it is like inflating a paper bag and not a
balloon.  Inflate1 is the step just after tessellation, and inflate2
is the step just after topology fixing. Calls mris_inflate. Creates
?h.inflated, ?h.sulc, ?h.curv, and ?h.area.

QSphere (-<no>qsphere)

This is the initial step of automatic topology fixing. It is a
quasi-homeomorphic spherical transformation of the inflated surface designed
to localize topological defects for the subsequent automatic topology fixer.
Calls mris_sphere. Creates surf/?h.qsphere.nofix.

Automatic Topology Fixer (-<no>fix)

Finds topological defects (ie, holes in a filled hemisphere) using
surf/?h.qsphere.nofix, and changes the orig surface (surf/?h.orig.nofix)
to remove the defects. Changes the number of vertices.  All the defects
will be removed, but the user should check the orig surface in the volume
to make sure that it looks appropriate. Calls mris_topo_fixer.
Creates surf/?h.orig (by iteratively fixing surf/?h.orig.nofix).

White Surface (-<no>white)

Creates the ?h.white surfacees as well as the curvature file (?h.curv).
The white surface is created by "nudging" the orig surface so that it
closely follows the white-gray intensity gradient as found in the T1 volume.
Calls mris_make_surfaces.  See also "Pial Surface" and "Final Surfaces".

Spherical Inflation (-<no>sphere)

Inflates the orig surface into a sphere while minimizing metric
distortion.  This step is necessary in order to register the surface
to the spherical atlas. (also known as the spherical morph). Calls
mris_sphere. Creates surf/?h.sphere.  The -autorecon3 stage begins here.

Ipsilateral Surface Registation (Spherical Morph) (-<no>surfreg)

Registers the orig surface to the spherical atlas through
surf/?h.sphere. The surfaces are first coarsely registered by aligning
the large scale folding patterns found in ?h.sulc and then fine tuned
using the small-scale patterns as in ?h.curv.
Calls mris_register. Creates surf/?h.sphere.reg.

Jacobian (-<no>jacobian_white)

Computes how much the white surface was distorted in order to register
to the spherical atlas during the -surfreg step. Creates ?h.jacobian_white
(a curv formatted file). This step follows the surface registration step.

Surface Registation, maximal distortion, with Jacobian (-<no>jacobian_dist0)

Run spherical registration with no metric distortion penalty. This will
cause surface geometry to align regardless of the amount of distortion
induced (ie, distance contraints are turned off). The distortion will then
be quantified by the Jacobian of the transform. Creates ?h.jacobian_dist0 (a
curv formatted file) and ?h.sphere.dist0.jacobian.reg (a surface file). This
step is not run automatically because it can add about an hour per hemi.
Note: the file ?h.jacobian_white (see prior help text) is the Jacobian of
the white surface to spherical atlas alignment from -surfreg.

Contralateral Surface Registation (Spherical Morph) (-<no>contrasurfreg)

Same as ipsilateral but registers to the contralateral atlas.
Creates lh.rh.sphere.reg and rh.lh.sphere.reg.

Average Curvature (-<no>avgcurv)

Resamples the average curvature from the atlas to that of the subject.
Allows the user to display activity on the surface of an individual
with the folding pattern (ie, anatomy) of a group. Calls mrisp_paint.
Creates surf/?h.avg_curv.

Cortical Parcellation (-<no>cortparc, -<no>cortparc2)

Assigns a neuroanatomical label to each location on the cortical surface.
Incorporates both geometric information derived from the cortical model
(sulcus and curvature), and neuroanatomical convention.
Calls mris_ca_label.  -cortparc creates label/?h.aparc.annot, and
-cortparc2 creates /label/?h.aparc.a2009s.annot.

Pial Surface (-<no>pial)

Creates the ?h.pial surfaces as well as the thickness file (?h.thickness).
The pial surface is created by expanding the white surface so that it closely
follows the gray-CSF intensity gradient as found in the T1 volume.  The
cortical parcellation is also used to refine the surface in certain areas.
Calls mris_make_surfaces.  See also "Final Surfaces".

Final Surfaces (-<no>finalsurfs)

!!! DEPRECATED !!! This flag is intended only to emulate the old-style single-run
mris_make_surfaces, where the white and pial surfaces are created at the same
time without aid from the cortical parcellation data.

Surface Volume (-surfvolume)

Creates the ?h.volume file by first creating the ?h.mid.area file by
adding ?h.area(.white) to ?h.area.pial, then dividing by two.  Then
?h.volume is created by multiplying ?.mid.area with ?h.thickness.
This step is also run at the end of the -pial step.

Parcellation Statistics (-<no>parcstats, -<no>parcstats2)

Runs mris_anatomical_stats to create a summary table of cortical
parcellation statistics for each structure, including 1. structure
name 2. number of vertices 3. total wm surface area (mm^2) 4. total gray
matter volume (mm^3) 5. average cortical thickness (mm) 6. standard
error of cortical thickness (mm) 7. integrated rectified mean wm
curvature 8. integrated rectified Gaussian wm curvature 9. folding index
10. intrinsic curvature index.
For -parcstats, the file is saved in stats/?h.aparc.stats.
For -parcstats2, the file is saved in stats/?h.aparc.${DESTRIEUX_NAME}.stats.

Cortical Ribbon Mask (-<no>cortribbon)

Creates binary volume masks of the cortical ribbon, ie, each voxel is
either a 1 or 0 depending upon whether it falls in the ribbon or not.
Saved as ?h.ribbon.mgz.  Uses mgz regardless of whether the -mgz
option is used.

Curvature Statistics  (-<no>curvstats)

Runs mris_curvature_stats to create a summary file (stats/?h.curv.stats)
of cortical curvature statistics.

LONGITUDINAL PROCESSING

The longitudinal processing scheme aims to incorporate the subject-wise
correlation of longitudinal data into the processing stream in order to
further reduce the measurement noise.

Here is a summary of the longitudinal workflow, where tpN refers to the
name of one timepoint of subject data, and longbase refers to the name
given to the base subject of a collection of timepoints:

1) cross-sectionally process tpN subjects (the default workflow):
  recon-all -s tp1 -i path_to_tp1_dicom -all
  recon-all -s tp2 -i path_to_tp2_dicom -all

2) create base subject and cross-sectionally process:
  recon-all -base longbase -base-tp tp1 -base-tp tp2 -all

3) longitudinally process tpN subjects:
  recon-all -long tp1 longbase -all
  recon-all -long tp2 longbase -all

4) do comparisons on results from 3), e.g. calculate differences
between tp2.long.longbase - tp1.long.longbase

Note that the longitudinal processing stream always produces output subject
data containing  .long.  in the name (to help distinguish from the default
stream).

-long tp1 longbase
-longitudinal tp1 longbase

Enables longitudinal processing.

Example:

  recon-all -long <tpNsubjid> <longbasesubjid> -all

The output subject is named <tpNsubjid>.long.<longbasesubjid>.

Notice that the -all flag is included. A work directive flag is required.

Other flags:

-uselongbasectrlvol

With -long: Switch on use of control-points from the base in the long
runs for intensity normalization (T1.mgz).

-uselongbasewmedits

With -long: Optionally transfer WM edits from base/template.
Default: map WM edits from corresponding cross run.

-no-orig-pial

If the orig pial surface data is not available, then specify this flag so that
mris_make_surfaces does not attempt to use it.

-noasegfusion

Do not create 'fused' aseg from the longbase timepoints, which would normally
be used to initialize the ca_labeling.  Instead, initialize using the longbase
aseg.mgz.

-addtp

If a new timepoint needs to be added to a longitudinal run where a base subject
has already been created (from prior timepoints), then the -addtp command
can be added to the -long command in order to 'fix-up' the longitudinal
stream to accept the new timepoint.  Note that the base subject is *not*
recomputed using the new timepoint.  See the LongitudinalProcessing wiki page.

Example:

  recon-all -long <tpNsubjid> <longbasesubjid> -addtp -all

In this example, 'tnNsubjid' is the subject name (assumed processed in the
cross-sectional stream) to add as a new timepoint and upon which to run
the longitudinal stream (creating <tpNsubjid>.long.<longbasesubjid>).

MANUAL CHECKING AND EDITING OF SURFACES

To manually edit segmenation, run the following command (make sure
that your SUBJECTS_DIR environment variable is properly set).

  tkmedit subjid wm.mgz -aux T1.mgz

The surfaces can be loaded through the menu item
File->LoadMainSurface. To enable editing, set Tools->EditVoxels.  It
may also be convenient to bring up the reconstruction toolbar with
View->ToolBars->Reconstruction. Alt-C toggles between the main (wm)
and auxiliary (T1) volumes. Middle clicking will set a voxel value to
255; left clicking will set a voxel value to 0. Only edit the wm
volume. When finished, File->SaveMainVolume.

To view the inflated surface simultaneosly with the volume, run the
following command from a different shell:

  tksurfer subjid lh inflated

To goto a point on the surface inside the volume, click on the point
and hit SavePoint (icon looks like a floppy disk), then, in tkmedit,
hit GotoSavedPoint (icon looks like an open file).

Be sure to see the tutorials found at:
https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial


TOUCH FILES

This script creates a directory called "touch". Each time a stage is
run a "touch file" is created (eg, skull_strip.touch). This will be
used in the future to automatically determine which stages need to be
run or re-run. The modification time of the touch file is important.
The content is irrelevent, though it often contains a command-line.


FLATTENING

Flattening is not actually done in this script. This part just documents
how one would go about performing the flattening. First, load the subject
surface into tksurfer:

  tksurfer subjid lh inflated

Load the curvature through the File->Curvature->Load menu (load
lh.curv). This should show a green/red curvature pattern. Red = sulci.

Right click before making a cut; this will clear previous points. This
is needed because it will string together all the previous places you
have clicked to make the cut. To make a line cut, left click on a line
of points. Make the points fairly close together; if they are too far
appart, the cut fails. After making your line of points, execute the
cut by clicking on the Cut icon (scissors with an open triangle for a
line cut or scissors with a closed triangle for a closed cut). To make
a plane cut, left click on three points to define the plane, then left
click on the side to keep. Then hit the CutPlane icon.

Fill the patch. Left click in the part of the surface that you want to
form your patch. Then hit the Fill Uncut Area button (icon = filled
triangle). This will fill the patch with white. The non-patch area
will be unaccessible through the interface.  Save the patch through
File->Patch->SaveAs. For whole cortex, save it to something like
lh.cort.patch.3d. For occipital patches, save it to lh.occip.patch.3d.

Cd into the subject surf directory and run

  mris_flatten -w N -distances Size Radius lh.patch.3d lh.patch.flat

where N instructs mris_flatten to write out an intermediate surface
every N interations. This is only useful for making movies; otherwise
set N=0.  Size is maximum number of neighbors; Radius radius (mm) in
which to search for neighbors. In general, the more neighbors that are
taken into account, the less the metric distortion but the more
computationally intensive. Typical values are Size=12 for large
patches, and Size=20 for small patches. Radius is typically 7.
Note: flattening may take 12-24 hours to complete. The patch can be
viewed at any time by loading the subjects inflated surface, then
loading the patch through File->Patch->LoadPatch...


GETTING HELP

Send email to freesurfer@nmr.mgh.harvard.edu. Also see
https://surfer.nmr.mgh.harvard.edu. In particular, there is both a
reconstruction guide and tutorial as well as manuals for tkmedit and
tksurfer.


REFERENCES

[1] Collins, DL, Neelin, P., Peters, TM, and Evans, AC. (1994)
Automatic 3D Inter-Subject Registration of MR Volumetric Data in
Standardized Talairach Space, Journal of Computer Assisted Tomography,
18(2) p192-205, 1994 PMID: 8126267; UI: 94172121

[2] Cortical Surface-Based Analysis I: Segmentation and Surface
Reconstruction Dale, A.M., Fischl, Bruce, Sereno, M.I.,
(1999). Cortical Surface-Based Analysis I: Segmentation and Surface
Reconstruction.  NeuroImage 9(2):179-194

[3] Fischl, B.R., Sereno, M.I.,Dale, A. M.  (1999) Cortical
Surface-Based Analysis II: Inflation, Flattening, and Surface-Based
Coordinate System. NeuroImage, 9, 195-207.

[4] Fischl, Bruce, Sereno, M.I., Tootell, R.B.H., and Dale, A.M.,
(1999). High-resolution inter-subject averaging and a coordinate
system for the cortical surface. Human Brain Mapping, 8(4): 272-284

[5] Fischl, Bruce, and Dale, A.M., (2000).  Measuring the Thickness of
the Human Cerebral Cortex from Magnetic Resonance Images.  Proceedings
of the National Academy of Sciences, 97:11044-11049.

[6] Fischl, Bruce, Liu, Arthur, and Dale, A.M., (2001). Automated
Manifold Surgery: Constructing Geometrically Accurate and
Topologically Correct Models of the Human Cerebral Cortex. IEEE
Transactions on Medical Imaging, 20(1):70-80

[7] Non-Uniform Intensity Correction.
http://www.nitrc.org/projects/nu_correct/

[8] Fischl B, Salat DH, Busa E, Albert M, Dieterich M, Haselgrove C,
van der Kouwe A, Killiany R, Kennedy D, Klaveness S, Montillo A,
Makris N, Rosen B, Dale AM. Whole brain segmentation: automated
labeling of neuroanatomical structures in the human
brain. Neuron. 2002 Jan 31;33(3):341-55.

[9] Bruce Fischl, Andre van der Kouwe, Christophe Destrieux, Eric
Halgren, Florent Segonne, David H. Salat, Evelina Busa, Larry
J. Seidman, Jill Goldstein, David Kennedy, Verne Caviness, Nikos
Makris, Bruce Rosen, and Anders M. Dale.  Automatically Parcellating
the Human Cerebral Cortex. Cerebral Cortex January 2004; 14:11-22.

[10] Fischl B, Salat DH, van der Kouwe AJW, Makris N, Sgonne F, Dale
AM. Sequence-Independent  Segmentation of Magnetic Resonance Images.
NeuroImage 23 Suppl 1, S69-84.

[11] Segonne F, Dale, AM, Busa E, Glessner M, Salvolini U, Hahn HK,
Fischl B, A Hybrid Approach to the Skull-Stripping Problem in MRI.
NeuroImage, 22,  pp. 1160-1075, 2004

[12] Han et al.,  Reliability of MRI-derived measurements of human
cerebral cortical thickness: The effects of field strength, scanner
upgrade and manufacturer, (2006) NeuroImage, 32(1):180-194.

[13] Schaer et al., A Surface-based Approach to Quantify Local Cortical
Gyrification (2007) IEEE Transactions on Medical Imaging.

[14] Martin Reuter, H Diana Rosas, Bruce Fischl.
Highly Accurate Inverse Consistent Registration: A Robust Approach.
NeuroImage (2010). http://dx.doi.org/10.1016/j.neuroimage.2010.07.020
